{
  "repository": "strands-utcp",
  "commit_hash": "adf69fb56bc5763407f479503ad8c9209e071af5",
  "commit_timestamp": "1759911478",
  "file_count": 6,
  "extractions": [
    {
      "file_path": "UPSTREAM\\strands-utcp\\pyproject.toml",
      "content_type": "other",
      "content": "[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[project]\nname = \"strands-utcp\"\nversion = \"0.1.0\"\ndescription = \"Universal Tool Calling Protocol (UTCP) integration for Strands Agents SDK\"\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\nlicense = \"MIT\"\nauthors = [\n    { name = \"UTCP Community\", email = \"community@utcp.dev\" }\n]\nkeywords = [\"strands\", \"agents\", \"utcp\", \"tools\", \"ai\", \"llm\"]\nclassifiers = [\n    \"Development Status :: 3 - Alpha\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: Python :: 3.12\",\n    \"Topic :: Software Development :: Libraries :: Python Modules\",\n    \"Topic :: Scientific/Engineering :: Artificial Intelligence\",\n]\ndependencies = [\n    \"strands-agents\",\n    \"utcp>=1.0.0\",\n    \"utcp-http>=1.0.0\",\n    \"httpx>=0.27.0\",\n    \"pydantic>=2.0.0\",\n]\n\n[project.urls]\nHomepage = \"https://github.com/universal-tool-calling-protocol/strands-utcp\"\nDocumentation = \"https://github.com/universal-tool-calling-protocol/strands-utcp#readme\"\nRepository = \"https://github.com/universal-tool-calling-protocol/strands-utcp\"\nIssues = \"https://github.com/universal-tool-calling-protocol/strands-utcp/issues\"\n\n[project.optional-dependencies]\ndev = [\n    \"pytest>=7.0.0\",\n    \"pytest-asyncio>=0.21.0\",\n    \"pytest-cov>=4.0.0\",\n    \"pytest-mock>=3.0.0\",\n    \"black>=23.0.0\",\n    \"ruff>=0.1.0\",\n    \"mypy>=1.0.0\",\n    \"build\",\n    \"twine\",\n]\n\n[tool.hatch.build.targets.wheel]\npackages = [\"src/strands_utcp\"]\n\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\npython_files = [\"test_*.py\"]\nasyncio_mode = \"auto\"\n\n[tool.black]\nline-length = 120\ntarget-version = [\"py310\", \"py311\", \"py312\"]\n\n[tool.ruff]\nline-length = 120\n\n[tool.mypy]\npython_version = \"3.10\"\nwarn_return_any = true\nwarn_unused_configs = true\nignore_missing_imports = true\n",
      "line_count": 74,
      "word_count": 192,
      "title": "Pyproject.Toml",
      "summary": "[build-system] requires = [\"hatchling\"]",
      "key_terms": [
        "integration",
        "build",
        "project",
        "Python",
        "packages",
        "mypy",
        "optional-dependencies",
        "md",
        "twine",
        "dependencies",
        "community",
        "line-length",
        "version",
        "pytest-asyncio",
        "Calling",
        "strands",
        "llm",
        "https",
        "system",
        "strands-utcp"
      ],
      "timestamp": "2025-12-24T18:56:16.048760"
    },
    {
      "file_path": "UPSTREAM\\strands-utcp\\README.md",
      "content_type": "documentation",
      "content": "# strands-utcp\n\n[![PyPI version](https://badge.fury.io/py/strands-utcp.svg)](https://badge.fury.io/py/strands-utcp)\n[![Python Support](https://img.shields.io/pypi/pyversions/strands-utcp.svg)](https://pypi.org/project/strands-utcp/)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\nUniversal Tool Calling Protocol (UTCP) community plugin for [Strands Agents SDK](https://github.com/strands-agents/sdk-python)\n\n## Features\n\n- **Universal Tool Access** - Connect to any UTCP-compatible tool source\n- **OpenAPI/Swagger Support** - Automatic tool discovery from API specifications  \n- **Multiple Sources** - Connect to multiple tool sources simultaneously\n- **Async/Await Support** - Full async support with context managers\n- **Type Safe** - Full type hints and validation\n- **Easy Integration** - Drop-in tool adapter for Strands agents\n\n**Key Technical Features:**\n- **AgentTool Inheritance**: Full inheritance from Strands `AgentTool` base class\n- **Tool Name Sanitization**: UUID suffixes for names >64 characters (Bedrock requirement)\n\n## Requirements\n\n- Python 3.10+\n- Strands Agents SDK 1.7.0+\n- UTCP core libraries 1.0+\n\n## Installation\n\n```bash\npip install strands-agents strands-utcp\n```\n\n## Quick Start\n\n### Basic Usage\n\n```python\nfrom strands import Agent\nfrom strands_utcp import UtcpToolAdapter\n\n# Configure UTCP tool adapter\nconfig = {\n    \"manual_call_templates\": [\n        {\n            \"name\": \"weather_api\",\n            \"call_template_type\": \"http\",\n            \"url\": \"https://api.weather.com/utcp\",\n            \"http_method\": \"GET\"\n        }\n    ]\n}\n\n# Use UTCP tools with Strands agent\nasync def main():\n    async with UtcpToolAdapter(config) as adapter:\n        # Get available tools\n        tools = adapter.list_tools()\n        print(f\"Found {len(tools)} UTCP tools\")\n        \n        # Create agent with UTCP tools\n        agent = Agent(tools=adapter.to_strands_tools())\n        \n        # Use the agent\n        response = await agent.invoke_async(\"What's the weather like today?\")\n        print(response.message)\n\nimport asyncio\nasyncio.run(main())\n```\n\n### Tool Discovery\n\n```python\nasync with UtcpToolAdapter(config) as adapter:\n    # List all available tools\n    all_tools = adapter.list_tools()\n    \n    # Search for specific tools\n    weather_tools = await adapter.search_tools(\"weather\")\n    \n    # Get a specific tool\n    weather_tool = adapter.get_tool(\"get_weather\")\n    \n    if weather_tool:\n        result = await weather_tool.call(location=\"New York\")\n        print(result)\n```\n\n### Multiple Sources\n\n```python\nconfig = {\n    \"manual_call_templates\": [\n        {\n            \"name\": \"petstore\",\n            \"call_template_type\": \"http\", \n            \"url\": \"https://petstore.swagger.io/v2/swagger.json\"\n        },\n        {\n            \"name\": \"openlibrary\",\n            \"call_template_type\": \"http\",\n            \"url\": \"https://openlibrary.org/static/openapi.json\"\n        }\n    ]\n}\n\nasync with UtcpToolAdapter(config) as adapter:\n    tools = adapter.list_tools()\n    print(f\"Total tools from all sources: {len(tools)}\")\n```\n\n## Configuration\n\n### Supported Call Template Types\n\nThe plugin supports all UTCP call template types:\n\n#### HTTP Templates\n```python\n{\n    \"name\": \"api_name\",\n    \"call_template_type\": \"http\",\n    \"url\": \"https://api.example.com/utcp\",\n    \"http_method\": \"GET\",  # GET, POST, PUT, DELETE\n    \"content_type\": \"application/json\"\n}\n```\n\n#### Server-Sent Events (SSE)\n```python\n{\n    \"name\": \"sse_stream\",\n    \"call_template_type\": \"sse\", \n    \"url\": \"https://api.example.com/stream\",\n    \"http_method\": \"GET\"\n}\n```\n\n#### Streamable HTTP\n```python\n{\n    \"name\": \"http_stream\",\n    \"call_template_type\": \"streamable_http\",\n    \"url\": \"https://api.example.com/stream\",\n    \"http_method\": \"POST\"\n}\n```\n\n#### Command Line Interface\n```python\n{\n    \"name\": \"cli_tool\",\n    \"call_template_type\": \"cli\",\n    \"command\": \"python script.py\"\n}\n```\n\n#### GraphQL\n```python\n{\n    \"name\": \"graphql_api\",\n    \"call_template_type\": \"graphql\",\n    \"url\": \"https://api.example.com/graphql\"\n}\n```\n\n#### Model Context Protocol (MCP)\n```python\n{\n    \"name\": \"mcp_server\",\n    \"call_template_type\": \"mcp\",\n    \"command\": \"node mcp-server.js\"\n}\n```\n\n#### TCP Socket\n```python\n{\n    \"name\": \"tcp_service\",\n    \"call_template_type\": \"tcp\",\n    \"host\": \"localhost\",\n    \"port\": 8080\n}\n```\n\n#### UDP Socket\n```python\n{\n    \"name\": \"udp_service\", \n    \"call_template_type\": \"udp\",\n    \"host\": \"localhost\",\n    \"port\": 8081\n}\n```\n\n#### Text File\n```python\n{\n    \"name\": \"text_tools\",\n    \"call_template_type\": \"text\",\n    \"file_path\": \"/path/to/tools.txt\"\n}\n```\n\n## API Reference\n\n### UtcpToolAdapter\n\nMain adapter class for UTCP tool integration.\n\n#### Methods\n\n- `start()` - Initialize the UTCP client\n- `stop()` - Clean up resources  \n- `list_tools()` - Get all available tools\n- `get_tool(name)` - Get specific tool by name\n- `search_tools(query, max_results)` - Search for tools\n- `call_tool(name, arguments)` - Execute a tool\n- `to_strands_tools()` - Convert to Strands tool format\n\n### UtcpAgentTool\n\nWrapper for individual UTCP tools.\n\n#### Properties\n\n- `name` - Tool name (sanitized)\n- `description` - Tool description\n- `input_schema` - JSON Schema for inputs\n\n#### Methods\n\n- `call(**kwargs)` - Execute the tool\n\n### UtcpToolAdapterError\n\nException raised for UTCP-specific errors.\n\n## Testing\n\n```bash\n# Install development dependencies\npip install -e \".[dev]\"\n\n# Run tests\npytest tests/ -v\n\n# Run with coverage\npytest tests/ --cov=strands_utcp --cov-report=html\n```\n\n## Contributing\n\nContributions are welcome! Please feel free to submit a Pull Request.\n\n1. Fork the repository\n2. Create your feature branch (`git checkout -b feature/amazing-feature`)\n3. Commit your changes (`git commit -m 'Add amazing feature'`)\n4. Push to the branch (`git push origin feature/amazing-feature`)\n5. Open a Pull Request\n\n## License\n\nThis project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.\n\n## Links\n\n- [Strands Agents SDK](https://github.com/strands-agents/sdk-python)\n- [UTCP Specification](https://github.com/universal-tool-calling-protocol/utcp-specification)\n- [UTCP Python Implementation](https://github.com/universal-tool-calling-protocol/python-utcp)\n- [PyPI Package](https://pypi.org/project/strands-utcp/)\n\n\n---\n\nBuilt for the UTCP and Strands communities ðŸš€\n",
      "line_count": 278,
      "word_count": 681,
      "title": "strands-utcp",
      "summary": "[![PyPI version](https://badge.fury.io/py/strands-utcp.svg)](https://badge.fury.io/py/strands-utcp) [![Python Support](https://img.shields.io/pypi/pyversions/strands-utcp.svg)](https://pypi.org/projec...",
      "key_terms": [
        "sanitized",
        "Model",
        "localhost",
        "img",
        "Type",
        "Found",
        "licensed",
        "multiple",
        "UtcpAgentTool",
        "Async",
        "Drop",
        "if",
        "Features",
        "sse",
        "Supported",
        "Configure",
        "Main",
        "git",
        "await",
        "call"
      ],
      "timestamp": "2025-12-24T18:56:16.096244"
    },
    {
      "file_path": "UPSTREAM\\strands-utcp\\examples\\basic_usage.py",
      "content_type": "code",
      "content": "#!/usr/bin/env python\n\"\"\"Basic usage example of strands-utcp.\"\"\"\n\nimport asyncio\nimport os\nfrom dotenv import load_dotenv\n\nfrom strands_utcp import UtcpToolAdapter\nfrom strands import Agent\n\n\nasync def main():\n    \"\"\"Run basic UTCP example.\"\"\"\n    # Load environment variables\n    load_dotenv()\n    \n    print(\"=== Basic UTCP Tool Provider Example ===\\n\")\n    \n    # Configure UTCP tool provider with real OpenAPI endpoints\n    config = {\n        \"manual_call_templates\": [\n            {\n                \"name\": \"petstore\",\n                \"call_template_type\": \"http\",\n                \"http_method\": \"GET\",\n                \"url\": \"https://petstore.swagger.io/v2/swagger.json\"\n            },\n            {\n                \"name\": \"openlibrary\", \n                \"call_template_type\": \"http\",\n                \"http_method\": \"GET\",\n                \"url\": \"https://openlibrary.org/static/openapi.json\"\n            }\n        ]\n    }\n    \n    # Use UTCP tool provider\n    async with UtcpToolAdapter(config) as adapter:\n        print(\"UTCP tool provider initialized successfully\")\n        \n        # List available tools\n        tools = adapter.list_tools()\n        print(f\"Found {len(tools)} UTCP tools:\")\n        \n        for tool in tools:\n            print(f\"  - {tool.tool_name}: {tool.description}\")\n        \n        # Search for specific tools\n        pet_tools = await adapter.search_tools(\"pet\", max_results=5)\n        print(f\"\\nFound {len(pet_tools)} pet-related tools:\")\n        \n        for tool in pet_tools:\n            print(f\"  - {tool.tool_name}: {tool.description}\")\n        \n        # Search for OpenLibrary tools specifically\n        openlibrary_tools = [tool for tool in tools if \"openlibrary\" in tool.tool_name][:5]\n        print(f\"\\nFound {len(openlibrary_tools)} OpenLibrary tools:\")\n        \n        for tool in openlibrary_tools:\n            print(f\"  - {tool.tool_name}: {tool.description}\")\n        \n        # Create agent with UTCP tools\n        if tools:\n            print(f\"\\nCreating agent with {len(tools)} UTCP tools...\")\n            agent = Agent(\n                tools=adapter.to_strands_tools(),\n                system_prompt=\"You are a helpful assistant with access to external tools.\"\n            )\n            \n            # Example conversation\n            print(\"\\nAgent: Ready to help! I have access to external tools via UTCP.\")\n            print(\"You can ask me to use pet store APIs, library services, or other tools.\")\n            \n            # Example tool usage - Shakespeare author lookup\n            print(\"\\nExample: Find Shakespeare's author ID in OpenLibrary\")\n            try:\n                response = await agent.invoke_async(\"Can you find William Shakespeare's author ID in the OpenLibrary database?\")\n                print(f\"Agent: {response.message}\")\n            except Exception as e:\n                print(f\"Error: {e}\")\n            \n            # Example tool usage - Pet store\n            if pet_tools:\n                print(\"\\nExample: Find information about pets in the store\")\n                try:\n                    response = await agent.invoke_async(\"What pets are available in the store?\")\n                    print(f\"Agent: {response.message}\")\n                except Exception as e:\n                    print(f\"Tool execution error: {e}\")\n        else:\n            print(\"\\nNo tools available - check API endpoints\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n",
      "line_count": 96,
      "word_count": 310,
      "title": "Basic Usage.Py",
      "summary": "\"\"\"Basic usage example of strands-utcp.\"\"\" import asyncio",
      "key_terms": [
        "async",
        "error",
        "check",
        "Utcp",
        "available",
        "me",
        "Found",
        "other",
        "usage",
        "Error",
        "except",
        "You",
        "nCreating",
        "strands",
        "https",
        "if",
        "pets",
        "Run",
        "basic",
        "nFound"
      ],
      "timestamp": "2025-12-24T18:56:16.128146"
    },
    {
      "file_path": "UPSTREAM\\strands-utcp\\src\\strands_utcp\\utcp_tool_adapter.py",
      "content_type": "code",
      "content": "\"\"\"UTCP Tool Adapter for Strands Agents SDK.\"\"\"\n\nimport asyncio\nimport json\nimport logging\nimport uuid\nfrom typing import Any, Dict, List, Optional, Union\n\nfrom utcp.data.tool import Tool as UTCPTool\nfrom utcp.data.utcp_client_config import UtcpClientConfig\nfrom utcp.utcp_client import UtcpClient\n\n# Import all available call templates\nfrom utcp_http.http_call_template import HttpCallTemplate\nfrom utcp_http.sse_call_template import SseCallTemplate\nfrom utcp_http.streamable_http_call_template import StreamableHttpCallTemplate\n\n# Optional imports for other protocols\ntry:\n    from utcp_cli.cli_call_template import CliCallTemplate\nexcept ImportError:\n    CliCallTemplate = None\n\ntry:\n    from utcp_gql.gql_call_template import GqlCallTemplate\nexcept ImportError:\n    GqlCallTemplate = None\n\ntry:\n    from utcp_mcp.mcp_call_template import McpCallTemplate\nexcept ImportError:\n    McpCallTemplate = None\n\ntry:\n    from utcp_socket.tcp_call_template import TcpCallTemplate\n    from utcp_socket.udp_call_template import UdpCallTemplate\nexcept ImportError:\n    TcpCallTemplate = None\n    UdpCallTemplate = None\n\ntry:\n    from utcp_text.text_call_template import TextCallTemplate\nexcept ImportError:\n    TextCallTemplate = None\n\n# Import Strands types for proper integration\ntry:\n    from strands.types.tools import AgentTool, ToolSpec, ToolUse, ToolGenerator\n    from strands.types._events import ToolResultEvent\n    from strands.types.tools import ToolResult\nexcept ImportError:\n    # Fallback for testing without full Strands installation\n    AgentTool = object\n    ToolSpec = Dict[str, Any]\n    ToolUse = Dict[str, Any] \n    ToolGenerator = Any\n    ToolResultEvent = Any\n    ToolResult = Dict[str, Any]\n\nlogger = logging.getLogger(__name__)\n\n\ndef format_tool_name_for_bedrock(tool_name: str) -> str:\n    \"\"\"Format a tool name to meet Bedrock's requirements.\n    \n    Bedrock requires tool names to:\n    - Be 64 characters or less\n    - Match pattern ^[a-zA-Z0-9_-]{1,64}$\n    \"\"\"\n    # Replace periods with underscores (common in UTCP tool names)\n    bedrock_name = tool_name.replace(\".\", \"_\")\n    \n    # Remove any other invalid characters and replace with underscores\n    valid_chars = []\n    for char in bedrock_name:\n        if char.isalnum() or char in ['_', '-']:\n            valid_chars.append(char)\n        else:\n            valid_chars.append('_')\n    \n    bedrock_name = ''.join(valid_chars)\n    \n    # Truncate if longer than 64 characters\n    if len(bedrock_name) > 64:\n        # Use first 55 chars + underscore + 8-char UUID\n        short_uuid = str(uuid.uuid4()).replace('-', '')[:8]\n        bedrock_name = f\"{bedrock_name[:55]}_{short_uuid}\"\n    \n    return bedrock_name\n\n\nclass UtcpToolAdapterError(Exception):\n    \"\"\"Exception for UTCP tool adapter errors.\"\"\"\n    pass\n\n\nclass UtcpAgentTool(AgentTool):\n    \"\"\"Wrapper for UTCP tools to be used with Strands agents.\"\"\"\n    \n    def __init__(self, utcp_tool: UTCPTool, adapter: \"UtcpToolAdapter\"):\n        super().__init__()\n        self.utcp_tool = utcp_tool\n        self.adapter = adapter\n        \n    @property\n    def name(self) -> str:\n        \"\"\"Tool name, sanitized for Bedrock compatibility.\"\"\"\n        return format_tool_name_for_bedrock(self.utcp_tool.name)\n    \n    @property\n    def tool_name(self) -> str:\n        \"\"\"Tool name, sanitized for Bedrock compatibility.\"\"\"\n        return self.name\n    \n    def _convert_schema_to_dict(self, schema_obj) -> Dict[str, Any]:\n        \"\"\"Convert UTCP JsonSchema object to plain dictionary.\"\"\"\n        if hasattr(schema_obj, 'type'):\n            # Map invalid JSON Schema types to valid ones\n            type_mapping = {\n                \"file\": \"string\",  # Files are represented as strings in JSON Schema\n                None: \"string\"     # Default fallback\n            }\n            schema_type = type_mapping.get(schema_obj.type, schema_obj.type)\n            \n            result = {\"type\": schema_type}\n            if hasattr(schema_obj, 'description') and schema_obj.description:\n                result[\"description\"] = schema_obj.description\n            if hasattr(schema_obj, 'enum') and schema_obj.enum:\n                result[\"enum\"] = schema_obj.enum\n            if hasattr(schema_obj, 'format') and schema_obj.format:\n                result[\"format\"] = schema_obj.format\n            return result\n        return {\"type\": \"string\"}  # fallback\n    \n    @property\n    def tool_spec(self) -> ToolSpec:\n        \"\"\"Tool specification in Strands format.\"\"\"\n        # Convert properties to plain dictionaries\n        properties = {}\n        if self.utcp_tool.inputs.properties:\n            for key, value in self.utcp_tool.inputs.properties.items():\n                properties[key] = self._convert_schema_to_dict(value)\n        \n        schema = {\n            \"type\": \"object\",  # Always object for tool inputs\n            \"properties\": properties,\n        }\n        \n        if self.utcp_tool.inputs.required:\n            schema[\"required\"] = self.utcp_tool.inputs.required\n        if self.utcp_tool.inputs.description:\n            schema[\"description\"] = self.utcp_tool.inputs.description\n            \n        return {\n            \"inputSchema\": {\"json\": schema},\n            \"name\": self.tool_name,\n            \"description\": self.description,\n        }\n    \n    @property\n    def tool_type(self) -> str:\n        \"\"\"Tool type for Strands.\"\"\"\n        return \"utcp\"\n    \n    @property\n    def description(self) -> str:\n        \"\"\"Tool description.\"\"\"\n        return self.utcp_tool.description or f\"Tool: {self.utcp_tool.name}\"\n    \n    @property\n    def input_schema(self) -> Dict[str, Any]:\n        \"\"\"Tool input schema in JSON Schema format.\"\"\"\n        # Convert properties to plain dictionaries\n        properties = {}\n        if self.utcp_tool.inputs.properties:\n            for key, value in self.utcp_tool.inputs.properties.items():\n                properties[key] = self._convert_schema_to_dict(value)\n        \n        schema = {\n            \"type\": \"object\",  # Always object for tool inputs\n            \"properties\": properties,\n        }\n        \n        if self.utcp_tool.inputs.required:\n            schema[\"required\"] = self.utcp_tool.inputs.required\n        if self.utcp_tool.inputs.description:\n            schema[\"description\"] = self.utcp_tool.inputs.description\n            \n        return schema\n    \n    def stream(self, tool_use: ToolUse, invocation_state: Dict[str, Any], **kwargs: Any) -> ToolGenerator:\n        \"\"\"Stream tool execution for Strands.\"\"\"\n        async def _execute():\n            try:\n                result = await self.adapter.call_tool(\n                    self.utcp_tool.name, \n                    tool_use.get(\"input\", {})\n                )\n                \n                # Format result as ToolResult\n                if isinstance(result, str):\n                    content = result\n                elif isinstance(result, dict):\n                    content = json.dumps(result, indent=2)\n                else:\n                    content = str(result)\n                \n                tool_result = {\n                    \"toolUseId\": tool_use.get(\"toolUseId\", \"unknown\"),\n                    \"content\": [{\"text\": content}],\n                    \"status\": \"success\"\n                }\n                \n                yield ToolResultEvent(tool_result)\n                \n            except Exception as e:\n                error_result = {\n                    \"toolUseId\": tool_use.get(\"toolUseId\", \"unknown\"),\n                    \"content\": [{\"text\": f\"Error: {str(e)}\"}],\n                    \"status\": \"error\"\n                }\n                yield ToolResultEvent(error_result)\n        \n        return _execute()\n    \n    async def call(self, **kwargs) -> Any:\n        \"\"\"Execute the tool with given arguments.\"\"\"\n        return await self.adapter.call_tool(self.utcp_tool.name, kwargs)\n\n\nclass UtcpToolAdapter:\n    \"\"\"UTCP Tool Adapter for Strands Agents SDK.\"\"\"\n\n    def __init__(self, config: Optional[Dict[str, Any]] = None):\n        \"\"\"Initialize UTCP tool adapter.\n\n        Args:\n            config: Configuration dictionary containing:\n                   - 'manual_call_templates': List of call template configurations\n                     Supported types: http, sse, streamable_http, cli, graphql, mcp, tcp, udp, text\n        \"\"\"\n        self._config = config or {}\n        self._utcp_client: Optional[UtcpClient] = None\n        self._tools_cache: List[UtcpAgentTool] = []\n        logger.debug(\"Initializing UTCP tool adapter with config: %s\", config)\n\n    async def __aenter__(self) -> \"UtcpToolAdapter\":\n        \"\"\"Async context manager entry.\"\"\"\n        return await self.start()\n\n    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:\n        \"\"\"Async context manager exit.\"\"\"\n        await self.stop()\n\n    async def start(self) -> \"UtcpToolAdapter\":\n        \"\"\"Initialize and start the UTCP client.\"\"\"\n        try:\n            # Convert manual call templates\n            call_templates = []\n            for template_config in self._config.get(\"manual_call_templates\", []):\n                call_template_type = template_config.get(\"call_template_type\")\n                \n                if call_template_type == \"http\":\n                    call_template = HttpCallTemplate(\n                        name=template_config[\"name\"],\n                        call_template_type=\"http\",\n                        url=template_config[\"url\"],\n                        http_method=template_config.get(\"http_method\", \"GET\"),\n                        content_type=template_config.get(\"content_type\", \"application/json\"),\n                    )\n                    call_templates.append(call_template)\n                \n                elif call_template_type == \"sse\":\n                    call_template = SseCallTemplate(\n                        name=template_config[\"name\"],\n                        call_template_type=\"sse\",\n                        url=template_config[\"url\"],\n                        http_method=template_config.get(\"http_method\", \"GET\"),\n                        content_type=template_config.get(\"content_type\", \"application/json\"),\n                    )\n                    call_templates.append(call_template)\n                \n                elif call_template_type == \"streamable_http\":\n                    call_template = StreamableHttpCallTemplate(\n                        name=template_config[\"name\"],\n                        call_template_type=\"streamable_http\",\n                        url=template_config[\"url\"],\n                        http_method=template_config.get(\"http_method\", \"GET\"),\n                        content_type=template_config.get(\"content_type\", \"application/json\"),\n                    )\n                    call_templates.append(call_template)\n                \n                elif call_template_type == \"cli\" and CliCallTemplate:\n                    call_template = CliCallTemplate(\n                        name=template_config[\"name\"],\n                        call_template_type=\"cli\",\n                        command=template_config[\"command\"],\n                    )\n                    call_templates.append(call_template)\n                \n                elif call_template_type == \"graphql\" and GqlCallTemplate:\n                    call_template = GqlCallTemplate(\n                        name=template_config[\"name\"],\n                        call_template_type=\"graphql\",\n                        url=template_config[\"url\"],\n                    )\n                    call_templates.append(call_template)\n                \n                elif call_template_type == \"mcp\" and McpCallTemplate:\n                    call_template = McpCallTemplate(\n                        name=template_config[\"name\"],\n                        call_template_type=\"mcp\",\n                        command=template_config[\"command\"],\n                    )\n                    call_templates.append(call_template)\n                \n                elif call_template_type == \"tcp\" and TcpCallTemplate:\n                    call_template = TcpCallTemplate(\n                        name=template_config[\"name\"],\n                        call_template_type=\"tcp\",\n                        host=template_config[\"host\"],\n                        port=template_config[\"port\"],\n                    )\n                    call_templates.append(call_template)\n                \n                elif call_template_type == \"udp\" and UdpCallTemplate:\n                    call_template = UdpCallTemplate(\n                        name=template_config[\"name\"],\n                        call_template_type=\"udp\",\n                        host=template_config[\"host\"],\n                        port=template_config[\"port\"],\n                    )\n                    call_templates.append(call_template)\n                \n                elif call_template_type == \"text\" and TextCallTemplate:\n                    call_template = TextCallTemplate(\n                        name=template_config[\"name\"],\n                        call_template_type=\"text\",\n                        file_path=template_config[\"file_path\"],\n                    )\n                    call_templates.append(call_template)\n                \n                else:\n                    logger.warning(\"Unsupported or unavailable call template type: %s\", call_template_type)\n\n            # Create UTCP client config\n            utcp_config = UtcpClientConfig(manual_call_templates=call_templates)\n            \n            # Initialize UTCP client\n            self._utcp_client = await UtcpClient.create(config=utcp_config)\n            \n            # Load tools\n            await self._load_tools()\n            \n            logger.info(\"UTCP tool adapter started successfully with %d tools\", len(self._tools_cache))\n            return self\n\n        except Exception as e:\n            logger.error(\"Failed to start UTCP tool adapter: %s\", e)\n            raise UtcpToolAdapterError(f\"UTCP tool adapter initialization failed: {e}\") from e\n\n    async def stop(self) -> None:\n        \"\"\"Stop and cleanup the UTCP client.\"\"\"\n        if self._utcp_client:\n            self._utcp_client = None\n            self._tools_cache.clear()\n            logger.info(\"UTCP tool adapter stopped\")\n\n    async def _load_tools(self) -> None:\n        \"\"\"Load tools from UTCP client.\"\"\"\n        if not self._utcp_client:\n            return\n            \n        try:\n            utcp_tools = await self._utcp_client.search_tools(query=\"\", limit=1000)\n            self._tools_cache = [UtcpAgentTool(tool, self) for tool in utcp_tools]\n            logger.debug(\"Loaded %d tools from UTCP client\", len(self._tools_cache))\n        except Exception as e:\n            logger.error(\"Failed to load tools: %s\", e)\n            self._tools_cache = []\n\n    def list_tools(self) -> List[UtcpAgentTool]:\n        \"\"\"Get list of available tools.\"\"\"\n        return self._tools_cache.copy()\n\n    def get_tool(self, name: str) -> Optional[UtcpAgentTool]:\n        \"\"\"Get a specific tool by name.\"\"\"\n        for tool in self._tools_cache:\n            if tool.tool_name == name or tool.utcp_tool.name == name:\n                return tool\n        return None\n\n    async def call_tool(self, tool_name: str, arguments: Dict[str, Any]) -> Any:\n        \"\"\"Execute a tool with given arguments.\"\"\"\n        if not self._utcp_client:\n            raise UtcpToolAdapterError(\"UTCP client not initialized\")\n\n        try:\n            logger.debug(\"Calling tool %s with arguments: %s\", tool_name, arguments)\n            result = await self._utcp_client.call_tool(tool_name=tool_name, tool_args=arguments)\n            logger.debug(\"Tool %s returned: %s\", tool_name, result)\n            return result\n        except Exception as e:\n            logger.error(\"Failed to call tool %s: %s\", tool_name, e)\n            raise UtcpToolAdapterError(f\"Tool execution failed: {e}\") from e\n\n    async def search_tools(self, query: str, max_results: Optional[int] = None) -> List[UtcpAgentTool]:\n        \"\"\"Search for tools matching the query.\"\"\"\n        if not self._utcp_client:\n            raise UtcpToolAdapterError(\"UTCP client not initialized\")\n\n        try:\n            limit = max_results or 100\n            utcp_tools = await self._utcp_client.search_tools(query=query, limit=limit)\n            return [UtcpAgentTool(tool, self) for tool in utcp_tools]\n        except Exception as e:\n            logger.error(\"Failed to search tools: %s\", e)\n            return []\n\n    def to_strands_tools(self) -> List[UtcpAgentTool]:\n        \"\"\"Convert UTCP tools to Strands-compatible tool objects.\"\"\"\n        return self._tools_cache.copy()\n",
      "line_count": 423,
      "word_count": 1226,
      "title": "Utcp Tool Adapter.Py",
      "summary": "\"\"\"UTCP Tool Adapter for Strands Agents SDK.\"\"\" import asyncio",
      "key_terms": [
        "integration",
        "Fallback",
        "sanitized",
        "entry",
        "async",
        "clear",
        "search",
        "chars",
        "error",
        "pattern",
        "kwargs",
        "list",
        "info",
        "compatible",
        "format",
        "started",
        "cleanup",
        "available",
        "unknown",
        "Unsupported"
      ],
      "timestamp": "2025-12-24T18:56:16.160192"
    },
    {
      "file_path": "UPSTREAM\\strands-utcp\\src\\strands_utcp\\__init__.py",
      "content_type": "code",
      "content": "\"\"\"Universal Tool Calling Protocol (UTCP) integration for Strands Agents SDK.\n\nThis package provides seamless integration between UTCP tool providers and the Strands\nAgents framework, enabling agents to discover and use external tools via the UTCP protocol.\n\"\"\"\n\nfrom typing import Dict, List, Optional\n\nfrom .utcp_tool_adapter import UtcpToolAdapter, UtcpToolAdapterError\n\n__version__ = \"0.1.0\"\n__all__ = [\"UtcpToolAdapter\", \"UtcpToolAdapterError\"]\n\n\ndef create_utcp_adapter(config: Optional[Dict] = None, **kwargs) -> UtcpToolAdapter:\n    \"\"\"Create a UTCP tool provider with default settings.\n\n    Args:\n        config: UTCP configuration dictionary\n        **kwargs: Additional adapter parameters\n\n    Returns:\n        Configured UtcpToolAdapter instance\n    \"\"\"\n    return UtcpToolAdapter(config=config, **kwargs)\n",
      "line_count": 26,
      "word_count": 88,
      "title": "  Init  .Py",
      "summary": "\"\"\"Universal Tool Calling Protocol (UTCP) integration for Strands Agents SDK. This package provides seamless integration between UTCP tool providers and the Strands",
      "key_terms": [
        "integration",
        "from",
        "None",
        "config",
        "kwargs",
        "def",
        "utcp",
        "with",
        "Tool",
        "Utcp",
        "tool",
        "settings",
        "configuration",
        "Universal",
        "providers",
        "protocol",
        "dictionary",
        "for",
        "default",
        "and"
      ],
      "timestamp": "2025-12-24T18:56:16.176094"
    },
    {
      "file_path": "UPSTREAM\\strands-utcp\\tests\\test_utcp_tool_adapter.py",
      "content_type": "code",
      "content": "\"\"\"Unit tests for UTCP tool adapter.\"\"\"\n\nfrom unittest.mock import AsyncMock, MagicMock, patch\nimport pytest\n\nfrom strands_utcp import UtcpToolAdapter, UtcpToolAdapterError\n\n\n@pytest.fixture\ndef adapter_config():\n    \"\"\"Sample adapter configuration.\"\"\"\n    return {\n        \"manual_call_templates\": [\n            {\n                \"name\": \"test_api\",\n                \"call_template_type\": \"http\",\n                \"url\": \"https://api.test.com/utcp\",\n                \"http_method\": \"GET\"\n            }\n        ]\n    }\n\n\n@pytest.fixture\ndef mock_utcp_tool():\n    \"\"\"Mock UTCP tool.\"\"\"\n    tool = MagicMock()\n    tool.name = \"test_tool\"\n    tool.description = \"Test tool description\"\n    tool.inputs.type = \"object\"\n    tool.inputs.properties = {\"param1\": {\"type\": \"string\"}}\n    tool.inputs.required = [\"param1\"]\n    tool.inputs.description = \"Test input schema\"\n    return tool\n\n\ndef test_adapter_initialization(adapter_config):\n    \"\"\"Test UtcpToolAdapter initialization.\"\"\"\n    adapter = UtcpToolAdapter(adapter_config)\n    assert adapter._config == adapter_config\n    assert adapter._utcp_client is None\n    assert adapter._tools_cache == []\n\n\ndef test_adapter_initialization_empty_config():\n    \"\"\"Test UtcpToolAdapter initialization with empty config.\"\"\"\n    adapter = UtcpToolAdapter()\n    assert adapter._config == {}\n    assert adapter._utcp_client is None\n\n\n@pytest.mark.asyncio\nasync def test_adapter_context_manager(adapter_config):\n    \"\"\"Test UtcpToolAdapter as async context manager.\"\"\"\n    with patch('strands_utcp.utcp_tool_adapter.UtcpClient') as mock_client_class:\n        mock_client = AsyncMock()\n        mock_client_class.create = AsyncMock(return_value=mock_client)\n        mock_client.search_tools.return_value = []\n        \n        async with UtcpToolAdapter(adapter_config) as adapter:\n            assert adapter._utcp_client is not None\n            mock_client_class.create.assert_called_once()\n        \n        # After context exit, client should be cleaned up\n        assert adapter._utcp_client is None\n\n\n@pytest.mark.asyncio\nasync def test_adapter_start_success(adapter_config, mock_utcp_tool):\n    \"\"\"Test successful adapter start.\"\"\"\n    with patch('strands_utcp.utcp_tool_adapter.UtcpClient') as mock_client_class:\n        mock_client = AsyncMock()\n        mock_client_class.create = AsyncMock(return_value=mock_client)\n        mock_client.search_tools.return_value = [mock_utcp_tool]\n        \n        adapter = UtcpToolAdapter(adapter_config)\n        result = await adapter.start()\n        \n        assert result is adapter\n        assert adapter._utcp_client is not None\n        assert len(adapter._tools_cache) == 1\n        mock_client_class.create.assert_called_once()\n\n\n@pytest.mark.asyncio\nasync def test_adapter_start_failure(adapter_config):\n    \"\"\"Test adapter start failure.\"\"\"\n    with patch('strands_utcp.utcp_tool_adapter.UtcpClient') as mock_client_class:\n        mock_client_class.create.side_effect = Exception(\"Connection failed\")\n        \n        adapter = UtcpToolAdapter(adapter_config)\n        \n        with pytest.raises(UtcpToolAdapterError, match=\"UTCP tool adapter initialization failed\"):\n            await adapter.start()\n\n\n@pytest.mark.asyncio\nasync def test_list_tools(adapter_config, mock_utcp_tool):\n    \"\"\"Test listing tools.\"\"\"\n    with patch('strands_utcp.utcp_tool_adapter.UtcpClient') as mock_client_class:\n        mock_client = AsyncMock()\n        mock_client_class.create = AsyncMock(return_value=mock_client)\n        mock_client.search_tools.return_value = [mock_utcp_tool]\n        \n        async with UtcpToolAdapter(adapter_config) as adapter:\n            tools = adapter.list_tools()\n            \n            assert len(tools) == 1\n            assert tools[0].name == \"test_tool\"\n            assert tools[0].description == \"Test tool description\"\n\n\n@pytest.mark.asyncio\nasync def test_get_tool(adapter_config, mock_utcp_tool):\n    \"\"\"Test getting specific tool.\"\"\"\n    with patch('strands_utcp.utcp_tool_adapter.UtcpClient') as mock_client_class:\n        mock_client = AsyncMock()\n        mock_client_class.create = AsyncMock(return_value=mock_client)\n        mock_client.search_tools.return_value = [mock_utcp_tool]\n        \n        async with UtcpToolAdapter(adapter_config) as adapter:\n            tool = adapter.get_tool(\"test_tool\")\n            assert tool is not None\n            assert tool.name == \"test_tool\"\n            \n            # Test non-existent tool\n            missing_tool = adapter.get_tool(\"missing_tool\")\n            assert missing_tool is None\n\n\n@pytest.mark.asyncio\nasync def test_call_tool(adapter_config, mock_utcp_tool):\n    \"\"\"Test calling a tool.\"\"\"\n    with patch('strands_utcp.utcp_tool_adapter.UtcpClient') as mock_client_class:\n        mock_client = AsyncMock()\n        mock_client_class.create = AsyncMock(return_value=mock_client)\n        mock_client.search_tools.return_value = [mock_utcp_tool]\n        mock_client.call_tool.return_value = {\"result\": \"success\"}\n        \n        async with UtcpToolAdapter(adapter_config) as adapter:\n            result = await adapter.call_tool(\"test_tool\", {\"param1\": \"value1\"})\n            \n            assert result == {\"result\": \"success\"}\n            mock_client.call_tool.assert_called_once_with(\n                tool_name=\"test_tool\",\n                tool_args={\"param1\": \"value1\"}\n            )\n\n\n@pytest.mark.asyncio\nasync def test_call_tool_not_initialized():\n    \"\"\"Test calling tool when adapter not initialized.\"\"\"\n    adapter = UtcpToolAdapter()\n    \n    with pytest.raises(UtcpToolAdapterError, match=\"UTCP client not initialized\"):\n        await adapter.call_tool(\"test_tool\", {})\n\n\n@pytest.mark.asyncio\nasync def test_search_tools(adapter_config, mock_utcp_tool):\n    \"\"\"Test searching tools.\"\"\"\n    with patch('strands_utcp.utcp_tool_adapter.UtcpClient') as mock_client_class:\n        mock_client = AsyncMock()\n        mock_client_class.create = AsyncMock(return_value=mock_client)\n        mock_client.search_tools.return_value = [mock_utcp_tool]\n        \n        async with UtcpToolAdapter(adapter_config) as adapter:\n            # Initial search_tools call during start() loads tools\n            # Now test the search functionality\n            mock_client.search_tools.return_value = [mock_utcp_tool]\n            \n            results = await adapter.search_tools(\"test\", max_results=10)\n            \n            assert len(results) == 1\n            assert results[0].name == \"test_tool\"\n            \n            # Verify the search was called with correct parameters\n            # Note: search_tools is called twice - once during start() and once in our test\n            assert mock_client.search_tools.call_count >= 2\n\n\n@pytest.mark.asyncio\nasync def test_to_strands_tools(adapter_config, mock_utcp_tool):\n    \"\"\"Test converting to Strands tools format.\"\"\"\n    with patch('strands_utcp.utcp_tool_adapter.UtcpClient') as mock_client_class:\n        mock_client = AsyncMock()\n        mock_client_class.create = AsyncMock(return_value=mock_client)\n        mock_client.search_tools.return_value = [mock_utcp_tool]\n        \n        async with UtcpToolAdapter(adapter_config) as adapter:\n            strands_tools = adapter.to_strands_tools()\n            \n            assert len(strands_tools) == 1\n            tool_spec = strands_tools[0]\n            \n            assert tool_spec.name == \"test_tool\"\n\n\ndef test_utcp_agent_tool_properties(mock_utcp_tool):\n    \"\"\"Test UtcpAgentTool properties.\"\"\"\n    from strands_utcp.utcp_tool_adapter import UtcpAgentTool\n    \n    adapter = MagicMock()\n    tool = UtcpAgentTool(mock_utcp_tool, adapter)\n    \n    assert tool.name == \"test_tool\"\n    assert tool.description == \"Test tool description\"\n    \n    schema = tool.input_schema\n    assert schema[\"type\"] == \"object\"\n    assert schema[\"properties\"] == {\"param1\": {\"type\": \"string\"}}\n    assert schema[\"required\"] == [\"param1\"]\n    assert schema[\"description\"] == \"Test input schema\"\n\n\ndef test_utcp_agent_tool_name_sanitization():\n    \"\"\"Test tool name sanitization.\"\"\"\n    from strands_utcp.utcp_tool_adapter import UtcpAgentTool\n    \n    mock_tool = MagicMock()\n    mock_tool.name = \"api.v1.get_data\"  # Name with dots\n    mock_tool.description = \"Test tool\"\n    mock_tool.inputs.type = \"object\"\n    mock_tool.inputs.properties = {}\n    mock_tool.inputs.required = []\n    mock_tool.inputs.description = None\n    \n    adapter = MagicMock()\n    tool = UtcpAgentTool(mock_tool, adapter)\n    \n    # Dots should be replaced with underscores\n    assert tool.name == \"api_v1_get_data\"\n\n\n@pytest.mark.asyncio\nasync def test_utcp_agent_tool_call():\n    \"\"\"Test UtcpAgentTool call method.\"\"\"\n    from strands_utcp.utcp_tool_adapter import UtcpAgentTool\n    \n    mock_utcp_tool = MagicMock()\n    mock_utcp_tool.name = \"test_tool\"\n    \n    mock_adapter = AsyncMock()\n    mock_adapter.call_tool.return_value = {\"result\": \"success\"}\n    \n    tool = UtcpAgentTool(mock_utcp_tool, mock_adapter)\n    result = await tool.call(param1=\"value1\")\n    \n    assert result == {\"result\": \"success\"}\n    mock_adapter.call_tool.assert_called_once_with(\"test_tool\", {\"param1\": \"value1\"})\n",
      "line_count": 251,
      "word_count": 667,
      "title": "Test Utcp Tool Adapter.Py",
      "summary": "\"\"\"Unit tests for UTCP tool adapter.\"\"\" from unittest.mock import AsyncMock, MagicMock, patch",
      "key_terms": [
        "up",
        "AsyncMock",
        "async",
        "After",
        "getting",
        "search",
        "format",
        "Utcp",
        "during",
        "Test",
        "string",
        "twice",
        "UtcpAgentTool",
        "parameters",
        "https",
        "failure",
        "correct",
        "Connection",
        "exit",
        "MagicMock"
      ],
      "timestamp": "2025-12-24T18:56:16.197394"
    }
  ],
  "timestamp": "2025-12-24T18:56:16.197394"
}