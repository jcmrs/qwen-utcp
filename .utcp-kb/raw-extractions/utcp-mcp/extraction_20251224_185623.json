{
  "repository": "utcp-mcp",
  "commit_hash": "5ed1f04660cd276879d0e6bba365dd0a490948dc",
  "commit_timestamp": "1764255088",
  "file_count": 35,
  "extractions": [
    {
      "file_path": "UPSTREAM\\utcp-mcp\\.utcp_config.json",
      "content_type": "configuration",
      "content": "{\n    \"load_variables_from\": [\n      {\n        \"variable_loader_type\": \"dotenv\",\n        \"env_file_path\": \".env\"\n      }\n    ],\n    \"tool_repository\": {\n      \"tool_repository_type\": \"in_memory\"\n    },\n    \"tool_search_strategy\": {\n      \"tool_search_strategy_type\": \"tag_and_description_word_match\"\n    },\n    \"manual_call_templates\": [\n      {\n          \"name\": \"openlibrary\",\n          \"call_template_type\": \"http\",\n          \"http_method\": \"GET\",\n          \"url\": \"https://openlibrary.org/static/openapi.json\",\n          \"content_type\": \"application/json\"\n      }\n    ],\n    \"post_processing\": [\n      {\n          \"tool_post_processor_type\": \"filter_dict\",\n          \"only_include_keys\": [\"name\", \"key\"],\n          \"only_include_tools\": [\"openlibrary.read_search_authors_json_search_authors_json_get\"]\n      }\n    ]\n  }",
      "line_count": 30,
      "word_count": 48,
      "title": ".Utcp Config.Json",
      "summary": "\"load_variables_from\": [ \"variable_loader_type\": \"dotenv\",",
      "key_terms": [
        "url",
        "https",
        "GET",
        "org",
        "env",
        "api",
        "dotenv",
        "json",
        "static",
        "openlibrary",
        "key",
        "openapi",
        "application",
        "method",
        "http",
        "name"
      ],
      "timestamp": "2025-12-24T18:56:22.937401"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\index.ts",
      "content_type": "code",
      "content": "#!/usr/bin/env node\n\n// UTCP-MCP Bridge Entry Point\n// This is the main entry point for the npx @utcp/mcp-bridge command\n\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\nimport path from \"path\";\nimport { promises as fs } from \"fs\";\nimport { parse as parseDotEnv } from 'dotenv';\nimport { fileURLToPath } from 'url';\nimport { dirname } from 'path';\n\nimport \"@utcp/http\";\nimport \"@utcp/text\";\nimport \"@utcp/mcp\";\nimport \"@utcp/cli\";\nimport \"@utcp/dotenv-loader\"\nimport \"@utcp/file\"\n\nimport {\n    UtcpClient,\n    CallTemplateSchema,\n    InMemConcurrentToolRepository,\n    TagSearchStrategy,\n    DefaultVariableSubstitutor,\n    ensureCorePluginsInitialized,\n    UtcpClientConfigSerializer\n} from \"@utcp/sdk\";\nimport type { UtcpClientConfig } from \"@utcp/sdk\";\n\n// Get current file directory for Node.js ESM\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\nensureCorePluginsInitialized();\n\nlet utcpClient: UtcpClient | null = null;\n\nasync function main() {\n    setupMcpTools();\n    utcpClient = await initializeUtcpClient();\n    const transport = new StdioServerTransport();\n    await mcp.connect(transport);\n}\n\nconst mcp = new McpServer({\n    name: \"UTCP-Client-MCP-Bridge\",\n    version: \"1.0.0\",\n});\n\nfunction setupMcpTools() {\n    mcp.registerTool(\"register_manual\", {\n        title: \"Register a UTCP Manual\",\n        description: \"Registers a new tool provider by providing its call template.\",\n        inputSchema: { manual_call_template: CallTemplateSchema.describe(\"The call template for the UTCP Manual endpoint.\") },\n    }, async (input) => {\n        const client = await initializeUtcpClient();\n        try {\n            const result = await client.registerManual(input.manual_call_template as any);\n            return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n\n    mcp.registerTool(\"deregister_manual\", {\n        title: \"Deregister a UTCP Manual\",\n        description: \"Deregisters a tool provider from the UTCP client.\",\n        inputSchema: { manual_name: z.string().describe(\"The name of the manual to deregister.\") },\n    }, async (input) => {\n        const client = await initializeUtcpClient();\n        try {\n            const success = await client.deregisterManual(input.manual_name);\n            const message = success ? `Manual '${input.manual_name}' deregistered.` : `Manual '${input.manual_name}' not found.`;\n            return { content: [{ type: \"text\", text: JSON.stringify({ success, message }) }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n\n    mcp.registerTool(\"call_tool\", {\n        title: \"Call a UTCP Tool\",\n        description: \"Calls a registered tool by its full namespaced name.\",\n        inputSchema: {\n            tool_name: z.string().describe(\"The full name of the tool to call.\"),\n            arguments: z.record(z.string(), z.any()).describe(\"A JSON object of arguments.\"),\n        },\n    }, async (input) => {\n        const client = await initializeUtcpClient();\n        try {\n            const result = await client.callTool(input.tool_name, input.arguments);\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: true, tool_name: input.tool_name, result }) }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n\n    mcp.registerTool(\"search_tools\", {\n        title: \"Search for UTCP Tools\",\n        description: \"Searches for relevant tools based on a task description.\",\n        inputSchema: {\n            task_description: z.string().describe(\"A natural language description of the task.\"),\n            limit: z.number().optional().default(10),\n        },\n    }, async (input) => {\n        const client = await initializeUtcpClient();\n        try {\n            const tools = await client.searchTools(input.task_description, input.limit);\n            const simplified = tools.map(t => ({ name: t.name, description: t.description, input_schema: t.inputs }));\n            return { content: [{ type: \"text\", text: JSON.stringify({ tools: simplified }) }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n\n    mcp.registerTool(\"list_tools\", {\n        title: \"List All Registered UTCP Tools\",\n        description: \"Returns a list of all tool names currently registered.\",\n        inputSchema: {},\n    }, async () => {\n        const client = await initializeUtcpClient();\n        try {\n            const tools = await client.config.tool_repository.getTools();\n            const toolNames = tools.map(t => t.name);\n            return { content: [{ type: \"text\", text: JSON.stringify({ tools: toolNames }) }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n\n    mcp.registerTool(\"get_required_keys_for_tool\", {\n        title: \"Get Required Variables for Tool\",\n        description: \"Get required environment variables for a registered tool.\",\n        inputSchema: {\n            tool_name: z.string().describe(\"Name of the tool to get required variables for.\"),\n        },\n    }, async (input) => {\n        const client = await initializeUtcpClient();\n        try {\n            const variables = await client.getRequiredVariablesForRegisteredTool(input.tool_name);\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: true, tool_name: input.tool_name, required_variables: variables }) }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, tool_name: input.tool_name, error: e.message }) }] };\n        }\n    });\n\n    mcp.registerTool(\"tool_info\", {\n        title: \"Get Tool Information\",\n        description: \"Get complete information about a specific tool including all details.\",\n        inputSchema: {\n            tool_name: z.string().describe(\"Name of the tool to get complete information for.\"),\n        },\n    }, async (input) => {\n        const client = await initializeUtcpClient();\n        try {\n            const tool = await client.config.tool_repository.getTool(input.tool_name);\n            if (!tool) {\n                return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: `Tool '${input.tool_name}' not found` }) }] };\n            }\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: true, tool: tool }) }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n}\n\nasync function initializeUtcpClient(): Promise<UtcpClient> {\n    if (utcpClient) {\n        return utcpClient as UtcpClient;\n    }\n\n    // Look for config file: 1) Environment variable, 2) Current working directory, 3) Package directory\n    const cwd = process.cwd();\n    const packageDir = __dirname;\n    \n    let configPath: string;\n    let scriptDir: string;\n    \n    // Check if UTCP_CONFIG_FILE environment variable is set\n    if (process.env.UTCP_CONFIG_FILE) {\n        configPath = path.resolve(process.env.UTCP_CONFIG_FILE);\n        scriptDir = path.dirname(configPath);\n        \n        try {\n            await fs.access(configPath);\n        } catch {\n            console.warn(`UTCP config file specified in UTCP_CONFIG_FILE not found: ${configPath}`);\n        }\n    } else {\n        // Fall back to current working directory first, then package directory\n        configPath = path.resolve(cwd, '.utcp_config.json');\n        scriptDir = cwd;\n        \n        try {\n            await fs.access(configPath);\n        } catch {\n            configPath = path.resolve(packageDir, '.utcp_config.json');\n            scriptDir = packageDir;\n        }\n    }\n\n    let rawConfig: any = {};\n    try {\n        const configFileContent = await fs.readFile(configPath, 'utf-8');\n        rawConfig = JSON.parse(configFileContent);\n    } catch (e: any) {\n        if (e.code !== 'ENOENT') {\n            console.warn(`Could not read or parse .utcp_config.json. Error: ${e.message}`);\n        }\n    }\n\n    const clientConfig = new UtcpClientConfigSerializer().validateDict(rawConfig);\n\n    const newClient = await UtcpClient.create(scriptDir, clientConfig);\n\n    utcpClient = newClient;\n    return utcpClient as UtcpClient;\n}\n\nmain().catch(err => {\n    console.error(\"Failed to start UTCP-MCP Bridge:\", err);\n    process.exit(1);\n});\n",
      "line_count": 226,
      "word_count": 967,
      "title": "Index.Ts",
      "summary": "// UTCP-MCP Bridge Entry Point // This is the main entry point for the npx @utcp/mcp-bridge command",
      "key_terms": [
        "null",
        "const",
        "entry",
        "async",
        "number",
        "error",
        "record",
        "based",
        "list",
        "Utcp",
        "connect",
        "specified",
        "found",
        "natural",
        "string",
        "Error",
        "task",
        "version",
        "path",
        "validateDict"
      ],
      "timestamp": "2025-12-24T18:56:22.977585"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\package.json",
      "content_type": "configuration",
      "content": "{\n  \"name\": \"@utcp/mcp-bridge\",\n  \"version\": \"1.0.3\",\n  \"description\": \"Model Context Protocol (MCP) server to use Universal Tool Calling Protocol (UTCP)\",\n  \"type\": \"module\",\n  \"main\": \"dist/index.js\",\n  \"bin\": {\n    \"mcp-bridge\": \"./dist/index.js\"\n  },\n  \"files\": [\n    \"dist/**/*\",\n    \"README.md\"\n  ],\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"prepublishOnly\": \"npm run build\",\n    \"start\": \"node dist/index.js\"\n  },\n  \"keywords\": [\n    \"utcp\",\n    \"mcp\",\n    \"model-context-protocol\",\n    \"universal-tool-calling-protocol\",\n    \"bridge\",\n    \"tools\",\n    \"ai\"\n  ],\n  \"author\": \"UTCP Team\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/universal-tool-calling-protocol/utcp-mcp.git\"\n  },\n  \"homepage\": \"https://github.com/universal-tool-calling-protocol/utcp-mcp#readme\",\n  \"bugs\": {\n    \"url\": \"https://github.com/universal-tool-calling-protocol/utcp-mcp/issues\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  },\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"typescript\": \"^5.0.0\"\n  },\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^1.20.2\",\n    \"@utcp/cli\": \"^1.0.12\",\n    \"@utcp/http\": \"^1.0.13\",\n    \"@utcp/mcp\": \"^1.0.12\",\n    \"@utcp/sdk\": \"^1.0.16\",\n    \"@utcp/text\": \"^1.0.12\",\n    \"@utcp/dotenv-loader\": \"^1.0.0\",\n    \"@utcp/file\": \"^1.0.0\",\n    \"dotenv\": \"^16.0.0\",\n    \"zod\": \"^3.22.0\"\n  }\n}\n",
      "line_count": 61,
      "word_count": 114,
      "title": "Package.Json",
      "summary": "\"name\": \"@utcp/mcp-bridge\", \"version\": \"1.0.3\",",
      "key_terms": [
        "build",
        "Model",
        "md",
        "index",
        "dependencies",
        "version",
        "devDependencies",
        "Calling",
        "model",
        "https",
        "utcp-mcp",
        "universal-tool",
        "readme",
        "git",
        "files",
        "ai",
        "description",
        "loader",
        "bugs",
        "scripts"
      ],
      "timestamp": "2025-12-24T18:56:23.009306"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\README.md",
      "content_type": "documentation",
      "content": "# UTCP-MCP Bridge\n\n**The last MCP server you'll ever need.**\n\nA universal, all-in-one MCP server that brings the full power of the Universal Tool Calling Protocol (UTCP) to the MCP ecosystem.\n\n## üöÄ Quick Start\n\nAdd this configuration to your MCP client (Claude Desktop, etc.):\n\n```json\n{\n  \"mcpServers\": {\n    \"utcp\": {\n      \"command\": \"npx\",\n      \"args\": [\"@utcp/mcp-bridge\"],\n      \"env\": {\n        \"UTCP_CONFIG_FILE\": \"/path/to/your/.utcp_config.json\"\n      }\n    }\n  }\n}\n```\n\n**That's it!** No installation required. The bridge will automatically:\n- Download and run the latest version via npx\n- Load your UTCP configuration from the specified path\n- Register all your UTCP manuals as MCP tools\n- Provide a unified interface to manage your tool ecosystem\n\n## üîß Configuration\n\nCreate a `.utcp_config.json` file to configure your tools and services:\n\n```json\n{\n    \"load_variables_from\": [\n      {\n        \"variable_loader_type\": \"dotenv\",\n        \"env_file_path\": \".env\"\n      }\n    ],\n    \"manual_call_templates\": [\n      {\n          \"name\": \"openlibrary\",\n          \"call_template_type\": \"http\",\n          \"http_method\": \"GET\", \n          \"url\": \"https://openlibrary.org/static/openapi.json\",\n          \"content_type\": \"application/json\"\n      }\n    ],\n    \"post_processing\": [\n      {\n          \"tool_post_processor_type\": \"filter_dict\",\n          \"only_include_keys\": [\"name\", \"description\"],\n          \"only_include_tools\": [\"openlibrary.*\"]\n      }\n    ],\n    \"tool_repository\": {\n      \"tool_repository_type\": \"in_memory\"\n    },\n    \"tool_search_strategy\": {\n      \"tool_search_strategy_type\": \"tag_and_description_word_match\"\n    }\n}\n```\n\n## üõ†Ô∏è Available MCP Tools\n\nThe bridge exposes these MCP tools for managing your UTCP ecosystem:\n\n- **`register_manual`** - Register new UTCP manuals/APIs\n- **`deregister_manual`** - Remove registered manuals\n- **`call_tool`** - Execute any registered UTCP tool\n- **`search_tools`** - Find tools by description\n- **`list_tools`** - List all registered tool names\n- **`get_required_keys_for_tool`** - Get required environment variables\n- **`tool_info`** - Get complete tool information and schema\n\n## üìÅ What is UTCP?\n\nThe Universal Tool Calling Protocol (UTCP) allows you to:\n- **Connect to any API** via HTTP, OpenAPI specs, or custom formats\n- **Use command-line tools** with automatic argument parsing\n- **Process text and files** with built-in utilities\n- **Chain and combine** multiple tools seamlessly\n\nWith this MCP bridge, all your UTCP tools become available in Claude Desktop and other MCP clients.\n\n## üåü Features\n\n- ‚úÖ **Zero installation** - Works via npx\n- ‚úÖ **Universal compatibility** - Works with any MCP client\n- ‚úÖ **Dynamic configuration** - Update tools without restarting\n- ‚úÖ **Environment isolation** - Each project can have its own config\n- ‚úÖ **Comprehensive tool management** - Register, search, call, and inspect tools\n- ‚úÖ **Web interface available** - See [web_ui_utcp_mcp_bridge/](web_ui_utcp_mcp_bridge/)\n\n## üêç Python Version\n\nFor Python users, see the standalone Python implementation in [`python_mcp_bridge/`](python_mcp_bridge/)\n\n## üåê Web Interface\n\nFor advanced management with a web UI, check out [`web_ui_utcp_mcp_bridge/`](web_ui_utcp_mcp_bridge/)\n\n---\n\n<img width=\"2263\" height=\"976\" alt=\"UTCP MCP Bridge Interface\" src=\"https://github.com/user-attachments/assets/a6759512-1c0d-4265-9518-64916fbe1428\" />",
      "line_count": 109,
      "word_count": 407,
      "title": "UTCP-MCP Bridge",
      "summary": "**The last MCP server you'll ever need.** A universal, all-in-one MCP server that brings the full power of the Universal Tool Calling Protocol (UTCP) to the MCP ecosystem.",
      "key_terms": [
        "project",
        "Python",
        "isolation",
        "search",
        "etc",
        "img",
        "check",
        "Comprehensive",
        "Available",
        "available",
        "specified",
        "other",
        "unified",
        "multiple",
        "application",
        "Chain",
        "version",
        "Calling",
        "Execute",
        "path"
      ],
      "timestamp": "2025-12-24T18:56:23.041271"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\tsconfig.json",
      "content_type": "configuration",
      "content": "{\n  \"compilerOptions\": {\n    // Environment setup & latest features\n    \"lib\": [\"ESNext\", \"ES2022\"],\n    \"target\": \"ES2022\",\n    \"module\": \"ESNext\",\n    \"moduleDetection\": \"force\",\n    \"allowJs\": true,\n\n    // Node.js mode\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"resolveJsonModule\": true,\n\n    // Output configuration\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./\",\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true,\n\n    // Best practices\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"noUncheckedIndexedAccess\": true,\n    \"noImplicitOverride\": true,\n\n    // Some stricter flags (disabled by default)\n    \"noUnusedLocals\": false,\n    \"noUnusedParameters\": false,\n    \"noPropertyAccessFromIndexSignature\": false\n  },\n  \"include\": [\n    \"index.ts\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"examples\",\n    \"web_ui_utcp_mcp_bridge\",\n    \"python_mcp_bridge\"\n  ]\n}\n",
      "line_count": 46,
      "word_count": 84,
      "title": "Tsconfig.Json",
      "summary": "\"compilerOptions\": { // Environment setup & latest features",
      "key_terms": [
        "node",
        "disabled",
        "exclude",
        "Some",
        "lib",
        "module",
        "skipLibCheck",
        "flags",
        "force",
        "target",
        "allowSyntheticDefaultImports",
        "outDir",
        "index",
        "mode",
        "utcp",
        "examples",
        "configuration",
        "rootDir",
        "default",
        "ts"
      ],
      "timestamp": "2025-12-24T18:56:23.041271"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\utcp-client-mcp.ts",
      "content_type": "code",
      "content": "// utcp-client-mcp.ts (TypeScript MCP-UTCP Bridge Server)\n\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\nimport path from \"path\";\nimport { promises as fs } from \"fs\";\nimport { parse as parseDotEnv } from 'dotenv';\n\nimport \"@utcp/http\";\nimport \"@utcp/text\";\nimport \"@utcp/mcp\";\nimport \"@utcp/cli\";\n\nimport {\n    UtcpClient,\n    CallTemplateSchema,\n    InMemConcurrentToolRepository,\n    TagSearchStrategy,\n    DefaultVariableSubstitutor,\n    ensureCorePluginsInitialized\n} from \"@utcp/sdk\";\nimport type { UtcpClientConfig } from \"@utcp/sdk\";\n\nensureCorePluginsInitialized();\n\nlet utcpClient: UtcpClient | null = null;\n\nasync function main() {\n    console.log(\"Initializing UTCP-MCP Bridge...\");\n    setupMcpTools();\n    utcpClient = await initializeUtcpClient();\n\n    const bridgeScriptPath = path.resolve(import.meta.dir, import.meta.file);\n    const connectionConfig = {\n        mcpServers: {\n            \"typescript-utcp-bridge\": {\n                command: \"bun\",\n                args: [\"run\", bridgeScriptPath],\n            }\n        }\n    };\n\n    console.log(\"\\n‚úÖ Bridge is ready. To connect, use this configuration in your MCP client's config file:\");\n    console.log(\"================================ MCP CONFIG ================================\");\n    console.log(JSON.stringify(connectionConfig, null, 2));\n    console.log(\"==========================================================================\");\n\n    console.log(\"\\nStarting MCP server on stdio...\");\n    const transport = new StdioServerTransport();\n    await mcp.connect(transport);\n}\n\nconst mcp = new McpServer({\n    name: \"UTCP-Client-MCP-Bridge\",\n    version: \"1.0.0\",\n});\n\nfunction setupMcpTools() {\n    mcp.registerTool(\"register_manual\", {\n        title: \"Register a UTCP Manual\",\n        description: \"Registers a new tool provider by providing its call template.\",\n        inputSchema: { manual_call_template: CallTemplateSchema.describe(\"The call template for the UTCP Manual endpoint.\") },\n    }, async (input) => {\n        const client = await initializeUtcpClient();\n        try {\n            const result = await client.registerManual(input.manual_call_template as any);\n            return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n\n    mcp.registerTool(\"deregister_manual\", {\n        title: \"Deregister a UTCP Manual\",\n        description: \"Deregisters a tool provider from the UTCP client.\",\n        inputSchema: { manual_name: z.string().describe(\"The name of the manual to deregister.\") },\n    }, async (input) => {\n        const client = await initializeUtcpClient();\n        try {\n            const success = await client.deregisterManual(input.manual_name);\n            const message = success ? `Manual '${input.manual_name}' deregistered.` : `Manual '${input.manual_name}' not found.`;\n            return { content: [{ type: \"text\", text: JSON.stringify({ success, message }) }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n\n    mcp.registerTool(\"call_tool\", {\n        title: \"Call a UTCP Tool\",\n        description: \"Calls a registered tool by its full namespaced name.\",\n        inputSchema: {\n            tool_name: z.string().describe(\"The full name of the tool to call.\"),\n            arguments: z.record(z.string(), z.any()).describe(\"A JSON object of arguments.\"),\n        },\n    }, async (input) => {\n        const client = await initializeUtcpClient();\n        try {\n            const result = await client.callTool(input.tool_name, input.arguments);\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: true, tool_name: input.tool_name, result }) }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n\n    mcp.registerTool(\"search_tools\", {\n        title: \"Search for UTCP Tools\",\n        description: \"Searches for relevant tools based on a task description.\",\n        inputSchema: {\n            task_description: z.string().describe(\"A natural language description of the task.\"),\n            limit: z.number().optional().default(10),\n        },\n    }, async (input) => {\n        const client = await initializeUtcpClient();\n        try {\n            const tools = await client.searchTools(input.task_description, input.limit);\n            const simplified = tools.map(t => ({ name: t.name, description: t.description, input_schema: t.inputs }));\n            return { content: [{ type: \"text\", text: JSON.stringify({ tools: simplified }) }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n\n    mcp.registerTool(\"list_tools\", {\n        title: \"List All Registered UTCP Tools\",\n        description: \"Returns a list of all tools currently registered.\",\n        inputSchema: {},\n    }, async () => {\n        const client = await initializeUtcpClient();\n        try {\n            const tools = await client.config.tool_repository.getTools();\n            const toolInfo = tools.map(t => ({ name: t.name, description: t.description }));\n            return { content: [{ type: \"text\", text: JSON.stringify({ tools: toolInfo }) }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n}\n\nasync function initializeUtcpClient(): Promise<UtcpClient> {\n    if (utcpClient) {\n        return utcpClient as UtcpClient;\n    }\n\n    const scriptDir = path.resolve(import.meta.dir);\n    const configPath = path.resolve(scriptDir, '.utcp_config.json');\n    console.log(`Searching for UTCP config file at: ${configPath}`);\n\n    let rawConfig: any = {};\n    try {\n        const configFileContent = await fs.readFile(configPath, 'utf-8');\n        rawConfig = JSON.parse(configFileContent);\n        console.log(\"Loaded UTCP client configuration from .utcp_config.json\");\n    } catch (e: any) {\n        if (e.code !== 'ENOENT') {\n            console.warn(`Could not read or parse .utcp_config.json. Error: ${e.message}`);\n        }\n        console.log(\"No valid .utcp_config.json found. Initializing with default config.\");\n    }\n\n    const toolRepository = new InMemConcurrentToolRepository();\n    const searchStrategy = new TagSearchStrategy({\n        tool_search_strategy_type: 'tag_and_description_word_match',\n        ...rawConfig.tool_search_strategy\n    });\n    const variableSubstitutor = new DefaultVariableSubstitutor();\n\n    const loadedVariables: Record<string, string> = {};\n    if (rawConfig.load_variables_from) {\n        for (const loaderConfig of rawConfig.load_variables_from) {\n            if (loaderConfig.variable_loader_type === 'dotenv' && loaderConfig.env_file_path) {\n                try {\n                    const envPath = path.resolve(scriptDir, loaderConfig.env_file_path);\n                    const envContent = await fs.readFile(envPath, 'utf-8');\n                    Object.assign(loadedVariables, parseDotEnv(envContent));\n                    console.log(`Successfully loaded variables from ${envPath}`);\n                } catch (e: any) {\n                    console.warn(`Could not load .env file from '${loaderConfig.env_file_path}': ${e.message}`);\n                }\n            }\n        }\n    }\n\n    const finalVariables = { ...loadedVariables, ...(rawConfig.variables || {}) };\n\n    const clientConfig: UtcpClientConfig = {\n        variables: finalVariables,\n        load_variables_from: [],\n        tool_repository: toolRepository,\n        tool_search_strategy: searchStrategy,\n        post_processing: rawConfig.post_processing || [],\n        manual_call_templates: [],\n    };\n\n    const newClient = new (UtcpClient as any)(clientConfig, variableSubstitutor, scriptDir);\n\n    if (rawConfig.manual_call_templates && Array.isArray(rawConfig.manual_call_templates)) {\n        console.log(`Registering ${rawConfig.manual_call_templates.length} initial manuals from config...`);\n        for (const manualTemplate of rawConfig.manual_call_templates) {\n            try {\n                if (!manualTemplate.name) {\n                    manualTemplate.name = manualTemplate.call_template_type || 'unnamed_manual';\n                }\n                await newClient.registerManual(manualTemplate);\n            } catch (e: any) {\n                console.error(`Failed to register initial manual '${manualTemplate.name}': ${e.message}`);\n            }\n        }\n    }\n\n    console.log(\"UTCP Client manually initialized successfully.\");\n    utcpClient = newClient;\n    return utcpClient as UtcpClient;\n}\n\nmain().catch(err => {\n    console.error(\"Failed to start UTCP-MCP Bridge:\", err);\n    process.exit(1);\n});",
      "line_count": 219,
      "word_count": 868,
      "title": "Utcp Client Mcp.Ts",
      "summary": "// utcp-client-mcp.ts (TypeScript MCP-UTCP Bridge Server) import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";",
      "key_terms": [
        "null",
        "const",
        "loadedVariables",
        "async",
        "number",
        "error",
        "record",
        "envContent",
        "based",
        "Record",
        "list",
        "Utcp",
        "utcp-client",
        "connect",
        "loaderConfig",
        "found",
        "natural",
        "Loaded",
        "string",
        "Error"
      ],
      "timestamp": "2025-12-24T18:56:23.091059"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\code-mode-mcp\\.utcp_config.json",
      "content_type": "configuration",
      "content": "{\n    \"load_variables_from\": [\n      {\n        \"variable_loader_type\": \"dotenv\",\n        \"env_file_path\": \".env\"\n      }\n    ],\n    \"tool_repository\": {\n      \"tool_repository_type\": \"in_memory\"\n    },\n    \"tool_search_strategy\": {\n      \"tool_search_strategy_type\": \"tag_and_description_word_match\"\n    },\n    \"manual_call_templates\": [\n      {\n          \"name\": \"openlibrary\",\n          \"call_template_type\": \"http\",\n          \"http_method\": \"GET\",\n          \"url\": \"https://openlibrary.org/static/openapi.json\",\n          \"content_type\": \"application/json\"\n      }\n    ],\n    \"post_processing\": [\n    ]\n  }",
      "line_count": 25,
      "word_count": 39,
      "title": ".Utcp Config.Json",
      "summary": "\"load_variables_from\": [ \"variable_loader_type\": \"dotenv\",",
      "key_terms": [
        "url",
        "https",
        "GET",
        "org",
        "env",
        "api",
        "dotenv",
        "json",
        "static",
        "openlibrary",
        "openapi",
        "application",
        "method",
        "http",
        "name"
      ],
      "timestamp": "2025-12-24T18:56:23.092585"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\code-mode-mcp\\index.ts",
      "content_type": "code",
      "content": "#!/usr/bin/env node\n\n// UTCP-MCP Bridge Entry Point\n// This is the main entry point for the npx @utcp/mcp-bridge command\n\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\nimport path from \"path\";\nimport { promises as fs } from \"fs\";\nimport { parse as parseDotEnv } from 'dotenv';\nimport { fileURLToPath } from 'url';\nimport { dirname } from 'path';\n\nimport \"@utcp/http\";\nimport \"@utcp/text\";\nimport \"@utcp/mcp\";\nimport \"@utcp/cli\";\nimport \"@utcp/dotenv-loader\"\nimport \"@utcp/file\"\n\nimport {\n    UtcpClient,\n    CallTemplateSchema,\n    InMemConcurrentToolRepository,\n    TagSearchStrategy,\n    DefaultVariableSubstitutor,\n    ensureCorePluginsInitialized,\n    UtcpClientConfigSerializer\n} from \"@utcp/sdk\";\nimport type { UtcpClientConfig } from \"@utcp/sdk\";\nimport { CodeModeUtcpClient } from \"@utcp/code-mode\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\nensureCorePluginsInitialized();\n\nlet utcpClient: CodeModeUtcpClient | null = null;\n\nasync function main() {\n    setupMcpTools();\n    utcpClient = await initializeUtcpClient();\n    const transport = new StdioServerTransport();\n    await mcp.connect(transport);\n}\n\nconst mcp = new McpServer({\n    name: \"CodeMode-MCP\",\n    version: \"1.0.0\",\n});\n\nfunction setupMcpTools() {\n    // Register MCP prompt for using the code mode server\n    mcp.registerPrompt(\"utcp_codemode_usage\", {\n        title: \"UTCP Code Mode Usage Guide\",\n        description: \"Comprehensive guide on how to use the UTCP Code Mode MCP server for executing TypeScript code with tool access.\"\n    }, async () => {\n        const codeInstructions = `# UTCP Code Mode MCP Server Usage Guide\n\nYou have access to a powerful UTCP Code Mode MCP server that allows you to execute TypeScript code with direct access to registered tools.\n\n## Workflow: Always Follow This Pattern\n\n### 1. üîç DISCOVER TOOLS FIRST\n**Always start by searching for relevant tools before writing code:**\n- Use \\`search_tools\\` with a description of your task to find relevant tools\n- This returns tools with their TypeScript interfaces - study these carefully\n- Use \\`tool_info\\` to get detailed interface information for specific tools if needed\n\n${CodeModeUtcpClient.AGENT_PROMPT_TEMPLATE}\n\n- in the call_tool_chain code, return the result that you want to see, your code will be wrapped in an async function and executed\n\nRemember: The power of this system comes from combining multiple tools in sophisticated TypeScript code execution workflows.`;\n\n        return {\n            messages: [{\n                role: \"user\",\n                content: {\n                    type: \"text\",\n                    text: codeInstructions\n                }\n            }]\n        };\n    });\n\n    mcp.registerTool(\"register_manual\", {\n        title: \"Register a UTCP Manual\",\n        description: \"Registers a new tool provider by providing its call template.\",\n        inputSchema: { manual_call_template: CallTemplateSchema.describe(\"The call template for the UTCP Manual endpoint.\") },\n    }, async (input) => {\n        const client = await initializeUtcpClient();\n        try {\n            const result = await client.registerManual(input.manual_call_template as any);\n            return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n\n    mcp.registerTool(\"deregister_manual\", {\n        title: \"Deregister a UTCP Manual\",\n        description: \"Deregisters a tool provider from the UTCP client.\",\n        inputSchema: { manual_name: z.string().describe(\"The name of the manual to deregister.\") },\n    }, async (input) => {\n        const client = await initializeUtcpClient();\n        try {\n            const success = await client.deregisterManual(input.manual_name);\n            const message = success ? `Manual '${input.manual_name}' deregistered.` : `Manual '${input.manual_name}' not found.`;\n            return { content: [{ type: \"text\", text: JSON.stringify({ success, message }) }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n\n    mcp.registerTool(\"search_tools\", {\n        title: \"Search for UTCP Tools\",\n        description: \"Searches for relevant tools based on a task description.\",\n        inputSchema: {\n            task_description: z.string().describe(\"A natural language description of the task.\"),\n            limit: z.number().optional().default(10),\n        },\n    }, async (input) => {\n        const client = await initializeUtcpClient();\n        try {\n            const tools = await client.searchTools(input.task_description, input.limit);\n            const toolsWithInterfaces = tools.map(t => ({\n                name: t.name,\n                description: t.description,\n                typescript_interface: client.toolToTypeScriptInterface(t)\n            }));\n            return { content: [{ type: \"text\", text: JSON.stringify({ tools: toolsWithInterfaces }) }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n\n    mcp.registerTool(\"list_tools\", {\n        title: \"List All Registered UTCP Tools\",\n        description: \"Returns a list of all tool names currently registered.\",\n        inputSchema: {},\n    }, async () => {\n        const client = await initializeUtcpClient();\n        try {\n            const tools = await client.config.tool_repository.getTools();\n            const toolNames = tools.map(t => t.name);\n            return { content: [{ type: \"text\", text: JSON.stringify({ tools: toolNames }) }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n\n    mcp.registerTool(\"get_required_keys_for_tool\", {\n        title: \"Get Required Variables for Tool\",\n        description: \"Get required environment variables for a registered tool.\",\n        inputSchema: {\n            tool_name: z.string().describe(\"Name of the tool to get required variables for.\"),\n        },\n    }, async (input) => {\n        const client = await initializeUtcpClient();\n        try {\n            const variables = await client.getRequiredVariablesForRegisteredTool(input.tool_name);\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: true, tool_name: input.tool_name, required_variables: variables }) }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, tool_name: input.tool_name, error: e.message }) }] };\n        }\n    });\n\n    mcp.registerTool(\"tool_info\", {\n        title: \"Get Tool Information with TypeScript Interface\",\n        description: \"Get complete information about a specific tool including TypeScript interface definition.\",\n        inputSchema: {\n            tool_name: z.string().describe(\"Name of the tool to get complete information for.\"),\n        },\n    }, async (input) => {\n        const client = await initializeUtcpClient();\n        try {\n            const tool = await client.config.tool_repository.getTool(input.tool_name);\n            if (!tool) {\n                return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: `Tool '${input.tool_name}' not found` }) }] };\n            }\n            const typescript_interface = client.toolToTypeScriptInterface(tool);\n            return { content: [{ type: \"text\", text: typescript_interface }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n\n    // Code Mode specific tools\n    mcp.registerTool(\"call_tool_chain\", {\n        title: \"Execute TypeScript Code with Tool Access\",\n        description: \"Execute TypeScript code with direct access to all registered tools as hierarchical functions (e.g., manual.tool()).\",\n        inputSchema: {\n            code: z.string().describe(\"TypeScript code to execute with access to all registered tools.\"),\n            timeout: z.number().optional().default(30000).describe(\"Optional timeout in milliseconds (default: 30000).\"),\n            max_output_size: z.number().optional().default(200000).describe(\"Optional maximum output size in characters (default: 200000).\"),\n        },\n    }, async (input) => {\n        const client = await initializeUtcpClient();\n        try {\n            const { result, logs } = await client.callToolChain(input.code, input.timeout);\n            const content = JSON.stringify({ success: true, result, logs })\n            if (content.length > input.max_output_size) {\n                return { content: [{ type: \"text\", text: content.slice(0, input.max_output_size) + \"...\\nmax_output_size exceeded\" }] };\n            }\n            return { content: [{ type: \"text\", text: content }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n\n}\n\nasync function initializeUtcpClient(): Promise<CodeModeUtcpClient> {\n    if (utcpClient) {\n        return utcpClient;\n    }\n\n    // Look for config file: 1) Environment variable, 2) Current working directory, 3) Package directory\n    const cwd = process.cwd();\n    const packageDir = __dirname;\n    \n    let configPath: string;\n    let scriptDir: string;\n    \n    // Check if UTCP_CONFIG_FILE environment variable is set\n    if (process.env.UTCP_CONFIG_FILE) {\n        configPath = path.resolve(process.env.UTCP_CONFIG_FILE);\n        scriptDir = path.dirname(configPath);\n        \n        try {\n            await fs.access(configPath);\n        } catch {\n            console.warn(`UTCP config file specified in UTCP_CONFIG_FILE not found: ${configPath}`);\n        }\n    } else {\n        // Fall back to current working directory first, then package directory\n        configPath = path.resolve(cwd, '.utcp_config.json');\n        scriptDir = cwd;\n        \n        try {\n            await fs.access(configPath);\n        } catch {\n            configPath = path.resolve(packageDir, '.utcp_config.json');\n            scriptDir = packageDir;\n        }\n    }\n\n    let rawConfig: any = {};\n    try {\n        const configFileContent = await fs.readFile(configPath, 'utf-8');\n        rawConfig = JSON.parse(configFileContent);\n    } catch (e: any) {\n        if (e.code !== 'ENOENT') {\n            console.warn(`Could not read or parse .utcp_config.json. Error: ${e.message}`);\n        }\n    }\n\n    const clientConfig = new UtcpClientConfigSerializer().validateDict(rawConfig);\n\n    const newClient = await CodeModeUtcpClient.create(scriptDir, clientConfig);\n\n    utcpClient = newClient;\n    return utcpClient;\n}\n\nmain().catch(err => {\n    console.error(\"Failed to start UTCP-MCP Bridge:\", err);\n    process.exit(1);\n});\n",
      "line_count": 272,
      "word_count": 1210,
      "title": "Index.Ts",
      "summary": "// UTCP-MCP Bridge Entry Point // This is the main entry point for the npx @utcp/mcp-bridge command",
      "key_terms": [
        "executing",
        "output",
        "const",
        "null",
        "role",
        "entry",
        "async",
        "number",
        "error",
        "Code",
        "based",
        "list",
        "Comprehensive",
        "wrapped",
        "mode",
        "Utcp",
        "connect",
        "specified",
        "TOOLS",
        "found"
      ],
      "timestamp": "2025-12-24T18:56:23.137237"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\code-mode-mcp\\package-lock.json",
      "content_type": "configuration",
      "content": "{\n  \"name\": \"@utcp/code-mode-mcp\",\n  \"version\": \"1.0.9\",\n  \"lockfileVersion\": 3,\n  \"requires\": true,\n  \"packages\": {\n    \"\": {\n      \"name\": \"@utcp/code-mode-mcp\",\n      \"version\": \"1.0.9\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@modelcontextprotocol/sdk\": \"^1.20.2\",\n        \"@utcp/cli\": \"^1.0.12\",\n        \"@utcp/code-mode\": \"^1.0.5\",\n        \"@utcp/dotenv-loader\": \"^1.0.0\",\n        \"@utcp/file\": \"^1.0.0\",\n        \"@utcp/http\": \"^1.0.13\",\n        \"@utcp/mcp\": \"^1.0.16\",\n        \"@utcp/sdk\": \"^1.0.16\",\n        \"@utcp/text\": \"^1.0.12\",\n        \"dotenv\": \"^16.0.0\",\n        \"zod\": \"^3.22.0\"\n      },\n      \"bin\": {\n        \"mcp-bridge\": \"dist/index.js\"\n      },\n      \"devDependencies\": {\n        \"@types/node\": \"^20.0.0\",\n        \"typescript\": \"^5.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=18.0.0\"\n      }\n    },\n    \"node_modules/@modelcontextprotocol/sdk\": {\n      \"version\": \"1.21.1\",\n      \"resolved\": \"https://registry.npmjs.org/@modelcontextprotocol/sdk/-/sdk-1.21.1.tgz\",\n      \"integrity\": \"sha512-UyLFcJLDvUuZbGnaQqXFT32CpPpGj7VS19roLut6gkQVhb439xUzYWbsUvdI3ZPL+2hnFosuugtYWE0Mcs1rmQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ajv\": \"^8.17.1\",\n        \"ajv-formats\": \"^3.0.1\",\n        \"content-type\": \"^1.0.5\",\n        \"cors\": \"^2.8.5\",\n        \"cross-spawn\": \"^7.0.5\",\n        \"eventsource\": \"^3.0.2\",\n        \"eventsource-parser\": \"^3.0.0\",\n        \"express\": \"^5.0.1\",\n        \"express-rate-limit\": \"^7.5.0\",\n        \"pkce-challenge\": \"^5.0.0\",\n        \"raw-body\": \"^3.0.0\",\n        \"zod\": \"^3.23.8\",\n        \"zod-to-json-schema\": \"^3.24.1\"\n      },\n      \"engines\": {\n        \"node\": \">=18\"\n      },\n      \"peerDependencies\": {\n        \"@cfworker/json-schema\": \"^4.1.1\"\n      },\n      \"peerDependenciesMeta\": {\n        \"@cfworker/json-schema\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/@types/node\": {\n      \"version\": \"20.19.24\",\n      \"resolved\": \"https://registry.npmjs.org/@types/node/-/node-20.19.24.tgz\",\n      \"integrity\": \"sha512-FE5u0ezmi6y9OZEzlJfg37mqqf6ZDSF2V/NLjUyGrR9uTZ7Sb9F7bLNZ03S4XVUNRWGA7Ck4c1kK+YnuWjl+DA==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"undici-types\": \"~6.21.0\"\n      }\n    },\n    \"node_modules/@utcp/cli\": {\n      \"version\": \"1.0.12\",\n      \"resolved\": \"https://registry.npmjs.org/@utcp/cli/-/cli-1.0.12.tgz\",\n      \"integrity\": \"sha512-0wPoSvYuQw7enQmwaldmv9nT62yFTgiJZiPhzISH7octStUlwy1PWicqJ6dFryFkESXmhp7JypD4vsmhfij73Q==\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"@utcp/sdk\": \"^1.0.15\"\n      }\n    },\n    \"node_modules/@utcp/code-mode\": {\n      \"version\": \"1.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/@utcp/code-mode/-/code-mode-1.0.5.tgz\",\n      \"integrity\": \"sha512-u1ewOfV8eb8jg9/k4dmwLoz+yml28obpt5JuCQ+NeBjz0vi3vsd1ILf9YXNaofXow2QL7dBrM1+1v9SueXHrlg==\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"@utcp/sdk\": \"^1.0.17\"\n      }\n    },\n    \"node_modules/@utcp/dotenv-loader\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/@utcp/dotenv-loader/-/dotenv-loader-1.0.1.tgz\",\n      \"integrity\": \"sha512-tXCtwJefv+lyQITFQrs7RyW9BKUxw0hvHbpCU1RXAsuR6l29oYhNLrAfJYIndFJSyhR51RPGnB1GI0Tx522rYA==\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"dotenv\": \"^17.2.1\",\n        \"zod\": \"^3.23.8\"\n      },\n      \"peerDependencies\": {\n        \"@utcp/sdk\": \"^1.0.15\"\n      }\n    },\n    \"node_modules/@utcp/dotenv-loader/node_modules/dotenv\": {\n      \"version\": \"17.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/dotenv/-/dotenv-17.2.3.tgz\",\n      \"integrity\": \"sha512-JVUnt+DUIzu87TABbhPmNfVdBDt18BLOWjMUFJMSi/Qqg7NTYtabbvSNJGOJ7afbRuv9D/lngizHtP7QyLQ+9w==\",\n      \"license\": \"BSD-2-Clause\",\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://dotenvx.com\"\n      }\n    },\n    \"node_modules/@utcp/file\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/@utcp/file/-/file-1.0.1.tgz\",\n      \"integrity\": \"sha512-rSI21gAm5jgQ88wLhxFL+MlHn9cmW8JysRaZ21RtGqDN2ifs/EAkiA6FpZWbye/URD8Tfm14cuVgH21AT9ETfg==\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"@utcp/http\": \"^1.0.13\",\n        \"@utcp/sdk\": \"^1.0.15\",\n        \"js-yaml\": \"^4.1.0\"\n      }\n    },\n    \"node_modules/@utcp/http\": {\n      \"version\": \"1.0.13\",\n      \"resolved\": \"https://registry.npmjs.org/@utcp/http/-/http-1.0.13.tgz\",\n      \"integrity\": \"sha512-XsiUbyd9kiiriSvWCQ6s+JlMgrEaczO7UYpCt7E68ZQMULAJIUjTJbqV6/fbMlraFkEZooZiZUM+/oNYd4JWiw==\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"@utcp/sdk\": \"^1.0.15\",\n        \"axios\": \"^1.11.0\",\n        \"js-yaml\": \"^4.1.0\"\n      }\n    },\n    \"node_modules/@utcp/mcp\": {\n      \"version\": \"1.0.16\",\n      \"resolved\": \"https://registry.npmjs.org/@utcp/mcp/-/mcp-1.0.16.tgz\",\n      \"integrity\": \"sha512-dlyIfkb1LsSX/zwECPMNnj17JzKpYhhd4xUnSARy8Ob1rG6z3UWaDcLZrIRSNL0vAaP5lKUtJh1AXT1IWsqVoQ==\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"@modelcontextprotocol/sdk\": \"^1.17.4\",\n        \"@utcp/sdk\": \"^1.0.15\",\n        \"axios\": \"^1.11.0\"\n      }\n    },\n    \"node_modules/@utcp/sdk\": {\n      \"version\": \"1.0.17\",\n      \"resolved\": \"https://registry.npmjs.org/@utcp/sdk/-/sdk-1.0.17.tgz\",\n      \"integrity\": \"sha512-Eyuq7W9YcrymT2wFlhyLYayaEp1fLreIyNWfpOWrjuTcrjzFFIK/4GbWVxwAbPaesf4ZyvUwRBowDsJ8vh7SWg==\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"dotenv\": \"^17.2.1\",\n        \"zod\": \"^3.23.8\"\n      }\n    },\n    \"node_modules/@utcp/sdk/node_modules/dotenv\": {\n      \"version\": \"17.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/dotenv/-/dotenv-17.2.3.tgz\",\n      \"integrity\": \"sha512-JVUnt+DUIzu87TABbhPmNfVdBDt18BLOWjMUFJMSi/Qqg7NTYtabbvSNJGOJ7afbRuv9D/lngizHtP7QyLQ+9w==\",\n      \"license\": \"BSD-2-Clause\",\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://dotenvx.com\"\n      }\n    },\n    \"node_modules/@utcp/text\": {\n      \"version\": \"1.0.12\",\n      \"resolved\": \"https://registry.npmjs.org/@utcp/text/-/text-1.0.12.tgz\",\n      \"integrity\": \"sha512-OAgFLBs8gtuZiNdqJf0kAULf5VbUtKiNLXdZenMkK85gVUu3OZnxrz6vIom0kjMgp4XNZAMJBcumlk2gP96pLw==\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"@utcp/http\": \"^1.0.13\",\n        \"@utcp/sdk\": \"^1.0.15\",\n        \"js-yaml\": \"^4.1.0\"\n      }\n    },\n    \"node_modules/accepts\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/accepts/-/accepts-2.0.0.tgz\",\n      \"integrity\": \"sha512-5cvg6CtKwfgdmVqY1WIiXKc3Q1bkRqGLi+2W/6ao+6Y7gu/RCwRuAhGEzh5B4KlszSuTLgZYuqFqo5bImjNKng==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"mime-types\": \"^3.0.0\",\n        \"negotiator\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/ajv\": {\n      \"version\": \"8.17.1\",\n      \"resolved\": \"https://registry.npmjs.org/ajv/-/ajv-8.17.1.tgz\",\n      \"integrity\": \"sha512-B/gBuNg5SiMTrPkC+A2+cW0RszwxYmn6VYxB/inlBStS5nx6xHIt/ehKRhIMhqusl7a8LjQoZnjCs5vhwxOQ1g==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"fast-deep-equal\": \"^3.1.3\",\n        \"fast-uri\": \"^3.0.1\",\n        \"json-schema-traverse\": \"^1.0.0\",\n        \"require-from-string\": \"^2.0.2\"\n      },\n      \"funding\": {\n        \"type\": \"github\",\n        \"url\": \"https://github.com/sponsors/epoberezkin\"\n      }\n    },\n    \"node_modules/ajv-formats\": {\n      \"version\": \"3.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/ajv-formats/-/ajv-formats-3.0.1.tgz\",\n      \"integrity\": \"sha512-8iUql50EUR+uUcdRQ3HDqa6EVyo3docL8g5WJ3FNcWmu62IbkGUue/pEyLBW8VGKKucTPgqeks4fIU1DA4yowQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ajv\": \"^8.0.0\"\n      },\n      \"peerDependencies\": {\n        \"ajv\": \"^8.0.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"ajv\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/argparse\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz\",\n      \"integrity\": \"sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==\",\n      \"license\": \"Python-2.0\"\n    },\n    \"node_modules/asynckit\": {\n      \"version\": \"0.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz\",\n      \"integrity\": \"sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/axios\": {\n      \"version\": \"1.13.2\",\n      \"resolved\": \"https://registry.npmjs.org/axios/-/axios-1.13.2.tgz\",\n      \"integrity\": \"sha512-VPk9ebNqPcy5lRGuSlKx752IlDatOjT9paPlm8A7yOuW2Fbvp4X3JznJtT4f0GzGLLiWE9W8onz51SqLYwzGaA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"follow-redirects\": \"^1.15.6\",\n        \"form-data\": \"^4.0.4\",\n        \"proxy-from-env\": \"^1.1.0\"\n      }\n    },\n    \"node_modules/body-parser\": {\n      \"version\": \"2.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/body-parser/-/body-parser-2.2.0.tgz\",\n      \"integrity\": \"sha512-02qvAaxv8tp7fBa/mw1ga98OGm+eCbqzJOKoRt70sLmfEEi+jyBYVTDGfCL/k06/4EMk/z01gCe7HoCH/f2LTg==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"bytes\": \"^3.1.2\",\n        \"content-type\": \"^1.0.5\",\n        \"debug\": \"^4.4.0\",\n        \"http-errors\": \"^2.0.0\",\n        \"iconv-lite\": \"^0.6.3\",\n        \"on-finished\": \"^2.4.1\",\n        \"qs\": \"^6.14.0\",\n        \"raw-body\": \"^3.0.0\",\n        \"type-is\": \"^2.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/bytes\": {\n      \"version\": \"3.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz\",\n      \"integrity\": \"sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/call-bind-apply-helpers\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz\",\n      \"integrity\": \"sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"es-errors\": \"^1.3.0\",\n        \"function-bind\": \"^1.1.2\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/call-bound\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/call-bound/-/call-bound-1.0.4.tgz\",\n      \"integrity\": \"sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"call-bind-apply-helpers\": \"^1.0.2\",\n        \"get-intrinsic\": \"^1.3.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/combined-stream\": {\n      \"version\": \"1.0.8\",\n      \"resolved\": \"https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz\",\n      \"integrity\": \"sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"delayed-stream\": \"~1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/content-disposition\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/content-disposition/-/content-disposition-1.0.0.tgz\",\n      \"integrity\": \"sha512-Au9nRL8VNUut/XSzbQA38+M78dzP4D+eqg3gfJHMIHHYa3bg067xj1KxMUWj+VULbiZMowKngFFbKczUrNJ1mg==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"safe-buffer\": \"5.2.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/content-type\": {\n      \"version\": \"1.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz\",\n      \"integrity\": \"sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/cookie\": {\n      \"version\": \"0.7.2\",\n      \"resolved\": \"https://registry.npmjs.org/cookie/-/cookie-0.7.2.tgz\",\n      \"integrity\": \"sha512-yki5XnKuf750l50uGTllt6kKILY4nQ1eNIQatoXEByZ5dWgnKqbnqmTrBE5B4N7lrMJKQ2ytWMiTO2o0v6Ew/w==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/cookie-signature\": {\n      \"version\": \"1.2.2\",\n      \"resolved\": \"https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.2.2.tgz\",\n      \"integrity\": \"sha512-D76uU73ulSXrD1UXF4KE2TMxVVwhsnCgfAyTg9k8P6KGZjlXKrOLe4dJQKI3Bxi5wjesZoFXJWElNWBjPZMbhg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=6.6.0\"\n      }\n    },\n    \"node_modules/cors\": {\n      \"version\": \"2.8.5\",\n      \"resolved\": \"https://registry.npmjs.org/cors/-/cors-2.8.5.tgz\",\n      \"integrity\": \"sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"object-assign\": \"^4\",\n        \"vary\": \"^1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.10\"\n      }\n    },\n    \"node_modules/cross-spawn\": {\n      \"version\": \"7.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz\",\n      \"integrity\": \"sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"path-key\": \"^3.1.0\",\n        \"shebang-command\": \"^2.0.0\",\n        \"which\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 8\"\n      }\n    },\n    \"node_modules/debug\": {\n      \"version\": \"4.4.3\",\n      \"resolved\": \"https://registry.npmjs.org/debug/-/debug-4.4.3.tgz\",\n      \"integrity\": \"sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ms\": \"^2.1.3\"\n      },\n      \"engines\": {\n        \"node\": \">=6.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"supports-color\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/delayed-stream\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz\",\n      \"integrity\": \"sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=0.4.0\"\n      }\n    },\n    \"node_modules/depd\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/depd/-/depd-2.0.0.tgz\",\n      \"integrity\": \"sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/dotenv\": {\n      \"version\": \"16.6.1\",\n      \"resolved\": \"https://registry.npmjs.org/dotenv/-/dotenv-16.6.1.tgz\",\n      \"integrity\": \"sha512-uBq4egWHTcTt33a72vpSG0z3HnPuIl6NqYcTrKEg2azoEyl2hpW0zqlxysq2pK9HlDIHyHyakeYaYnSAwd8bow==\",\n      \"license\": \"BSD-2-Clause\",\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://dotenvx.com\"\n      }\n    },\n    \"node_modules/dunder-proto\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz\",\n      \"integrity\": \"sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"call-bind-apply-helpers\": \"^1.0.1\",\n        \"es-errors\": \"^1.3.0\",\n        \"gopd\": \"^1.2.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/ee-first\": {\n      \"version\": \"1.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz\",\n      \"integrity\": \"sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/encodeurl\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz\",\n      \"integrity\": \"sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/es-define-property\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz\",\n      \"integrity\": \"sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/es-errors\": {\n      \"version\": \"1.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz\",\n      \"integrity\": \"sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/es-object-atoms\": {\n      \"version\": \"1.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz\",\n      \"integrity\": \"sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"es-errors\": \"^1.3.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/es-set-tostringtag\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.1.0.tgz\",\n      \"integrity\": \"sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"es-errors\": \"^1.3.0\",\n        \"get-intrinsic\": \"^1.2.6\",\n        \"has-tostringtag\": \"^1.0.2\",\n        \"hasown\": \"^2.0.2\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/escape-html\": {\n      \"version\": \"1.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz\",\n      \"integrity\": \"sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/etag\": {\n      \"version\": \"1.8.1\",\n      \"resolved\": \"https://registry.npmjs.org/etag/-/etag-1.8.1.tgz\",\n      \"integrity\": \"sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/eventsource\": {\n      \"version\": \"3.0.7\",\n      \"resolved\": \"https://registry.npmjs.org/eventsource/-/eventsource-3.0.7.tgz\",\n      \"integrity\": \"sha512-CRT1WTyuQoD771GW56XEZFQ/ZoSfWid1alKGDYMmkt2yl8UXrVR4pspqWNEcqKvVIzg6PAltWjxcSSPrboA4iA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"eventsource-parser\": \"^3.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=18.0.0\"\n      }\n    },\n    \"node_modules/eventsource-parser\": {\n      \"version\": \"3.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/eventsource-parser/-/eventsource-parser-3.0.6.tgz\",\n      \"integrity\": \"sha512-Vo1ab+QXPzZ4tCa8SwIHJFaSzy4R6SHf7BY79rFBDf0idraZWAkYrDjDj8uWaSm3S2TK+hJ7/t1CEmZ7jXw+pg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=18.0.0\"\n      }\n    },\n    \"node_modules/express\": {\n      \"version\": \"5.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/express/-/express-5.1.0.tgz\",\n      \"integrity\": \"sha512-DT9ck5YIRU+8GYzzU5kT3eHGA5iL+1Zd0EutOmTE9Dtk+Tvuzd23VBU+ec7HPNSTxXYO55gPV/hq4pSBJDjFpA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"accepts\": \"^2.0.0\",\n        \"body-parser\": \"^2.2.0\",\n        \"content-disposition\": \"^1.0.0\",\n        \"content-type\": \"^1.0.5\",\n        \"cookie\": \"^0.7.1\",\n        \"cookie-signature\": \"^1.2.1\",\n        \"debug\": \"^4.4.0\",\n        \"encodeurl\": \"^2.0.0\",\n        \"escape-html\": \"^1.0.3\",\n        \"etag\": \"^1.8.1\",\n        \"finalhandler\": \"^2.1.0\",\n        \"fresh\": \"^2.0.0\",\n        \"http-errors\": \"^2.0.0\",\n        \"merge-descriptors\": \"^2.0.0\",\n        \"mime-types\": \"^3.0.0\",\n        \"on-finished\": \"^2.4.1\",\n        \"once\": \"^1.4.0\",\n        \"parseurl\": \"^1.3.3\",\n        \"proxy-addr\": \"^2.0.7\",\n        \"qs\": \"^6.14.0\",\n        \"range-parser\": \"^1.2.1\",\n        \"router\": \"^2.2.0\",\n        \"send\": \"^1.1.0\",\n        \"serve-static\": \"^2.2.0\",\n        \"statuses\": \"^2.0.1\",\n        \"type-is\": \"^2.0.1\",\n        \"vary\": \"^1.1.2\"\n      },\n      \"engines\": {\n        \"node\": \">= 18\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/express\"\n      }\n    },\n    \"node_modules/express-rate-limit\": {\n      \"version\": \"7.5.1\",\n      \"resolved\": \"https://registry.npmjs.org/express-rate-limit/-/express-rate-limit-7.5.1.tgz\",\n      \"integrity\": \"sha512-7iN8iPMDzOMHPUYllBEsQdWVB6fPDMPqwjBaFrgr4Jgr/+okjvzAy+UHlYYL/Vs0OsOrMkwS6PJDkFlJwoxUnw==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 16\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/express-rate-limit\"\n      },\n      \"peerDependencies\": {\n        \"express\": \">= 4.11\"\n      }\n    },\n    \"node_modules/fast-deep-equal\": {\n      \"version\": \"3.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz\",\n      \"integrity\": \"sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/fast-uri\": {\n      \"version\": \"3.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/fast-uri/-/fast-uri-3.1.0.tgz\",\n      \"integrity\": \"sha512-iPeeDKJSWf4IEOasVVrknXpaBV0IApz/gp7S2bb7Z4Lljbl2MGJRqInZiUrQwV16cpzw/D3S5j5Julj/gT52AA==\",\n      \"funding\": [\n        {\n          \"type\": \"github\",\n          \"url\": \"https://github.com/sponsors/fastify\"\n        },\n        {\n          \"type\": \"opencollective\",\n          \"url\": \"https://opencollective.com/fastify\"\n        }\n      ],\n      \"license\": \"BSD-3-Clause\"\n    },\n    \"node_modules/finalhandler\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/finalhandler/-/finalhandler-2.1.0.tgz\",\n      \"integrity\": \"sha512-/t88Ty3d5JWQbWYgaOGCCYfXRwV1+be02WqYYlL6h0lEiUAMPM8o8qKGO01YIkOHzka2up08wvgYD0mDiI+q3Q==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"debug\": \"^4.4.0\",\n        \"encodeurl\": \"^2.0.0\",\n        \"escape-html\": \"^1.0.3\",\n        \"on-finished\": \"^2.4.1\",\n        \"parseurl\": \"^1.3.3\",\n        \"statuses\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/follow-redirects\": {\n      \"version\": \"1.15.11\",\n      \"resolved\": \"https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.15.11.tgz\",\n      \"integrity\": \"sha512-deG2P0JfjrTxl50XGCDyfI97ZGVCxIpfKYmfyrQ54n5FO/0gfIES8C/Psl6kWVDolizcaaxZJnTS0QSMxvnsBQ==\",\n      \"funding\": [\n        {\n          \"type\": \"individual\",\n          \"url\": \"https://github.com/sponsors/RubenVerborgh\"\n        }\n      ],\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=4.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"debug\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/form-data\": {\n      \"version\": \"4.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/form-data/-/form-data-4.0.4.tgz\",\n      \"integrity\": \"sha512-KrGhL9Q4zjj0kiUt5OO4Mr/A/jlI2jDYs5eHBpYHPcBEVSiipAvn2Ko2HnPe20rmcuuvMHNdZFp+4IlGTMF0Ow==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"asynckit\": \"^0.4.0\",\n        \"combined-stream\": \"^1.0.8\",\n        \"es-set-tostringtag\": \"^2.1.0\",\n        \"hasown\": \"^2.0.2\",\n        \"mime-types\": \"^2.1.12\"\n      },\n      \"engines\": {\n        \"node\": \">= 6\"\n      }\n    },\n    \"node_modules/form-data/node_modules/mime-db\": {\n      \"version\": \"1.52.0\",\n      \"resolved\": \"https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz\",\n      \"integrity\": \"sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/form-data/node_modules/mime-types\": {\n      \"version\": \"2.1.35\",\n      \"resolved\": \"https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz\",\n      \"integrity\": \"sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"mime-db\": \"1.52.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/forwarded\": {\n      \"version\": \"0.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz\",\n      \"integrity\": \"sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/fresh\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/fresh/-/fresh-2.0.0.tgz\",\n      \"integrity\": \"sha512-Rx/WycZ60HOaqLKAi6cHRKKI7zxWbJ31MhntmtwMoaTeF7XFH9hhBp8vITaMidfljRQ6eYWCKkaTK+ykVJHP2A==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/function-bind\": {\n      \"version\": \"1.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz\",\n      \"integrity\": \"sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==\",\n      \"license\": \"MIT\",\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/get-intrinsic\": {\n      \"version\": \"1.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz\",\n      \"integrity\": \"sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"call-bind-apply-helpers\": \"^1.0.2\",\n        \"es-define-property\": \"^1.0.1\",\n        \"es-errors\": \"^1.3.0\",\n        \"es-object-atoms\": \"^1.1.1\",\n        \"function-bind\": \"^1.1.2\",\n        \"get-proto\": \"^1.0.1\",\n        \"gopd\": \"^1.2.0\",\n        \"has-symbols\": \"^1.1.0\",\n        \"hasown\": \"^2.0.2\",\n        \"math-intrinsics\": \"^1.1.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/get-proto\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz\",\n      \"integrity\": \"sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"dunder-proto\": \"^1.0.1\",\n        \"es-object-atoms\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/gopd\": {\n      \"version\": \"1.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz\",\n      \"integrity\": \"sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/has-symbols\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz\",\n      \"integrity\": \"sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/has-tostringtag\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.2.tgz\",\n      \"integrity\": \"sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"has-symbols\": \"^1.0.3\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/hasown\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz\",\n      \"integrity\": \"sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"function-bind\": \"^1.1.2\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/http-errors\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/http-errors/-/http-errors-2.0.0.tgz\",\n      \"integrity\": \"sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"depd\": \"2.0.0\",\n        \"inherits\": \"2.0.4\",\n        \"setprototypeof\": \"1.2.0\",\n        \"statuses\": \"2.0.1\",\n        \"toidentifier\": \"1.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/http-errors/node_modules/statuses\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/statuses/-/statuses-2.0.1.tgz\",\n      \"integrity\": \"sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/iconv-lite\": {\n      \"version\": \"0.6.3\",\n      \"resolved\": \"https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.6.3.tgz\",\n      \"integrity\": \"sha512-4fCk79wshMdzMp2rH06qWrJE4iolqLhCUH+OiuIgU++RB0+94NlDL81atO7GX55uUKueo0txHNtvEyI6D7WdMw==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"safer-buffer\": \">= 2.1.2 < 3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      }\n    },\n    \"node_modules/inherits\": {\n      \"version\": \"2.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz\",\n      \"integrity\": \"sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==\",\n      \"license\": \"ISC\"\n    },\n    \"node_modules/ipaddr.js\": {\n      \"version\": \"1.9.1\",\n      \"resolved\": \"https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz\",\n      \"integrity\": \"sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.10\"\n      }\n    },\n    \"node_modules/is-promise\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/is-promise/-/is-promise-4.0.0.tgz\",\n      \"integrity\": \"sha512-hvpoI6korhJMnej285dSg6nu1+e6uxs7zG3BYAm5byqDsgJNWwxzM6z6iZiAgQR4TJ30JmBTOwqZUw3WlyH3AQ==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/isexe\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz\",\n      \"integrity\": \"sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==\",\n      \"license\": \"ISC\"\n    },\n    \"node_modules/js-yaml\": {\n      \"version\": \"4.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz\",\n      \"integrity\": \"sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"argparse\": \"^2.0.1\"\n      },\n      \"bin\": {\n        \"js-yaml\": \"bin/js-yaml.js\"\n      }\n    },\n    \"node_modules/json-schema-traverse\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-1.0.0.tgz\",\n      \"integrity\": \"sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/math-intrinsics\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz\",\n      \"integrity\": \"sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/media-typer\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/media-typer/-/media-typer-1.1.0.tgz\",\n      \"integrity\": \"sha512-aisnrDP4GNe06UcKFnV5bfMNPBUw4jsLGaWwWfnH3v02GnBuXX2MCVn5RbrWo0j3pczUilYblq7fQ7Nw2t5XKw==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/merge-descriptors\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-2.0.0.tgz\",\n      \"integrity\": \"sha512-Snk314V5ayFLhp3fkUREub6WtjBfPdCPY1Ln8/8munuLuiYhsABgBVWsozAG+MWMbVEvcdcpbi9R7ww22l9Q3g==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=18\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/mime-db\": {\n      \"version\": \"1.54.0\",\n      \"resolved\": \"https://registry.npmjs.org/mime-db/-/mime-db-1.54.0.tgz\",\n      \"integrity\": \"sha512-aU5EJuIN2WDemCcAp2vFBfp/m4EAhWJnUNSSw0ixs7/kXbd6Pg64EmwJkNdFhB8aWt1sH2CTXrLxo/iAGV3oPQ==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/mime-types\": {\n      \"version\": \"3.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/mime-types/-/mime-types-3.0.1.tgz\",\n      \"integrity\": \"sha512-xRc4oEhT6eaBpU1XF7AjpOFD+xQmXNB5OVKwp4tqCuBpHLS/ZbBDrc07mYTDqVMg6PfxUjjNp85O6Cd2Z/5HWA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"mime-db\": \"^1.54.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/ms\": {\n      \"version\": \"2.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/ms/-/ms-2.1.3.tgz\",\n      \"integrity\": \"sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/negotiator\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/negotiator/-/negotiator-1.0.0.tgz\",\n      \"integrity\": \"sha512-8Ofs/AUQh8MaEcrlq5xOX0CQ9ypTF5dl78mjlMNfOK08fzpgTHQRQPBxcPlEtIw0yRpws+Zo/3r+5WRby7u3Gg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/object-assign\": {\n      \"version\": \"4.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz\",\n      \"integrity\": \"sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      }\n    },\n    \"node_modules/object-inspect\": {\n      \"version\": \"1.13.4\",\n      \"resolved\": \"https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz\",\n      \"integrity\": \"sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/on-finished\": {\n      \"version\": \"2.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz\",\n      \"integrity\": \"sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ee-first\": \"1.1.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/once\": {\n      \"version\": \"1.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/once/-/once-1.4.0.tgz\",\n      \"integrity\": \"sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==\",\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"wrappy\": \"1\"\n      }\n    },\n    \"node_modules/parseurl\": {\n      \"version\": \"1.3.3\",\n      \"resolved\": \"https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz\",\n      \"integrity\": \"sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/path-key\": {\n      \"version\": \"3.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz\",\n      \"integrity\": \"sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/path-to-regexp\": {\n      \"version\": \"8.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-8.3.0.tgz\",\n      \"integrity\": \"sha512-7jdwVIRtsP8MYpdXSwOS0YdD0Du+qOoF/AEPIt88PcCFrZCzx41oxku1jD88hZBwbNUIEfpqvuhjFaMAqMTWnA==\",\n      \"license\": \"MIT\",\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/express\"\n      }\n    },\n    \"node_modules/pkce-challenge\": {\n      \"version\": \"5.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/pkce-challenge/-/pkce-challenge-5.0.0.tgz\",\n      \"integrity\": \"sha512-ueGLflrrnvwB3xuo/uGob5pd5FN7l0MsLf0Z87o/UQmRtwjvfylfc9MurIxRAWywCYTgrvpXBcqjV4OfCYGCIQ==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=16.20.0\"\n      }\n    },\n    \"node_modules/proxy-addr\": {\n      \"version\": \"2.0.7\",\n      \"resolved\": \"https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz\",\n      \"integrity\": \"sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"forwarded\": \"0.2.0\",\n        \"ipaddr.js\": \"1.9.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.10\"\n      }\n    },\n    \"node_modules/proxy-from-env\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/proxy-from-env/-/proxy-from-env-1.1.0.tgz\",\n      \"integrity\": \"sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/qs\": {\n      \"version\": \"6.14.0\",\n      \"resolved\": \"https://registry.npmjs.org/qs/-/qs-6.14.0.tgz\",\n      \"integrity\": \"sha512-YWWTjgABSKcvs/nWBi9PycY/JiPJqOD4JA6o9Sej2AtvSGarXxKC3OQSk4pAarbdQlKAh5D4FCQkJNkW+GAn3w==\",\n      \"license\": \"BSD-3-Clause\",\n      \"dependencies\": {\n        \"side-channel\": \"^1.1.0\"\n      },\n      \"engines\": {\n        \"node\": \">=0.6\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/range-parser\": {\n      \"version\": \"1.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz\",\n      \"integrity\": \"sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/raw-body\": {\n      \"version\": \"3.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/raw-body/-/raw-body-3.0.1.tgz\",\n      \"integrity\": \"sha512-9G8cA+tuMS75+6G/TzW8OtLzmBDMo8p1JRxN5AZ+LAp8uxGA8V8GZm4GQ4/N5QNQEnLmg6SS7wyuSmbKepiKqA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"bytes\": \"3.1.2\",\n        \"http-errors\": \"2.0.0\",\n        \"iconv-lite\": \"0.7.0\",\n        \"unpipe\": \"1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.10\"\n      }\n    },\n    \"node_modules/raw-body/node_modules/iconv-lite\": {\n      \"version\": \"0.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.7.0.tgz\",\n      \"integrity\": \"sha512-cf6L2Ds3h57VVmkZe+Pn+5APsT7FpqJtEhhieDCvrE2MK5Qk9MyffgQyuxQTm6BChfeZNtcOLHp9IcWRVcIcBQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"safer-buffer\": \">= 2.1.2 < 3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/express\"\n      }\n    },\n    \"node_modules/require-from-string\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/require-from-string/-/require-from-string-2.0.2.tgz\",\n      \"integrity\": \"sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      }\n    },\n    \"node_modules/router\": {\n      \"version\": \"2.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/router/-/router-2.2.0.tgz\",\n      \"integrity\": \"sha512-nLTrUKm2UyiL7rlhapu/Zl45FwNgkZGaCpZbIHajDYgwlJCOzLSk+cIPAnsEqV955GjILJnKbdQC1nVPz+gAYQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"debug\": \"^4.4.0\",\n        \"depd\": \"^2.0.0\",\n        \"is-promise\": \"^4.0.0\",\n        \"parseurl\": \"^1.3.3\",\n        \"path-to-regexp\": \"^8.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 18\"\n      }\n    },\n    \"node_modules/safe-buffer\": {\n      \"version\": \"5.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz\",\n      \"integrity\": \"sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==\",\n      \"funding\": [\n        {\n          \"type\": \"github\",\n          \"url\": \"https://github.com/sponsors/feross\"\n        },\n        {\n          \"type\": \"patreon\",\n          \"url\": \"https://www.patreon.com/feross\"\n        },\n        {\n          \"type\": \"consulting\",\n          \"url\": \"https://feross.org/support\"\n        }\n      ],\n      \"license\": \"MIT\"\n    },\n    \"node_modules/safer-buffer\": {\n      \"version\": \"2.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz\",\n      \"integrity\": \"sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/send\": {\n      \"version\": \"1.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/send/-/send-1.2.0.tgz\",\n      \"integrity\": \"sha512-uaW0WwXKpL9blXE2o0bRhoL2EGXIrZxQ2ZQ4mgcfoBxdFmQold+qWsD2jLrfZ0trjKL6vOw0j//eAwcALFjKSw==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"debug\": \"^4.3.5\",\n        \"encodeurl\": \"^2.0.0\",\n        \"escape-html\": \"^1.0.3\",\n        \"etag\": \"^1.8.1\",\n        \"fresh\": \"^2.0.0\",\n        \"http-errors\": \"^2.0.0\",\n        \"mime-types\": \"^3.0.1\",\n        \"ms\": \"^2.1.3\",\n        \"on-finished\": \"^2.4.1\",\n        \"range-parser\": \"^1.2.1\",\n        \"statuses\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 18\"\n      }\n    },\n    \"node_modules/serve-static\": {\n      \"version\": \"2.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/serve-static/-/serve-static-2.2.0.tgz\",\n      \"integrity\": \"sha512-61g9pCh0Vnh7IutZjtLGGpTA355+OPn2TyDv/6ivP2h/AdAVX9azsoxmg2/M6nZeQZNYBEwIcsne1mJd9oQItQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"encodeurl\": \"^2.0.0\",\n        \"escape-html\": \"^1.0.3\",\n        \"parseurl\": \"^1.3.3\",\n        \"send\": \"^1.2.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 18\"\n      }\n    },\n    \"node_modules/setprototypeof\": {\n      \"version\": \"1.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz\",\n      \"integrity\": \"sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==\",\n      \"license\": \"ISC\"\n    },\n    \"node_modules/shebang-command\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz\",\n      \"integrity\": \"sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"shebang-regex\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/shebang-regex\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz\",\n      \"integrity\": \"sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/side-channel\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz\",\n      \"integrity\": \"sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"es-errors\": \"^1.3.0\",\n        \"object-inspect\": \"^1.13.3\",\n        \"side-channel-list\": \"^1.0.0\",\n        \"side-channel-map\": \"^1.0.1\",\n        \"side-channel-weakmap\": \"^1.0.2\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/side-channel-list\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz\",\n      \"integrity\": \"sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"es-errors\": \"^1.3.0\",\n        \"object-inspect\": \"^1.13.3\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/side-channel-map\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz\",\n      \"integrity\": \"sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"call-bound\": \"^1.0.2\",\n        \"es-errors\": \"^1.3.0\",\n        \"get-intrinsic\": \"^1.2.5\",\n        \"object-inspect\": \"^1.13.3\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/side-channel-weakmap\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz\",\n      \"integrity\": \"sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"call-bound\": \"^1.0.2\",\n        \"es-errors\": \"^1.3.0\",\n        \"get-intrinsic\": \"^1.2.5\",\n        \"object-inspect\": \"^1.13.3\",\n        \"side-channel-map\": \"^1.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/statuses\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/statuses/-/statuses-2.0.2.tgz\",\n      \"integrity\": \"sha512-DvEy55V3DB7uknRo+4iOGT5fP1slR8wQohVdknigZPMpMstaKJQWhwiYBACJE3Ul2pTnATihhBYnRhZQHGBiRw==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/toidentifier\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz\",\n      \"integrity\": \"sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=0.6\"\n      }\n    },\n    \"node_modules/type-is\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/type-is/-/type-is-2.0.1.tgz\",\n      \"integrity\": \"sha512-OZs6gsjF4vMp32qrCbiVSkrFmXtG/AZhY3t0iAMrMBiAZyV9oALtXO8hsrHbMXF9x6L3grlFuwW2oAz7cav+Gw==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"content-type\": \"^1.0.5\",\n        \"media-typer\": \"^1.1.0\",\n        \"mime-types\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/typescript\": {\n      \"version\": \"5.9.3\",\n      \"resolved\": \"https://registry.npmjs.org/typescript/-/typescript-5.9.3.tgz\",\n      \"integrity\": \"sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==\",\n      \"dev\": true,\n      \"license\": \"Apache-2.0\",\n      \"bin\": {\n        \"tsc\": \"bin/tsc\",\n        \"tsserver\": \"bin/tsserver\"\n      },\n      \"engines\": {\n        \"node\": \">=14.17\"\n      }\n    },\n    \"node_modules/undici-types\": {\n      \"version\": \"6.21.0\",\n      \"resolved\": \"https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz\",\n      \"integrity\": \"sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/unpipe\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz\",\n      \"integrity\": \"sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/vary\": {\n      \"version\": \"1.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/vary/-/vary-1.1.2.tgz\",\n      \"integrity\": \"sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/which\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/which/-/which-2.0.2.tgz\",\n      \"integrity\": \"sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==\",\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"isexe\": \"^2.0.0\"\n      },\n      \"bin\": {\n        \"node-which\": \"bin/node-which\"\n      },\n      \"engines\": {\n        \"node\": \">= 8\"\n      }\n    },\n    \"node_modules/wrappy\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz\",\n      \"integrity\": \"sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==\",\n      \"license\": \"ISC\"\n    },\n    \"node_modules/zod\": {\n      \"version\": \"3.25.76\",\n      \"resolved\": \"https://registry.npmjs.org/zod/-/zod-3.25.76.tgz\",\n      \"integrity\": \"sha512-gzUt/qt81nXsFGKIFcC3YnfEAx5NkunCfnDlvuBSSFS02bcXu4Lmea0AFIUwbLWxWPx3d9p8S5QoaujKcNQxcQ==\",\n      \"license\": \"MIT\",\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/colinhacks\"\n      }\n    },\n    \"node_modules/zod-to-json-schema\": {\n      \"version\": \"3.24.6\",\n      \"resolved\": \"https://registry.npmjs.org/zod-to-json-schema/-/zod-to-json-schema-3.24.6.tgz\",\n      \"integrity\": \"sha512-h/z3PKvcTcTetyjl1fkj79MHNEjm+HpD6NXheWjzOekY7kV+lwDYnHw+ivHkijnCSMz1yJaWBD9vu/Fcmk+vEg==\",\n      \"license\": \"ISC\",\n      \"peerDependencies\": {\n        \"zod\": \"^3.24.1\"\n      }\n    }\n  }\n}\n",
      "line_count": 1416,
      "word_count": 2583,
      "title": "Package Lock.Json",
      "summary": "\"name\": \"@utcp/code-mode-mcp\", \"version\": \"1.0.9\",",
      "key_terms": [
        "form-data",
        "packages",
        "sha512-Rx",
        "lite",
        "list",
        "mode",
        "dotenvx",
        "cookie",
        "shebang",
        "http-errors",
        "es-errors",
        "jyBYVTDGfCL",
        "es-object",
        "devDependencies",
        "disposition",
        "side",
        "safe",
        "fresh",
        "Gw",
        "call"
      ],
      "timestamp": "2025-12-24T18:56:23.169013"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\code-mode-mcp\\package.json",
      "content_type": "configuration",
      "content": "{\n  \"name\": \"@utcp/code-mode-mcp\",\n  \"version\": \"1.0.9\",\n  \"description\": \"Model Context Protocol (MCP) server for UTCP Code Mode - Execute TypeScript code with direct tool access\",\n  \"type\": \"module\",\n  \"main\": \"dist/index.js\",\n  \"bin\": {\n    \"mcp-bridge\": \"./dist/index.js\"\n  },\n  \"files\": [\n    \"dist/**/*\",\n    \"README.md\"\n  ],\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"prepublishOnly\": \"npm run build\",\n    \"start\": \"node dist/index.js\"\n  },\n  \"keywords\": [\n    \"utcp\",\n    \"mcp\",\n    \"code-mode\",\n    \"typescript\",\n    \"model-context-protocol\",\n    \"universal-tool-calling-protocol\",\n    \"bridge\",\n    \"tools\",\n    \"ai\",\n    \"code-execution\"\n  ],\n  \"author\": \"UTCP Team\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/universal-tool-calling-protocol/utcp-mcp.git\"\n  },\n  \"homepage\": \"https://github.com/universal-tool-calling-protocol/utcp-mcp#readme\",\n  \"bugs\": {\n    \"url\": \"https://github.com/universal-tool-calling-protocol/utcp-mcp/issues\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  },\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"typescript\": \"^5.0.0\"\n  },\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^1.20.2\",\n    \"@utcp/cli\": \"^1.0.12\",\n    \"@utcp/code-mode\": \"^1.0.5\",\n    \"@utcp/dotenv-loader\": \"^1.0.0\",\n    \"@utcp/file\": \"^1.0.0\",\n    \"@utcp/http\": \"^1.0.13\",\n    \"@utcp/mcp\": \"^1.0.16\",\n    \"@utcp/sdk\": \"^1.0.16\",\n    \"@utcp/text\": \"^1.0.12\",\n    \"dotenv\": \"^16.0.0\",\n    \"zod\": \"^3.22.0\"\n  }\n}\n",
      "line_count": 65,
      "word_count": 124,
      "title": "Package.Json",
      "summary": "\"name\": \"@utcp/code-mode-mcp\", \"version\": \"1.0.9\",",
      "key_terms": [
        "build",
        "Model",
        "Code",
        "md",
        "index",
        "mode",
        "dependencies",
        "version",
        "devDependencies",
        "Execute",
        "model",
        "https",
        "code-mode",
        "utcp-mcp",
        "universal-tool",
        "readme",
        "git",
        "files",
        "ai",
        "description"
      ],
      "timestamp": "2025-12-24T18:56:23.208602"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\code-mode-mcp\\README.md",
      "content_type": "documentation",
      "content": "# UTCP Code Mode MCP Bridge\n\n**Execute TypeScript code with direct tool access through MCP.**\n\nAn advanced MCP server that brings UTCP Code Mode to the MCP ecosystem, allowing you to execute TypeScript code with all registered tools available as native TypeScript functions.\n\n## üöÄ Quick Start\n\nAdd this configuration to your MCP client (Claude Desktop, etc.):\n\n```json\n{\n  \"mcpServers\": {\n    \"utcp-codemode\": {\n      \"command\": \"npx\",\n      \"args\": [\"@utcp/code-mode-mcp\"],\n      \"env\": {\n        \"UTCP_CONFIG_FILE\": \"/path/to/your/.utcp_config.json\"\n      }\n    }\n  }\n}\n```\n\n**That's it!** No installation required. The bridge will automatically:\n- Download and run the latest version via npx\n- Load your UTCP configuration from the specified path\n- Register all your UTCP manuals as tools available in TypeScript code\n- Enable TypeScript code execution with hierarchical tool access (e.g., `manual.tool()`)\n\n## üîß Configuration\n\nCreate a `.utcp_config.json` file to configure your tools and services:\n\n```json\n{\n    \"load_variables_from\": [\n      {\n        \"variable_loader_type\": \"dotenv\",\n        \"env_file_path\": \".env\"\n      }\n    ],\n    \"manual_call_templates\": [\n      {\n          \"name\": \"openlibrary\",\n          \"call_template_type\": \"http\",\n          \"http_method\": \"GET\", \n          \"url\": \"https://openlibrary.org/static/openapi.json\",\n          \"content_type\": \"application/json\"\n      }\n    ],\n    \"post_processing\": [\n      {\n          \"tool_post_processor_type\": \"filter_dict\",\n          \"only_include_keys\": [\"name\", \"description\"],\n          \"only_include_tools\": [\"openlibrary.*\"]\n      }\n    ],\n    \"tool_repository\": {\n      \"tool_repository_type\": \"in_memory\"\n    },\n    \"tool_search_strategy\": {\n      \"tool_search_strategy_type\": \"tag_and_description_word_match\"\n    }\n}\n```\n\n## üõ†Ô∏è Available MCP Tools\n\nThe bridge exposes these MCP tools for managing your UTCP Code Mode ecosystem:\n\n- **`register_manual`** - Register new UTCP manuals/APIs\n- **`deregister_manual`** - Remove registered manuals\n- **`search_tools`** - Find tools by description with TypeScript interfaces\n- **`list_tools`** - List all registered tool names\n- **`get_required_keys_for_tool`** - Get required environment variables\n- **`tool_info`** - Get complete tool information with TypeScript interface\n- **`call_tool_chain`** - Execute TypeScript code with direct tool access\n\n## üìÅ What is UTCP?\n\nThe Universal Tool Calling Protocol (UTCP) allows you to:\n- **Connect to any API** via HTTP, OpenAPI specs, or custom formats\n- **Use command-line tools** with automatic argument parsing\n- **Process text and files** with built-in utilities\n- **Chain and combine** multiple tools seamlessly\n\nWith this MCP bridge, all your UTCP tools become available in Claude Desktop and other MCP clients.\n\n## üíª Code Mode Example\n\nThe main feature of this bridge is the ability to execute TypeScript code with direct access to all registered tools:\n\n```typescript\n// Example using call_tool_chain\nconst result = await call_tool_chain(`\n  // Get user data from an API\n  const user = await user_service.getUserProfile({ userId: \"123\" });\n  console.log('User data:', user);\n  \n  // Process the data with another tool\n  const processed = await data_processor.analyzeUserBehavior({\n    userData: user,\n    timeframe: \"30days\"\n  });\n  \n  // Generate a report\n  const report = await reporting.generateInsights({\n    analysis: processed,\n    format: \"summary\"\n  });\n  \n  return {\n    userId: user.id,\n    totalActions: processed.actionCount,\n    topInsight: report.insights[0]\n  };\n`);\n```\n\n**Key Benefits:**\n- **Hierarchical Access**: Use `manual.tool()` syntax to avoid naming conflicts\n- **Type Safety**: Get TypeScript interfaces for all tools via `search_tools` or `tool_info`\n- **Code Execution**: Chain multiple tool calls in a single code block\n- **Error Handling**: Proper error handling with timeout support\n\n## üåü Features\n\n- ‚úÖ **Zero installation** - Works via npx\n- ‚úÖ **Universal compatibility** - Works with any MCP client\n- ‚úÖ **Dynamic configuration** - Update tools without restarting\n- ‚úÖ **Environment isolation** - Each project can have its own config\n- ‚úÖ **Comprehensive tool management** - Register, search, call, and inspect tools\n- ‚úÖ **Web interface available** - See [web_ui_utcp_mcp_bridge/](web_ui_utcp_mcp_bridge/)\n\n## üêç Python Version\n\nFor Python users, see the standalone Python implementation in [`python_mcp_bridge/`](python_mcp_bridge/)\n\n## üåê Web Interface\n\nFor advanced management with a web UI, check out [`web_ui_utcp_mcp_bridge/`](web_ui_utcp_mcp_bridge/)\n\n---\n\n<img width=\"2263\" height=\"976\" alt=\"UTCP MCP Bridge Interface\" src=\"https://github.com/user-attachments/assets/a6759512-1c0d-4265-9518-64916fbe1428\" />",
      "line_count": 146,
      "word_count": 572,
      "title": "UTCP Code Mode MCP Bridge",
      "summary": "**Execute TypeScript code with direct tool access through MCP.** An advanced MCP server that brings UTCP Code Mode to the MCP ecosystem, allowing you to execute TypeScript code with all registered too...",
      "key_terms": [
        "const",
        "project",
        "Python",
        "isolation",
        "search",
        "etc",
        "error",
        "img",
        "Type",
        "Code",
        "through",
        "check",
        "Comprehensive",
        "Available",
        "id",
        "Hierarchical",
        "mode",
        "format",
        "available",
        "specified"
      ],
      "timestamp": "2025-12-24T18:56:23.240639"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\code-mode-mcp\\tsconfig.json",
      "content_type": "configuration",
      "content": "{\n  \"compilerOptions\": {\n    // Environment setup & latest features\n    \"lib\": [\"ESNext\", \"ES2022\"],\n    \"target\": \"ES2022\",\n    \"module\": \"ESNext\",\n    \"moduleDetection\": \"force\",\n    \"allowJs\": true,\n\n    // Node.js mode\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"resolveJsonModule\": true,\n\n    // Output configuration\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./\",\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true,\n\n    // Best practices\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"noUncheckedIndexedAccess\": true,\n    \"noImplicitOverride\": true,\n\n    // Some stricter flags (disabled by default)\n    \"noUnusedLocals\": false,\n    \"noUnusedParameters\": false,\n    \"noPropertyAccessFromIndexSignature\": false\n  },\n  \"include\": [\n    \"index.ts\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"examples\",\n    \"web_ui_utcp_mcp_bridge\",\n    \"python_mcp_bridge\"\n  ]\n}\n",
      "line_count": 46,
      "word_count": 84,
      "title": "Tsconfig.Json",
      "summary": "\"compilerOptions\": { // Environment setup & latest features",
      "key_terms": [
        "node",
        "disabled",
        "exclude",
        "Some",
        "lib",
        "module",
        "skipLibCheck",
        "flags",
        "force",
        "target",
        "allowSyntheticDefaultImports",
        "outDir",
        "index",
        "mode",
        "utcp",
        "examples",
        "configuration",
        "rootDir",
        "default",
        "ts"
      ],
      "timestamp": "2025-12-24T18:56:23.240639"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\examples\\mcp_strands\\mcp_strands_agent.py",
      "content_type": "code",
      "content": "from mcp.client.streamable_http import streamablehttp_client\nfrom strands import Agent\nfrom strands.tools.mcp import MCPClient\nimport traceback\nimport os\nfrom contextlib import ExitStack\n\nMODEL_ID = \"anthropic.claude-3-sonnet-20240229-v1:0\"\nos.environ['AWS_REGION'] = 'us-east-1'\n\n# MCP server configurations\nMCP_SERVERS = [\n    \"http://localhost:8777/utcp-proxy\",\n    # \"http://localhost:8776/utcp-client\"\n]\n\nsystem_prompt = \"\"\"You are a helpful AI assistant that can use various tools through MCP (Model Context Protocol) \nand its dedicated Universal Tool Calling Protocol server.\nYou have access to tools that can help you perform different tasks. When a user asks for something, \nanalyze their request and use the appropriate tools to help them accomplish their goal.\n\nBe helpful, accurate, and explain what you're doing when you use tools.\"\"\"\n\n# This application uses Strand SDK to connect to MCP servers and provides a simple interface\n# to call available MCP tools through natural language prompts.\n\ndef create_streamable_http_transport(url):\n    return streamablehttp_client(url=url)\n\ndef print_help():\n    \"\"\"Print available commands\"\"\"\n    print(\"\\nAvailable commands:\")\n    print(\"  /help - Show this help message\")\n    print(\"  /clear - Clear the conversation history\")\n    print(\"  /quit, /bye, /exit - End the conversation\")\n\ndef main():\n    print(\"\\nInitializing MCP clients...\")\n    try:\n        # Create MCP clients for each server\n        mcp_clients = []\n        all_tools = []\n        \n        # Connect to each MCP server and collect tools\n        for server_url in MCP_SERVERS:\n            print(f\"Connecting to {server_url}...\")\n            try:\n                # Fix lambda closure issue by using default parameter\n                mcp_client = MCPClient(lambda url=server_url: create_streamable_http_transport(url))\n                mcp_clients.append(mcp_client)\n            except Exception as e:\n                print(f\"Warning: Could not create client for {server_url}: {e}\")\n                continue\n\n        if not mcp_clients:\n            print(\"No MCP clients could be created. Please check your MCP servers.\")\n            return\n\n        # Use nested context managers to keep all MCP connections active\n        with ExitStack() as stack:\n            # Enter context for all MCP clients\n            active_clients = []\n            for i, client in enumerate(mcp_clients):\n                try:\n                    stack.enter_context(client)\n                    active_clients.append((client, MCP_SERVERS[i]))\n                except Exception as e:\n                    print(f\"Warning: Could not enter context for client {MCP_SERVERS[i]}: {e}\")\n                    continue\n            \n            if not active_clients:\n                print(\"No MCP clients could be activated.\")\n                return\n            \n            # Collect tools from all active clients\n            for client, server_url in active_clients:\n                try:\n                    tools = client.list_tools_sync()\n                    all_tools.extend(tools)\n                    print(f\"Found {len(tools)} tools from {server_url}\")\n                except Exception as e:\n                    print(f\"Warning: Could not get tools from {server_url}: {e}\")\n                    continue\n\n            print(f\"\\nTotal available tools: {len(all_tools)}\")\n            for tool in all_tools:\n                print(f\"- Name: {tool.tool_name}; Type: {tool.tool_type}\")\n            \n            if not all_tools:\n                print(\"No tools available. Please check your MCP servers.\")\n                return\n            \n            # Create a single agent instance to maintain conversation context\n            mcp_agent = Agent(\n                model=MODEL_ID,\n                system_prompt=system_prompt,\n                tools=all_tools\n            )\n            \n            print(\"\\nMCP agent initialized. You can now start your conversation.\")\n            print(\"Type /help to see available commands.\")\n            \n            while True:\n                try:\n                    user_prompt = input(\"\\nEnter your query (I can use available MCP tools to help). /help: \")\n                    \n                    # Handle special commands\n                    if user_prompt.lower() in [\"/bye\", \"/quit\", \"/exit\", \"bye\", \"quit\", \"exit\"]:\n                        print(\"\\nEnding current chat session. Now Go Build...\")\n                        break\n                    elif user_prompt.lower() == \"/help\":\n                        print_help()\n                        continue\n                    elif user_prompt.lower() == \"/clear\":\n                        # Create a new agent instance to clear conversation history\n                        mcp_agent = Agent(\n                            model=MODEL_ID,\n                            system_prompt=system_prompt,\n                            tools=all_tools\n                        )\n                        print(\"\\nConversation history cleared.\")\n                        continue\n                    \n                    # Use the same agent instance for all interactions to maintain context\n                    print(f\"\\nUser query: {user_prompt}\")\n                    print(\"\\nResponse:\")\n                    \n                    response = mcp_agent(user_prompt)\n                    if hasattr(response, 'message') and response.message:\n                        content = response.message.get(\"content\", [{}])\n                        if content and isinstance(content, list) and len(content) > 0:\n                            text = content[0].get(\"text\", \"No response\")\n                            print(text)\n                        else:\n                            print(\"No content in response\")\n                    else:\n                        print(\"No message in response\")\n                    \n                    print(\"\\n\")  # Add a newline after the response\n\n                except KeyboardInterrupt:\n                    print(\"\\nChat session terminated by user.\")\n                    break\n                except Exception as error:\n                    print(f\"\\nError during chat session: {error}\")\n                    traceback.print_exc()\n    \n    except Exception as e:\n        print(\"\\nException Details:\")\n        print(f\"Type: {type(e)}\")\n        print(f\"Message: {str(e)}\")\n        print(\"\\nTraceback:\")\n        traceback.print_exc()\n\nif __name__ == \"__main__\":\n    main()\n",
      "line_count": 157,
      "word_count": 561,
      "title": "Mcp Strands Agent.Py",
      "summary": "from mcp.client.streamable_http import streamablehttp_client from strands import Agent",
      "key_terms": [
        "traceback",
        "lower",
        "chat",
        "Model",
        "maintain",
        "clear",
        "localhost",
        "error",
        "each",
        "Type",
        "utcp-proxy",
        "nException",
        "through",
        "check",
        "analyze",
        "list",
        "uses",
        "during",
        "available",
        "same"
      ],
      "timestamp": "2025-12-24T18:56:23.280471"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\examples\\mcp_strands\\README.md",
      "content_type": "documentation",
      "content": "# MCP Strands Agent Example\n\n## Overview\n\nThis example demonstrates how to build an AI agent using the **Strands SDK** that connects to **UTCP-MCP Bridge** servers to access and utilize tools through the Model Context Protocol (MCP). The agent provides a conversational interface where users can interact with various tools exposed by the UTCP ecosystem.\n\n## What This Example Does\n\nThe MCP Strands Agent (`mcp_strands_agent.py`) creates an intelligent assistant that:\n\n- **Connects to UTCP-MCP Bridge servers** to discover available tools\n- **Uses Strands SDK** to create a conversational AI agent powered by Amazon Bedrock's Claude 3 Sonnet\n- **Maintains conversation context** across multiple interactions\n- **Provides a command-line interface** for natural language tool interaction\n- **Handles multiple MCP servers** simultaneously for maximum tool availability\n\n## Key Features\n\n### UTCP-MCP Integration\n- Connects to the UTCP Proxy MCP server (port 8777) by default\n- Automatically discovers and loads all available tools from connected servers\n- Seamlessly bridges UTCP tools to the Strands agent framework\n\n### Conversational Interface\n- Natural language interaction with AI-powered tool selection\n- Persistent conversation history within a session\n- Built-in commands for session management (`/help`, `/clear`, `/quit`)\n\n### Error Handling & Resilience\n- Graceful handling of server connection failures\n- Continues operation even if some MCP servers are unavailable\n- Detailed error reporting and debugging information\n\n## Prerequisites\n\nBefore running this example, ensure you have:\n\n1. **UTCP-MCP Bridge running** (see main project README)\n2. **AWS credentials configured** with Amazon Bedrock access for Claude 3 Sonnet\n3. **Python 3.8+** installed\n4. **Required Python packages** (see requirements.txt)\n\n## Quick Start\n\n### 1. Start UTCP-MCP Bridge\n\nFrom the main project directory:\n```bash\n# Using Docker\ndocker-compose up --build\n\n# OR using local script\n./run.sh\n```\n\nThis will start the UTCP-MCP Bridge servers on:\n- Port 8777 (UTCP Proxy MCP)\n- Port 8776 (UTCP Client MCP) \n- Port 8778 (Web UI)\n\n### 2. Install Dependencies\n\n```bash\npip install -r requirements.txt\n```\n\n### 3. Configure AWS Credentials\n\nEnsure your AWS credentials are configured with Amazon Bedrock access for Claude models:\n```bash\naws configure\n# OR set environment variables\nexport AWS_ACCESS_KEY_ID=your_key\nexport AWS_SECRET_ACCESS_KEY=your_secret\nexport AWS_REGION=us-east-1\n```\n\n**Note:** Your AWS account must have access to Amazon Bedrock and the Claude 3 Sonnet model in the specified region.\n\n### 4. Run the Agent\n\n```bash\npython mcp_strands_agent.py\n```\n\n## Usage\n\nOnce the agent starts, you'll see:\n```\nInitializing MCP clients...\nConnecting to http://localhost:8777/utcp-proxy...\nFound X tools from http://localhost:8777/utcp-proxy\n\nTotal available tools: X\n- Name: tool1; Type: function\n- Name: tool2; Type: function\n...\n\nMCP agent initialized. You can now start your conversation.\nType /help to see available commands.\n\nEnter your query (I can use available MCP tools to help). /help:\n```\n\n### Available Commands\n\n- `/help` - Show available commands\n- `/clear` - Clear conversation history and start fresh\n- `/quit`, `/bye`, `/exit` - End the session\n\n### Example Interactions\n\n```\nEnter your query: What tools do you have available?\n\nResponse: I have access to several tools through the UTCP-MCP Bridge...\n\nEnter your query: Can you help me search for files in my project?\n\nResponse: I can help you search for files. Let me use the file search tool...\n```\n\n## Configuration\n\n### MCP Server URLs\n\nModify the `MCP_SERVERS` list in the script to connect to different servers:\n\n```python\nMCP_SERVERS = [\n    \"http://localhost:8777/utcp-proxy\",    # UTCP Proxy MCP\n    \"http://localhost:8776/utcp-client\",   # UTCP Client MCP (optional)\n    # Add more MCP servers as needed\n]\n```\n\n### AI Model\n\nChange the Amazon Bedrock model by modifying the `MODEL_ID` variable:\n\n```python\nMODEL_ID = \"anthropic.claude-3-sonnet-20240229-v1:0\"  # Default - Claude 3 Sonnet\n# MODEL_ID = \"anthropic.claude-3-haiku-20240307-v1:0\"  # Claude 3 Haiku - Faster, less capable\n```\n\n**Note:** Ensure the selected model is available in your AWS region and that your account has access to it through Amazon Bedrock.\n\n### System Prompt\n\nCustomize the agent's behavior by modifying the `system_prompt` variable to change how the AI assistant behaves and responds to user queries.\n\n## Architecture\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ   User Input    ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  Strands Agent   ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  Amazon Bedrock     ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ  (Claude Models)    ‚îÇ\n                                ‚îÇ               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                                ‚ñº\n                       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n                       ‚îÇ   MCP Clients    ‚îÇ\n                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                                ‚îÇ\n                                ‚ñº\n                       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n                       ‚îÇ UTCP-MCP Bridge  ‚îÇ\n                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                                ‚îÇ\n                                ‚ñº\n                       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n                       ‚îÇ   UTCP Tools     ‚îÇ\n                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n## Troubleshooting\n\n### Common Issues\n\n1. **\"No MCP clients could be created\"**\n   - Ensure UTCP-MCP Bridge is running\n   - Check that ports 8777/8776 are accessible\n   - Verify server URLs in `MCP_SERVERS`\n\n2. **AWS/Amazon Bedrock errors**\n   - Verify AWS credentials are configured\n   - Check AWS region is set to `us-east-1` (or your preferred Bedrock region)\n   - Ensure you have access to Amazon Bedrock and Claude models\n   - Verify the model ID exists and is available in your region\n\n3. **\"No tools available\"**\n   - Check UTCP-MCP Bridge web UI at http://localhost:8778\n   - Verify UTCP providers are registered and tools are enabled\n   - Check server logs for connection issues\n\n### Debug Mode\n\nFor detailed debugging, the script includes comprehensive error handling and traceback printing. Monitor the console output for specific error messages.\n\n## Integration with UTCP Ecosystem\n\nThis example showcases the power of the UTCP-MCP Bridge by:\n\n- **Leveraging UTCP's universal tool protocol** through MCP compatibility\n- **Accessing any UTCP-registered tools** without direct UTCP client integration\n- **Demonstrating seamless tool discovery** and usage in AI applications\n- **Providing a template** for building more complex UTCP-powered agents\n\n## Next Steps\n\n- Explore the UTCP-MCP Bridge web UI at http://localhost:8778\n- Register additional UTCP providers to expand tool availability\n- Customize the agent's system prompt for specific use cases\n- Build more sophisticated workflows using the discovered tools\n\n## Related\n\n- [UTCP-MCP Bridge Main README](../../README.md)\n- [Strands SDK Documentation](https://github.com/strands-ai/strands)\n- [Model Context Protocol Specification](https://modelcontextprotocol.io/)\n",
      "line_count": 220,
      "word_count": 935,
      "title": "MCP Strands Agent Example",
      "summary": "This example demonstrates how to build an AI agent using the **Strands SDK** that connects to **UTCP-MCP Bridge** servers to access and utilize tools through the Model Context Protocol (MCP). The agen...",
      "key_terms": [
        "comprehensive",
        "Model",
        "packages",
        "clear",
        "Architecture",
        "localhost",
        "Type",
        "list",
        "selected",
        "providers",
        "Found",
        "multiple",
        "model",
        "if",
        "that",
        "Features",
        "interface",
        "behaves",
        "Configure",
        "Main"
      ],
      "timestamp": "2025-12-24T18:56:23.296915"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\examples\\mcp_strands\\requirements.txt",
      "content_type": "other",
      "content": "# MCP Strands Agent Requirements\n\n# Core MCP and Strands dependencies\nstrands-agents \nstrands-agents-tools\nmcp>=1.0.0\n\n# AWS SDK for Amazon Bedrock model access\nboto3>=1.34.0\nbotocore>=1.34.0\n\n# HTTP client for MCP connections\nhttpx>=0.25.0\naiohttp>=3.8.0\n\n# Async support\nasyncio-mqtt>=0.11.0\n\n# Environment and configuration\npython-dotenv>=1.0.0\n\n# Optional: Enhanced CLI experience\nrich>=13.0.0\nclick>=8.1.0\n\n# Development and debugging (optional)\npytest>=7.0.0\npytest-asyncio>=0.21.0\n",
      "line_count": 29,
      "word_count": 55,
      "title": "MCP Strands Agent Requirements",
      "summary": "strands-agents strands-agents-tools",
      "key_terms": [
        "Bedrock",
        "Development",
        "botocore",
        "support",
        "click",
        "experience",
        "dependencies",
        "configuration",
        "and",
        "Amazon",
        "for",
        "aiohttp",
        "Strands",
        "asyncio",
        "rich",
        "asyncio-mqtt",
        "strands-agents",
        "AWS",
        "pytest-asyncio",
        "strands"
      ],
      "timestamp": "2025-12-24T18:56:23.333878"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\python_mcp_bridge\\.utcp_config.json",
      "content_type": "configuration",
      "content": "{\n    \"load_variables_from\": [\n      {\n        \"variable_loader_type\": \"dotenv\",\n        \"env_file_path\": \".env\"\n      }\n    ],\n    \"tool_repository\": {\n      \"tool_repository_type\": \"in_memory\"\n    },\n    \"tool_search_strategy\": {\n      \"tool_search_strategy_type\": \"tag_and_description_word_match\"\n    },\n    \"manual_call_templates\": [\n      {\n          \"name\": \"openlibrary\",\n          \"call_template_type\": \"http\",\n          \"http_method\": \"GET\",\n          \"url\": \"https://openlibrary.org/static/openapi.json\",\n          \"content_type\": \"application/json\"\n      }\n    ],\n    \"post_processing\": [\n      {\n          \"tool_post_processor_type\": \"filter_dict\",\n          \"only_include_keys\": [\"name\", \"key\"],\n          \"only_include_tools\": [\"openlibrary.read_search_authors_json_search_authors_json_get\"]\n      }\n    ]\n  }",
      "line_count": 30,
      "word_count": 48,
      "title": ".Utcp Config.Json",
      "summary": "\"load_variables_from\": [ \"variable_loader_type\": \"dotenv\",",
      "key_terms": [
        "url",
        "https",
        "GET",
        "org",
        "env",
        "api",
        "dotenv",
        "json",
        "static",
        "openlibrary",
        "key",
        "openapi",
        "application",
        "method",
        "http",
        "name"
      ],
      "timestamp": "2025-12-24T18:56:23.333878"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\python_mcp_bridge\\README.md",
      "content_type": "documentation",
      "content": "# UTCP-MCP Bridge (Python)\n\nPython implementation of the UTCP-MCP Bridge for users who prefer Python or need specific Python environment features.\n\n## üöÄ Quick Start\n\n### 1. Install Dependencies\n\nEnsure you have [uv](https://docs.astral.sh/uv/getting-started/installation/) installed on your system:\n\n```bash\n# Using pipx (recommended)\npipx install uv\n\n# Using pip\npip install uv\n\n# Or using curl\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n```\n\n### 2. Download the Script\n\nDownload the [`utcp-client-mcp.py`](utcp-client-mcp.py) file to your desired location.\n\n### 3. Configure Your MCP Client\n\nAdd this configuration to your MCP client (Claude Desktop, etc.):\n\n```json\n{\n  \"mcpServers\": {\n    \"utcp-python\": {\n      \"command\": \"uv\",\n      \"args\": [\n        \"run\",\n        \"/path/to/utcp-client-mcp.py\"\n      ],\n      \"env\": {\n        \"UTCP_CONFIG_FILE\": \"/path/to/your/.utcp_config.json\"\n      }\n    }\n  }\n}\n```\n\n## üîß Configuration\n\nCreate a `.utcp_config.json` file in the same directory as the Python script:\n\n```json\n{\n    \"load_variables_from\": [\n      {\n        \"variable_loader_type\": \"dotenv\",\n        \"env_file_path\": \".env\"\n      }\n    ],\n    \"manual_call_templates\": [\n      {\n          \"name\": \"openlibrary\",\n          \"call_template_type\": \"http\",\n          \"http_method\": \"GET\",\n          \"url\": \"https://openlibrary.org/static/openapi.json\",\n          \"content_type\": \"application/json\"\n      }\n    ],\n    \"post_processing\": [\n      {\n          \"tool_post_processor_type\": \"filter_dict\",\n          \"only_include_keys\": [\"name\", \"description\"],\n          \"only_include_tools\": [\"openlibrary.*\"]\n      }\n    ],\n    \"tool_repository\": {\n      \"tool_repository_type\": \"in_memory\"\n    },\n    \"tool_search_strategy\": {\n      \"tool_search_strategy_type\": \"tag_and_description_word_match\"\n    }\n}\n```\n\n## üõ†Ô∏è Available MCP Tools\n\nThe Python bridge exposes the same MCP tools as the Node.js version:\n\n- **`register_manual`** - Register new UTCP manuals/APIs\n- **`deregister_manual`** - Remove registered manuals\n- **`call_tool`** - Execute any registered UTCP tool\n- **`search_tools`** - Find tools by description\n- **`list_tools`** - List all registered tool names\n- **`get_required_keys_for_tool`** - Get required environment variables\n- **`tool_info`** - Get complete tool information and schema\n\n## üìã Dependencies\n\nThe Python script uses these dependencies (automatically handled by `uv`):\n\n- `fastmcp` - Fast MCP server implementation\n- `utcp` - Core UTCP client\n- `utcp-mcp` - MCP integration\n- `utcp-text` - Text processing tools\n- `utcp-cli` - Command-line tools\n- `utcp-http` - HTTP tools\n\n## üåü Features\n\n- ‚úÖ **Zero global installation** - Uses `uv run` for dependency isolation\n- ‚úÖ **Python ecosystem** - Perfect for Python-heavy workflows\n- ‚úÖ **Same functionality** - All features from the Node.js version\n- ‚úÖ **Environment isolation** - Each project can have its own config\n- ‚úÖ **Fast startup** - Optimized for quick tool loading\n\n## üîÑ Alternative: Using pip/pipx\n\nIf you prefer not to use `uv`, you can also install dependencies globally:\n\n```bash\npip install fastmcp utcp utcp-mcp utcp-text utcp-cli utcp-http\n```\n\nThen use this MCP configuration:\n\n```json\n{\n  \"mcpServers\": {\n    \"utcp-python\": {\n      \"command\": \"python\",\n      \"args\": [\"/path/to/utcp-client-mcp.py\"]\n    }\n  }\n}\n```\n\n## üÜö Why Choose Python Version?\n\n- **Python expertise** - If your team is more comfortable with Python\n- **Custom Python tools** - Easy to extend with Python-specific functionality\n- **Environment control** - More granular control over Python dependencies\n- **Debugging** - Easier to debug and modify if you know Python\n\nFor most users, we recommend the **Node.js version** via `npx @utcp/mcp-bridge` as it requires zero installation and works out of the box.\n",
      "line_count": 144,
      "word_count": 470,
      "title": "UTCP-MCP Bridge (Python)",
      "summary": "Python implementation of the UTCP-MCP Bridge for users who prefer Python or need specific Python environment features. Ensure you have [uv](https://docs.astral.sh/uv/getting-started/installation/) ins...",
      "key_terms": [
        "integration",
        "we",
        "project",
        "Python",
        "recommend",
        "isolation",
        "getting",
        "etc",
        "If",
        "Optimized",
        "Available",
        "uses",
        "started",
        "same",
        "dependencies",
        "utcp-client",
        "global",
        "control",
        "expertise",
        "application"
      ],
      "timestamp": "2025-12-24T18:56:23.368492"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\python_mcp_bridge\\requirements.txt",
      "content_type": "other",
      "content": "utcp\nfastmcp\nfastapi\npython-dotenv\nutcp-http\nutcp-mcp\nutcp-text\nutcp-cli",
      "line_count": 8,
      "word_count": 8,
      "title": "Requirements.Txt",
      "summary": "python-dotenv",
      "key_terms": [
        "mcp",
        "python",
        "text",
        "fastapi",
        "cli",
        "utcp-http",
        "dotenv",
        "fastmcp",
        "api",
        "utcp-mcp",
        "utcp-text",
        "python-dotenv",
        "utcp-cli",
        "utcp",
        "http"
      ],
      "timestamp": "2025-12-24T18:56:23.393052"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\python_mcp_bridge\\utcp-client-mcp.py",
      "content_type": "code",
      "content": "# /// script\n# dependencies = [\n#   \"fastmcp\",\n#   \"utcp==1.0.1\",\n#   \"utcp-mcp==1.0.1\",\n#   \"utcp-text==1.0.1\",\n#   \"utcp-cli==1.0.1\",\n#   \"utcp-http==1.0.1\",\n# ]\n# ///\n\"\"\"FastMCP stdio server that proxies UTCP client functionalities as tools.\n\nThis server provides MCP tools that expose the core UTCP client operations:\n- Registering and deregistering tool providers\n- Calling tools through providers\n- Searching for available tools\n- Loading providers from a JSON configuration file\n- Getting required variables for tools\n\nThe server automatically loads providers from a 'providers.json' file in the same directory.\n\"\"\"\n\nimport asyncio\nimport json\nfrom pathlib import Path\nfrom typing import Any, Dict, Optional\n\nfrom fastmcp import FastMCP\nfrom pydantic import BaseModel, Field\n\n# UTCP imports\nfrom utcp.utcp_client import UtcpClient\nfrom utcp.data.utcp_client_config import UtcpClientConfig\nfrom utcp.data.call_template import CallTemplate\n\n# Global UTCP client instance\nutcp_client: Optional[UtcpClient] = None\n\n# Initialize FastMCP server\nmcp = FastMCP(\"UTCP Client MCP Server\")\n\nasync def initialize_utcp_client():\n    \"\"\"Initialize the UTCP client and try to load providers.json from the same directory.\"\"\"\n    global utcp_client\n    \n    if utcp_client is not None:\n        return utcp_client\n    \n    script_dir = Path(__file__).parent\n    config_file = script_dir / \".utcp_config.json\"\n    \n    if config_file.exists():\n        config = json.loads(config_file.read_text())\n        config = UtcpClientConfig.model_validate(config)\n    else:\n        config = UtcpClientConfig()\n\n    # Create UTCP client\n    utcp_client = await UtcpClient.create(config=config)\n    \n    return utcp_client\n\n\n@mcp.tool()\nasync def register_manual(manual_call_template: CallTemplate) -> Dict[str, Any]:\n    \"\"\"Register a new tool provider with the UTCP client.\n    \n    Args:\n        manual_call_template: Call template to the endpoint of a UTCP Manual\n        \n    Returns:\n        Dictionary with success status and list of registered tools\n    \"\"\"\n    client = await initialize_utcp_client()\n    \n    try:\n        tools = await client.register_manual(manual_call_template)\n        \n        return {\n            \"success\": True,\n            \"manual_name\": manual_call_template.name,\n            \"tools_registered\": len(tools),\n            \"tool_names\": [tool.name for tool in tools]\n        }\n    except Exception as e:\n        return {\n            \"success\": False,\n            \"error\": str(e)\n        }\n\n\n@mcp.tool()\nasync def deregister_manual(manual_name: str) -> Dict[str, Any]:\n    \"\"\"Deregister a tool provider from the UTCP client.\n    \n    Args:\n        manual_name: Name of the manual to deregister\n        \n    Returns:\n        Dictionary with success status\n    \"\"\"\n    client = await initialize_utcp_client()\n    \n    try:\n        await client.deregister_manual(manual_name)\n        return {\n            \"success\": True,\n            \"message\": f\"Manual '{manual_name}' deregistered successfully\"\n        }\n    except Exception as e:\n        return {\n            \"success\": False,\n            \"error\": str(e)\n        }\n\n\n@mcp.tool()\nasync def call_tool(tool_name: str, arguments: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Call a tool through the UTCP client.\n    \n    Args:\n        tool_name: Name of the tool to call\n        arguments: Arguments for the tool call\n        \n    Returns:\n        Dictionary with success status and tool result\n    \"\"\"\n    client = await initialize_utcp_client()\n    \n    try:\n        result = await client.call_tool(tool_name, arguments)\n        return {\n            \"success\": True,\n            \"tool_name\": tool_name,\n            \"result\": result\n        }\n    except Exception as e:\n        return {\n            \"success\": False,\n            \"tool_name\": tool_name,\n            \"error\": str(e)\n        }\n\n\n@mcp.tool()\nasync def search_tools(task_description: str, limit: int = 10) -> Dict[str, Any]:\n    \"\"\"Search for tools using a query string.\n    \n    Args:\n        task_description: Description of the task to search for tools\n        limit: Optional limit on the number of tools to return\n        \n    Returns:\n        Dictionary with success status and matching tools\n    \"\"\"\n    client = await initialize_utcp_client()\n    \n    try:\n        tools = await client.search_tools(task_description, limit)\n        return {\"tools\": [{\"name\": tool.name, \"description\": tool.description, \"input_schema\": tool.inputs.model_dump(exclude_none=True)} for tool in tools]}\n    except Exception as e:\n        return {\"error\": str(e)}\n\n\n@mcp.tool()\nasync def get_required_keys_for_tool(tool_name: str) -> Dict[str, Any]:\n    \"\"\"Get required environment variables for a registered tool.\n    \n    Args:\n        tool_name: Name of the tool to get variables for\n        \n    Returns:\n        Dictionary with success status and required variables\n    \"\"\"\n    client = await initialize_utcp_client()\n    \n    try:\n        variables = await client.get_required_variables_for_registered_tool(tool_name)\n        return {\n            \"success\": True,\n            \"tool_name\": tool_name,\n            \"required_variables\": variables\n        }\n    except Exception as e:\n        return {\n            \"success\": False,\n            \"error\": str(e)\n        }\n\n\n@mcp.tool()\nasync def tool_info(tool_name: str) -> Dict[str, Any]:\n    \"\"\"Get complete information about a specific tool including all details using model_dump().\n    \n    Args:\n        tool_name: Name of the tool to get complete information for\n        \n    Returns:\n        Dictionary with success status and complete tool information with model_dump()\n    \"\"\"\n    client = await initialize_utcp_client()\n    \n    try:\n        # Search for the specific tool\n        tool = await client.config.tool_repository.get_tool(tool_name)\n        \n        if not tool:\n            return {\n                \"success\": False,\n                \"error\": f\"Tool '{tool_name}' not found\"\n            }\n        \n        # Return complete tool information with model_dump()\n        return {\n            \"success\": True,\n            \"tool\": tool.model_dump()\n        }\n    except Exception as e:\n        return {\n            \"success\": False,\n            \"error\": str(e)\n        }\n\nasync def main():\n    global utcp_client\n    utcp_client = await initialize_utcp_client()\n    await mcp.run_async(transport=\"stdio\")\n\nif __name__ == \"__main__\":\n    # Run the FastMCP server\n    asyncio.run(main())\n",
      "line_count": 232,
      "word_count": 664,
      "title": "/// script",
      "summary": "\"\"\"FastMCP stdio server that proxies UTCP client functionalities as tools. This server provides MCP tools that expose the core UTCP client operations:",
      "key_terms": [
        "async",
        "search",
        "number",
        "error",
        "through",
        "list",
        "Utcp",
        "same",
        "available",
        "dependencies",
        "providers",
        "global",
        "found",
        "string",
        "except",
        "task",
        "using",
        "Calling",
        "if",
        "that"
      ],
      "timestamp": "2025-12-24T18:56:23.435729"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\rust_mcp_bridge\\Cargo.toml",
      "content_type": "other",
      "content": "[package]\nname = \"mcp-bridge-rs-utcp\"\nversion = \"1.0.0\"\nedition = \"2021\"\ndescription = \"MCP bridge for Rust UTCP - exposes UTCP tools as MCP tools\"\nlicense = \"MIT OR Apache-2.0\"\nauthors = [\"Universal Tool Calling Protocol\"]\n\n[dependencies]\n\n# Async runtime\ntokio = { version = \"1.0\", features = [\"full\"] }\nasync-trait = \"0.1\"\n\n# Serialization\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\n\n# Error handling\nanyhow = \"1.0\"\nthiserror = \"1.0\"\n\n# Logging\ntracing = \"0.1\"\ntracing-subscriber = { version = \"0.3\", features = [\"env-filter\"] }\n\n# For stdio communication\ntokio-util = { version = \"0.7\", features = [\"codec\"] }\nfutures = \"0.3\"\n\n# UTCP client\nrs-utcp = \"=0.2.1\"\n",
      "line_count": 33,
      "word_count": 114,
      "title": "Cargo.Toml",
      "summary": "name = \"mcp-bridge-rs-utcp\" version = \"1.0.0\"",
      "key_terms": [
        "futures",
        "env",
        "async",
        "env-filter",
        "runtime",
        "codec",
        "full",
        "utcp",
        "as",
        "subscriber",
        "Tool",
        "thiserror",
        "tracing-subscriber",
        "dependencies",
        "Universal",
        "for",
        "Serialization",
        "package",
        "exposes",
        "UTCP"
      ],
      "timestamp": "2025-12-24T18:56:23.445785"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\rust_mcp_bridge\\providers.example.json",
      "content_type": "configuration",
      "content": "{\n    \"manual_call_templates\": [\n        {\n            \"call_template_type\": \"http\",\n            \"name\": \"weather_api\",\n            \"url\": \"https://api.weather.example.com/tools\",\n            \"http_method\": \"GET\"\n        },\n        {\n            \"call_template_type\": \"mcp\",\n            \"name\": \"file_tools\",\n            \"command\": \"python3\",\n            \"args\": [\n                \"mcp_server.py\"\n            ]\n        }\n    ],\n    \"load_variables_from\": [\n        {\n            \"variable_loader_type\": \"dotenv\",\n            \"env_file_path\": \".env\"\n        }\n    ]\n}",
      "line_count": 24,
      "word_count": 36,
      "title": "Providers.Example.Json",
      "summary": "\"manual_call_templates\": [ \"call_template_type\": \"http\",",
      "key_terms": [
        "url",
        "https",
        "GET",
        "mcp",
        "args",
        "tools",
        "api",
        "env",
        "dotenv",
        "example",
        "com",
        "command",
        "py",
        "weather",
        "method",
        "http",
        "name"
      ],
      "timestamp": "2025-12-24T18:56:23.469291"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\rust_mcp_bridge\\README.md",
      "content_type": "documentation",
      "content": "![MCP vs. UTCP](https://github.com/universal-tool-calling-protocol/.github/raw/main/assets/banner.png)\n\n# UTCP MCP Bridge (Rust)\n\nThis **Rust UTCP bridge** enables seamless integration between UTCP tools and any MCP-based ecosystem, providing standard tool invocation, search, streaming, and provider registration functionalities.\n\nA lightweight Rust-based bridge that exposes **UTCP tools** as **MCP tools** ‚Äî enabling any MCP-compatible client (Claude Desktop, Claude CLI, LLM runtimes implementing MCP) to call UTCP tools seamlessly.\n\n## Features\n\nThis bridge lets you:\n\n- üîå Load UTCP providers dynamically from JSON configuration\n- üõ† Call UTCP tools via MCP\n- üîç Search the UTCP tool registry\n- üîÑ Stream UTCP tool results over MCP\n- ü§ù Register new providers dynamically at runtime (planned)\n\nDesigned with flexibility in mind, the bridge can power anything from local tool-automation setups to distributed LLM agent workflows.\n\n---\n\n## UTCP ‚Üí MCP Tool Mapping\n\n| MCP Tool Name             | Description |\n|---------------------------|-------------|\n| `utcp_call_tool`          | Call any UTCP tool with arguments |\n| `utcp_search_tools`       | Fuzzy-search tools in UTCP registry |\n| `utcp_call_tool_stream`   | Stream responses from UTCP tools |\n| `utcp_register_provider`  | Register new UTCP provider at runtime (planned) |\n\n---\n\n## Installation\n\n### From Source\n\n```bash\ngit clone https://github.com/universal-tool-calling-protocol/mcp-bridge-rs-utcp.git\ncd mcp-bridge-rs-utcp\ncargo build --release\n```\n\n### Install Globally\n\nTo install the bridge globally so it can be used from anywhere:\n\n```bash\n# Copy to your local bin directory (recommended)\ncp target/release/mcp-bridge-rs-utcp ~/.local/bin/\n\n# OR copy to system bin (requires sudo)\nsudo cp target/release/mcp-bridge-rs-utcp /usr/local/bin/\n```\n\nEnsure `~/.local/bin` or `/usr/local/bin` is in your `PATH`.\n\n---\n\n## Usage\n\n### Quick Start\n\n```bash\n# Set the path to your UTCP providers file (optional)\nexport UTCP_PROVIDERS_FILE=/path/to/providers.json\n\n# Run the bridge\nmcp-bridge-rs-utcp\n```\n\n### With Claude Desktop\n\nAdd the following to your Claude Desktop MCP configuration:\n\n```json\n{\n  \"mcpServers\": {\n    \"utcp-bridge\": {\n      \"command\": \"mcp-bridge-rs-utcp\",\n      \"env\": {\n        \"UTCP_PROVIDERS_FILE\": \"/absolute/path/to/providers.json\"\n      }\n    }\n  }\n}\n```\n\n---\n\n## Features\n\n### CodeMode\n\nThe bridge includes **CodeMode** support, allowing you to execute inline Rhai scripts that can call UTCP tools. This enables complex logic and data processing directly within the MCP tool call.\n\n#### Example: Run Code\n\n```json\n{\n  \"name\": \"utcp_run_code\",\n  \"arguments\": {\n    \"code\": \"let x = 10; x * 2\",\n    \"timeout\": 1000\n  }\n}\n```\n\n#### Example: Call Tool from Code\n\n```json\n{\n  \"name\": \"utcp_run_code\",\n  \"arguments\": {\n    \"code\": \"let weather = call_tool(\\\"get_weather\\\", #{\\\"city\\\": \\\"London\\\"}); weather\"\n  }\n}\n```\n\n---\n\n## Configuration\n\nThe bridge uses the `rs-utcp` configuration format. Create a `providers.json` file:\n\n```json\n{\n  \"manual_call_templates\": [\n    {\n      \"call_template_type\": \"http\",\n      \"name\": \"weather_api\",\n      \"url\": \"https://api.weather.example.com/tools\",\n      \"http_method\": \"GET\"\n    },\n    {\n      \"call_template_type\": \"mcp\",\n      \"name\": \"file_tools\",\n      \"command\": \"python3\",\n      \"args\": [\"mcp_server.py\"]\n    }\n  ],\n  \"load_variables_from\": [\n    {\n      \"variable_loader_type\": \"dotenv\",\n      \"env_file_path\": \".env\"\n    }\n  ]\n}\n```\n\n---\n\n## Architecture\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ   MCP Client    ‚îÇ  (Claude Desktop, etc.)\n‚îÇ  (JSON-RPC)     ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚îÇ\n         ‚îÇ stdio/SSE\n         ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  MCP Bridge     ‚îÇ  (this project)\n‚îÇ  (Rust)         ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚îÇ\n         ‚îÇ UTCP Protocol\n         ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  UTCP Client    ‚îÇ  (rs-utcp)\n‚îÇ                 ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚îÇ\n         ‚îÇ Various Transports\n         ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  Tool Providers ‚îÇ\n‚îÇ  (HTTP, gRPC,   ‚îÇ\n‚îÇ   WebSocket,    ‚îÇ\n‚îÇ   MCP, etc.)    ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n---\n\n## Tool Examples\n\n### Call a UTCP Tool\n\n```json\n{\n  \"name\": \"utcp_call_tool\",\n  \"arguments\": {\n    \"tool_name\": \"get_weather\",\n    \"arguments\": {\n      \"city\": \"San Francisco\"\n    }\n  }\n}\n```\n\n### Search for Tools\n\n```json\n{\n  \"name\": \"utcp_search_tools\",\n  \"arguments\": {\n    \"query\": \"weather\",\n    \"limit\": 5\n  }\n}\n```\n\n### Stream Tool Results\n\n```json\n{\n  \"name\": \"utcp_call_tool_stream\",\n  \"arguments\": {\n    \"tool_name\": \"generate_report\",\n    \"arguments\": {\n      \"topic\": \"AI trends\"\n    }\n  }\n}\n```\n\n---\n\n## Development\n\n### Building\n\n```bash\ncargo build\n```\n\n### Running Tests\n\n```bash\ncargo test\n```\n\n### Running Locally\n\n```bash\nRUST_LOG=info cargo run\n```\n\n---\n\n## Comparison with Go Implementation\n\nThis Rust implementation provides the same core functionality as the [Go UTCP MCP Bridge](https://github.com/universal-tool-calling-protocol/go-utcp-mcp-bridge), with the following differences:\n\n- ‚úÖ **Performance**: Rust implementation offers better memory safety and performance\n- ‚úÖ **Type Safety**: Leverages Rust's type system for more robust error handling\n- ‚úÖ **CodeMode**: Inline code execution supported via Rhai engine\n- üöß **Chain Execution**: UTCP Chain support planned for future release\n\n---\n\n## Status\n\nThis bridge is currently in **beta** status. The following features are implemented:\n\n- ‚úÖ Tool calling\n- ‚úÖ Tool search\n- ‚úÖ Streaming support\n- ‚úÖ CodeMode support\n- üöß Dynamic provider registration (in progress)\n- üöß Chain execution (planned)\n\n---\n\n## Related Projects\n\n- [rs-utcp](https://github.com/universal-tool-calling-protocol/rs-utcp) - Rust UTCP client library\n- [go-utcp](https://github.com/universal-tool-calling-protocol/go-utcp) - Go UTCP implementation\n- [go-utcp-mcp-bridge](https://github.com/universal-tool-calling-protocol/go-utcp-mcp-bridge) - Go MCP bridge\n\n---\n\n## License\n\nMIT OR Apache-2.0\n\n---\n\n## Contributing\n\nContributions are welcome! Please feel free to submit a Pull Request.\n",
      "line_count": 294,
      "word_count": 741,
      "title": "UTCP MCP Bridge (Rust)",
      "summary": "![MCP vs. UTCP](https://github.com/universal-tool-calling-protocol/.github/raw/main/assets/banner.png) This **Rust UTCP bridge** enables seamless integration between UTCP tools and any MCP-based ecosy...",
      "key_terms": [
        "progress",
        "integration",
        "London",
        "mind",
        "build",
        "project",
        "Rust-based",
        "Architecture",
        "search",
        "etc",
        "error",
        "Type",
        "Globally",
        "Code",
        "based",
        "WebSocket",
        "Designed",
        "compatible",
        "info",
        "format"
      ],
      "timestamp": "2025-12-24T18:56:23.488537"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\rust_mcp_bridge\\src\\main.rs",
      "content_type": "code",
      "content": "use anyhow::{Context, Result};\nuse rs_utcp::config::UtcpClientConfig;\nuse rs_utcp::plugins::codemode::{CodeModeArgs, CodeModeUtcp};\nuse rs_utcp::repository::in_memory::InMemoryToolRepository;\nuse rs_utcp::tag::tag_search::TagSearchStrategy;\nuse rs_utcp::{UtcpClient, UtcpClientInterface};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{json, Value};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};\nuse tracing::{error, info};\nuse std::path::PathBuf;\n\n/// JSON-RPC 2.0 Request\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct JsonRpcRequest {\n    jsonrpc: String,\n    id: Option<Value>,\n    method: String,\n    params: Option<Value>,\n}\n\n/// JSON-RPC 2.0 Response\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct JsonRpcResponse {\n    jsonrpc: String,\n    id: Option<Value>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    result: Option<Value>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    error: Option<JsonRpcError>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct JsonRpcError {\n    code: i32,\n    message: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    data: Option<Value>,\n}\n\n/// MCP Server Info\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct ServerInfo {\n    name: String,\n    version: String,\n}\n\n/// MCP Server Capabilities\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct ServerCapabilities {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    tools: Option<Value>,\n}\n\n/// MCP Tool Schema\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct McpTool {\n    name: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    description: Option<String>,\n    #[serde(rename = \"inputSchema\")]\n    input_schema: Value,\n}\n\n/// The main bridge struct\npub struct UtcpMcpBridge {\n    utcp_client: Arc<UtcpClient>,\n    utcp_code: Arc<CodeModeUtcp>,\n}\n\nimpl UtcpMcpBridge {\n    /// Create a new bridge\n    pub async fn new(config: UtcpClientConfig) -> Result<Self> {\n        let repo = Arc::new(InMemoryToolRepository::new());\n        let strat = Arc::new(TagSearchStrategy::new(repo.clone(), 0.5));\n        \n        let utcp_client = Arc::new(\n            UtcpClient::new(config, repo, strat).await.context(\"Failed to create UTCP client\")?\n        );\n\n        let utcp_code = Arc::new(CodeModeUtcp::new(utcp_client.clone()));\n\n        Ok(Self {\n            utcp_client,\n            utcp_code,\n        })\n    }\n\n    /// Get MCP tool definitions\n    fn get_tools() -> Vec<McpTool> {\n        vec![\n            McpTool {\n                name: \"utcp_call_tool\".to_string(),\n                description: Some(\"Call a UTCP tool by name with arguments\".to_string()),\n                input_schema: json!({\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"tool_name\": {\n                            \"type\": \"string\",\n                            \"description\": \"Name of the UTCP tool to call\"\n                        },\n                        \"arguments\": {\n                            \"type\": \"object\",\n                            \"description\": \"Arguments to pass to the tool\"\n                        }\n                    },\n                    \"required\": [\"tool_name\"]\n                }),\n            },\n            McpTool {\n                name: \"utcp_search_tools\".to_string(),\n                description: Some(\"Search for available UTCP tools\".to_string()),\n                input_schema: json!({\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"query\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query\"\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of results\",\n                            \"default\": 10\n                        }\n                    },\n                    \"required\": [\"query\"]\n                }),\n            },\n            McpTool {\n                name: \"utcp_call_tool_stream\".to_string(),\n                description: Some(\"Call a UTCP tool with streaming response\".to_string()),\n                input_schema: json!({\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"tool_name\": {\n                            \"type\": \"string\",\n                            \"description\": \"Name of the UTCP tool to call\"\n                        },\n                        \"arguments\": {\n                            \"type\": \"object\",\n                            \"description\": \"Arguments to pass to the tool\"\n                        }\n                    },\n                    \"required\": [\"tool_name\"]\n                }),\n            },\n            McpTool {\n                name: \"utcp_run_code\".to_string(),\n                description: Some(\"Execute inline code via UTCP CodeMode engine\".to_string()),\n                input_schema: json!({\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"code\": {\n                            \"type\": \"string\",\n                            \"description\": \"Rhai script to execute\"\n                        },\n                        \"timeout\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Timeout in milliseconds\",\n                            \"default\": 3000\n                        }\n                    },\n                    \"required\": [\"code\"]\n                }),\n            },\n        ]\n    }\n\n    /// Handle a JSON-RPC request\n    async fn handle_request(&self, request: JsonRpcRequest) -> JsonRpcResponse {\n        let id = request.id.clone();\n\n        match request.method.as_str() {\n            \"initialize\" => {\n                let result = json!({\n                    \"protocolVersion\": \"2024-11-05\",\n                    \"serverInfo\": {\n                        \"name\": \"utcp-bridge\",\n                        \"version\": \"1.0.0\"\n                    },\n                    \"capabilities\": {\n                        \"tools\": {}\n                    }\n                });\n\n                JsonRpcResponse {\n                    jsonrpc: \"2.0\".to_string(),\n                    id,\n                    result: Some(result),\n                    error: None,\n                }\n            }\n            \"tools/list\" => {\n                let tools = Self::get_tools();\n                JsonRpcResponse {\n                    jsonrpc: \"2.0\".to_string(),\n                    id,\n                    result: Some(json!({ \"tools\": tools })),\n                    error: None,\n                }\n            }\n            \"tools/call\" => self.handle_tool_call(id, request.params).await,\n            _ => JsonRpcResponse {\n                jsonrpc: \"2.0\".to_string(),\n                id,\n                result: None,\n                error: Some(JsonRpcError {\n                    code: -32601,\n                    message: format!(\"Method not found: {}\", request.method),\n                    data: None,\n                }),\n            },\n        }\n    }\n\n    async fn handle_tool_call(&self, id: Option<Value>, params: Option<Value>) -> JsonRpcResponse {\n        let params = match params {\n            Some(p) => p,\n            None => {\n                return JsonRpcResponse {\n                    jsonrpc: \"2.0\".to_string(),\n                    id,\n                    result: None,\n                    error: Some(JsonRpcError {\n                        code: -32602,\n                        message: \"Invalid params\".to_string(),\n                        data: None,\n                    }),\n                }\n            }\n        };\n\n        let tool_name = match params.get(\"name\").and_then(|v| v.as_str()) {\n            Some(name) => name,\n            None => {\n                return JsonRpcResponse {\n                    jsonrpc: \"2.0\".to_string(),\n                    id,\n                    result: None,\n                    error: Some(JsonRpcError {\n                        code: -32602,\n                        message: \"Missing tool name\".to_string(),\n                        data: None,\n                    }),\n                }\n            }\n        };\n\n        let arguments = params\n            .get(\"arguments\")\n            .and_then(|v| v.as_object())\n            .cloned()\n            .unwrap_or_default();\n\n        match tool_name {\n            \"utcp_call_tool\" => self.handle_utcp_call_tool(id, arguments).await,\n            \"utcp_search_tools\" => self.handle_utcp_search_tools(id, arguments).await,\n            \"utcp_call_tool_stream\" => self.handle_utcp_call_tool_stream(id, arguments).await,\n            \"utcp_run_code\" => self.handle_utcp_run_code(id, arguments).await,\n            _ => JsonRpcResponse {\n                jsonrpc: \"2.0\".to_string(),\n                id,\n                result: None,\n                error: Some(JsonRpcError {\n                    code: -32602,\n                    message: format!(\"Unknown tool: {}\", tool_name),\n                    data: None,\n                }),\n            },\n        }\n    }\n\n    async fn handle_utcp_run_code(\n        &self,\n        id: Option<Value>,\n        arguments: serde_json::Map<String, Value>,\n    ) -> JsonRpcResponse {\n        let code = match arguments.get(\"code\").and_then(|v| v.as_str()) {\n            Some(c) => c.to_string(),\n            None => {\n                return JsonRpcResponse {\n                    jsonrpc: \"2.0\".to_string(),\n                    id,\n                    result: None,\n                    error: Some(JsonRpcError {\n                        code: -32602,\n                        message: \"code is required\".to_string(),\n                        data: None,\n                    }),\n                }\n            }\n        };\n\n        let timeout = arguments\n            .get(\"timeout\")\n            .and_then(|v| v.as_u64())\n            .map(|t| t);\n\n        let args = CodeModeArgs {\n            code,\n            timeout,\n        };\n\n        match self.utcp_code.execute(args).await {\n            Ok(result) => JsonRpcResponse {\n                jsonrpc: \"2.0\".to_string(),\n                id,\n                result: Some(json!({\n                    \"content\": [{\n                        \"type\": \"text\",\n                        \"text\": serde_json::to_string_pretty(&result.value).unwrap_or_else(|_| \"{}\".to_string())\n                    }]\n                })),\n                error: None,\n            },\n            Err(e) => JsonRpcResponse {\n                jsonrpc: \"2.0\".to_string(),\n                id,\n                result: None,\n                error: Some(JsonRpcError {\n                    code: -32603,\n                    message: format!(\"Error executing code: {}\", e),\n                    data: None,\n                }),\n            },\n        }\n    }\n\n    async fn handle_utcp_call_tool(\n        &self,\n        id: Option<Value>,\n        arguments: serde_json::Map<String, Value>,\n    ) -> JsonRpcResponse {\n        let tool_name = match arguments.get(\"tool_name\").and_then(|v| v.as_str()) {\n            Some(name) => name,\n            None => {\n                return JsonRpcResponse {\n                    jsonrpc: \"2.0\".to_string(),\n                    id,\n                    result: None,\n                    error: Some(JsonRpcError {\n                        code: -32602,\n                        message: \"tool_name is required\".to_string(),\n                        data: None,\n                    }),\n                }\n            }\n        };\n\n        let tool_args = arguments\n            .get(\"arguments\")\n            .and_then(|v| v.as_object())\n            .map(|obj| {\n                obj.iter()\n                    .map(|(k, v)| (k.clone(), v.clone()))\n                    .collect::<HashMap<String, Value>>()\n            })\n            .unwrap_or_default();\n\n        match self.utcp_client.call_tool(tool_name, tool_args).await {\n            Ok(result) => JsonRpcResponse {\n                jsonrpc: \"2.0\".to_string(),\n                id,\n                result: Some(json!({\n                    \"content\": [{\n                        \"type\": \"text\",\n                        \"text\": serde_json::to_string_pretty(&result).unwrap_or_else(|_| \"{}\".to_string())\n                    }]\n                })),\n                error: None,\n            },\n            Err(e) => JsonRpcResponse {\n                jsonrpc: \"2.0\".to_string(),\n                id,\n                result: None,\n                error: Some(JsonRpcError {\n                    code: -32603,\n                    message: format!(\"Error calling tool: {}\", e),\n                    data: None,\n                }),\n            },\n        }\n    }\n\n    async fn handle_utcp_search_tools(\n        &self,\n        id: Option<Value>,\n        arguments: serde_json::Map<String, Value>,\n    ) -> JsonRpcResponse {\n        let query = match arguments.get(\"query\").and_then(|v| v.as_str()) {\n            Some(q) => q,\n            None => {\n                return JsonRpcResponse {\n                    jsonrpc: \"2.0\".to_string(),\n                    id,\n                    result: None,\n                    error: Some(JsonRpcError {\n                        code: -32602,\n                        message: \"query is required\".to_string(),\n                        data: None,\n                    }),\n                }\n            }\n        };\n\n        let limit = arguments\n            .get(\"limit\")\n            .and_then(|v| v.as_u64())\n            .unwrap_or(10) as usize;\n\n        match self.utcp_client.search_tools(query, limit).await {\n            Ok(tools) => JsonRpcResponse {\n                jsonrpc: \"2.0\".to_string(),\n                id,\n                result: Some(json!({\n                    \"content\": [{\n                        \"type\": \"text\",\n                        \"text\": serde_json::to_string_pretty(&tools).unwrap_or_else(|_| \"[]\".to_string())\n                    }]\n                })),\n                error: None,\n            },\n            Err(e) => JsonRpcResponse {\n                jsonrpc: \"2.0\".to_string(),\n                id,\n                result: None,\n                error: Some(JsonRpcError {\n                    code: -32603,\n                    message: format!(\"Error searching tools: {}\", e),\n                    data: None,\n                }),\n            },\n        }\n    }\n\n    async fn handle_utcp_call_tool_stream(\n        &self,\n        id: Option<Value>,\n        arguments: serde_json::Map<String, Value>,\n    ) -> JsonRpcResponse {\n        let tool_name = match arguments.get(\"tool_name\").and_then(|v| v.as_str()) {\n            Some(name) => name,\n            None => {\n                return JsonRpcResponse {\n                    jsonrpc: \"2.0\".to_string(),\n                    id,\n                    result: None,\n                    error: Some(JsonRpcError {\n                        code: -32602,\n                        message: \"tool_name is required\".to_string(),\n                        data: None,\n                    }),\n                }\n            }\n        };\n\n        let tool_args = arguments\n            .get(\"arguments\")\n            .and_then(|v| v.as_object())\n            .map(|obj| {\n                obj.iter()\n                    .map(|(k, v)| (k.clone(), v.clone()))\n                    .collect::<HashMap<String, Value>>()\n            })\n            .unwrap_or_default();\n\n        match self.utcp_client.call_tool_stream(tool_name, tool_args).await {\n            Ok(mut stream) => {\n                let mut chunks = Vec::new();\n\n                loop {\n                    match stream.next().await {\n                        Ok(Some(chunk)) => {\n                            chunks.push(chunk);\n                        }\n                        Ok(None) => break,\n                        Err(e) => {\n                            return JsonRpcResponse {\n                                jsonrpc: \"2.0\".to_string(),\n                                id,\n                                result: None,\n                                error: Some(JsonRpcError {\n                                    code: -32603,\n                                    message: format!(\"Stream error: {}\", e),\n                                    data: None,\n                                }),\n                            };\n                        }\n                    }\n                }\n\n                JsonRpcResponse {\n                    jsonrpc: \"2.0\".to_string(),\n                    id,\n                    result: Some(json!({\n                        \"content\": [{\n                            \"type\": \"text\",\n                            \"text\": serde_json::to_string_pretty(&json!({ \"chunks\": chunks })).unwrap_or_else(|_| \"{}\".to_string())\n                        }]\n                    })),\n                    error: None,\n                }\n            }\n            Err(e) => JsonRpcResponse {\n                jsonrpc: \"2.0\".to_string(),\n                id,\n                result: None,\n                error: Some(JsonRpcError {\n                    code: -32603,\n                    message: format!(\"Error calling tool stream: {}\", e),\n                    data: None,\n                }),\n            },\n        }\n    }\n\n    /// Run the MCP server over stdio\n    pub async fn run(&self) -> Result<()> {\n        let stdin = tokio::io::stdin();\n        let mut stdout = tokio::io::stdout();\n        let reader = BufReader::new(stdin);\n        let mut lines = reader.lines();\n\n        info!(\"UTCP MCP Bridge is ready on stdio\");\n\n        while let Some(line) = lines.next_line().await? {\n            if line.trim().is_empty() {\n                continue;\n            }\n\n            // Parse the JSON-RPC request\n            let request: JsonRpcRequest = match serde_json::from_str(&line) {\n                Ok(req) => req,\n                Err(e) => {\n                    error!(\"Failed to parse request: {}\", e);\n                    let error_response = JsonRpcResponse {\n                        jsonrpc: \"2.0\".to_string(),\n                        id: None,\n                        result: None,\n                        error: Some(JsonRpcError {\n                            code: -32700,\n                            message: format!(\"Parse error: {}\", e),\n                            data: None,\n                        }),\n                    };\n                    let response_str = serde_json::to_string(&error_response)?;\n                    stdout.write_all(response_str.as_bytes()).await?;\n                    stdout.write_all(b\"\\n\").await?;\n                    stdout.flush().await?;\n                    continue;\n                }\n            };\n\n            // Handle the request\n            let response = self.handle_request(request).await;\n\n            // Send the response\n            let response_str = serde_json::to_string(&response)?;\n            stdout.write_all(response_str.as_bytes()).await?;\n            stdout.write_all(b\"\\n\").await?;\n            stdout.flush().await?;\n        }\n\n        Ok(())\n    }\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    // Initialize tracing\n    tracing_subscriber::fmt()\n        .with_env_filter(\n            tracing_subscriber::EnvFilter::try_from_default_env()\n                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new(\"info\")),\n        )\n        .with_writer(std::io::stderr) // Write logs to stderr to avoid interfering with stdio protocol\n        .init();\n\n    info!(\"Starting UTCP MCP Bridge...\");\n\n    // Create UTCP client config\n    let providers_file = std::env::var(\"UTCP_PROVIDERS_FILE\").ok();\n    let mut config = UtcpClientConfig::default();\n    if let Some(path) = providers_file {\n        config.providers_file_path = Some(path.into());\n    }\n\n    // Create and run the bridge\n    let bridge = UtcpMcpBridge::new(config).await?;\n    bridge.run().await?;\n\n    info!(\"Bridge shutting down\");\n    Ok(())\n}\n",
      "line_count": 597,
      "word_count": 1367,
      "title": "Main.Rs",
      "summary": "use anyhow::{Context, Result}; use rs_utcp::config::UtcpClientConfig;",
      "key_terms": [
        "Timeout",
        "executing",
        "Result",
        "async",
        "number",
        "error",
        "McpTool",
        "list",
        "id",
        "fmt",
        "info",
        "Clone",
        "format",
        "Utcp",
        "available",
        "trim",
        "cloned",
        "codemode",
        "repo",
        "req"
      ],
      "timestamp": "2025-12-24T18:56:23.519561"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\web_ui_utcp_mcp_bridge\\docker-compose.yml",
      "content_type": "configuration",
      "content": "services:\n  utcp-mcp-server:\n    build: .\n    privileged: true\n    ports:\n      - \"8776:8776\"\n      - \"8777:8777\"\n      - \"8778:8778\"\n    environment:\n      - PROVIDERS_PATH=/app/data/providers.json\n      - HOST=0.0.0.0\n      - FASTAPI_PORT=8778\n      - MCP_PROXY_PORT=8777\n      - MCP_CLIENT_PORT=8776\n      - MCP_PROXY_PATH=/utcp-proxy\n      - MCP_CLIENT_PATH=/utcp-client\n      # Docker-in-Docker specific environment variables\n      - DOCKER_TLS_CERTDIR=/certs\n      - DOCKER_HOST=unix:///var/run/docker.sock\n    volumes:\n      - ./data:/app/data\n      - docker-certs-ca:/certs/ca\n      - docker-certs-client:/certs/client\n    restart: unless-stopped\n    init: true\n\nvolumes:\n  docker-certs-ca:\n  docker-certs-client:",
      "line_count": 29,
      "word_count": 51,
      "title": "Docker Compose.Yml",
      "summary": "utcp-mcp-server: privileged: true",
      "key_terms": [
        "ports",
        "build",
        "specific",
        "app",
        "variables",
        "utcp-proxy",
        "utcp",
        "Docker-in",
        "docker",
        "utcp-client",
        "docker-certs",
        "providers",
        "restart",
        "services",
        "volumes",
        "server",
        "run",
        "HOST",
        "mcp",
        "ca"
      ],
      "timestamp": "2025-12-24T18:56:23.535676"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\web_ui_utcp_mcp_bridge\\README.md",
      "content_type": "documentation",
      "content": "# Full Project Setup\n\n## Getting Started\n\nYou can run the UTCP-MCP Bridge in two ways: using Docker or a local bash script.\n\n### 1.1 Run with Docker\n\nEnsure you have Docker and Docker Compose installed.\n\n```bash\ndocker-compose up --build\n```\n\n### 1.2 Run with Bash Script\n\nEnsure you have Python 3 installed.\n\n```bash\n./run.sh\n```\n\n### 1.3 Run with PowerShell Script\n\nEnsure you have Python 3 installed.\n\n```bash\n./run.ps1\n```\n\nThis will:\n- Set up a Python virtual environment with all dependencies or build the Docker image\n- Start the MCP servers and WEB server\n- Expose the following ports:\n  - `8776` (UTCP Client MCP)\n  - `8777` (UTCP Proxy MCP)\n  - `8778` (FastAPI web server)\n\n### 2 Connect with your MCP Client of choice\n\nTo connect your MCP client to the UTCP-MCP Bridge, add the following entries to your client's `mcp.json` (or equivalent configuration file):\n\n#### Cursor example:\n```json\n{\n  \"mcpServers\": {\n    // any other mcp servers\n    \"utcp-proxy-mcp-local\": {\n      \"url\": \"http://localhost:8777/utcp-proxy\"\n    },\n    \"utcp-client-mcp-local\": {\n      \"url\": \"http://localhost:8776/utcp-client\"\n    }\n  }\n}\n```\n#### VS Code example:\n```json\n{\n\t\"servers\": {\n    // any other mcp servers\n\t\t\"utcp-proxy-mcp-local\": {\n\t\t\t\"url\": \"http://localhost:8777/utcp-proxy\",\n\t\t\t\"type\": \"http\"\n\t\t},\n\t\t\"utcp-client-mcp-local\": {\n\t\t\t\"url\": \"http://localhost:8776/utcp-client\",\n\t\t\t\"type\": \"http\"\n\t\t}\n\t},\n\t\"inputs\": []\n}\n```\n\n- `utcp-proxy-mcp-local` connects to the UTCP Proxy MCP server (port 8777)\n- `utcp-client-mcp-local` connects to the UTCP Client MCP server (port 8776)\n\nAdjust the URLs if you are running the server on a different host or port.\n\n### 3 UI Interface\n\nWeb Interface to view and manage providers and tools is accessible in any browser at [http://localhost:8778/](http://localhost:8778/)\n\n<img width=\"1512\" height=\"982\" alt=\"Screenshot 2025-07-30 at 17 53 42\" src=\"https://github.com/user-attachments/assets/2164587b-72ec-426f-98be-3a75df761dbb\" />\n\n\n---\n\n## Configuration\n\n- Provider and tool definitions are loaded from the `data/` directory (e.g., `data/providers.json`).\n- Environment variables can be set in Docker Compose or your shell to customize ports and paths.\n\n---\n\n## API Endpoints\n\n- `/` ‚Äì Web UI\n- `/health` ‚Äì Health check and status\n- `/tools` ‚Äì List available tools\n- `/providers` ‚Äì List available providers\n\n---\n\n\n\n## Dependencies\n\n- `utcp`\n- `fastmcp`\n- `fastapi`\n- `python-dotenv`\n\nAll dependencies are installed automatically by the Docker image or the bash script.\n",
      "line_count": 115,
      "word_count": 356,
      "title": "Full Project Setup",
      "summary": "You can run the UTCP-MCP Bridge in two ways: using Docker or a local bash script. Ensure you have Docker and Docker Compose installed.",
      "key_terms": [
        "build",
        "up",
        "Python",
        "paths",
        "localhost",
        "utcp-proxy",
        "img",
        "Code",
        "Setup",
        "check",
        "Compose",
        "choice",
        "available",
        "mcp-local",
        "dependencies",
        "utcp-client",
        "connect",
        "providers",
        "other",
        "customize"
      ],
      "timestamp": "2025-12-24T18:56:23.570103"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\web_ui_utcp_mcp_bridge\\requirements.txt",
      "content_type": "other",
      "content": "utcp==0.2.1\nfastmcp\nfastapi\npython-dotenv",
      "line_count": 4,
      "word_count": 4,
      "title": "Requirements.Txt",
      "summary": "utcp==0.2.1 python-dotenv",
      "key_terms": [
        "python",
        "api",
        "fastapi",
        "dotenv",
        "fastmcp",
        "python-dotenv",
        "utcp"
      ],
      "timestamp": "2025-12-24T18:56:23.584751"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\web_ui_utcp_mcp_bridge\\data\\newsapi_manual.json",
      "content_type": "configuration",
      "content": "{\n  \"version\": \"1.0\",\n  \"tools\": [\n    {\n      \"name\": \"everything_get\",\n      \"description\": \"Search through millions of articles from over 150,000 large and small news sources and blogs. This endpoint suits article discovery and analysis. It requires either a search query, a source, or a domain.\",\n      \"tags\": [\n        \"articles\"\n      ],\n      \"inputs\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"q\": {\n            \"type\": \"string\",\n            \"description\": \"Keywords or phrases to search for in the article title and body. Advanced search is supported. Max length: 500 chars.\"\n          },\n          \"searchIn\": {\n            \"type\": \"string\",\n            \"description\": \"The fields to restrict your q search to. Possible options: title, description, content. Multiple options can be specified by separating them with a comma.\"\n          },\n          \"sources\": {\n            \"type\": \"string\",\n            \"description\": \"A comma-seperated string of identifiers (maximum 20) for the news sources or blogs you want headlines from.\"\n          },\n          \"domains\": {\n            \"type\": \"string\",\n            \"description\": \"A comma-seperated string of domains (eg bbc.co.uk, techcrunch.com, engadget.com) to restrict the search to.\"\n          },\n          \"excludeDomains\": {\n            \"type\": \"string\",\n            \"description\": \"A comma-seperated string of domains (eg bbc.co.uk, techcrunch.com, engadget.com) to remove from the results.\"\n          },\n          \"from\": {\n            \"type\": \"string\",\n            \"description\": \"A date and optional time for the oldest article allowed. This should be in ISO 8601 format (e.g. 2025-07-09 or 2025-07-09T09:28:11)\"\n          },\n          \"to\": {\n            \"type\": \"string\",\n            \"description\": \"A date and optional time for the newest article allowed. This should be in ISO 8601 format (e.g. 2025-07-09 or 2025-07-09T09:28:11)\"\n          },\n          \"language\": {\n            \"type\": \"string\",\n            \"description\": \"The 2-letter ISO-639-1 code of the language you want to get headlines for.\"\n          },\n          \"sortBy\": {\n            \"type\": \"string\",\n            \"description\": \"The order to sort the articles in. Possible options: relevancy, popularity, publishedAt.\"\n          },\n          \"pageSize\": {\n            \"type\": \"integer\",\n            \"description\": \"The number of results to return per page. Maximum: 100.\"\n          },\n          \"page\": {\n            \"type\": \"integer\",\n            \"description\": \"Use this to page through the results.\"\n          }\n        },\n        \"required\": [\n          \"q\"\n        ]\n      },\n      \"outputs\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"status\": {\n            \"type\": \"string\",\n            \"description\": \"If the request was successful or not. Options: ok, error.\"\n          },\n          \"totalResults\": {\n            \"type\": \"integer\",\n            \"description\": \"The total number of results available for your request.\"\n          },\n          \"articles\": {\n            \"type\": \"array\",\n            \"description\": \"The results of the request.\",\n            \"items\": {\n              \"type\": \"object\",\n              \"properties\": {\n                \"source\": {\n                  \"type\": \"object\",\n                  \"description\": \"The identifier id and a display name name for the source this article came from.\",\n                  \"properties\": {\n                    \"id\": {\n                      \"type\": \"string\"\n                    },\n                    \"name\": {\n                      \"type\": \"string\"\n                    }\n                  }\n                },\n                \"author\": {\n                  \"type\": \"string\",\n                  \"description\": \"The author of the article\"\n                },\n                \"title\": {\n                  \"type\": \"string\",\n                  \"description\": \"The headline or title of the article.\"\n                },\n                \"description\": {\n                  \"type\": \"string\",\n                  \"description\": \"A description or snippet from the article.\"\n                },\n                \"url\": {\n                  \"type\": \"string\",\n                  \"description\": \"The direct URL to the article.\"\n                },\n                \"urlToImage\": {\n                  \"type\": \"string\",\n                  \"description\": \"The URL to a relevant image for the article.\"\n                },\n                \"publishedAt\": {\n                  \"type\": \"string\",\n                  \"description\": \"The date and time that the article was published, in UTC (+000)\"\n                },\n                \"content\": {\n                  \"type\": \"string\",\n                  \"description\": \"The unformatted content of the article, where available. This is truncated to 200 chars.\"\n                }\n              },\n              \"required\": [\n                \"title\"\n              ]\n            }\n          }\n        }\n      },\n      \"tool_provider\": {\n        \"provider_type\": \"http\",\n        \"url\": \"https://newsapi.org/v2/everything\",\n        \"http_method\": \"GET\",\n        \"content_type\": \"application/json\",\n        \"auth\": {\n          \"auth_type\": \"api_key\",\n          \"api_key\": \"$NEWS_API_KEY\",\n          \"var_name\": \"X-Api-Key\"\n        }\n      }\n    },\n    {\n      \"name\": \"top_headlines_get\",\n      \"description\": \"This endpoint provides live top and breaking headlines for a country, specific category in a country, single source, or multiple sources. You can also search with keywords. Articles are sorted by the earliest date published first. This endpoint is great for retrieving headlines for use with news tickers or similar.\",\n      \"tags\": [\n        \"articles\"\n      ],\n      \"inputs\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"country\": {\n            \"type\": \"string\",\n            \"description\": \"The 2-letter ISO 3166-1 code of the country you want to get headlines for. Note: you can't mix this param with the sources param.\"\n          },\n          \"category\": {\n            \"type\": \"string\",\n            \"description\": \"The category you want to get headlines for. Possible options: business, entertainment, general, health, science, sports, technology. Note: you can't mix this param with the sources param.\"\n          },\n          \"sources\": {\n            \"type\": \"string\",\n            \"description\": \"A comma-seperated string of identifiers for the news sources or blogs you want headlines from. Note: you can't mix this param with the country or category params.\"\n          },\n          \"q\": {\n            \"type\": \"string\",\n            \"description\": \"Keywords or a phrase to search for.\"\n          },\n          \"pageSize\": {\n            \"type\": \"integer\",\n            \"description\": \"The number of results to return per page (request). 20 is the default, 100 is the maximum.\"\n          },\n          \"page\": {\n            \"type\": \"integer\",\n            \"description\": \"Use this to page through the results if the total results found is greater than the page size.\"\n          }\n        }\n      },\n      \"outputs\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"status\": {\n            \"type\": \"string\",\n            \"description\": \"If the request was successful or not. Options: ok, error.\"\n          },\n          \"totalResults\": {\n            \"type\": \"integer\",\n            \"description\": \"The total number of results available for your request.\"\n          },\n          \"articles\": {\n            \"type\": \"array\",\n            \"description\": \"The results of the request.\",\n            \"items\": {\n              \"type\": \"object\",\n              \"properties\": {\n                \"source\": {\n                  \"type\": \"object\",\n                  \"description\": \"The identifier id and a display name name for the source this article came from.\",\n                  \"properties\": {\n                    \"id\": {\n                      \"type\": \"string\"\n                    },\n                    \"name\": {\n                      \"type\": \"string\"\n                    }\n                  }\n                },\n                \"author\": {\n                  \"type\": \"string\",\n                  \"description\": \"The author of the article\"\n                },\n                \"title\": {\n                  \"type\": \"string\",\n                  \"description\": \"The headline or title of the article.\"\n                },\n                \"description\": {\n                  \"type\": \"string\",\n                  \"description\": \"A description or snippet from the article.\"\n                },\n                \"url\": {\n                  \"type\": \"string\",\n                  \"description\": \"The direct URL to the article.\"\n                },\n                \"urlToImage\": {\n                  \"type\": \"string\",\n                  \"description\": \"The URL to a relevant image for the article.\"\n                },\n                \"publishedAt\": {\n                  \"type\": \"string\",\n                  \"description\": \"The date and time that the article was published, in UTC (+000)\"\n                },\n                \"content\": {\n                  \"type\": \"string\",\n                  \"description\": \"The unformatted content of the article, where available. This is truncated to 200 chars.\"\n                }\n              },\n              \"required\": [\n                \"title\"\n              ]\n            }\n          }\n        }\n      },\n      \"tool_provider\": {\n        \"provider_type\": \"http\",\n        \"url\": \"https://newsapi.org/v2/top-headlines\",\n        \"http_method\": \"GET\",\n        \"content_type\": \"application/json\",\n        \"auth\": {\n          \"auth_type\": \"api_key\",\n          \"api_key\": \"$NEWS_API_KEY\",\n          \"var_name\": \"X-Api-Key\"\n        }\n      }\n    }\n  ]\n}",
      "line_count": 252,
      "word_count": 959,
      "title": "Newsapi Manual.Json",
      "summary": "\"version\": \"1.0\", \"name\": \"everything_get\",",
      "key_terms": [
        "ISO",
        "page",
        "phrase",
        "search",
        "number",
        "chars",
        "error",
        "co",
        "If",
        "display",
        "either",
        "through",
        "Articles",
        "id",
        "format",
        "available",
        "searchIn",
        "It",
        "specified",
        "small"
      ],
      "timestamp": "2025-12-24T18:56:23.620491"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\web_ui_utcp_mcp_bridge\\data\\providers.json",
      "content_type": "configuration",
      "content": "[\n  {\n      \"name\": \"openlibrary\",\n      \"provider_type\": \"http\",\n      \"http_method\": \"GET\",\n      \"url\": \"https://openlibrary.org/static/openapi.json\",\n      \"content_type\": \"application/json\"\n  },\n  {\n      \"name\": \"newsapi\",\n      \"provider_type\": \"text\",\n      \"file_path\": \"C:\\\\Users\\\\razva\\\\Documents\\\\Startup\\\\utcp\\\\utcp-mcp\\\\data\\\\newsapi_manual.json\"\n  }\n]",
      "line_count": 14,
      "word_count": 22,
      "title": "Providers.Json",
      "summary": "\"name\": \"openlibrary\", \"provider_type\": \"http\",",
      "key_terms": [
        "Documents",
        "Startup",
        "static",
        "utcp",
        "method",
        "url",
        "GET",
        "newsapi",
        "openlibrary",
        "application",
        "name",
        "mcp",
        "https",
        "razva",
        "http",
        "utcp-mcp",
        "org",
        "Users",
        "text",
        "api"
      ],
      "timestamp": "2025-12-24T18:56:23.631542"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\web_ui_utcp_mcp_bridge\\src\\config.py",
      "content_type": "code",
      "content": "import os\nfrom dotenv import load_dotenv\n\n\nload_dotenv()  \n\nclass Config:\n    PROVIDERS_PATH = os.getenv(\"PROVIDERS_PATH\", \"/app/data/providers.json\")\n    HOST = os.getenv(\"HOST\", \"0.0.0.0\")\n    FASTAPI_PORT = int(os.getenv(\"FASTAPI_PORT\", \"8778\"))\n    MCP_PROXY_PORT = int(os.getenv(\"MCP_PROXY_PORT\", \"8777\"))\n    MCP_CLIENT_PORT = int(os.getenv(\"MCP_CLIENT_PORT\", \"8776\"))\n    MCP_PROXY_PATH = os.getenv(\"MCP_PROXY_PATH\", \"/utcp-proxy\")\n    MCP_CLIENT_PATH = os.getenv(\"MCP_CLIENT_PATH\", \"/utcp-client\")\n",
      "line_count": 15,
      "word_count": 37,
      "title": "Config.Py",
      "summary": "from dotenv import load_dotenv load_dotenv()",
      "key_terms": [
        "from",
        "app",
        "utcp-proxy",
        "utcp",
        "utcp-client",
        "providers",
        "int",
        "HOST",
        "dotenv",
        "import",
        "API",
        "class",
        "Config",
        "json",
        "client",
        "data",
        "getenv",
        "os",
        "proxy"
      ],
      "timestamp": "2025-12-24T18:56:23.663623"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\web_ui_utcp_mcp_bridge\\src\\logger.py",
      "content_type": "code",
      "content": "import logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(\"utcp-mcp\")",
      "line_count": 4,
      "word_count": 6,
      "title": "Logger.Py",
      "summary": "import logging logging.basicConfig(level=logging.INFO)",
      "key_terms": [
        "mcp",
        "logger",
        "basicConfig",
        "level",
        "import",
        "INFO",
        "logging",
        "getLogger",
        "utcp",
        "utcp-mcp"
      ],
      "timestamp": "2025-12-24T18:56:23.670837"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\web_ui_utcp_mcp_bridge\\src\\main.py",
      "content_type": "code",
      "content": "import asyncio\nimport uvicorn\nfrom logger import logger\nfrom config import Config\nfrom server import utcp_client, utcp_proxy, app\n\nasync def run_client_mcp():\n    \"\"\"Run UTCP Client MCP server asynchronously\"\"\"\n    await utcp_client.run()\n\nasync def run_proxy_mcp():\n    \"\"\"Run UTCP Proxy MCP server asynchronously\"\"\"\n    await utcp_proxy.run()\n\nasync def run_fastapi():\n    \"\"\"Run FastAPI server asynchronously\"\"\"\n    config = uvicorn.Config(\n        app, \n        host=Config.HOST, \n        port=Config.FASTAPI_PORT, \n        log_level=\"info\",\n        reload=True\n    )\n    server = uvicorn.Server(config)\n    await server.serve()\n\nasync def main():\n    \"\"\"Main entry point\"\"\"\n    await asyncio.gather(\n        run_fastapi(),\n        run_proxy_mcp(),\n        run_client_mcp(),\n        return_exceptions=True\n    )\n\nif __name__ == \"__main__\":\n    try:\n        logger.info(\"Starting UTCP-MCP Bridge...\")\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        logger.info(\"Received shutdown signal\")\n    except Exception as e:\n        logger.error(f\"Application error: {e}\")\n        raise\n    finally:\n        logger.info(\"Application shutting down...\")\n",
      "line_count": 47,
      "word_count": 100,
      "title": "Main.Py",
      "summary": "import asyncio import uvicorn",
      "key_terms": [
        "from",
        "down",
        "uvicorn",
        "entry",
        "async",
        "app",
        "config",
        "error",
        "shutdown",
        "def",
        "info",
        "as",
        "utcp",
        "shutting",
        "logger",
        "Application",
        "UTCP",
        "asyncio",
        "server",
        "except"
      ],
      "timestamp": "2025-12-24T18:56:23.686335"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\web_ui_utcp_mcp_bridge\\src\\mvp-server.py",
      "content_type": "code",
      "content": "import os\nimport asyncio\nfrom fastmcp import FastMCP\nfrom fastapi import FastAPI\nfrom starlette.responses import JSONResponse\nimport uvicorn\nfrom utcp.client.utcp_client import UtcpClient\nfrom utcp.client.utcp_client_config import UtcpClientConfig\nfrom utcp.client.tool_repositories.in_mem_tool_repository import InMemToolRepository\nfrom utcp.client.tool_search_strategies.tag_search import TagSearchStrategy\n\n# Path to providers.json\nPROVIDERS_PATH = os.path.join(os.path.dirname(__file__), \"providers.json\")\n\n# Create FastAPI app for /health endpoint\napp = FastAPI()\n\n# Create MCP server\nmcp = FastMCP(\"utcp-mcp-bridge\")\n\nutcp_client = None\nutcp_tools = []\nutcp_providers = []\n\ndef make_proxy(tool):\n    param_map = {}\n    required = set(tool.inputs.required or [])\n    required_params = []\n    optional_params = []\n    for orig_name in tool.inputs.properties.keys():\n        py_name = orig_name[:-2] if orig_name.endswith('[]') else orig_name\n        param_map[py_name] = orig_name\n        if py_name in required or orig_name in required:\n            required_params.append(py_name)\n        else:\n            optional_params.append(f\"{py_name}=None\")\n    params_str = \", \".join(required_params + optional_params)\n    func_code = f\"async def proxy({params_str}):\\n\"\n    func_code += \"    args = {}\\n\"\n    for py_name, orig_name in param_map.items():\n        func_code += f\"    args['{orig_name}'] = {py_name}\\n\"\n    func_code += f\"    return await utcp_client.call_tool('{tool.name}', args)\\n\"\n    ns = {}\n    exec(func_code, globals(), ns)\n    proxy_func = ns[\"proxy\"]\n    proxy_func.__name__ = tool.name.replace('.', '_')\n    proxy_func.__doc__ = tool.description or 'UTCP tool proxy'\n    return proxy_func\n\n@app.get(\"/health\")\nasync def health():\n    return JSONResponse({\n        \"providers\": len(utcp_providers),\n        \"tools\": len(utcp_tools),\n        \"provider_names\": [p.name for p in utcp_providers],\n        \"tool_names\": [t.name for t in utcp_tools],\n    })\n\nasync def utcp_init():\n    global utcp_client, utcp_tools, utcp_providers\n    config = UtcpClientConfig(providers_file_path=PROVIDERS_PATH)\n    utcp_client = await UtcpClient.create(\n        config=config,\n        tool_repository=InMemToolRepository(),\n        search_strategy=TagSearchStrategy(InMemToolRepository())\n    )\n    utcp_tools = await utcp_client.tool_repository.get_tools()\n    utcp_providers = await utcp_client.tool_repository.get_providers()\n\n    print(f\"Successfully registered {len(utcp_providers)} providers with {len(utcp_tools)} tools\")\n    # Register each UTCP tool as an MCP tool\n    for tool in utcp_tools:\n        proxy_func = make_proxy(tool)\n        mcp.tool(name=tool.name, description=tool.description or \"UTCP tool\")(proxy_func)\n\nasync def run_fastapi():\n    \"\"\"Run FastAPI server asynchronously\"\"\"\n    config = uvicorn.Config(app, host=\"0.0.0.0\", port=8788, log_level=\"info\")\n    server = uvicorn.Server(config)\n    await server.serve()\n\nasync def run_mcp():\n    \"\"\"Run MCP server asynchronously\"\"\"\n    await mcp.run_async(transport=\"http\", host=\"0.0.0.0\", port=8787, path=\"/mcp\")\n\nasync def main():\n    # Initialize UTCP first\n    await utcp_init()\n    \n    # Run both servers concurrently\n    await asyncio.gather(\n        run_fastapi(),\n        run_mcp()\n    )\n\n# Entrypoint\nif __name__ == \"__main__\":\n    asyncio.run(main())",
      "line_count": 98,
      "word_count": 299,
      "title": "Mvp Server.Py",
      "summary": "import asyncio from fastmcp import FastMCP",
      "key_terms": [
        "async",
        "each",
        "info",
        "endswith",
        "Utcp",
        "providers",
        "global",
        "gather",
        "path",
        "if",
        "Run",
        "utcp-mcp",
        "Config",
        "description",
        "await",
        "os",
        "TagSearchStrategy",
        "fastmcp",
        "items",
        "def"
      ],
      "timestamp": "2025-12-24T18:56:23.711225"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\web_ui_utcp_mcp_bridge\\src\\server.py",
      "content_type": "code",
      "content": "import os\nimport json\nimport asyncio\nimport uvicorn\nfrom contextlib import asynccontextmanager\nfrom typing import Dict, List, Optional, Any\nfrom fastmcp import FastMCP\nfrom fastapi import FastAPI, HTTPException\nfrom starlette.responses import JSONResponse\nfrom config import Config\nfrom logger import logger\nfrom utcp_proxy_mcp import UTCPProxy\nfrom utcp_client_mcp import UTCPClient\nfrom fastapi.staticfiles import StaticFiles\nfrom fastapi.responses import FileResponse\nfrom fastapi import Body\nfrom utcp.shared.provider import Provider, HttpProvider, CliProvider, SSEProvider, StreamableHttpProvider, WebSocketProvider, GRPCProvider, GraphQLProvider, TCPProvider, UDPProvider, WebRTCProvider, MCPProvider, TextProvider\n\n\nutcp_proxy = UTCPProxy()\nutcp_client = UTCPClient()\n\nPROVIDERS_PATH = os.path.join(os.path.dirname(__file__), '../data/providers.json')\n# Ensure we have the absolute path\nPROVIDERS_PATH = os.path.abspath(PROVIDERS_PATH)\n\ndef read_providers_file():\n    try:\n        if not os.path.exists(PROVIDERS_PATH):\n            # Create empty providers file if it doesn't exist\n            os.makedirs(os.path.dirname(PROVIDERS_PATH), exist_ok=True)\n            with open(PROVIDERS_PATH, 'w') as f:\n                json.dump([], f)\n            return []\n        \n        with open(PROVIDERS_PATH, 'r') as f:\n            content = f.read().strip()\n            if not content:\n                return []\n            return json.loads(content)\n    except Exception as e:\n        logger.error(f\"Error reading providers file: {e}\")\n        return []\n\ndef write_providers_file(providers):\n    try:\n        os.makedirs(os.path.dirname(PROVIDERS_PATH), exist_ok=True)\n        with open(PROVIDERS_PATH, 'w') as f:\n            json.dump(providers, f, indent=2)\n    except Exception as e:\n        logger.error(f\"Error writing providers file: {e}\")\n        raise\n\nasync def reload_providers():\n    logger.info(\"Reloading providers...\")\n    await utcp_client.initialize()\n    await utcp_proxy.initialize()\n    logger.info(\"Providers reloaded successfully\")\n\n\n# Provider type mapping (reuse from UtcpClient)\nprovider_classes = {\n    'http': HttpProvider,\n    'cli': CliProvider,\n    'sse': SSEProvider,\n    'http_stream': StreamableHttpProvider,\n    'websocket': WebSocketProvider,\n    'grpc': GRPCProvider,\n    'graphql': GraphQLProvider,\n    'tcp': TCPProvider,\n    'udp': UDPProvider,\n    'webrtc': WebRTCProvider,\n    'mcp': MCPProvider,\n    'text': TextProvider\n}\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"FastAPI lifespan context manager\"\"\"\n    try:\n        logger.info(f\"Starting application with providers path: {PROVIDERS_PATH}\")\n        await utcp_client.initialize()\n        await utcp_proxy.initialize()\n        logger.info(\"Application started successfully\")\n        yield\n    except Exception as e:\n        logger.error(f\"Failed to start application: {e}\")\n        raise\n    finally:\n        logger.info(\"Application shutdown complete\")\n\napp = FastAPI(\n    title=\"UTCP-MCP Bridge\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\napp.mount(\"/web\", StaticFiles(directory=\"web\"), name=\"web\")\n\n@app.get(\"/\")\nasync def root():\n    return FileResponse(\"web/index.html\")\n\n@app.get(\"/health\")\nasync def health():\n    \"\"\"Health check endpoint\"\"\"\n    if not utcp_proxy.client:\n        raise HTTPException(status_code=503, detail=\"UTCP client not initialized\")\n    \n    return JSONResponse({\n        \"status\": \"healthy\",\n        \"providers\": len(utcp_proxy.providers),\n        \"tools\": len(utcp_proxy.tools),\n        \"provider_names\": [p.name for p in utcp_proxy.providers],\n        \"tool_names\": [t.name for t in utcp_proxy.tools],\n    })\n\n@app.post(\"/validate-providers\")\nasync def validate_providers(providers_data: list = Body(...)):\n    \"\"\"Validate provider data without saving\"\"\"\n    if not isinstance(providers_data, list):\n        raise HTTPException(status_code=400, detail=\"Payload must be a JSON array\")\n    \n    validated = []\n    errors = []\n    \n    for i, provider in enumerate(providers_data):\n        try:\n            provider_type = provider.get('provider_type')\n            if not provider_type:\n                errors.append(f\"Provider {i}: missing 'provider_type'\")\n                continue\n                \n            provider_class = provider_classes.get(provider_type)\n            if not provider_class:\n                errors.append(f\"Provider {i}: unsupported provider_type '{provider_type}'\")\n                continue\n                \n            provider_obj = provider_class.model_validate(provider)\n            validated.append({\n                \"index\": i,\n                \"name\": provider_obj.name,\n                \"type\": provider_type,\n                \"valid\": True\n            })\n        except Exception as e:\n            errors.append(f\"Provider {i} ('{provider.get('name', 'unknown')}'): {str(e)}\")\n    \n    return JSONResponse({\n        \"valid\": len(errors) == 0,\n        \"validated\": validated,\n        \"errors\": errors\n    })\n\n@app.get(\"/tools\")\nasync def list_tools():\n    \"\"\"List available tools\"\"\"\n    if not utcp_proxy.client:\n        raise HTTPException(status_code=503, detail=\"UTCP client not initialized\")\n\n    def get(obj, attr, default=None):\n        if isinstance(obj, dict):\n            return obj.get(attr, default)\n        return getattr(obj, attr, default)\n\n    return JSONResponse({\n        \"tools\": [\n            {\n                \"name\": get(tool, 'name', ''),\n                \"description\": get(tool, 'description', ''),\n                \"inputs\": get(get(tool, 'inputs', {}), 'properties', {})\n            }\n            for tool in utcp_proxy.tools\n        ]\n    })\n\n@app.get(\"/providers\")\nasync def list_providers():\n    \"\"\"List available providers\"\"\"\n    try:\n        # Return the raw providers.json data for the web UI\n        providers = read_providers_file()\n        return JSONResponse({\"providers\": providers})\n    except Exception as e:\n        logger.error(f\"Error reading providers file: {e}\")\n        return JSONResponse({\"providers\": []})\n\n@app.post(\"/providers\")\nasync def add_provider(provider: dict = Body(...)):\n    \"\"\"Add a new provider and register it with UTCP clients, and register its tools as MCP tools.\"\"\"\n    providers = read_providers_file()\n    # Prevent duplicate names\n    if any(p.get('name') == provider.get('name') for p in providers):\n        raise HTTPException(status_code=400, detail=\"Provider with this name already exists\")\n    # Use correct provider class\n    provider_type = provider.get('provider_type')\n    provider_class = provider_classes.get(provider_type)\n    if not provider_class:\n        raise HTTPException(status_code=400, detail=f\"Unsupported provider_type: {provider_type}\")\n    \n    try:\n        provider_obj = provider_class.model_validate(provider)\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=f\"Invalid provider data: {str(e)}\")\n    \n    # Register with both proxy and client\n    if utcp_proxy.client:\n        await utcp_proxy.add_provider(provider_obj)\n    if utcp_client.client:\n        await utcp_client.add_provider(provider_obj)\n    providers.append(provider)\n    write_providers_file(providers)\n    return {\"status\": \"ok\", \"providers\": providers}\n\n@app.delete(\"/providers/{provider_name}\")\nasync def remove_provider(provider_name: str):\n    \"\"\"Remove a provider by name and deregister it from UTCP clients, and remove its tools from MCP.\"\"\"\n    providers = read_providers_file()\n    new_providers = [p for p in providers if p.get('name') != provider_name]\n    if len(new_providers) == len(providers):\n        raise HTTPException(status_code=404, detail=\"Provider not found\")\n    # Deregister from both proxy and client\n    if utcp_proxy.client:\n        await utcp_proxy.remove_provider(provider_name)\n    if utcp_client.client:\n        await utcp_client.remove_provider(provider_name)\n  \n    write_providers_file(new_providers)\n    return {\"status\": \"ok\", \"providers\": new_providers}\n\n@app.put(\"/providers\")\nasync def replace_providers(new_providers: list = Body(...)):\n    \"\"\"Replace the entire providers.json file and reload all providers/tools.\"\"\"\n    if not isinstance(new_providers, list):\n        raise HTTPException(status_code=400, detail=\"Payload must be a JSON array\")\n    \n    # Check if providers have actually changed\n    current_providers = read_providers_file()\n    if current_providers == new_providers:\n        logger.info(\"Providers unchanged, skipping reload\")\n        return {\"status\": \"ok\", \"providers\": new_providers, \"changed\": False}\n    \n    # Validate all providers first before making any changes\n    validated_providers = []\n    for provider in new_providers:\n        provider_type = provider.get('provider_type')\n        provider_class = provider_classes.get(provider_type)\n        if not provider_class:\n            raise HTTPException(status_code=400, detail=f\"Unsupported provider_type: {provider_type}\")\n        try:\n            provider_obj = provider_class.model_validate(provider)\n            validated_providers.append(provider_obj)\n        except Exception as e:\n            raise HTTPException(status_code=400, detail=f\"Invalid provider data for '{provider.get('name', 'unknown')}': {str(e)}\")\n    \n    logger.info(\"Providers changed, reloading...\")\n    \n    # Remove all current providers\n    if utcp_proxy.client:\n        for provider in list(await utcp_proxy.client.tool_repository.get_providers()):\n            await utcp_proxy.remove_provider(getattr(provider, 'name', None))\n    if utcp_client.client:\n        for provider in list(await utcp_client.client.tool_repository.get_providers()):\n            await utcp_client.remove_provider(getattr(provider, 'name', None))\n    \n    # Add all new providers\n    for provider_obj in validated_providers:\n        if utcp_proxy.client:\n            await utcp_proxy.add_provider(provider_obj)\n        if utcp_client.client:\n            await utcp_client.add_provider(provider_obj)\n    \n    write_providers_file(new_providers)\n    return {\"status\": \"ok\", \"providers\": new_providers, \"changed\": True}\n",
      "line_count": 275,
      "word_count": 818,
      "title": "Server.Py",
      "summary": "import json import asyncio",
      "key_terms": [
        "open",
        "reading",
        "we",
        "grpc",
        "makedirs",
        "async",
        "error",
        "GRPCProvider",
        "saving",
        "check",
        "list",
        "info",
        "index",
        "started",
        "websocket",
        "available",
        "unknown",
        "Unsupported",
        "FileResponse",
        "Utcp"
      ],
      "timestamp": "2025-12-24T18:56:23.746963"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\web_ui_utcp_mcp_bridge\\src\\utcp_client_mcp.py",
      "content_type": "code",
      "content": "import os\nimport asyncio\nfrom config import Config\nfrom logger import logger\nfrom fastmcp import FastMCP\nfrom utcp.client.utcp_client import UtcpClient\nfrom utcp.client.utcp_client_config import UtcpClientConfig\nfrom utcp.client.tool_repositories.in_mem_tool_repository import InMemToolRepository\nfrom utcp.client.tool_search_strategies.tag_search import TagSearchStrategy\nfrom utcp.shared.provider import Provider\nfrom typing import Dict, Any, List, Optional\n\n\nclass UTCPClient:\n    def __init__(self):\n        self.client: Optional[UtcpClient] = None\n        self.mcp = FastMCP(\"utcp-client-mcp\")\n\n    async def initialize(self) -> None:\n        logger.info(\"UTCP-CLIENT-MCP: initializing...\")\n        config = UtcpClientConfig(providers_file_path=Config.PROVIDERS_PATH)\n        self.client = await UtcpClient.create(\n            config=config,\n            tool_repository=InMemToolRepository(),\n            search_strategy=TagSearchStrategy(InMemToolRepository())\n        )\n        await self._register_mcp_tools()\n        logger.info(\"UTCP-CLIENT-MCP: server initialized.\")\n\n    async def _register_mcp_tools(self):\n        @self.mcp.tool(name=\"register_tool_provider\", description=\"Register a tool provider. Args: provider_dict (dict)\")\n        async def register_tool_provider(provider_dict: Dict[str, Any]) -> List[Dict[str, Any]]:\n            provider = Provider.model_validate(provider_dict)\n            tools = await self.client.register_tool_provider(provider)\n            return [tool.model_dump() for tool in tools]\n\n        @self.mcp.tool(name=\"deregister_tool_provider\", description=\"Deregister a tool provider. Args: provider_name (str)\")\n        async def deregister_tool_provider(provider_name: str) -> str:\n            await self.client.deregister_tool_provider(provider_name)\n            return f\"Provider '{provider_name}' deregistered.\"\n\n        @self.mcp.tool(name=\"call_tool\", description=\"Call a tool. Args: tool_name (str), arguments (dict)\")\n        async def call_tool(tool_name: str, arguments: Dict[str, Any]) -> Any:\n            return await self.client.call_tool(tool_name, arguments)\n\n        @self.mcp.tool(name=\"search_tools\", description=\"Search for tools. Args: query (str), limit (int, optional)\")\n        async def search_tools(query: str, limit: int = 10) -> List[Dict[str, Any]]:\n            tools = self.client.search_tools(query, limit)\n            return [tool.model_dump() for tool in tools]\n\n    async def add_provider(self, provider_obj) -> None:\n        logger.info(f\"UTCP-CLIENT-MCP: registering provider {provider_obj.name}\")\n        await self.client.register_tool_provider(provider_obj)\n\n    async def remove_provider(self, provider_name: str) -> None:\n        logger.info(f\"UTCP-CLIENT-MCP: deregistering provider {provider_name}\")\n        await self.client.deregister_tool_provider(provider_name)\n\n    async def cleanup(self) -> None:\n        \"\"\"Clean up resources\"\"\"\n        if self.client:\n            logger.info(\"UTCP-CLIENT-MCP: cleaning...\")\n            # Add any cleanup logic here if needed\n            self.client = None\n\n    async def run(self):\n        await self.mcp.run_async(\n            transport=\"http\",\n            host=Config.HOST,\n            port=Config.MCP_CLIENT_PORT,\n            path=Config.MCP_CLIENT_PATH\n        )\n",
      "line_count": 73,
      "word_count": 240,
      "title": "Utcp Client Mcp.Py",
      "summary": "import asyncio from config import Config",
      "key_terms": [
        "up",
        "async",
        "info",
        "cleanup",
        "CLIENT",
        "Utcp",
        "utcp-client",
        "logger",
        "shared",
        "HOST",
        "path",
        "if",
        "typing",
        "Config",
        "description",
        "await",
        "os",
        "cleaning",
        "any",
        "Add"
      ],
      "timestamp": "2025-12-24T18:56:23.774297"
    },
    {
      "file_path": "UPSTREAM\\utcp-mcp\\web_ui_utcp_mcp_bridge\\src\\utcp_proxy_mcp.py",
      "content_type": "code",
      "content": "import asyncio\nimport keyword\nfrom contextlib import asynccontextmanager\nfrom typing import Dict, List, Optional, Any\nfrom fastmcp import FastMCP\nfrom fastapi import FastAPI, HTTPException\nfrom starlette.responses import JSONResponse\nimport uvicorn\nfrom config import Config\nfrom logger import logger\nfrom utcp.client.utcp_client import UtcpClient\nfrom utcp.client.utcp_client_config import UtcpClientConfig\nfrom utcp.client.tool_repositories.in_mem_tool_repository import InMemToolRepository\nfrom utcp.client.tool_search_strategies.tag_search import TagSearchStrategy\nfrom utcp.shared.provider import Provider\n\n\nclass UTCPProxy:\n    def __init__(self):\n        self.client: Optional[UtcpClient] = None\n        self.tools: List[Any] = []\n        self.providers: List[Any] = []\n        self.mcp = FastMCP(\"utcp-proxy-mcp\")\n        \n    async def initialize(self) -> None:\n        \"\"\"Initialize UTCP client and register tools\"\"\"\n        try:\n            logger.info(\"UTCP-PROXY-MCP: initializing...\")\n            config = UtcpClientConfig(providers_file_path=Config.PROVIDERS_PATH)\n            self.client = await UtcpClient.create(\n                config=config,\n                tool_repository=InMemToolRepository(),\n                search_strategy=TagSearchStrategy(InMemToolRepository())\n            )\n            \n            self.tools = await self.client.tool_repository.get_tools()\n            self.providers = await self.client.tool_repository.get_providers()\n\n            for tool in self.tools:\n                proxy_func = self._create_tool_proxy(tool)\n                self.mcp.tool(name=tool.name, description=tool.description or \"UTCP tool\")(proxy_func)\n\n            logger.info(f\"UTCP-PROXY-MCP: registered {len(self.providers)} providers with {len(self.tools)} tools\")\n                            \n        except Exception as e:\n            logger.error(f\"UTCP-PROXY-MCP: failed to initialize - {e}\")\n            raise\n    \n    def _create_tool_proxy(self, tool):\n        \"\"\"Create a proxy function for a UTCP tool\"\"\"\n        # Helper to get attribute or dict value\n        def get(obj, attr, default=None):\n            if isinstance(obj, dict):\n                return obj.get(attr, default)\n            return getattr(obj, attr, default)\n\n        # Get the input schema (object or dict)\n        inputs = get(tool, 'inputs', {})\n        properties = get(inputs, 'properties', {})\n        required = set(get(inputs, 'required', []) or [])\n        param_map = {}\n        required_params = []\n        optional_params = []\n\n        for orig_name in properties.keys():\n            py_name = orig_name[:-2] if orig_name.endswith('[]') else orig_name\n            # If py_name is a Python keyword, append an underscore\n            if keyword.iskeyword(py_name):\n                py_name_safe = py_name + '_'\n            else:\n                py_name_safe = py_name\n            param_map[py_name_safe] = orig_name\n            if py_name in required or orig_name in required:\n                required_params.append(py_name_safe)\n            else:\n                optional_params.append(f\"{py_name_safe}=None\")\n\n        params_str = \", \".join(required_params + optional_params)\n\n        # Build function code\n        func_code = f\"async def proxy({params_str}):\\n\"\n        func_code += \"    args = {}\\n\"\n        for py_name_safe, orig_name in param_map.items():\n            func_code += f\"    if {py_name_safe} is not None:\\n\"\n            func_code += f\"        args['{orig_name}'] = {py_name_safe}\\n\"\n        func_code += f\"    return await client.call_tool('{get(tool, 'name')}', args)\\n\"\n\n        # Create function\n        namespace = { \"client\": self.client }\n        exec(func_code, globals(), namespace)\n        proxy_func = namespace[\"proxy\"]\n        proxy_func.__name__ = get(tool, 'name', 'utcp_tool').replace('.', '_')\n        proxy_func.__doc__ = get(tool, 'description', 'UTCP tool proxy')\n\n        return proxy_func\n    \n    async def add_provider(self, provider_obj) -> None:\n        logger.info(f\"UTCP-PROXY-MCP: registering provider {provider_obj.name}\")\n        \n        # Get the old tool list to compare\n        old_tools = {getattr(tool, 'name', 'unknown') for tool in self.tools}\n        logger.info(f\"UTCP-PROXY-MCP: old tools count: {len(old_tools)}\")\n        \n        # Register with UTCP\n        await self.client.register_tool_provider(provider_obj)\n        \n        # Refresh tool and provider lists\n        self.tools = await self.client.tool_repository.get_tools()\n        self.providers = await self.client.tool_repository.get_providers()\n        \n        # Get new tools and only register the ones that are actually new\n        new_tools = {getattr(tool, 'name', 'unknown') for tool in self.tools}\n        tools_to_add = new_tools - old_tools\n        logger.info(f\"UTCP-PROXY-MCP: new tools count: {len(new_tools)}, tools to add: {len(tools_to_add)}\")\n        \n        # Register only the new tools\n        new_tool_count = 0\n        for tool in self.tools:\n            tool_name = getattr(tool, 'name', 'unknown')\n            if tool_name in tools_to_add:\n                try:\n                    proxy_func = self._create_tool_proxy(tool)\n                    self.mcp.tool(name=tool_name, description=getattr(tool, 'description', None))(proxy_func)\n                    new_tool_count += 1\n                    logger.info(f\"UTCP-PROXY-MCP: registered new MCP tool {tool_name}\")\n                except Exception as e:\n                    logger.error(f\"UTCP-PROXY-MCP: failed to register tool {tool_name}: {e}\")\n        \n        logger.info(f\"UTCP-PROXY-MCP: provider {provider_obj.name} registered with {new_tool_count} tools\")\n\n    async def remove_provider(self, provider_name: str) -> None:\n        logger.info(f\"UTCP-PROXY-MCP: deregistering provider {provider_name}\")\n        \n        # First, identify tools for this provider\n        prefix = provider_name + \".\"\n        tools_to_remove = []\n        \n        for tool in self.tools:\n            tool_name = getattr(tool, 'name', None)\n            if tool_name and tool_name.startswith(prefix):\n                tools_to_remove.append(tool_name)\n        \n        # Remove tools from FastMCP\n        for tool_name in tools_to_remove:\n            try:\n                self.mcp.remove_tool(tool_name)\n                logger.info(f\"UTCP-PROXY-MCP: removed MCP tool {tool_name}\")\n            except Exception as e:\n                logger.warning(f\"UTCP-PROXY-MCP: failed to remove MCP tool {tool_name}: {e}\")\n        \n        # Deregister from UTCP\n        await self.client.deregister_tool_provider(provider_name)\n        \n        # Refresh proxy's tool and provider lists\n        self.tools = await self.client.tool_repository.get_tools()\n        self.providers = await self.client.tool_repository.get_providers()\n        \n        logger.info(f\"UTCP-PROXY-MCP: provider {provider_name} deregistered, removed {len(tools_to_remove)} tools\")\n\n    async def cleanup(self) -> None:\n        \"\"\"Clean up resources\"\"\"\n        if self.client:\n            logger.info(\"UTCP-PROXY-MCP: cleaning...\")\n            # Add any cleanup logic here if needed\n            self.client = None\n\n    async def run(self):\n        await self.mcp.run_async(\n            transport=\"http\", \n            host=Config.HOST, \n            port=Config.MCP_PROXY_PORT, \n            path=Config.MCP_PROXY_PATH\n        )\n",
      "line_count": 174,
      "word_count": 605,
      "title": "Utcp Proxy Mcp.Py",
      "summary": "import asyncio import keyword",
      "key_terms": [
        "up",
        "Python",
        "async",
        "error",
        "If",
        "utcp-proxy",
        "list",
        "info",
        "endswith",
        "cleanup",
        "Utcp",
        "unknown",
        "only",
        "providers",
        "isinstance",
        "logger",
        "except",
        "shared",
        "keyword",
        "PROXY"
      ],
      "timestamp": "2025-12-24T18:56:23.822213"
    }
  ],
  "timestamp": "2025-12-24T18:56:23.822213"
}