{
  "repository": "go-utcp-mcp-bridge",
  "commit_hash": "5ed2236fe494ec1f71c3d31fbbc94e3886d86140",
  "commit_timestamp": "1763895105",
  "file_count": 2,
  "extractions": [
    {
      "file_path": "UPSTREAM\\go-utcp-mcp-bridge\\main.go",
      "content_type": "code",
      "content": "package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\tmark3lab \"github.com/mark3labs/mcp-go/mcp\"\n\n\t\"github.com/mark3labs/mcp-go/server\"\n\t\"github.com/universal-tool-calling-protocol/go-utcp\"\n\t\"github.com/universal-tool-calling-protocol/go-utcp/src/plugins/chain\"\n\t\"github.com/universal-tool-calling-protocol/go-utcp/src/plugins/codemode\"\n\t\"github.com/universal-tool-calling-protocol/go-utcp/src/providers/base\"\n\t\"github.com/universal-tool-calling-protocol/go-utcp/src/providers/cli\"\n\t\"github.com/universal-tool-calling-protocol/go-utcp/src/providers/graphql\"\n\t\"github.com/universal-tool-calling-protocol/go-utcp/src/providers/grpc\"\n\t\"github.com/universal-tool-calling-protocol/go-utcp/src/providers/http\"\n\t\"github.com/universal-tool-calling-protocol/go-utcp/src/providers/mcp\"\n\t\"github.com/universal-tool-calling-protocol/go-utcp/src/providers/sse\"\n\t\"github.com/universal-tool-calling-protocol/go-utcp/src/providers/streamable\"\n\t\"github.com/universal-tool-calling-protocol/go-utcp/src/providers/tcp\"\n\t\"github.com/universal-tool-calling-protocol/go-utcp/src/providers/text\"\n\t\"github.com/universal-tool-calling-protocol/go-utcp/src/providers/udp\"\n\t\"github.com/universal-tool-calling-protocol/go-utcp/src/providers/webrtc\"\n\t\"github.com/universal-tool-calling-protocol/go-utcp/src/providers/websocket\"\n)\n\n// UnmarshalProvider converts JSON into the appropriate providers.Provider implementation.\nfunc UnmarshalProvider(data []byte) (base.Provider, error) {\n\tvar peek struct {\n\t\tProviderType string `json:\"provider_type\"`\n\t}\n\tif err := json.Unmarshal(data, &peek); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to unmarshal provider_type: %w\", err)\n\t}\n\n\tswitch peek.ProviderType {\n\tcase \"cli\":\n\t\tvar p cli.CliProvider\n\t\tif err := json.Unmarshal(data, &p); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal CLIProvider: %w\", err)\n\t\t}\n\t\treturn &p, nil\n\tcase \"graphql\":\n\t\tvar p graphql.GraphQLProvider\n\t\tif err := json.Unmarshal(data, &p); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal GraphQLProvider: %w\", err)\n\t\t}\n\t\treturn &p, nil\n\tcase \"grpc\":\n\t\tvar p grpc.GRPCProvider\n\t\tif err := json.Unmarshal(data, &p); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal GRPCProvider: %w\", err)\n\t\t}\n\t\treturn &p, nil\n\tcase \"http\":\n\t\tvar p http.HttpProvider\n\t\tif err := json.Unmarshal(data, &p); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal HttpProvider: %w\", err)\n\t\t}\n\t\treturn &p, nil\n\tcase \"mcp\":\n\t\tvar p mcp.MCPProvider\n\t\tif err := json.Unmarshal(data, &p); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal MCPProvider: %w\", err)\n\t\t}\n\t\treturn &p, nil\n\tcase \"sse\":\n\t\tvar p sse.SSEProvider\n\t\tif err := json.Unmarshal(data, &p); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal SSEProvider: %w\", err)\n\t\t}\n\t\treturn &p, nil\n\tcase \"streamable\":\n\t\tvar p streamable.StreamableHttpProvider\n\t\tif err := json.Unmarshal(data, &p); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal StreamableHttpProvider: %w\", err)\n\t\t}\n\t\treturn &p, nil\n\tcase \"tcp\":\n\t\tvar p tcp.TCPProvider\n\t\tif err := json.Unmarshal(data, &p); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal TCPProvider: %w\", err)\n\t\t}\n\t\treturn &p, nil\n\tcase \"text\":\n\t\tvar p text.TextProvider\n\t\tif err := json.Unmarshal(data, &p); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal TextProvider: %w\", err)\n\t\t}\n\t\treturn &p, nil\n\tcase \"udp\":\n\t\tvar p udp.UDPProvider\n\t\tif err := json.Unmarshal(data, &p); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal UDPProvider: %w\", err)\n\t\t}\n\t\treturn &p, nil\n\tcase \"webrtc\":\n\t\tvar p webrtc.WebRTCProvider\n\t\tif err := json.Unmarshal(data, &p); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal WebRTCProvider: %w\", err)\n\t\t}\n\t\treturn &p, nil\n\tcase \"websocket\":\n\t\tvar p websocket.WebSocketProvider\n\t\tif err := json.Unmarshal(data, &p); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal WebSocketProvider: %w\", err)\n\t\t}\n\t\treturn &p, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported provider_type: %s\", peek.ProviderType)\n\t}\n}\n\n// UTCPMCPBridge connects a UTCP client to an MCP server\ntype UTCPMCPBridge struct {\n\tutcpClient utcp.UtcpClientInterface\n\tutcpChain  chain.UtcpChainClient\n\tutcpCode   codemode.CodeModeUTCP\n\n\tmcpServer *server.MCPServer\n}\n\nfunc NewUTCPMCPBridge(utcpClient utcp.UtcpClientInterface) (*UTCPMCPBridge, error) {\n\tbridge := &UTCPMCPBridge{\n\t\tutcpClient: utcpClient,\n\t\tutcpChain: chain.UtcpChainClient{\n\t\t\tClient: utcpClient,\n\t\t},\n\t\tutcpCode: *codemode.NewCodeModeUTCP(utcpClient, nil),\n\t}\n\n\t// Create MCP server\n\tmcpServer := server.NewMCPServer(\"utcp-bridge\", \"1.0.0\", server.WithToolCapabilities(true))\n\tbridge.mcpServer = mcpServer\n\n\t// Register tools\n\tif err := bridge.registerToolHandlers(); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to register tool handlers: %w\", err)\n\t}\n\n\treturn bridge, nil\n}\n\nfunc (b *UTCPMCPBridge) registerToolHandlers() error {\n\t// CallTool\n\tb.mcpServer.AddTool(mark3lab.Tool{\n\t\tName:        \"utcp_call_tool\",\n\t\tDescription: \"Call a UTCP tool by name with arguments\",\n\t\tInputSchema: mark3lab.ToolInputSchema{\n\t\t\tType: \"object\",\n\t\t\tProperties: map[string]interface{}{\n\t\t\t\t\"tool_name\": map[string]interface{}{\"type\": \"string\"},\n\t\t\t\t\"arguments\": map[string]interface{}{\"type\": \"object\"},\n\t\t\t},\n\t\t\tRequired: []string{\"tool_name\"},\n\t\t},\n\t}, b.handleCallTool)\n\n\t// SearchTools\n\tb.mcpServer.AddTool(mark3lab.Tool{\n\t\tName:        \"utcp_search_tools\",\n\t\tDescription: \"Search for available UTCP tools\",\n\t\tInputSchema: mark3lab.ToolInputSchema{\n\t\t\tType: \"object\",\n\t\t\tProperties: map[string]interface{}{\n\t\t\t\t\"query\": map[string]interface{}{\"type\": \"string\"},\n\t\t\t\t\"limit\": map[string]interface{}{\"type\": \"integer\", \"default\": 10},\n\t\t\t},\n\t\t\tRequired: []string{\"query\"},\n\t\t},\n\t}, b.handleSearchTools)\n\n\t// CallToolStream\n\tb.mcpServer.AddTool(mark3lab.Tool{\n\t\tName:        \"utcp_call_tool_stream\",\n\t\tDescription: \"Call a UTCP tool with streaming response\",\n\t\tInputSchema: mark3lab.ToolInputSchema{\n\t\t\tType: \"object\",\n\t\t\tProperties: map[string]interface{}{\n\t\t\t\t\"tool_name\": map[string]interface{}{\"type\": \"string\"},\n\t\t\t\t\"arguments\": map[string]interface{}{\"type\": \"object\"},\n\t\t\t},\n\t\t\tRequired: []string{\"tool_name\"},\n\t\t},\n\t}, b.handleCallToolStream)\n\n\t// RegisterToolProvider\n\tb.mcpServer.AddTool(mark3lab.Tool{\n\t\tName:        \"utcp_register_provider\",\n\t\tDescription: \"Register a new UTCP tool provider\",\n\t\tInputSchema: mark3lab.ToolInputSchema{\n\t\t\tType: \"object\",\n\t\t\tProperties: map[string]interface{}{\n\t\t\t\t\"provider_config\": map[string]interface{}{\"type\": \"object\"},\n\t\t\t},\n\t\t\tRequired: []string{\"provider_config\"},\n\t\t},\n\t}, b.handleRegisterProvider)\n\tregisterUTCPRunChain(b)\n\tregisterUTCPCodeMode(b)\n\n\treturn nil\n}\n\nfunc registerUTCPCodeMode(b *UTCPMCPBridge) {\n\t// RunCodeMode\n\tb.mcpServer.AddTool(mark3lab.Tool{\n\t\tName:        \"utcp_run_code\",\n\t\tDescription: \"Execute inline Go code via UTCP CodeMode engine\",\n\t\tInputSchema: mark3lab.ToolInputSchema{\n\t\t\tType: \"object\",\n\t\t\tProperties: map[string]interface{}{\n\t\t\t\t\"code\": map[string]interface{}{\"type\": \"string\"},\n\t\t\t\t\"timeout\": map[string]interface{}{\n\t\t\t\t\t\"type\":    \"integer\",\n\t\t\t\t\t\"default\": 3000,\n\t\t\t\t},\n\t\t\t},\n\t\t\tRequired: []string{\"code\"},\n\t\t},\n\t}, b.handleCodeMode)\n}\n\nfunc registerUTCPRunChain(b *UTCPMCPBridge) {\n\tb.mcpServer.AddTool(mark3lab.Tool{\n\t\tName:        \"utcp_run_chain\",\n\t\tDescription: \"Run a UTCP tool chain using UtcpChainClient\",\n\t\tInputSchema: mark3lab.ToolInputSchema{\n\t\t\tType: \"object\",\n\t\t\tProperties: map[string]interface{}{\n\t\t\t\t\"steps\": map[string]interface{}{\n\t\t\t\t\t\"type\":  \"array\",\n\t\t\t\t\t\"items\": map[string]interface{}{\"type\": \"object\"},\n\t\t\t\t},\n\t\t\t\t\"timeout\": map[string]interface{}{\n\t\t\t\t\t\"type\":    \"integer\",\n\t\t\t\t\t\"default\": 30000,\n\t\t\t\t},\n\t\t\t},\n\t\t\tRequired: []string{\"steps\"},\n\t\t},\n\t}, b.handleRunChain)\n}\n\nfunc (b *UTCPMCPBridge) handleRunChain(\n\tctx context.Context,\n\trequest mark3lab.CallToolRequest,\n) (*mark3lab.CallToolResult, error) {\n\n\t// ----- Extract arguments -----\n\targs, ok := request.Params.Arguments.(map[string]any)\n\tif !ok {\n\t\treturn mark3lab.NewToolResultError(\"invalid arguments\"), nil\n\t}\n\n\trawSteps, ok := args[\"steps\"].([]any)\n\tif !ok {\n\t\treturn mark3lab.NewToolResultError(\"steps must be an array\"), nil\n\t}\n\n\t// ----- Handle timeout -----\n\ttimeout := 30 * time.Second\n\tif t, exists := args[\"timeout\"]; exists {\n\t\tif tf, ok := t.(float64); ok {\n\t\t\ttimeout = time.Duration(int(tf)) * time.Millisecond\n\t\t}\n\t}\n\n\t// ----- Map raw MCP steps -> UTCP ChainStep -----\n\tsteps := make([]chain.ChainStep, 0, len(rawSteps))\n\n\tfor _, raw := range rawSteps {\n\t\tm, _ := raw.(map[string]any)\n\n\t\tstep := chain.ChainStep{\n\t\t\tID:          castString(m[\"id\"]),\n\t\t\tToolName:    castString(m[\"tool_name\"]),\n\t\t\tInputs:      castMap(m[\"inputs\"]),\n\t\t\tUsePrevious: castBool(m[\"use_previous\"]),\n\t\t\tStream:      castBool(m[\"stream\"]),\n\t\t}\n\n\t\t// Basic validation\n\t\tif step.ToolName == \"\" {\n\t\t\treturn mark3lab.NewToolResultError(\"each step requires tool_name\"), nil\n\t\t}\n\n\t\tsteps = append(steps, step)\n\t}\n\n\t// ----- Execute Chain -----\n\tresult, err := b.utcpChain.CallToolChain(ctx, steps, timeout)\n\tif err != nil {\n\t\treturn mark3lab.NewToolResultError(fmt.Sprintf(\"chain failed: %v\", err)), nil\n\t}\n\n\t// ----- Return JSON result -----\n\tresJSON, _ := json.Marshal(result)\n\treturn mark3lab.NewToolResultText(string(resJSON)), nil\n}\nfunc (b *UTCPMCPBridge) handleCallTool(ctx context.Context, request mark3lab.CallToolRequest) (*mark3lab.CallToolResult, error) {\n\n\targsRaw, ok := request.Params.Arguments.(map[string]any)\n\tif !ok {\n\t\treturn mark3lab.NewToolResultError(\"invalid arguments\"), nil\n\t}\n\n\tcode, _ := argsRaw[\"code\"].(string)\n\n\ttimeout := 3000\n\tif t, ok := argsRaw[\"timeout\"].(float64); ok {\n\t\ttimeout = int(t)\n\t}\n\n\tcmArgs := codemode.CodeModeArgs{\n\t\tCode:    code,\n\t\tTimeout: timeout,\n\t}\n\n\tresult, err := b.utcpCode.Execute(ctx, cmArgs)\n\tif err != nil {\n\t\treturn mark3lab.NewToolResultError(fmt.Sprintf(\"codemode error: %v\", err)), nil\n\t}\n\n\tresJSON, _ := json.Marshal(result)\n\treturn mark3lab.NewToolResultText(string(resJSON)), nil\n}\n\n// Handlers using server.CallToolRequest / server.CallToolResult\nfunc (b *UTCPMCPBridge) handleCodeMode(ctx context.Context, request mark3lab.CallToolRequest) (*mark3lab.CallToolResult, error) {\n\targs, ok := request.Params.Arguments.(map[string]any)\n\tif !ok {\n\t\treturn mark3lab.NewToolResultError(\"invalid arguments\"), nil\n\t}\n\n\ttoolName, ok := args[\"tool_name\"].(string)\n\tif !ok {\n\t\treturn mark3lab.NewToolResultError(\"tool_name must be string\"), nil\n\t}\n\n\tvar toolArgs map[string]any\n\tif a, exists := args[\"arguments\"]; exists {\n\t\ttoolArgs, _ = a.(map[string]any)\n\t} else {\n\t\ttoolArgs = map[string]any{}\n\t}\n\n\tresult, err := b.utcpClient.CallTool(ctx, toolName, toolArgs)\n\tif err != nil {\n\t\treturn mark3lab.NewToolResultError(fmt.Sprintf(\"failed to call tool: %v\", err)), nil\n\t}\n\n\tresJSON, _ := json.Marshal(result)\n\treturn mark3lab.NewToolResultText(string(resJSON)), nil\n}\n\nfunc (b *UTCPMCPBridge) handleSearchTools(ctx context.Context, request mark3lab.CallToolRequest) (*mark3lab.CallToolResult, error) {\n\targs, ok := request.Params.Arguments.(map[string]any)\n\tif !ok {\n\t\treturn mark3lab.NewToolResultError(\"invalid arguments\"), nil\n\t}\n\tquery, _ := args[\"query\"].(string)\n\tlimit := 10\n\tif l, exists := args[\"limit\"]; exists {\n\t\tif lf, ok := l.(float64); ok {\n\t\t\tlimit = int(lf)\n\t\t}\n\t}\n\n\ttools, err := b.utcpClient.SearchTools(query, limit)\n\tif err != nil {\n\t\treturn mark3lab.NewToolResultError(fmt.Sprintf(\"failed to search tools: %v\", err)), nil\n\t}\n\n\tresJSON, _ := json.Marshal(tools)\n\treturn mark3lab.NewToolResultText(string(resJSON)), nil\n}\n\nfunc (b *UTCPMCPBridge) handleCallToolStream(ctx context.Context, request mark3lab.CallToolRequest) (*mark3lab.CallToolResult, error) {\n\targs, ok := request.Params.Arguments.(map[string]any)\n\tif !ok {\n\t\treturn mark3lab.NewToolResultError(\"invalid arguments\"), nil\n\t}\n\n\ttoolName, _ := args[\"tool_name\"].(string)\n\tvar toolArgs map[string]any\n\tif a, exists := args[\"arguments\"]; exists {\n\t\ttoolArgs, _ = a.(map[string]any)\n\t} else {\n\t\ttoolArgs = map[string]any{}\n\t}\n\n\tstream, err := b.utcpClient.CallToolStream(ctx, toolName, toolArgs)\n\tif err != nil {\n\t\treturn mark3lab.NewToolResultError(fmt.Sprintf(\"stream failed: %v\", err)), nil\n\t}\n\n\tvar chunks []string\n\tfor {\n\t\tchunk, err := stream.Next()\n\t\tif err != nil {\n\t\t\treturn mark3lab.NewToolResultError(fmt.Sprintf(\"stream error: %v\", err)), nil\n\t\t}\n\t\tif chunk == nil {\n\t\t\tbreak\n\t\t}\n\t\tcJSON, _ := json.Marshal(chunk)\n\t\tchunks = append(chunks, string(cJSON))\n\t}\n\n\tresJSON, _ := json.Marshal(map[string]any{\"chunks\": chunks})\n\treturn mark3lab.NewToolResultText(string(resJSON)), nil\n}\n\nfunc (b *UTCPMCPBridge) handleRegisterProvider(ctx context.Context, request mark3lab.CallToolRequest) (*mark3lab.CallToolResult, error) {\n\targs, ok := request.Params.Arguments.(map[string]any)\n\tif !ok {\n\t\treturn mark3lab.NewToolResultError(\"invalid arguments\"), nil\n\t}\n\n\tconfig, ok := args[\"provider_config\"].(map[string]any)\n\tif !ok {\n\t\treturn mark3lab.NewToolResultError(\"provider_config must be object\"), nil\n\t}\n\n\tcfgJSON, _ := json.Marshal(config)\n\tprovider, err := UnmarshalProvider(cfgJSON)\n\tif err != nil {\n\t\treturn mark3lab.NewToolResultError(fmt.Sprintf(\"failed to unmarshal provider: %v\", err)), nil\n\t}\n\n\ttools, err := b.utcpClient.RegisterToolProvider(ctx, provider)\n\tif err != nil {\n\t\treturn mark3lab.NewToolResultError(fmt.Sprintf(\"failed to register provider: %v\", err)), nil\n\t}\n\n\tresJSON, _ := json.Marshal(map[string]any{\n\t\t\"registered_tools\": tools,\n\t\t\"count\":            len(tools),\n\t})\n\treturn mark3lab.NewToolResultText(string(resJSON)), nil\n}\n\nfunc (b *UTCPMCPBridge) Start() error {\n\treturn server.ServeStdio(b.mcpServer)\n}\n\nfunc main() {\n\tctx := context.Background()\n\n\tconfig := utcp.NewClientConfig()\n\tif p := os.Getenv(\"UTCP_PROVIDERS_FILE\"); p != \"\" {\n\t\tconfig.ProvidersFilePath = p\n\t}\n\n\tutcpClient, err := utcp.NewUTCPClient(ctx, config, nil, nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create UTCP client: %v\", err)\n\t}\n\tbridge, err := NewUTCPMCPBridge(utcpClient)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create MCP bridge: %v\", err)\n\t}\n\n\tlog.Println(\"Starting UTCP MCP Bridge...\")\n\tif err := bridge.Start(); err != nil {\n\t\tlog.Fatalf(\"Failed to start MCP bridge: %v\", err)\n\t}\n}\n\nfunc castString(v any) string {\n\tif v == nil {\n\t\treturn \"\"\n\t}\n\ts, _ := v.(string)\n\treturn s\n}\n\nfunc castBool(v any) bool {\n\tb, _ := v.(bool)\n\treturn b\n}\n\nfunc castMap(v any) map[string]any {\n\tif v == nil {\n\t\treturn map[string]any{}\n\t}\n\tm, _ := v.(map[string]any)\n\tif m == nil {\n\t\treturn map[string]any{}\n\t}\n\treturn m\n}\n",
      "line_count": 499,
      "word_count": 1451,
      "title": "Main.Go",
      "summary": "package main \"encoding/json\"",
      "key_terms": [
        "Timeout",
        "CLIProvider",
        "grpc",
        "search",
        "each",
        "error",
        "GRPCProvider",
        "Type",
        "Code",
        "id",
        "fmt",
        "Duration",
        "Utcp",
        "websocket",
        "available",
        "providers",
        "codemode",
        "Marshal",
        "must",
        "string"
      ],
      "timestamp": "2025-12-24T18:56:07.717440"
    },
    {
      "file_path": "UPSTREAM\\go-utcp-mcp-bridge\\README.md",
      "content_type": "documentation",
      "content": "![MCP vs. UTCP](https://github.com/universal-tool-calling-protocol/.github/raw/main/assets/banner.png)\n\nThis **utcp bridge** enables seamless integration between UTCP tools and any MCP-based ecosystem, providing standard tool invocation, search, streaming, and provider registration functionalities.\nA lightweight Go-based bridge that exposes **UTCP tools**, **UTCP chains**, and **UTCP CodeMode** execution as **MCP tools** ‚Äî enabling any MCP-compatible client (Claude Desktop, Claude CLI, LLM runtimes implementing MCP) to call UTCP tools seamlessly.\n\nThis bridge lets you:\n\n- üîå Load UTCP providers dynamically from JSON  \n- üõ† Call UTCP tools via MCP  \n- üîç Search the UTCP tool registry  \n- üîÑ Stream UTCP tool results over MCP  \n- ‚õìÔ∏è Execute multi-step **UTCP Chains** via a single MCP call  \n- üß© Run **Go CodeMode** snippets through UTCP (inline Go execution)  \n- ü§ù Register new providers dynamically at runtime  \n\nDesigned with flexibility in mind, the bridge can power anything from local tool-automation setups to distributed LLM agent workflows.\n\n---\n\n## Features\n\n### ‚úì UTCP ‚Üí MCP Tool Mapping\n\n| MCP Tool Name             | Description |\n|---------------------------|-------------|\n| `utcp_call_tool`          | Call any UTCP tool with arguments |\n| `utcp_search_tools`       | Fuzzy-search tools in UTCP registry |\n| `utcp_call_tool_stream`   | Stream responses from UTCP tools |\n| `utcp_register_provider`  | Register new UTCP provider at runtime |\n| `utcp_run_chain`          | Execute UTCP tool chain (ChainStep[]) |\n| `utcp_run_code`           | Execute Go CodeMode                   |\n\n---\n\n\n## Installation\n\n```bash\ngit clone https://github.com/your-org/utcp-mcp-bridge.git\ncd utcp-mcp-bridge\ngo mod tidy\ngo build -o utcp-mcp-bridge main.go\nsudo mv utcp-mcp-bridge /usr/local/bin/\n```\n",
      "line_count": 45,
      "word_count": 238,
      "title": "Readme.Md",
      "summary": "![MCP vs. UTCP](https://github.com/universal-tool-calling-protocol/.github/raw/main/assets/banner.png) This **utcp bridge** enables seamless integration between UTCP tools and any MCP-based ecosystem,...",
      "key_terms": [
        "mind",
        "integration",
        "build",
        "search",
        "based",
        "through",
        "Designed",
        "compatible",
        "MCP-based",
        "providers",
        "distributed",
        "Fuzzy-search",
        "dynamically",
        "seamless",
        "Execute",
        "https",
        "automation",
        "Chains",
        "Features",
        "that"
      ],
      "timestamp": "2025-12-24T18:56:07.746090"
    }
  ],
  "timestamp": "2025-12-24T18:56:07.746090"
}