{
  "repository": "langchain-utcp-adapters",
  "commit_hash": "00f0ebbb8f31eb439b5905e8e70f4f8a1a806e32",
  "commit_timestamp": "1759912520",
  "file_count": 21,
  "extractions": [
    {
      "file_path": "UPSTREAM\\langchain-utcp-adapters\\CHANGELOG.md",
      "content_type": "documentation",
      "content": "# Changelog\n\nAll notable changes to LangChain UTCP Adapters will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).\n\n## [0.1.0] - 2025-01-26\n\n### Added\n- Initial release of LangChain UTCP Adapters\n- `MultiProviderUTCPClient` for managing multiple UTCP providers\n- Automatic tool conversion from UTCP to LangChain format\n- Support for HTTP (OpenAPI) and Text (UTCP Manual) provider types\n- Tool search and discovery functionality\n- Provider health monitoring\n- Comprehensive test suite with real provider integration\n- Examples for basic usage, LangGraph, and Amazon Bedrock\n- Full async/await support with proper resource management\n\n### Features\n- Multi-provider support with dynamic configuration\n- Dynamic Pydantic schema generation from JSON schemas\n- Semantic search across tools by name, description, and tags\n- Real-time provider health checking\n- Robust error handling with graceful fallbacks\n- Complete type hints and Pydantic v2 compatibility\n\n### Tested Providers\n- OpenLibrary API (11 tools for books, authors, search)\n- NewsAPI (2 tools for news articles)\n\n### Dependencies\n- LangChain Core 0.3.36+\n- UTCP 0.1.8+\n- Python 3.10+\n",
      "line_count": 36,
      "word_count": 175,
      "title": "Changelog",
      "summary": "All notable changes to LangChain UTCP Adapters will be documented in this file. The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).",
      "key_terms": [
        "integration",
        "Python",
        "search",
        "async",
        "error",
        "based",
        "Comprehensive",
        "format",
        "providers",
        "usage",
        "multiple",
        "time",
        "https",
        "Features",
        "basic",
        "books",
        "Complete",
        "Changelog",
        "description",
        "function"
      ],
      "timestamp": "2025-12-24T18:56:07.877315"
    },
    {
      "file_path": "UPSTREAM\\langchain-utcp-adapters\\CONTRIBUTING.md",
      "content_type": "documentation",
      "content": "# Contributing to LangChain UTCP Adapters\n\nThank you for your interest in contributing! This guide will help you get started.\n\n## Development Setup\n\n### Using PDM (Recommended)\n\n```bash\ngit clone <repository-url>\ncd langchain-utcp-adapters\npdm install -G all\n```\n\n### Using pip\n\n```bash\ngit clone <repository-url>\ncd langchain-utcp-adapters\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\npip install -e \".[all]\"\n```\n\n### Dependency Groups\n\n- `test` - Core testing dependencies (pytest, etc.)\n- `dev` - Development tools (ruff, mypy, build tools)\n- `examples` - Dependencies for LangGraph and OpenAI examples\n- `server` - FastAPI and uvicorn for server-based examples\n- `bedrock` - Amazon Bedrock integration dependencies\n- `all` - Everything for complete development setup\n\n## Making Changes\n\n1. **Create a feature branch**: `git checkout -b feature/your-feature`\n2. **Make your changes** with tests and documentation\n3. **Run tests**: `pdm run pytest` or `pytest tests/`\n4. **Format code**: `black . && isort .`\n5. **Type check**: `mypy langchain_utcp_adapters/`\n6. **Commit**: Use conventional commits (e.g., `feat: add new provider type`)\n7. **Submit PR** with clear description\n\n## Code Style\n\n- Follow PEP 8 with Black formatting (88 char line length)\n- Use type hints for all functions\n- Write docstrings for public APIs\n- Include tests for new features\n- Update documentation as needed\n\n## Testing\n\n- Write async tests for async functionality\n- Test both success and error cases\n- Use meaningful test names and assertions\n- Maintain or improve test coverage\n\n### Running Tests\n\n```bash\n# Run all tests\npdm run pytest\n\n# Run with coverage\npdm run pytest --cov=langchain_utcp_adapters\n\n# Run specific test file\npdm run pytest tests/test_tools.py\n```\n\n## Pull Request Guidelines\n\n- Use descriptive titles and descriptions\n- Reference related issues\n- Include tests and documentation updates\n- Ensure all checks pass\n\n## Questions?\n\nOpen an issue for questions or discussion before starting major changes.\n",
      "line_count": 82,
      "word_count": 308,
      "title": "Contributing to LangChain UTCP Adapters",
      "summary": "Thank you for your interest in contributing! This guide will help you get started. git clone <repository-url>",
      "key_terms": [
        "integration",
        "build",
        "Maintain",
        "clear",
        "async",
        "commits",
        "etc",
        "error",
        "conventional",
        "mypy",
        "Type",
        "Setup",
        "based",
        "check",
        "coverage",
        "Code",
        "cases",
        "major",
        "started",
        "Recommended"
      ],
      "timestamp": "2025-12-24T18:56:07.900053"
    },
    {
      "file_path": "UPSTREAM\\langchain-utcp-adapters\\pyproject.toml",
      "content_type": "other",
      "content": "[build-system]\nrequires = [\"pdm-backend\"]\nbuild-backend = \"pdm.backend\"\n\n[project]\nname = \"langchain-utcp-adapters\"\nversion = \"0.1.0\"\ndescription = \"Make Universal Tool Calling Protocol (UTCP) tools compatible with LangChain and LangGraph agents.\"\nauthors = [\n    { name = \"UTCP Adapters Team\" },\n]\nlicense = \"MIT\"\nrepository = \"https://www.github.com/universal-tool-calling-protocol/langchain-utcp-adapters\"\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\ndependencies = [\n    \"langchain-core>=0.3.36,<0.4\",\n    \"utcp>=1.0.0\",\n    \"typing-extensions>=4.14.0\",\n    \"pydantic>=2.0\",\n    \"aiohttp>=3.8\",\n]\n\n[project.urls]\nHomepage = \"https://github.com/universal-tool-calling-protocol/langchain-utcp-adapters\"\nDocumentation = \"https://github.com/universal-tool-calling-protocol/langchain-utcp-adapters#readme\"\nRepository = \"https://github.com/universal-tool-calling-protocol/langchain-utcp-adapters\"\nIssues = \"https://github.com/universal-tool-calling-protocol/langchain-utcp-adapters/issues\"\n\n[dependency-groups]\n# Core testing dependencies\ntest = [\n    \"pytest>=8.0.0\",\n    \"pytest-asyncio>=0.26.0\",\n    \"pytest-socket>=0.7.0\",\n    \"pytest-timeout>=2.4.0\",\n    \"utcp-http>=1.0.0\",\n]\n\n# Development tools and linting\ndev = [\n    \"ruff>=0.9.4\",\n    \"mypy>=1.8.0\",\n    \"types-setuptools>=69.0.0\",\n    \"build\",\n    \"twine\",\n    \"pre-commit\",\n]\n\n# Basic examples (LangGraph + OpenAI)\nexamples = [\n    \"langgraph>=0.2.0\",\n    \"langchain-openai>=0.2.0\",\n    \"python-dotenv>=1.0.0\",\n    \"utcp-http>=1.0.0\",\n]\n\n# Server-based examples\nserver = [\n    \"fastapi>=0.100.0\",\n    \"uvicorn>=0.20.0\",\n]\n\n# Amazon Bedrock integration\nbedrock = [\n    \"langchain-aws>=0.1.0\",\n    \"boto3>=1.26.0\",\n]\n\n# Everything for complete development setup\nall = [\n    \"pytest>=8.0.0\",\n    \"pytest-asyncio>=0.26.0\",\n    \"pytest-socket>=0.7.0\",\n    \"pytest-timeout>=2.4.0\",\n    \"ruff>=0.9.4\",\n    \"mypy>=1.8.0\",\n    \"types-setuptools>=69.0.0\",\n    \"build\",\n    \"twine\",\n    \"pre-commit\",\n    \"langgraph>=0.2.0\",\n    \"langchain-openai>=0.2.0\",\n    \"python-dotenv>=1.0.0\",\n    \"fastapi>=0.100.0\",\n    \"uvicorn>=0.20.0\",\n    \"langchain-aws>=0.1.0\",\n    \"boto3>=1.26.0\",\n]\n\n[tool.pytest.ini_options]\nminversion = \"8.0\"\naddopts = \"-ra -q -v --durations=5\"\ntestpaths = [\"tests\"]\npython_files = [\"test_*.py\"]\npython_functions = [\"test_*\"]\nasyncio_mode = \"auto\"\nasyncio_default_fixture_loop_scope = \"function\"\n\n[tool.ruff]\nline-length = 88 \ntarget-version = \"py310\"\n\n[tool.ruff.lint]\nselect = [ \"ALL\",]\nignore = [\n  \"COM812\", # conflict with formatter\n]\n\n[tool.ruff.lint.pydocstyle]\nconvention = \"google\"\n\n[tool.mypy]\npython_version = \"3.11\"\nwarn_return_any = true\nwarn_unused_configs = true\ndisallow_untyped_defs = true\ncheck_untyped_defs = true\n\n[tool.ruff.lint.extend-per-file-ignores]\n\"tests/**/*.py\" = [\n    \"S101\", # asserts allowed in tests\n    \"ARG\", # Unused function args -> fixtures nevertheless are functionally relevant\n    \"FBT\", # Don't care about booleans as positional arguments in tests\n    \"D104\",\n    \"PLR2004\", # Magic value used in comparison\n    \"S311\", # Standard pseudo-random generators are not suitable for cryptographic purposes\n    \"D100\", # Missing docstring in public module\n    \"D101\", # Missing docstring in public class\n    \"D102\", # Missing docstring in public method\n    \"D103\", # Missing docstring in public function\n    \"D104\", # Missing docstring in public package\n    \"D105\", # Missing docstring in magic method\n    \"D415\", # First line should end with a period, question mark, or exclamation point\n    \"EM101\", # Exception must not use a string literal, assign to variable first\n    \"EM102\", # Exception must not use an f-string literal, assign to variable first\n    \"TRY003\", # Avoid specifying long messages outside the exception class\n    \"TRY004\", # Prefer `TypeError` exception for invalid type\n    \"RET504\", # Unnecessary assignment before return statement\n    \"SIM117\", # Use a single `with` statement instead of nested `with` statements\n    \"TC002\", # Move third-party imports into a type-checking block\n    \"TC003\", # Move standard library imports into a type-checking block\n    \"ANN001\", # Missing type annotation for function argument\n    \"ANN201\", # Missing return type annotation for public function\n    \"ANN202\", # Missing return type annotation for private function\n    \"ANN401\", # Dynamically typed expressions (typing.Any) are disallowed\n    \"PT006\", # Wrong type passed to first argument of `pytest.mark.parametrize`\n    \"PT011\", # pytest.raises is too broad, set the `match` parameter\n    \"PTH118\", # `os.path.join()` should be replaced by `Path` with `/` operator\n    \"S110\", # try-except-pass detected, consider logging the exception\n    \"BLE001\", # Do not catch blind exception: `Exception`\n    \"SLF001\", # Private member accessed\n    \"PERF203\", # `try-except` within a loop incurs performance overhead\n    \"C901\", # Function is too complex\n]\n\n\"examples/**/*.py\" = [\n    \"D100\", # Missing docstring in public module\n    \"D103\", # Missing docstring in public function\n    \"T201\", # print statements allowed in examples\n    \"S101\", # asserts allowed in examples\n]\n",
      "line_count": 163,
      "word_count": 551,
      "title": "Pyproject.Toml",
      "summary": "[build-system] requires = [\"pdm-backend\"]",
      "key_terms": [
        "integration",
        "build",
        "project",
        "setuptools",
        "mypy",
        "md",
        "based",
        "twine",
        "select",
        "compatible",
        "fixtures",
        "extensions",
        "dependencies",
        "nested",
        "private",
        "must",
        "Do",
        "pytest-socket",
        "assignment",
        "specifying"
      ],
      "timestamp": "2025-12-24T18:56:07.920583"
    },
    {
      "file_path": "UPSTREAM\\langchain-utcp-adapters\\README.md",
      "content_type": "documentation",
      "content": "# LangChain UTCP Adapters\n\n[![PyPI version](https://badge.fury.io/py/langchain-utcp-adapters.svg)](https://badge.fury.io/py/langchain-utcp-adapters)\n[![Python Support](https://img.shields.io/pypi/pyversions/langchain-utcp-adapters.svg)](https://pypi.org/project/langchain-utcp-adapters/)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\nA Python package that bridges Universal Tool Calling Protocol (UTCP) with LangChain, enabling seamless integration of external tools and APIs into LangChain applications.\n\n## Features\n\n- **Direct UTCP Integration**: Work directly with UTCP clients for maximum flexibility\n- **Automatic Tool Conversion**: Convert UTCP tools to LangChain-compatible tools with proper schemas\n- **Tool Discovery**: Search and filter tools by name, description, and tags\n- **Dynamic Call Template Registration**: Register call templates programmatically at runtime\n- **Async Support**: Full async/await implementation for optimal performance\n- **Type Safety**: Complete type hints and Pydantic v2 compatibility\n- **UTCP 1.0.1+ Compatible**: Works with the latest UTCP plugin architecture\n\n## Installation\n\n### Basic Installation\n\n```bash\npip install langchain-utcp-adapters\n```\n\n### Required UTCP Plugins\n\nThe adapters require UTCP core and relevant protocol plugins:\n\n```bash\n# Core UTCP library (automatically installed)\npip install utcp>=1.0.0\n\n# Protocol plugins (install as needed)\npip install utcp-http>=1.0.0    # For HTTP/REST APIs\npip install utcp-text>=1.0.0    # For text-based manuals\npip install utcp-mcp>=1.0.0     # For MCP integration\n```\n\n### Optional Dependencies\n\n```bash\n# Using pip\npip install langchain-utcp-adapters[examples]  # LangGraph + OpenAI\npip install langchain-utcp-adapters[bedrock]   # Amazon Bedrock\npip install langchain-utcp-adapters[all]       # Everything\n\n# Using PDM\npdm install -G examples  # LangGraph + OpenAI examples\npdm install -G bedrock   # Amazon Bedrock integration\npdm install -G test      # Testing dependencies\npdm install -G dev       # Development tools\npdm install -G all       # Everything for development\n```\n\n## Quick Start\n\n### Basic Usage\n\n```python\nimport asyncio\nfrom utcp.utcp_client import UtcpClient\nfrom utcp.data.utcp_client_config import UtcpClientConfig\nfrom utcp_http.http_call_template import HttpCallTemplate\nfrom langchain_utcp_adapters import load_utcp_tools, search_utcp_tools\n\nasync def main():\n    # Create UTCP client with call templates\n    config = UtcpClientConfig(\n        manual_call_templates=[\n            HttpCallTemplate(\n                name=\"petstore\",\n                call_template_type=\"http\",\n                url=\"https://petstore.swagger.io/v2/swagger.json\",\n                http_method=\"GET\"\n            )\n        ]\n    )\n    client = await UtcpClient.create(config=config)\n    \n    # Load all tools and convert to LangChain format\n    tools = await load_utcp_tools(client)\n    print(f\"Loaded {len(tools)} tools\")\n    \n    # Search for specific tools\n    pet_tools = await search_utcp_tools(client, \"pet\", max_results=5)\n    print(f\"Found {len(pet_tools)} pet-related tools\")\n\nasyncio.run(main())\n```\n\n### Using Configuration Files\n\n```python\nimport asyncio\nfrom utcp.utcp_client import UtcpClient\nfrom langchain_utcp_adapters import load_utcp_tools\n\nasync def main():\n    # Create client with config.json configuration\n    client = await UtcpClient.create(config=\"config.json\")\n    \n    # Load tools from all configured call templates\n    tools = await load_utcp_tools(client)\n    \n    # Use tools with LangChain agents...\n\nasyncio.run(main())\n```\n\n**config.json:**\n```json\n{\n  \"manual_call_templates\": [\n    {\n      \"name\": \"petstore\",\n      \"call_template_type\": \"http\",\n      \"url\": \"https://petstore.swagger.io/v2/swagger.json\",\n      \"http_method\": \"GET\"\n    }\n  ]\n}\n```\n\n### LangGraph Integration\n\n```python\nimport asyncio\nfrom utcp.utcp_client import UtcpClient\nfrom utcp.data.utcp_client_config import UtcpClientConfig\nfrom utcp_http.http_call_template import HttpCallTemplate\nfrom langchain_utcp_adapters import load_utcp_tools\nfrom langgraph.prebuilt import create_react_agent\nfrom langchain_openai import ChatOpenAI\n\nasync def main():\n    # Set up UTCP client\n    config = UtcpClientConfig(\n        manual_call_templates=[\n            HttpCallTemplate(\n                name=\"petstore\",\n                call_template_type=\"http\",\n                url=\"https://petstore.swagger.io/v2/swagger.json\",\n                http_method=\"GET\"\n            )\n        ]\n    )\n    client = await UtcpClient.create(config=config)\n    \n    # Load tools\n    tools = await load_utcp_tools(client)\n    \n    # Create LangGraph agent\n    llm = ChatOpenAI(model=\"gpt-4o-mini\")\n    agent = create_react_agent(llm, tools)\n    \n    # Use the agent\n    response = await agent.ainvoke({\n        \"messages\": [(\"user\", \"Find information about pets in the store\")]\n    })\n    \n    print(response[\"messages\"][-1].content)\n\n# Make sure to set OPENAI_API_KEY environment variable\nasyncio.run(main())\n```\n\n### Amazon Bedrock Integration\n\n```python\nimport asyncio\nfrom utcp.utcp_client import UtcpClient\nfrom utcp.data.utcp_client_config import UtcpClientConfig\nfrom utcp_http.http_call_template import HttpCallTemplate\nfrom langchain_utcp_adapters import load_utcp_tools, create_bedrock_tool_mapping\nfrom langgraph.prebuilt import create_react_agent\nfrom langchain_aws import ChatBedrock\n\nasync def main():\n    # Set up UTCP client\n    config = UtcpClientConfig(\n        manual_call_templates=[\n            HttpCallTemplate(\n                name=\"openlibrary\",\n                call_template_type=\"http\",\n                http_method=\"GET\",\n                url=\"https://openlibrary.org/static/openapi.json\",\n                content_type=\"application/json\"\n            )\n        ]\n    )\n    client = await UtcpClient.create(config=config)\n    \n    # Load tools and create Bedrock-compatible versions\n    original_tools = await load_utcp_tools(client)\n    bedrock_tools, name_mapping = create_bedrock_tool_mapping(original_tools)\n    \n    # Create Bedrock LLM\n    llm = ChatBedrock(\n        model_id=\"anthropic.claude-3-haiku-20240307-v1:0\",\n        region_name=\"us-east-1\"\n    )\n    \n    # Create LangGraph agent\n    agent = create_react_agent(llm, bedrock_tools)\n    \n    # Use the agent\n    response = await agent.ainvoke({\n        \"messages\": [(\"user\", \"Search for books about Python programming\")]\n    })\n    \n    print(response[\"messages\"][-1].content)\n\n# Make sure AWS credentials are configured\nasyncio.run(main())\n```\n\n## Authentication\n\nUTCP supports various authentication methods:\n\n```python\nfrom utcp_http.http_call_template import HttpCallTemplate\nfrom utcp.data.auth_implementations.api_key_auth import ApiKeyAuth\nfrom utcp.data.auth_implementations.basic_auth import BasicAuth\nfrom utcp.data.auth_implementations.oauth2_auth import OAuth2Auth\n\n# API Key authentication\ncall_template = HttpCallTemplate(\n    name=\"authenticated_api\",\n    call_template_type=\"http\",\n    url=\"https://api.example.com/openapi.json\",\n    http_method=\"GET\",\n    auth=ApiKeyAuth(\n        api_key=\"${API_KEY}\",  # Use environment variable\n        var_name=\"X-API-Key\",\n        location=\"header\"\n    )\n)\n\n# OAuth2 authentication\ncall_template = HttpCallTemplate(\n    name=\"oauth_api\",\n    call_template_type=\"http\",\n    url=\"https://api.example.com/openapi.json\",\n    http_method=\"GET\",\n    auth=OAuth2Auth(\n        token_url=\"https://api.example.com/oauth/token\",\n        client_id=\"${CLIENT_ID}\",\n        client_secret=\"${CLIENT_SECRET}\",\n        scope=\"read write\"\n    )\n)\n```\n\n## Supported Call Template Types\n\nThe adapters work with all UTCP call template types:\n\n- **HTTP/HTTPS APIs** - Including automatic OpenAPI conversion\n- **Server-Sent Events (SSE)** - For streaming data\n- **Streamable HTTP** - For streaming HTTP responses\n- **Text-based Manuals** - Direct UTCP manual definitions\n- **Model Context Protocol (MCP)** - For interoperability\n\n## API Reference\n\n### Core Functions\n\n```python\nfrom langchain_utcp_adapters import (\n    load_utcp_tools,\n    search_utcp_tools,\n    convert_utcp_tool_to_langchain_tool,\n    # Bedrock-specific utilities\n    create_bedrock_tool_mapping,\n    format_tool_name_for_bedrock,\n    BedrockCompatibleTool,\n    restore_original_tool_names\n)\n```\n\n#### `load_utcp_tools(utcp_client, call_template_name=None)`\nLoad all tools from UTCP client and convert to LangChain format.\n\n**Parameters:**\n- `utcp_client`: UTCP client instance\n- `call_template_name`: Optional call template name to filter tools\n\n**Returns:** List of LangChain BaseTool instances\n\n#### `search_utcp_tools(utcp_client, query, call_template_name=None, max_results=None)`\nSearch for tools and convert to LangChain format.\n\n**Parameters:**\n- `utcp_client`: UTCP client instance  \n- `query`: Search query string\n- `call_template_name`: Optional call template name to filter\n- `max_results`: Maximum number of results\n\n**Returns:** List of relevant LangChain BaseTool instances\n\n#### `convert_utcp_tool_to_langchain_tool(utcp_client, tool)`\nConvert a single UTCP tool to LangChain format.\n\n**Parameters:**\n- `utcp_client`: UTCP client instance\n- `tool`: UTCP Tool instance\n\n**Returns:** LangChain BaseTool instance\n\n### Bedrock Utilities\n\n#### `create_bedrock_tool_mapping(tools)`\nCreate Bedrock-compatible tools with name mapping for tools that don't meet Bedrock's naming requirements.\n\n**Parameters:**\n- `tools`: List of LangChain BaseTool instances\n\n**Returns:** Tuple containing:\n- List of Bedrock-compatible tools\n- Dictionary mapping Bedrock names to original names\n\n## Examples\n\nThe `examples/` directory contains comprehensive examples:\n\n- `basic_usage.py` - ‚úÖ Basic tool loading and usage (31 tools from Petstore + OpenLibrary)\n- `providers.py` - ‚úÖ Real-world call template examples (11 OpenLibrary tools)\n- `direct_usage.py` - ‚úÖ Direct UTCP client usage\n- `authentication.py` - ‚úÖ Authentication methods demonstration\n- `openapi.py` - ‚úÖ OpenAPI specification integration\n- `openai_langgraph.py` - üîë LangGraph integration (requires OPENAI_API_KEY)\n- `openai_advanced.py` - üîë Advanced LangGraph integration (requires OPENAI_API_KEY)\n- `bedrock_langgraph.py` - üîê Simple Amazon Bedrock integration (requires AWS credentials)\n- `bedrock_advanced.py` - üîê Comprehensive Amazon Bedrock integration (requires AWS credentials)\n\n**Legend:**\n- ‚úÖ Works immediately without external dependencies\n- üîë Requires API keys (OpenAI)\n- üîê Requires AWS credentials and Bedrock access\n\n### Running Examples\n\n```bash\n# Basic examples (no external dependencies)\npython examples/basic_usage.py\npython examples/providers.py\npython examples/authentication.py\n\n# Examples requiring API keys\nexport OPENAI_API_KEY=your_key_here\npython examples/openai_langgraph.py\n\n# Bedrock examples (requires AWS credentials)\npython examples/bedrock_langgraph.py\n```\n\n## Development\n\n### Setup\n\n```bash\n# Clone the repository\ngit clone https://github.com/universal-tool-calling-protocol/langchain-utcp-adapters\ncd langchain-utcp-adapters\n\n# Using PDM (recommended)\npdm install -G all\n\n# Or using pip\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\npip install -e \".[all]\"\n```\n\n### Running Tests\n\n```bash\n# With PDM\npdm run pytest\n\n# With pip\npytest\n\n# Run with coverage\npytest tests/ --cov=langchain_utcp_adapters\n```\n\n### Code Quality\n\n```bash\n# Format code\nruff format langchain_utcp_adapters/ tests/ examples/\n\n# Lint code\nruff check langchain_utcp_adapters/ tests/ examples/\n\n# Type checking\nmypy langchain_utcp_adapters/\n```\n\n## Requirements\n\n- Python 3.10+\n- LangChain Core 0.3.36+\n- UTCP 1.0.0+\n- Pydantic 2.0+\n\n## Contributing\n\nContributions are welcome! Please see [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.\n\n## License\n\nThis project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.\n\n## Related Projects\n\n- [UTCP Python Client](https://github.com/universal-tool-calling-protocol/python-utcp) - The core UTCP implementation\n- [LangChain](https://github.com/langchain-ai/langchain) - Framework for developing applications with LLMs\n- [LangGraph](https://github.com/langchain-ai/langgraph) - Library for building stateful, multi-actor applications\n",
      "line_count": 424,
      "word_count": 1213,
      "title": "LangChain UTCP Adapters",
      "summary": "[![PyPI version](https://badge.fury.io/py/langchain-utcp-adapters.svg)](https://badge.fury.io/py/langchain-utcp-adapters) [![Python Support](https://img.shields.io/pypi/pyversions/langchain-utcp-adapt...",
      "key_terms": [
        "comprehensive",
        "Model",
        "img",
        "convert",
        "Type",
        "Code",
        "Setup",
        "Bedrock-specific",
        "Clone",
        "providers",
        "Found",
        "licensed",
        "model",
        "Async",
        "pets",
        "that",
        "Features",
        "Supported",
        "LangChain-compatible",
        "Real-world"
      ],
      "timestamp": "2025-12-24T18:56:07.984377"
    },
    {
      "file_path": "UPSTREAM\\langchain-utcp-adapters\\examples\\authentication.py",
      "content_type": "code",
      "content": "\"\"\"Authentication example for LangChain UTCP Adapters.\n\nThis example demonstrates how to configure different authentication methods\nfor UTCP providers when connecting to real APIs that require authentication.\n\nNote: This is a demonstration of authentication patterns. The examples use\nworking test endpoints where possible, but real API usage would require\nvalid credentials.\n\"\"\"\n\nimport asyncio\nfrom pathlib import Path\n\nfrom utcp.utcp_client import UtcpClient\nfrom utcp.data.utcp_client_config import UtcpClientConfig\nfrom utcp_http.http_call_template import HttpCallTemplate\nfrom utcp.data.auth_implementations.api_key_auth import ApiKeyAuth\nfrom utcp.data.auth_implementations.basic_auth import BasicAuth\nfrom utcp.data.auth_implementations.oauth2_auth import OAuth2Auth\nfrom langchain_utcp_adapters import load_utcp_tools\n\n\nasync def demonstrate_api_key_auth():\n    \"\"\"Demonstrate API key authentication with a working test endpoint.\"\"\"\n    print(\"üîë API Key Authentication Example\")\n    print(\"-\" * 40)\n    \n    config = UtcpClientConfig()\n    client = await UtcpClient.create(config=config)\n    \n    # Example 1: API key in header (most common)\n    api_key_provider = HttpProvider(\n        name=\"httpbin_headers\",\n        provider_type=\"http\",\n        url=\"http://httpbin.org/headers\",\n        http_method=\"GET\",\n        auth=ApiKeyAuth(\n            api_key=\"demo-api-key-12345\",\n            var_name=\"X-API-Key\",\n            location=\"header\"\n        )\n    )\n    \n    try:\n        await client.register_tool_provider(api_key_provider)\n        tools = await load_utcp_tools(client, provider_name=\"httpbin_headers\")\n        \n        if tools:\n            print(f\"‚úÖ Successfully registered provider with API key auth\")\n            print(f\"   Tool: {tools[0].name}\")\n            print(f\"   Auth: API key in header 'X-API-Key'\")\n        else:\n            print(\"‚ö†Ô∏è  Provider registered but no tools found\")\n            \n    except Exception as e:\n        print(f\"‚ùå API key auth failed: {e}\")\n    \n    print()\n\n\nasync def demonstrate_basic_auth():\n    \"\"\"Demonstrate basic authentication with HTTPBin test endpoint.\"\"\"\n    print(\"üîê Basic Authentication Example\")\n    print(\"-\" * 40)\n    \n    config = UtcpClientConfig()\n    client = await UtcpClient.create(config=config)\n    \n    # HTTPBin provides a working basic auth test endpoint\n    basic_auth_provider = HttpProvider(\n        name=\"httpbin_basic_auth\",\n        provider_type=\"http\",\n        url=\"http://httpbin.org/basic-auth/testuser/testpass\",\n        http_method=\"GET\",\n        auth=BasicAuth(\n            username=\"testuser\",\n            password=\"testpass\"\n        )\n    )\n    \n    try:\n        await client.register_tool_provider(basic_auth_provider)\n        tools = await load_utcp_tools(client, provider_name=\"httpbin_basic_auth\")\n        \n        if tools:\n            print(f\"‚úÖ Successfully registered provider with basic auth\")\n            print(f\"   Tool: {tools[0].name}\")\n            print(f\"   Auth: Basic authentication (username/password)\")\n        else:\n            print(\"‚ö†Ô∏è  Provider registered but no tools found\")\n            \n    except Exception as e:\n        print(f\"‚ùå Basic auth failed: {e}\")\n    \n    print()\n\n\nasync def demonstrate_oauth2_auth():\n    \"\"\"Demonstrate OAuth2 authentication configuration.\"\"\"\n    print(\"üåê OAuth2 Authentication Example\")\n    print(\"-\" * 40)\n    \n    config = UtcpClientConfig()\n    client = await UtcpClient.create(config=config)\n    \n    # OAuth2 example (this would require real OAuth2 endpoints)\n    oauth2_provider = HttpProvider(\n        name=\"oauth2_demo\",\n        provider_type=\"http\",\n        url=\"https://api.github.com\",  # GitHub API as example\n        http_method=\"GET\",\n        auth=OAuth2Auth(\n            token_url=\"https://github.com/login/oauth/access_token\",\n            client_id=\"your_github_client_id\",\n            client_secret=\"your_github_client_secret\",\n            scope=\"repo read:user\"\n        )\n    )\n    \n    try:\n        # This will fail without real credentials, but shows the pattern\n        await client.register_tool_provider(oauth2_provider)\n        tools = await load_utcp_tools(client, provider_name=\"oauth2_demo\")\n        \n        if tools:\n            print(f\"‚úÖ Successfully registered provider with OAuth2\")\n            print(f\"   Tools found: {len(tools)}\")\n        else:\n            print(\"‚ö†Ô∏è  Provider registered but no tools found\")\n            \n    except Exception as e:\n        print(f\"‚ùå OAuth2 auth failed (expected without real credentials): {e}\")\n        print(\"   This demonstrates the OAuth2 configuration pattern\")\n    \n    print()\n\n\nasync def demonstrate_environment_variables():\n    \"\"\"Show how to use environment variables for credentials.\"\"\"\n    print(\"üåç Environment Variables for Authentication\")\n    print(\"-\" * 40)\n    \n    # Create a temporary .env file for demonstration\n    env_file = Path(\".env.demo\")\n    env_content = \"\"\"# Demo environment variables for authentication\nAPI_KEY=demo-key-from-env\nOAUTH_CLIENT_ID=demo-client-id\nOAUTH_CLIENT_SECRET=demo-client-secret\nBASIC_USERNAME=demo-user\nBASIC_PASSWORD=demo-pass\n\"\"\"\n    \n    with open(env_file, \"w\") as f:\n        f.write(env_content)\n    \n    print(\"üìù Created demo .env file with example credentials\")\n    print(\"   In real usage, you would set these environment variables:\")\n    print(\"   export API_KEY=your_real_api_key\")\n    print(\"   export OAUTH_CLIENT_ID=your_real_client_id\")\n    print(\"   # etc.\")\n    print()\n    \n    # Show how to reference environment variables in auth config\n    print(\"üîß Authentication with environment variables:\")\n    print(\"   API Key: ${API_KEY}\")\n    print(\"   OAuth Client ID: ${OAUTH_CLIENT_ID}\")\n    print(\"   Basic Auth Username: ${BASIC_USERNAME}\")\n    print()\n    \n    # Example of using environment variables in provider config\n    config = UtcpClientConfig()\n    client = await UtcpClient.create(config=config)\n    \n    # This would use environment variables if they were set\n    env_provider = HttpProvider(\n        name=\"env_auth_demo\",\n        provider_type=\"http\",\n        url=\"http://httpbin.org/headers\",\n        http_method=\"GET\",\n        auth=ApiKeyAuth(\n            api_key=\"${API_KEY}\",  # Would be replaced with env var value\n            var_name=\"Authorization\",\n            location=\"header\"\n        )\n    )\n    \n    print(\"‚úÖ Provider configured to use ${API_KEY} environment variable\")\n    \n    # Clean up\n    if env_file.exists():\n        env_file.unlink()\n    \n    print()\n\n\nasync def main():\n    \"\"\"Main example function demonstrating different authentication methods.\"\"\"\n    print(\"üîê LangChain UTCP Adapters - Authentication Examples\")\n    print(\"=\" * 60)\n    print(\"This example shows how to configure authentication for UTCP providers.\")\n    print(\"These patterns work with real APIs that require authentication.\")\n    print()\n    \n    await demonstrate_api_key_auth()\n    await demonstrate_basic_auth()\n    await demonstrate_oauth2_auth()\n    await demonstrate_environment_variables()\n    \n    print(\"üìö Summary of Authentication Methods:\")\n    print(\"   ‚Ä¢ API Key: Most common, key in header or query parameter\")\n    print(\"   ‚Ä¢ Basic Auth: Username/password, base64 encoded\")\n    print(\"   ‚Ä¢ OAuth2: Token-based, requires client credentials\")\n    print(\"   ‚Ä¢ Environment Variables: Secure credential storage\")\n    print()\n    print(\"üí° Best Practices:\")\n    print(\"   ‚Ä¢ Never hardcode credentials in source code\")\n    print(\"   ‚Ä¢ Use environment variables for sensitive data\")\n    print(\"   ‚Ä¢ Rotate API keys regularly\")\n    print(\"   ‚Ä¢ Use least-privilege access scopes\")\n    print()\n    print(\"‚úÖ Authentication examples completed!\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n",
      "line_count": 226,
      "word_count": 677,
      "title": "Authentication.Py",
      "summary": "\"\"\"Authentication example for LangChain UTCP Adapters. This example demonstrates how to configure different authentication methods",
      "key_terms": [
        "open",
        "up",
        "async",
        "privilege",
        "etc",
        "headers",
        "Never",
        "pattern",
        "based",
        "id",
        "unlink",
        "encoded",
        "Utcp",
        "providers",
        "repo",
        "found",
        "usage",
        "except",
        "using",
        "most"
      ],
      "timestamp": "2025-12-24T18:56:08.032121"
    },
    {
      "file_path": "UPSTREAM\\langchain-utcp-adapters\\examples\\basic_usage.py",
      "content_type": "code",
      "content": "\"\"\"Basic usage example for LangChain UTCP Adapters.\n\nThis example demonstrates how to:\n1. Set up a UTCP client with call templates (UTCP 1.0.0+)\n2. Load tools from UTCP call templates\n3. Convert them to LangChain tools\n\"\"\"\n\nimport asyncio\nfrom utcp.utcp_client import UtcpClient\nfrom utcp.data.utcp_client_config import UtcpClientConfig\nfrom utcp_http.http_call_template import HttpCallTemplate\nfrom langchain_utcp_adapters import load_utcp_tools, search_utcp_tools\n\n\nasync def main():\n    \"\"\"Main example function.\"\"\"\n    print(\"üöÄ Basic LangChain UTCP Adapters Usage (UTCP 1.0.0+)\")\n    print(\"=\" * 50)\n    \n    # Create UTCP client with new 1.0.0+ configuration\n    print(\"üì° Creating UTCP client...\")\n    config = UtcpClientConfig(\n        manual_call_templates=[\n            HttpCallTemplate(\n                name=\"petstore\",\n                call_template_type=\"http\",\n                url=\"https://petstore.swagger.io/v2/swagger.json\",\n                http_method=\"GET\"\n            ),\n            HttpCallTemplate(\n                name=\"openlibrary\",\n                call_template_type=\"http\",\n                url=\"https://openlibrary.org/static/openapi.json\",\n                http_method=\"GET\",\n                content_type=\"application/json\"\n            )\n        ]\n    )\n    client = await UtcpClient.create(config=config)\n    \n    print(\"‚úÖ Successfully created UTCP client with call templates\")\n    \n    # Get all available tools and convert to LangChain format\n    print(\"\\nüîß Loading tools...\")\n    tools = await load_utcp_tools(client)\n    print(f\"Found {len(tools)} LangChain tools:\")\n    \n    for tool in tools[:5]:  # Show first 5 tools\n        print(f\"  - {tool.name}: {tool.description}\")\n        print(f\"    Call Template: {tool.metadata.get('call_template', 'unknown')}\")\n        print(f\"    Type: {tool.metadata.get('call_template_type', 'unknown')}\")\n        print(f\"    Tags: {tool.metadata.get('tags', [])}\")\n    \n    if len(tools) > 5:\n        print(f\"  ... and {len(tools) - 5} more tools\")\n    \n    # Search for tools\n    if tools:\n        print(\"\\nüîç Searching for tools with 'pet'...\")\n        search_results = await search_utcp_tools(client, \"pet\", max_results=3)\n        print(f\"Found {len(search_results)} matching tools:\")\n        for tool in search_results:\n            print(f\"  - {tool.name}: {tool.description}\")\n    \n    # Show tool schemas\n    if tools:\n        print(f\"\\nüîß Example tool schema for '{tools[0].name}':\")\n        print(f\"  Description: {tools[0].description}\")\n        print(f\"  Args schema: {tools[0].args_schema}\")\n        print(f\"  Metadata: {tools[0].metadata}\")\n        \n        # Show how the tool would be called\n        print(f\"\\nüí° Usage example:\")\n        print(f\"    # To call this tool:\")\n        print(f\"    # result = await {tools[0].name}(**arguments)\")\n        print(f\"    # where arguments match the schema above\")\n    \n    if not tools:\n        print(\"\\n‚ö†Ô∏è  No tools were loaded. This might be because:\")\n        print(\"   - The OpenAPI endpoints are not accessible\")\n        print(\"   - The endpoints don't provide valid OpenAPI specifications\")\n        print(\"   - Network connectivity issues\")\n    \n    print(\"\\n‚úÖ Example completed successfully!\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n",
      "line_count": 90,
      "word_count": 301,
      "title": "Basic Usage.Py",
      "summary": "\"\"\"Basic usage example for LangChain UTCP Adapters. This example demonstrates how to:",
      "key_terms": [
        "up",
        "async",
        "convert",
        "Type",
        "format",
        "Utcp",
        "available",
        "unknown",
        "Found",
        "usage",
        "application",
        "Tags",
        "https",
        "if",
        "To",
        "petstore",
        "Network",
        "Main",
        "how",
        "function"
      ],
      "timestamp": "2025-12-24T18:56:08.070356"
    },
    {
      "file_path": "UPSTREAM\\langchain-utcp-adapters\\examples\\bedrock_advanced.py",
      "content_type": "code",
      "content": "\"\"\"Amazon Bedrock integration example for LangChain UTCP Adapters.\n\nThis example demonstrates how to use UTCP tools with Amazon Bedrock models\nthrough LangGraph agents using the current UTCP client API.\n\"\"\"\n\nimport asyncio\nimport os\nfrom utcp.utcp_client import UtcpClient\nfrom utcp.data.utcp_client_config import UtcpClientConfig\nfrom utcp_http.http_call_template import HttpCallTemplate\nfrom langchain_utcp_adapters import load_utcp_tools, search_utcp_tools, create_bedrock_tool_mapping\n\n# Optional: Only import if available\ntry:\n    from langgraph.prebuilt import create_react_agent\n    from langchain_aws import ChatBedrock\n    import boto3\n    BEDROCK_AVAILABLE = True\nexcept ImportError:\n    BEDROCK_AVAILABLE = False\n    print(\"Bedrock dependencies not available. Install with: pip install langchain-aws boto3\")\n\n\ndef check_aws_credentials():\n    \"\"\"Check if AWS credentials are configured.\"\"\"\n    try:\n        # Try to create a session to check credentials\n        session = boto3.Session()\n        credentials = session.get_credentials()\n        if credentials is None:\n            return False, \"No AWS credentials found\"\n        \n        # Check if we can access Bedrock\n        bedrock_client = session.client('bedrock', region_name='us-east-1')\n        try:\n            # Try to list foundation models to verify access\n            bedrock_client.list_foundation_models()\n            return True, \"AWS credentials and Bedrock access verified\"\n        except Exception as e:\n            return False, f\"Bedrock access error: {str(e)}\"\n            \n    except Exception as e:\n        return False, f\"AWS credential error: {str(e)}\"\n\n\n# Removed server creation code - this is CLIENT-SIDE only\n# LangChain UTCP Adapters should consume existing APIs, not create servers\n\n\nasync def main():\n    \"\"\"Main example function.\"\"\"\n    print(\"ü§ñ Amazon Bedrock + UTCP Integration Example\")\n    print(\"=\" * 50)\n    \n    if not BEDROCK_AVAILABLE:\n        print(\"‚ùå Required dependencies not available.\")\n        print(\"Install with: pip install langchain-aws boto3\")\n        return\n    \n    # Check AWS credentials and Bedrock access\n    print(\"üîç Checking AWS credentials and Bedrock access...\")\n    creds_ok, creds_msg = check_aws_credentials()\n    print(f\"AWS Status: {creds_msg}\")\n    \n    if not creds_ok:\n        print(\"\\nüí° To use this example, you need:\")\n        print(\"1. AWS credentials configured (via AWS CLI, environment variables, or IAM role)\")\n        print(\"2. Bedrock service access in your AWS account\")\n        print(\"3. Permissions to invoke Bedrock models\")\n        print(\"\\nüõ†Ô∏è  Setup instructions:\")\n        print(\"- Run 'aws configure' to set up credentials\")\n        print(\"- Ensure your AWS account has Bedrock access\")\n        print(\"- Request access to foundation models in Bedrock console\")\n        return\n    \n    # Create UTCP client directly\n    print(\"\\nüì° Creating UTCP client...\")\n    # Create UTCP client with call templates\n    print(\"üì° Creating UTCP client...\")\n    config = UtcpClientConfig(\n        manual_call_templates=[\n            HttpCallTemplate(\n                name=\"openlibrary\",\n                call_template_type=\"http\",\n                url=\"https://openlibrary.org/static/openapi.json\",\n                http_method=\"GET\",\n                content_type=\"application/json\"\n            )\n        ]\n    )\n    client = await UtcpClient.create(config=config)\n    \n    print(\"‚úÖ Successfully created UTCP client with call templates\")\n    \n    try:\n        # Load tools\n        print(\"\\nüîß Loading tools...\")\n        original_tools = await load_utcp_tools(client)\n        print(f\"Found {len(original_tools)} tools\")\n        \n        if not original_tools:\n            print(\"‚ùå No tools available for this example\")\n            return\n        \n        # Create Bedrock-compatible tools\n        print(\"üîß Creating Bedrock-compatible tool names...\")\n        bedrock_tools, name_mapping = create_bedrock_tool_mapping(original_tools)\n        \n        # Show name mappings for long tool names\n        long_names = [name for name in name_mapping.keys() if name != name_mapping[name]]\n        if long_names:\n            print(f\"üìù Mapped {len(long_names)} tool names for Bedrock compatibility:\")\n            for bedrock_name, original_name in name_mapping.items():\n                if bedrock_name != original_name:\n                    print(f\"  {original_name} -> {bedrock_name}\")\n        \n        # Create Bedrock LLM\n        print(\"\\nü§ñ Initializing Amazon Bedrock...\")\n        \n        # Use Claude 3 Haiku (fast and cost-effective)\n        model_id = \"anthropic.claude-3-haiku-20240307-v1:0\"\n        \n        try:\n            llm = ChatBedrock(\n                model_id=model_id,\n                region_name=\"us-east-1\",\n                model_kwargs={\n                    \"temperature\": 0.1,\n                    \"max_tokens\": 500,\n                }\n            )\n            print(f\"‚úÖ Bedrock model initialized: {model_id}\")\n        except Exception as e:\n            print(f\"‚ùå Bedrock initialization failed: {e}\")\n            if \"AccessDeniedException\" in str(e):\n                print(\"üí° Enable model access in Bedrock console:\")\n                print(\"   1. Go to AWS Bedrock console\")\n                print(\"   2. Navigate to 'Model access'\")\n                print(\"   3. Request access to Anthropic Claude models\")\n            return\n        \n        # Create agent with Bedrock-compatible tools\n        print(\"\\nüéØ Creating LangGraph agent...\")\n        agent = create_react_agent(llm, bedrock_tools)\n        \n        # Test queries\n        test_queries = [\n            \"What tools do you have available?\",\n            \"Can you search for Hamlet by William Shakespeare?\",\n            \"Help me understand what you can do with the available tools\"\n        ]\n        \n        for i, query in enumerate(test_queries, 1):\n            print(f\"\\n{'='*50}\")\n            print(f\"Test {i}: {query}\")\n            print('='*50)\n            \n            try:\n                response = await agent.ainvoke({\n                    \"messages\": [(\"user\", query)]\n                })\n                \n                # Get the final response\n                final_message = response[\"messages\"][-1]\n                print(f\"ü§ñ Bedrock Response:\")\n                print(final_message.content)\n                \n                # Show any tool usage\n                tool_messages = [\n                    msg for msg in response[\"messages\"] \n                    if hasattr(msg, 'tool_calls') and msg.tool_calls\n                ]\n                \n                if tool_messages:\n                    print(f\"\\nüîß Tools Used:\")\n                    for msg in tool_messages:\n                        for tool_call in msg.tool_calls:\n                            print(f\"  - {tool_call['name']}\")\n                            print(f\"    Args: {tool_call['args']}\")\n                \n            except Exception as e:\n                print(f\"‚ùå Error: {e}\")\n        \n        # Demonstrate tool search\n        print(f\"\\n{'='*50}\")\n        print(\"üîç Tool Search Demonstration\")\n        print('='*50)\n        \n        search_queries = [\"books\", \"http\", \"api\"]\n        for search_query in search_queries:\n            print(f\"\\nüîç Searching for: '{search_query}'\")\n            search_results = await search_utcp_tools(client, search_query, max_results=3)\n            \n            if search_results:\n                for tool in search_results:\n                    provider = tool.metadata.get('provider', 'unknown')\n                    original_name = tool.name\n                    # Find the corresponding Bedrock name\n                    bedrock_name = None\n                    for b_name, o_name in name_mapping.items():\n                        if o_name == original_name:\n                            bedrock_name = b_name\n                            break\n                    \n                    if bedrock_name and bedrock_name != original_name:\n                        print(f\"  ‚úÖ {original_name} -> {bedrock_name} ({provider})\")\n                    else:\n                        print(f\"  ‚úÖ {original_name} ({provider})\")\n            else:\n                print(\"  ‚ùå No matching tools found\")\n        \n    finally:\n        print(\"\\nüßπ Cleaning up...\")\n        # No providers file to clean up in direct approach\n        pass\n    \n    print(f\"\\n{'='*50}\")\n    print(\"‚úÖ Example completed successfully!\")\n    print('='*50)\n    print(\"What you just saw:\")\n    print(\"1. üîß UTCP tools loaded from real APIs\")\n    print(\"2. ü§ñ Amazon Bedrock Claude model integration\")\n    print(\"3. üéØ LangGraph agent with tool capabilities\")\n    print(\"4. üîç Tool search functionality\")\n    print()\n    print(\"üí° Next steps:\")\n    print(\"- Try different Bedrock models\")\n    print(\"- Add your own UTCP providers\")\n    print(\"- Integrate with your AWS infrastructure\")\n    print(\"- Monitor usage in CloudWatch\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n",
      "line_count": 236,
      "word_count": 807,
      "title": "Bedrock Advanced.Py",
      "summary": "\"\"\"Amazon Bedrock integration example for LangChain UTCP Adapters. This example demonstrates how to use UTCP tools with Amazon Bedrock models",
      "key_terms": [
        "integration",
        "Monitor",
        "we",
        "up",
        "role",
        "Session",
        "Model",
        "async",
        "search",
        "error",
        "Setup",
        "through",
        "check",
        "list",
        "compatible",
        "corresponding",
        "CLIENT",
        "Utcp",
        "available",
        "unknown"
      ],
      "timestamp": "2025-12-24T18:56:08.095835"
    },
    {
      "file_path": "UPSTREAM\\langchain-utcp-adapters\\examples\\bedrock_langgraph.py",
      "content_type": "code",
      "content": "\"\"\"Simple Amazon Bedrock integration example for LangChain UTCP Adapters.\n\nThis is a streamlined example showing the core integration between\nUTCP tools and Amazon Bedrock models, including proper tool name mapping\nfor Bedrock compatibility.\n\"\"\"\n\nimport asyncio\nimport os\nfrom utcp.client.utcp_client import UtcpClient\nfrom utcp.client.utcp_client_config import UtcpClientConfig\nfrom utcp.shared.provider import HttpProvider\nfrom langchain_utcp_adapters import load_utcp_tools, create_bedrock_tool_mapping\n\n# Optional: Only import if available\ntry:\n    from langgraph.prebuilt import create_react_agent\n    from langchain_aws import ChatBedrock\n    import boto3\n    BEDROCK_AVAILABLE = True\nexcept ImportError:\n    BEDROCK_AVAILABLE = False\n    print(\"Install Bedrock dependencies: pip install langchain-aws boto3\")\n\n\nasync def main():\n    \"\"\"Simple Bedrock integration example.\"\"\"\n    print(\"ü§ñ Simple Amazon Bedrock + UTCP Integration\")\n    print(\"=\" * 50)\n    \n    if not BEDROCK_AVAILABLE:\n        print(\"‚ùå Required dependencies not available.\")\n        print(\"Install with: pdm install -G bedrock\")\n        return\n    \n    # Check AWS credentials\n    try:\n        session = boto3.Session()\n        credentials = session.get_credentials()\n        if not credentials:\n            print(\"‚ùå No AWS credentials found\")\n            print(\"Run 'aws configure' or set environment variables:\")\n            print(\"  export AWS_ACCESS_KEY_ID=your_key\")\n            print(\"  export AWS_SECRET_ACCESS_KEY=your_secret\")\n            print(\"  export AWS_DEFAULT_REGION=us-east-1\")\n            return\n        print(\"‚úÖ AWS credentials found\")\n    except Exception as e:\n        print(f\"‚ùå AWS credential error: {e}\")\n        return\n    \n    # Create UTCP client\n    print(\"üì° Setting up UTCP client...\")\n    config = UtcpClientConfig()\n    client = await UtcpClient.create(config=config)\n    \n    # Register only OpenLibrary provider (like the working bedrock_integration.py)\n    print(\"üì° Registering OpenLibrary provider...\")\n    \n    try:\n        openlibrary_provider = HttpProvider(\n            name=\"openlibrary\",\n            provider_type=\"http\",\n            http_method=\"GET\",\n            url=\"https://openlibrary.org/static/openapi.json\",\n            content_type=\"application/json\"\n        )\n        await client.register_tool_provider(openlibrary_provider)\n        print(\"  ‚úÖ OpenLibrary API for book information\")\n    except Exception as e:\n        print(f\"  ‚ùå OpenLibrary registration failed: {e}\")\n        return\n    \n    # Load tools and convert to LangChain format\n    print(\"\\nüîß Loading UTCP tools...\")\n    original_tools = await load_utcp_tools(client)\n    print(f\"Loaded {len(original_tools)} original tools\")\n    \n    if not original_tools:\n        print(\"‚ùå No tools available. Cannot create agent.\")\n        return\n    \n    # Create Bedrock-compatible tools with name mapping\n    print(\"üîß Creating Bedrock-compatible tools...\")\n    bedrock_tools, name_mapping = create_bedrock_tool_mapping(original_tools)\n    print(f\"Created {len(bedrock_tools)} Bedrock-compatible tools\")\n    \n    # Show some examples of name mapping\n    print(\"üìù Tool name mapping examples:\")\n    mapped_count = 0\n    for bedrock_name, original_name in name_mapping.items():\n        if bedrock_name != original_name and mapped_count < 3:\n            print(f\"  {original_name} -> {bedrock_name}\")\n            mapped_count += 1\n    \n    total_mapped = sum(1 for b, o in name_mapping.items() if b != o)\n    if total_mapped > 3:\n        print(f\"  ... and {total_mapped - 3} more mappings\")\n    elif total_mapped == 0:\n        print(\"  (No name changes needed - all names are Bedrock-compatible)\")\n    \n    # Create Bedrock LLM\n    print(\"\\nü§ñ Creating Bedrock LLM...\")\n    try:\n        # Use Claude 3 Haiku (most cost-effective)\n        llm = ChatBedrock(\n            model_id=\"anthropic.claude-3-haiku-20240307-v1:0\",\n            region_name=os.getenv(\"AWS_DEFAULT_REGION\", \"us-east-1\"),\n            model_kwargs={\n                \"temperature\": 0.1,\n                \"max_tokens\": 1000,\n            }\n        )\n        print(\"‚úÖ Bedrock LLM initialized\")\n    except Exception as e:\n        print(f\"‚ùå Failed to initialize Bedrock LLM: {e}\")\n        print(\"Make sure you have access to Claude 3 Haiku in your AWS region\")\n        return\n    \n    # Create LangGraph agent with Bedrock-compatible tools\n    print(\"ü§ñ Creating LangGraph agent with Bedrock...\")\n    try:\n        agent = create_react_agent(llm, bedrock_tools)\n        print(\"‚úÖ Agent created successfully\")\n    except Exception as e:\n        print(f\"‚ùå Failed to create agent: {e}\")\n        return\n    \n    # Test the agent with a simple query\n    print(\"\\nüí¨ Testing agent with a Hamlet search query...\")\n    try:\n        response = await agent.ainvoke({\n            \"messages\": [(\"user\", \"Can you search for Hamlet by William Shakespeare?\")]\n        })\n        \n        print(\"üéâ Agent response:\")\n        print(response[\"messages\"][-1].content)\n        \n        # Check if tools were used and show original names\n        tool_calls = []\n        for message in response[\"messages\"]:\n            if hasattr(message, 'tool_calls') and message.tool_calls:\n                tool_calls.extend(message.tool_calls)\n        \n        if tool_calls:\n            print(f\"\\nüîß Tools Used:\")\n            for tool_call in tool_calls:\n                bedrock_name = tool_call['name']\n                original_name = name_mapping.get(bedrock_name, bedrock_name)\n                print(f\"  - {bedrock_name} (original: {original_name})\")\n                if 'args' in tool_call:\n                    print(f\"    Args: {tool_call['args']}\")\n        else:\n            print(\"\\nüí≠ No tools were called for this query\")\n        \n    except Exception as e:\n        print(f\"‚ùå Agent execution failed: {e}\")\n        print(\"This might be due to AWS permissions or model access issues\")\n    \n    print(f\"\\nüìä Summary:\")\n    print(f\"  Providers registered: 1 (OpenLibrary)\")\n    print(f\"  Original tools: {len(original_tools)}\")\n    print(f\"  Bedrock-compatible tools: {len(bedrock_tools)}\")\n    print(f\"  Tool name mappings: {len(name_mapping)}\")\n    print(f\"  Bedrock model: anthropic.claude-3-haiku-20240307-v1:0\")\n    \n    print(\"\\n‚úÖ Simple Bedrock integration example completed!\")\n    print(\"üí° Note: This example uses Amazon Bedrock which may incur AWS charges\")\n    print(\"üí° Tool names are automatically mapped to meet Bedrock's naming requirements\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n",
      "line_count": 174,
      "word_count": 616,
      "title": "Bedrock Langgraph.Py",
      "summary": "\"\"\"Simple Amazon Bedrock integration example for LangChain UTCP Adapters. This is a streamlined example showing the core integration between",
      "key_terms": [
        "integration",
        "showing",
        "up",
        "Session",
        "async",
        "search",
        "error",
        "convert",
        "compatible",
        "format",
        "uses",
        "Utcp",
        "available",
        "only",
        "dependencies",
        "Test",
        "found",
        "ImportError",
        "Loaded",
        "except"
      ],
      "timestamp": "2025-12-24T18:56:08.127625"
    },
    {
      "file_path": "UPSTREAM\\langchain-utcp-adapters\\examples\\direct_usage.py",
      "content_type": "code",
      "content": "\"\"\"Simple direct usage example for LangChain UTCP Adapters.\n\nThis example demonstrates the simplified approach:\n1. Create a UTCP client directly\n2. Register providers dynamically\n3. Load and use tools with LangChain\n\"\"\"\n\nimport asyncio\nfrom utcp.utcp_client import UtcpClient\nfrom utcp.data.utcp_client_config import UtcpClientConfig\nfrom utcp_http.http_call_template import HttpCallTemplate\nfrom langchain_utcp_adapters import load_utcp_tools, search_utcp_tools\n\n\nasync def main():\n    \"\"\"Main example function.\"\"\"\n    print(\"üöÄ Simple Direct UTCP + LangChain Integration\")\n    print(\"=\" * 50)\n    \n    # Create UTCP client directly\n    config = UtcpClientConfig()\n    client = await UtcpClient.create(config=config)\n    \n    # Register providers dynamically using Provider objects\n    print(\"üì° Registering providers...\")\n    \n    # Register OpenLibrary provider\n    openlibrary_provider = HttpProvider(\n        name=\"openlibrary\",\n        provider_type=\"http\",\n        http_method=\"GET\",\n        url=\"https://openlibrary.org/static/openapi.json\",\n        content_type=\"application/json\"\n    )\n    await client.register_tool_provider(openlibrary_provider)\n    \n    # Register a simple HTTP test provider\n    httpbin_provider = HttpProvider(\n        name=\"httpbin\",\n        provider_type=\"http\",\n        http_method=\"POST\",\n        url=\"http://httpbin.org/anything\",\n        content_type=\"application/json\"\n    )\n    await client.register_tool_provider(httpbin_provider)\n    \n    print(\"‚úÖ Providers registered successfully\")\n    \n    # Load all tools and convert to LangChain format\n    print(\"\\nüîß Loading tools...\")\n    tools = await load_utcp_tools(client)\n    print(f\"Found {len(tools)} LangChain tools:\")\n    \n    for tool in tools:\n        print(f\"  - {tool.name}\")\n        print(f\"    Description: {tool.description}\")\n        print(f\"    Provider: {tool.metadata.get('provider')}\")\n        print()\n    \n    # Search for specific tools\n    print(\"üîç Searching for book-related tools...\")\n    book_tools = await search_utcp_tools(client, \"books\", max_results=3)\n    print(f\"Found {len(book_tools)} book-related tools:\")\n    \n    for tool in book_tools:\n        print(f\"  - {tool.name}: {tool.description}\")\n    \n    # Use a tool if available\n    if book_tools:\n        print(f\"\\nüéØ Testing tool: {book_tools[0].name}\")\n        try:\n            # This would depend on the specific tool's schema\n            # For demonstration, we'll just show the tool is ready\n            print(f\"Tool ready for execution with schema: {book_tools[0].args_schema}\")\n        except Exception as e:\n            print(f\"Tool test failed: {e}\")\n    \n    print(\"\\n‚úÖ Example completed successfully!\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n",
      "line_count": 84,
      "word_count": 244,
      "title": "Direct Usage.Py",
      "summary": "\"\"\"Simple direct usage example for LangChain UTCP Adapters. This example demonstrates the simplified approach:",
      "key_terms": [
        "we",
        "async",
        "convert",
        "format",
        "Utcp",
        "available",
        "providers",
        "Found",
        "usage",
        "except",
        "application",
        "dynamically",
        "using",
        "https",
        "if",
        "books",
        "Main",
        "completed",
        "function",
        "description"
      ],
      "timestamp": "2025-12-24T18:56:08.159935"
    },
    {
      "file_path": "UPSTREAM\\langchain-utcp-adapters\\examples\\newsapi_manual.json",
      "content_type": "configuration",
      "content": "{\n  \"version\": \"1.0\",\n  \"tools\": [\n    {\n      \"name\": \"everything_get\",\n      \"description\": \"Search through millions of articles from over 150,000 large and small news sources and blogs. This endpoint suits article discovery and analysis. It requires either a search query, a source, or a domain.\",\n      \"tags\": [\n        \"articles\"\n      ],\n      \"inputs\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"q\": {\n            \"type\": \"string\",\n            \"description\": \"Keywords or phrases to search for in the article title and body. Advanced search is supported. Max length: 500 chars.\"\n          },\n          \"searchIn\": {\n            \"type\": \"string\",\n            \"description\": \"The fields to restrict your q search to. Possible options: title, description, content. Multiple options can be specified by separating them with a comma.\"\n          },\n          \"sources\": {\n            \"type\": \"string\",\n            \"description\": \"A comma-seperated string of identifiers (maximum 20) for the news sources or blogs you want headlines from.\"\n          },\n          \"domains\": {\n            \"type\": \"string\",\n            \"description\": \"A comma-seperated string of domains (eg bbc.co.uk, techcrunch.com, engadget.com) to restrict the search to.\"\n          },\n          \"excludeDomains\": {\n            \"type\": \"string\",\n            \"description\": \"A comma-seperated string of domains (eg bbc.co.uk, techcrunch.com, engadget.com) to remove from the results.\"\n          },\n          \"from\": {\n            \"type\": \"string\",\n            \"description\": \"A date and optional time for the oldest article allowed. This should be in ISO 8601 format (e.g. 2025-07-09 or 2025-07-09T09:28:11)\"\n          },\n          \"to\": {\n            \"type\": \"string\",\n            \"description\": \"A date and optional time for the newest article allowed. This should be in ISO 8601 format (e.g. 2025-07-09 or 2025-07-09T09:28:11)\"\n          },\n          \"language\": {\n            \"type\": \"string\",\n            \"description\": \"The 2-letter ISO-639-1 code of the language you want to get headlines for.\"\n          },\n          \"sortBy\": {\n            \"type\": \"string\",\n            \"description\": \"The order to sort the articles in. Possible options: relevancy, popularity, publishedAt.\"\n          },\n          \"pageSize\": {\n            \"type\": \"integer\",\n            \"description\": \"The number of results to return per page. Maximum: 100.\"\n          },\n          \"page\": {\n            \"type\": \"integer\",\n            \"description\": \"Use this to page through the results.\"\n          }\n        },\n        \"required\": [\n          \"q\"\n        ]\n      },\n      \"outputs\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"status\": {\n            \"type\": \"string\",\n            \"description\": \"If the request was successful or not. Options: ok, error.\"\n          },\n          \"totalResults\": {\n            \"type\": \"integer\",\n            \"description\": \"The total number of results available for your request.\"\n          },\n          \"articles\": {\n            \"type\": \"array\",\n            \"description\": \"The results of the request.\",\n            \"items\": {\n              \"type\": \"object\",\n              \"properties\": {\n                \"source\": {\n                  \"type\": \"object\",\n                  \"description\": \"The identifier id and a display name name for the source this article came from.\",\n                  \"properties\": {\n                    \"id\": {\n                      \"type\": \"string\"\n                    },\n                    \"name\": {\n                      \"type\": \"string\"\n                    }\n                  }\n                },\n                \"author\": {\n                  \"type\": \"string\",\n                  \"description\": \"The author of the article\"\n                },\n                \"title\": {\n                  \"type\": \"string\",\n                  \"description\": \"The headline or title of the article.\"\n                },\n                \"description\": {\n                  \"type\": \"string\",\n                  \"description\": \"A description or snippet from the article.\"\n                },\n                \"url\": {\n                  \"type\": \"string\",\n                  \"description\": \"The direct URL to the article.\"\n                },\n                \"urlToImage\": {\n                  \"type\": \"string\",\n                  \"description\": \"The URL to a relevant image for the article.\"\n                },\n                \"publishedAt\": {\n                  \"type\": \"string\",\n                  \"description\": \"The date and time that the article was published, in UTC (+000)\"\n                },\n                \"content\": {\n                  \"type\": \"string\",\n                  \"description\": \"The unformatted content of the article, where available. This is truncated to 200 chars.\"\n                }\n              },\n              \"required\": [\n                \"title\"\n              ]\n            }\n          }\n        }\n      },\n      \"tool_provider\": {\n        \"provider_type\": \"http\",\n        \"url\": \"https://newsapi.org/v2/everything\",\n        \"http_method\": \"GET\",\n        \"content_type\": \"application/json\",\n        \"auth\": {\n          \"auth_type\": \"api_key\",\n          \"api_key\": \"$NEWS_API_KEY\",\n          \"var_name\": \"X-Api-Key\"\n        }\n      }\n    },\n    {\n      \"name\": \"top_headlines_get\",\n      \"description\": \"This endpoint provides live top and breaking headlines for a country, specific category in a country, single source, or multiple sources. You can also search with keywords. Articles are sorted by the earliest date published first. This endpoint is great for retrieving headlines for use with news tickers or similar.\",\n      \"tags\": [\n        \"articles\"\n      ],\n      \"inputs\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"country\": {\n            \"type\": \"string\",\n            \"description\": \"The 2-letter ISO 3166-1 code of the country you want to get headlines for. Note: you can't mix this param with the sources param.\"\n          },\n          \"category\": {\n            \"type\": \"string\",\n            \"description\": \"The category you want to get headlines for. Possible options: business, entertainment, general, health, science, sports, technology. Note: you can't mix this param with the sources param.\"\n          },\n          \"sources\": {\n            \"type\": \"string\",\n            \"description\": \"A comma-seperated string of identifiers for the news sources or blogs you want headlines from. Note: you can't mix this param with the country or category params.\"\n          },\n          \"q\": {\n            \"type\": \"string\",\n            \"description\": \"Keywords or a phrase to search for.\"\n          },\n          \"pageSize\": {\n            \"type\": \"integer\",\n            \"description\": \"The number of results to return per page (request). 20 is the default, 100 is the maximum.\"\n          },\n          \"page\": {\n            \"type\": \"integer\",\n            \"description\": \"Use this to page through the results if the total results found is greater than the page size.\"\n          }\n        }\n      },\n      \"outputs\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"status\": {\n            \"type\": \"string\",\n            \"description\": \"If the request was successful or not. Options: ok, error.\"\n          },\n          \"totalResults\": {\n            \"type\": \"integer\",\n            \"description\": \"The total number of results available for your request.\"\n          },\n          \"articles\": {\n            \"type\": \"array\",\n            \"description\": \"The results of the request.\",\n            \"items\": {\n              \"type\": \"object\",\n              \"properties\": {\n                \"source\": {\n                  \"type\": \"object\",\n                  \"description\": \"The identifier id and a display name name for the source this article came from.\",\n                  \"properties\": {\n                    \"id\": {\n                      \"type\": \"string\"\n                    },\n                    \"name\": {\n                      \"type\": \"string\"\n                    }\n                  }\n                },\n                \"author\": {\n                  \"type\": \"string\",\n                  \"description\": \"The author of the article\"\n                },\n                \"title\": {\n                  \"type\": \"string\",\n                  \"description\": \"The headline or title of the article.\"\n                },\n                \"description\": {\n                  \"type\": \"string\",\n                  \"description\": \"A description or snippet from the article.\"\n                },\n                \"url\": {\n                  \"type\": \"string\",\n                  \"description\": \"The direct URL to the article.\"\n                },\n                \"urlToImage\": {\n                  \"type\": \"string\",\n                  \"description\": \"The URL to a relevant image for the article.\"\n                },\n                \"publishedAt\": {\n                  \"type\": \"string\",\n                  \"description\": \"The date and time that the article was published, in UTC (+000)\"\n                },\n                \"content\": {\n                  \"type\": \"string\",\n                  \"description\": \"The unformatted content of the article, where available. This is truncated to 200 chars.\"\n                }\n              },\n              \"required\": [\n                \"title\"\n              ]\n            }\n          }\n        }\n      },\n      \"tool_provider\": {\n        \"provider_type\": \"http\",\n        \"url\": \"https://newsapi.org/v2/top-headlines\",\n        \"http_method\": \"GET\",\n        \"content_type\": \"application/json\",\n        \"auth\": {\n          \"auth_type\": \"api_key\",\n          \"api_key\": \"$NEWS_API_KEY\",\n          \"var_name\": \"X-Api-Key\"\n        }\n      }\n    }\n  ]\n}",
      "line_count": 252,
      "word_count": 959,
      "title": "Newsapi Manual.Json",
      "summary": "\"version\": \"1.0\", \"name\": \"everything_get\",",
      "key_terms": [
        "ISO",
        "page",
        "phrase",
        "search",
        "number",
        "chars",
        "error",
        "co",
        "If",
        "display",
        "either",
        "through",
        "Articles",
        "id",
        "format",
        "available",
        "searchIn",
        "It",
        "specified",
        "small"
      ],
      "timestamp": "2025-12-24T18:56:08.191728"
    },
    {
      "file_path": "UPSTREAM\\langchain-utcp-adapters\\examples\\openai_advanced.py",
      "content_type": "code",
      "content": "\"\"\"Advanced LangGraph integration example for LangChain UTCP Adapters.\n\nThis example demonstrates advanced patterns for using UTCP tools with LangGraph agents,\nincluding multiple providers, error handling, and tool search functionality.\n\"\"\"\n\nimport asyncio\nimport os\nfrom utcp.utcp_client import UtcpClient\nfrom utcp.data.utcp_client_config import UtcpClientConfig\nfrom utcp_http.http_call_template import HttpCallTemplate\nfrom langchain_utcp_adapters import load_utcp_tools, search_utcp_tools\n\n# Optional: Only import if available\ntry:\n    from langgraph.prebuilt import create_react_agent\n    from langchain_openai import ChatOpenAI\n    LANGGRAPH_AVAILABLE = True\nexcept ImportError:\n    LANGGRAPH_AVAILABLE = False\n    print(\"LangGraph or OpenAI not available. Install with: pip install langgraph langchain-openai\")\n\n\nasync def main():\n    \"\"\"Advanced LangGraph integration example.\"\"\"\n    print(\"ü§ñ Advanced LangGraph + UTCP Integration\")\n    print(\"=\" * 45)\n    \n    if not LANGGRAPH_AVAILABLE:\n        print(\"‚ùå Required dependencies not available.\")\n        print(\"Install with: pdm install -G examples\")\n        return\n    \n    # Check for OpenAI API key\n    if not os.getenv(\"OPENAI_API_KEY\"):\n        print(\"‚ùå OPENAI_API_KEY environment variable not set\")\n        print(\"Set it with: export OPENAI_API_KEY=your_key_here\")\n        return\n    \n    # Check for OpenAI API key\n    if not os.getenv(\"OPENAI_API_KEY\"):\n        print(\"‚ùå OPENAI_API_KEY environment variable not set\")\n        print(\"Set it with: export OPENAI_API_KEY=your_key_here\")\n        return\n    \n    print(\"‚úÖ Dependencies and API key verified\")\n    \n    # Create UTCP client\n    print(\"\\nüì° Setting up UTCP client...\")\n    config = UtcpClientConfig()\n    client = await UtcpClient.create(config=config)\n    \n    # Register multiple providers for comprehensive testing\n    print(\"üì° Registering multiple providers...\")\n    \n    providers = [\n        {\n            \"name\": \"openlibrary\",\n            \"provider\": HttpProvider(\n                name=\"openlibrary\",\n                provider_type=\"http\",\n                http_method=\"GET\",\n                url=\"https://openlibrary.org/static/openapi.json\",\n                content_type=\"application/json\"\n            ),\n            \"description\": \"OpenLibrary API for book information\"\n        },\n        {\n            \"name\": \"petstore\",\n            \"provider\": HttpProvider(\n                name=\"petstore\",\n                provider_type=\"http\",\n                url=\"https://petstore.swagger.io/v2/swagger.json\",\n                http_method=\"GET\"\n            ),\n            \"description\": \"Swagger Petstore API for demo purposes\"\n        }\n    ]\n    \n    registered_providers = []\n    for provider_info in providers:\n        try:\n            print(f\"  Registering {provider_info['name']}...\")\n            await client.register_tool_provider(provider_info[\"provider\"])\n            registered_providers.append(provider_info[\"name\"])\n            print(f\"    ‚úÖ {provider_info['description']}\")\n        except Exception as e:\n            print(f\"    ‚ùå Failed to register {provider_info['name']}: {e}\")\n    \n    if not registered_providers:\n        print(\"‚ùå No providers registered successfully. Cannot continue.\")\n        return\n    \n    print(f\"‚úÖ Successfully registered {len(registered_providers)} providers\")\n    \n    # Load all tools and convert to LangChain format\n    print(\"\\nüîß Loading UTCP tools...\")\n    tools = await load_utcp_tools(client)\n    print(f\"Loaded {len(tools)} tools from all providers:\")\n    \n    # Group tools by provider for better organization\n    tools_by_provider = {}\n    for tool in tools:\n        provider = tool.metadata.get('provider', 'unknown')\n        if provider not in tools_by_provider:\n            tools_by_provider[provider] = []\n        tools_by_provider[provider].append(tool)\n    \n    for provider, provider_tools in tools_by_provider.items():\n        print(f\"  üì¶ {provider}: {len(provider_tools)} tools\")\n        for tool in provider_tools[:2]:  # Show first 2 tools per provider\n            print(f\"    - {tool.name}\")\n        if len(provider_tools) > 2:\n            print(f\"    ... and {len(provider_tools) - 2} more\")\n    \n    if not tools:\n        print(\"‚ùå No tools available. Cannot create agent.\")\n        return\n    \n    # Demonstrate tool search functionality\n    print(\"\\nüîç Demonstrating tool search...\")\n    search_queries = [\"book\", \"pet\", \"search\", \"get\"]\n    \n    for query in search_queries:\n        results = await search_utcp_tools(client, query, max_results=3)\n        if results:\n            print(f\"  Query '{query}': {len(results)} tools found\")\n            for tool in results[:2]:\n                provider = tool.metadata.get('provider', 'unknown')\n                print(f\"    - {tool.name} ({provider})\")\n    \n    # Create LangGraph agent with UTCP tools\n    print(\"\\nü§ñ Creating advanced LangGraph agent...\")\n    try:\n        llm = ChatOpenAI(model=\"gpt-4o-mini\", temperature=0.1)\n        agent = create_react_agent(llm, tools)\n        print(\"‚úÖ Agent created successfully with all available tools\")\n    except Exception as e:\n        print(f\"‚ùå Failed to create agent: {e}\")\n        return\n    \n    # Test the agent with multiple scenarios\n    test_scenarios = [\n        {\n            \"name\": \"Tool Discovery\",\n            \"query\": \"What tools do you have available? List them by category.\",\n            \"description\": \"Tests agent's ability to understand its capabilities\"\n        },\n        {\n            \"name\": \"Book Search\",\n            \"query\": \"Can you search for Hamlet by William Shakespeare?\",\n            \"description\": \"Tests integration with OpenLibrary API\"\n        },\n        {\n            \"name\": \"API Exploration\", \n            \"query\": \"What kind of information can you get about pets or animals?\",\n            \"description\": \"Tests integration with Petstore API\"\n        }\n    ]\n    \n    print(\"\\nüí¨ Testing agent with multiple scenarios...\")\n    \n    for i, scenario in enumerate(test_scenarios, 1):\n        print(f\"\\n{'='*50}\")\n        print(f\"Test {i}: {scenario['name']}\")\n        print(f\"{'='*50}\")\n        print(f\"Query: {scenario['query']}\")\n        print(f\"Purpose: {scenario['description']}\")\n        print()\n        \n        try:\n            response = await agent.ainvoke({\n                \"messages\": [(\"user\", scenario[\"query\"])]\n            })\n            \n            print(\"ü§ñ Agent Response:\")\n            print(response[\"messages\"][-1].content)\n            \n            # Check if tools were used\n            tool_calls = []\n            for message in response[\"messages\"]:\n                if hasattr(message, 'tool_calls') and message.tool_calls:\n                    tool_calls.extend(message.tool_calls)\n            \n            if tool_calls:\n                print(f\"\\nüîß Tools Used:\")\n                for tool_call in tool_calls:\n                    print(f\"  - {tool_call['name']}\")\n                    if 'args' in tool_call:\n                        print(f\"    Args: {tool_call['args']}\")\n            else:\n                print(\"\\nüí≠ No tools were called for this query\")\n                \n        except Exception as e:\n            print(f\"‚ùå Test failed: {e}\")\n    \n    # Performance and statistics\n    print(f\"\\nüìä Session Statistics:\")\n    print(f\"  Total providers registered: {len(registered_providers)}\")\n    print(f\"  Total tools available: {len(tools)}\")\n    print(f\"  Tool categories: {len(tools_by_provider)}\")\n    print(f\"  Average tools per provider: {len(tools) / len(tools_by_provider):.1f}\")\n    \n    print(\"\\n‚úÖ Advanced LangGraph integration example completed!\")\n    print(\"\\nüí° Key Features Demonstrated:\")\n    print(\"  ‚Ä¢ Multiple UTCP provider integration\")\n    print(\"  ‚Ä¢ Tool search and discovery\")\n    print(\"  ‚Ä¢ Advanced agent testing scenarios\")\n    print(\"  ‚Ä¢ Error handling and graceful degradation\")\n    print(\"  ‚Ä¢ Tool usage tracking and statistics\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n",
      "line_count": 215,
      "word_count": 701,
      "title": "Openai Advanced.Py",
      "summary": "\"\"\"Advanced LangGraph integration example for LangChain UTCP Adapters. This example demonstrates advanced patterns for using UTCP tools with LangGraph agents,",
      "key_terms": [
        "integration",
        "Total",
        "comprehensive",
        "up",
        "Session",
        "search",
        "async",
        "error",
        "convert",
        "format",
        "Utcp",
        "available",
        "unknown",
        "dependencies",
        "Demonstrated",
        "providers",
        "Test",
        "found",
        "ImportError",
        "Loaded"
      ],
      "timestamp": "2025-12-24T18:56:08.207656"
    },
    {
      "file_path": "UPSTREAM\\langchain-utcp-adapters\\examples\\openai_langgraph.py",
      "content_type": "code",
      "content": "\"\"\"Simple LangGraph integration example using direct UTCP client.\n\nThis example shows how to use UTCP tools with LangGraph agents\nusing the simplified direct approach.\n\"\"\"\n\nimport asyncio\nimport os\nfrom utcp.client.utcp_client import UtcpClient\nfrom utcp.client.utcp_client_config import UtcpClientConfig\nfrom utcp.shared.provider import HttpProvider\nfrom langchain_utcp_adapters import load_utcp_tools\n\n# Optional: Only import if available\ntry:\n    from langgraph.prebuilt import create_react_agent\n    from langchain_openai import ChatOpenAI\n    LANGGRAPH_AVAILABLE = True\nexcept ImportError:\n    LANGGRAPH_AVAILABLE = False\n    print(\"LangGraph or OpenAI not available. Install with: pip install langgraph langchain-openai\")\n\n\nasync def main():\n    \"\"\"Simple LangGraph integration example.\"\"\"\n    print(\"ü§ñ Simple LangGraph + UTCP Integration\")\n    print(\"=\" * 40)\n    \n    if not LANGGRAPH_AVAILABLE:\n        return\n    \n    # Check for OpenAI API key\n    if not os.getenv(\"OPENAI_API_KEY\"):\n        print(\"‚ùå OPENAI_API_KEY environment variable not set\")\n        print(\"Set it with: export OPENAI_API_KEY=your_key_here\")\n        return\n    \n    # Create UTCP client directly\n    print(\"üì° Setting up UTCP client...\")\n    config = UtcpClientConfig()\n    utcp_client = await UtcpClient.create(config=config)\n    \n    # Register a simple provider for demonstration\n    openlibrary_provider = HttpProvider(\n        name=\"openlibrary\",\n        provider_type=\"http\",\n        http_method=\"GET\", \n        url=\"https://openlibrary.org/static/openapi.json\",\n        content_type=\"application/json\"\n    )\n    await utcp_client.register_tool_provider(openlibrary_provider)\n    \n    # Load tools and convert to LangChain format\n    print(\"üîß Loading UTCP tools...\")\n    tools = await load_utcp_tools(utcp_client)\n    print(f\"Loaded {len(tools)} tools for the agent\")\n    \n    # Create LangGraph agent with UTCP tools\n    print(\"ü§ñ Creating LangGraph agent...\")\n    llm = ChatOpenAI(model=\"gpt-4o-mini\", temperature=0)\n    agent = create_react_agent(llm, tools)\n    \n    # Test the agent\n    print(\"üí¨ Testing agent with Hamlet search query...\")\n    try:\n        response = await agent.ainvoke({\n            \"messages\": [(\"user\", \"Can you search for Hamlet by William Shakespeare?\")]\n        })\n        \n        print(\"üéâ Agent response:\")\n        print(response[\"messages\"][-1].content)\n        \n    except Exception as e:\n        print(f\"‚ùå Agent execution failed: {e}\")\n    \n    print(\"\\n‚úÖ Example completed!\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n",
      "line_count": 81,
      "word_count": 244,
      "title": "Openai Langgraph.Py",
      "summary": "\"\"\"Simple LangGraph integration example using direct UTCP client. This example shows how to use UTCP tools with LangGraph agents",
      "key_terms": [
        "integration",
        "up",
        "async",
        "search",
        "convert",
        "format",
        "Utcp",
        "available",
        "Test",
        "ImportError",
        "Loaded",
        "except",
        "shared",
        "application",
        "using",
        "llm",
        "https",
        "model",
        "if",
        "Can"
      ],
      "timestamp": "2025-12-24T18:56:08.239461"
    },
    {
      "file_path": "UPSTREAM\\langchain-utcp-adapters\\examples\\openapi.py",
      "content_type": "code",
      "content": "\"\"\"OpenAPI integration example for LangChain UTCP Adapters.\n\nThis example demonstrates how UTCP can automatically convert OpenAPI specifications\ninto UTCP tools that can be used with LangChain.\n\"\"\"\n\nimport asyncio\nimport json\nfrom pathlib import Path\n\nfrom utcp.client.utcp_client import UtcpClient\nfrom utcp.client.utcp_client_config import UtcpClientConfig\nfrom utcp.shared.provider import HttpProvider\nfrom langchain_utcp_adapters import load_utcp_tools, search_utcp_tools\n\n\nasync def main():\n    \"\"\"Main example function demonstrating OpenAPI integration.\"\"\"\n    \n    print(\"OpenAPI Integration Example\")\n    print(\"=\" * 40)\n    print(\"This example shows how UTCP can automatically convert\")\n    print(\"OpenAPI specifications into usable tools.\")\n    print()\n    \n    # Create UTCP client\n    config = UtcpClientConfig()\n    client = await UtcpClient.create(config=config)\n    \n    # Example 1: Register OpenAPI specs directly as providers\n    print(\"üì° Registering OpenAPI providers...\")\n    \n    openapi_providers = [\n        {\n            \"name\": \"petstore\",\n            \"url\": \"https://petstore.swagger.io/v2/swagger.json\",\n            \"description\": \"Swagger Petstore - Classic OpenAPI example\"\n        },\n        {\n            \"name\": \"httpbin\", \n            \"url\": \"https://httpbin.org/spec.json\",\n            \"description\": \"HTTPBin - HTTP testing service\"\n        }\n    ]\n    \n    registered_providers = []\n    for provider_info in openapi_providers:\n        try:\n            print(f\"  Registering {provider_info['name']}...\")\n            provider = HttpProvider(\n                name=provider_info[\"name\"],\n                provider_type=\"http\",\n                url=provider_info[\"url\"],\n                http_method=\"GET\"\n            )\n            tools = await client.register_tool_provider(provider)\n            registered_providers.append(provider_info[\"name\"])\n            print(f\"    ‚úÖ Registered {len(tools)} tools from {provider_info['name']}\")\n        except Exception as e:\n            print(f\"    ‚ùå Failed to register {provider_info['name']}: {e}\")\n    \n    # Example 2: Create providers.json with OpenAPI URLs\n    print(\"\\nüìÑ Creating providers.json with OpenAPI specs...\")\n    providers_config = [\n        {\n            \"name\": \"jsonplaceholder\",\n            \"provider_type\": \"http\",\n            \"url\": \"https://jsonplaceholder.typicode.com\",\n            \"http_method\": \"GET\"\n        }\n    ]\n    \n    providers_file = Path(\"openapi_providers.json\")\n    with open(providers_file, \"w\") as f:\n        json.dump(providers_config, f, indent=2)\n    \n    # Load additional providers from file\n    try:\n        additional_providers = await client.load_providers(\"openapi_providers.json\")\n        print(f\"‚úÖ Loaded {len(additional_providers)} additional providers from file\")\n    except Exception as e:\n        print(f\"‚ùå Failed to load providers from file: {e}\")\n    \n    # Load all tools and convert to LangChain format\n    print(\"\\nüîß Loading all tools...\")\n    tools = await load_utcp_tools(client)\n    print(f\"Found {len(tools)} LangChain tools from OpenAPI specs:\")\n    \n    # Group tools by provider\n    tools_by_provider = {}\n    for tool in tools:\n        provider = tool.metadata.get('provider', 'unknown')\n        if provider not in tools_by_provider:\n            tools_by_provider[provider] = []\n        tools_by_provider[provider].append(tool)\n    \n    for provider, provider_tools in tools_by_provider.items():\n        print(f\"\\n  üì¶ {provider} ({len(provider_tools)} tools):\")\n        for tool in provider_tools[:3]:  # Show first 3 tools\n            print(f\"    - {tool.name}: {tool.description}\")\n        if len(provider_tools) > 3:\n            print(f\"    ... and {len(provider_tools) - 3} more tools\")\n    \n    # Search for specific functionality\n    print(\"\\nüîç Searching for specific functionality...\")\n    search_queries = [\"user\", \"post\", \"get\", \"pet\"]\n    \n    for query in search_queries:\n        results = await search_utcp_tools(client, query, max_results=3)\n        if results:\n            print(f\"\\n  Query '{query}' found {len(results)} tools:\")\n            for tool in results:\n                print(f\"    - {tool.name} ({tool.metadata.get('provider')})\")\n    \n    # Show detailed schema for one tool\n    if tools:\n        example_tool = tools[0]\n        print(f\"\\nüìã Example tool schema for '{example_tool.name}':\")\n        print(f\"  Description: {example_tool.description}\")\n        print(f\"  Provider: {example_tool.metadata.get('provider')}\")\n        print(f\"  Args schema: {example_tool.args_schema}\")\n        print(f\"  Metadata: {example_tool.metadata}\")\n    \n    # Cleanup\n    if providers_file.exists():\n        providers_file.unlink()\n    \n    print(\"\\n‚úÖ OpenAPI integration example completed!\")\n    print(f\"Successfully integrated {len(tools)} tools from OpenAPI specifications\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n",
      "line_count": 134,
      "word_count": 424,
      "title": "Openapi.Py",
      "summary": "\"\"\"OpenAPI integration example for LangChain UTCP Adapters. This example demonstrates how UTCP can automatically convert OpenAPI specifications",
      "key_terms": [
        "open",
        "integration",
        "async",
        "convert",
        "format",
        "unlink",
        "Utcp",
        "unknown",
        "providers",
        "Found",
        "found",
        "Loaded",
        "except",
        "typicode",
        "shared",
        "https",
        "if",
        "that",
        "load",
        "petstore"
      ],
      "timestamp": "2025-12-24T18:56:08.276785"
    },
    {
      "file_path": "UPSTREAM\\langchain-utcp-adapters\\examples\\providers.py",
      "content_type": "code",
      "content": "#!/usr/bin/env python3\n\"\"\"Real providers example for LangChain UTCP Adapters.\n\nThis example demonstrates the package working with actual UTCP call templates:\n- OpenLibrary API (via OpenAPI specification)\n- NewsAPI (via UTCP manual definition)\n\nIt shows how to load real tools, search them, and use them in practice.\n\"\"\"\n\nimport asyncio\nimport json\nfrom pathlib import Path\n\nfrom utcp.utcp_client import UtcpClient\nfrom utcp.data.utcp_client_config import UtcpClientConfig\nfrom utcp_http.http_call_template import HttpCallTemplate\nfrom utcp_text.text_call_template import TextCallTemplate\nfrom langchain_utcp_adapters import load_utcp_tools, search_utcp_tools\n\n\nasync def main():\n    \"\"\"Main example function demonstrating real UTCP call templates.\"\"\"\n    print(\"üåü LangChain UTCP Adapters - Real Call Templates Example\")\n    print(\"=\" * 60)\n    \n    # Create UTCP client with call templates\n    print(\"üì° Creating UTCP client...\")\n    \n    # Check if NewsAPI manual exists\n    newsapi_file = Path(\"newsapi_manual.json\")\n    call_templates = [\n        HttpCallTemplate(\n            name=\"openlibrary\",\n            call_template_type=\"http\",\n            http_method=\"GET\",\n            url=\"https://openlibrary.org/static/openapi.json\",\n            content_type=\"application/json\"\n        )\n    ]\n    \n    if newsapi_file.exists():\n        call_templates.append(\n            TextCallTemplate(\n                name=\"newsapi\",\n                call_template_type=\"text\",\n                file_path=\"./newsapi_manual.json\"\n            )\n        )\n        print(\"  üìÑ Found NewsAPI manual, including in configuration\")\n    else:\n        print(\"  ‚ö†Ô∏è  NewsAPI manual not found, using OpenLibrary only\")\n    \n    config = UtcpClientConfig(manual_call_templates=call_templates)\n    client = await UtcpClient.create(config=config)\n    \n    # Load all available tools\n    print(\"\\nüîß Loading UTCP tools...\")\n    try:\n        langchain_tools = await load_utcp_tools(client)\n        print(f\"‚úÖ Successfully loaded {len(langchain_tools)} tools\")\n        \n        # Display available tools\n        print(\"\\nüìã Available tools:\")\n        for tool in langchain_tools:\n            print(f\"  ‚Ä¢ {tool.name}: {tool.description}\")\n    \n    except Exception as e:\n        print(f\"‚ùå Failed to load tools: {e}\")\n        return\n    \n    # Demonstrate tool search\n    print(\"\\nüîç Searching for specific tools...\")\n    search_queries = [\"search\", \"book\", \"author\", \"news\"]\n    \n    for query in search_queries:\n        try:\n            matching_tools = await search_utcp_tools(client, query, max_results=3)\n            if matching_tools:\n                print(f\"\\n  Query: '{query}' -> {len(matching_tools)} matches:\")\n                for tool in matching_tools:\n                    print(f\"    ‚Ä¢ {tool.name}\")\n            else:\n                print(f\"\\n  Query: '{query}' -> No matches\")\n        except Exception as e:\n            print(f\"  ‚ùå Search failed for '{query}': {e}\")\n    \n    # Demonstrate tool execution (if tools are available)\n    if langchain_tools:\n        print(f\"\\nüöÄ Testing tool execution...\")\n        \n        # Try to find a simple tool to test\n        test_tool = None\n        for tool in langchain_tools:\n            if \"search\" in tool.name.lower() and \"author\" in tool.name.lower():\n                test_tool = tool\n                break\n        \n        if test_tool:\n            try:\n                print(f\"  Testing tool: {test_tool.name}\")\n                # Use a simple test query\n                result = await test_tool.ainvoke({\"q\": \"J.K. Rowling\"})\n                print(f\"  ‚úÖ Tool execution successful\")\n                print(f\"  üìÑ Result preview: {str(result)[:200]}...\")\n            except Exception as e:\n                print(f\"  ‚ùå Tool execution failed: {e}\")\n        else:\n            print(\"  ‚ö†Ô∏è  No suitable test tool found\")\n    \n    print(f\"\\n‚ú® Example completed!\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n",
      "line_count": 116,
      "word_count": 365,
      "title": "Providers.Py",
      "summary": "\"\"\"Real providers example for LangChain UTCP Adapters. This example demonstrates the package working with actual UTCP call templates:",
      "key_terms": [
        "lower",
        "preview",
        "Result",
        "search",
        "async",
        "Available",
        "Utcp",
        "available",
        "only",
        "It",
        "providers",
        "Found",
        "found",
        "Rowling",
        "except",
        "application",
        "using",
        "https",
        "if",
        "load"
      ],
      "timestamp": "2025-12-24T18:56:08.303688"
    },
    {
      "file_path": "UPSTREAM\\langchain-utcp-adapters\\examples\\README.md",
      "content_type": "documentation",
      "content": "# LangChain UTCP Adapters - Examples\n\nThis directory contains comprehensive examples demonstrating how to use the LangChain UTCP Adapters package to integrate Universal Tool Calling Protocol (UTCP) providers with LangChain applications.\n\n## Quick Start\n\n1. **Install the package**:\n   ```bash\n   pip install -e .\n1. **Install the base package**:\n   ```bash\n   pip install langchain-utcp-adapters\n   ```\n\n2. **Install optional dependencies**:\n   \n   **Using PDM (for development)**:\n   ```bash\n   pdm install -G examples  # For LangGraph and OpenAI examples\n   pdm install -G bedrock   # For Amazon Bedrock examples\n   pdm install -G server    # For server-based examples\n   ```\n   \n   **Using pip (for end users)**:\n   ```bash\n   pip install langchain-utcp-adapters[examples]  # LangGraph + OpenAI\n   pip install langchain-utcp-adapters[bedrock]   # Amazon Bedrock\n   pip install langchain-utcp-adapters[all]       # Everything\n   ```\n\n3. **Run a basic example**:\n   ```bash\n   python examples/basic_usage.py\n   ```\n\n## Examples Overview\n\n| Example | Description | Dependencies | API Keys Required |\n|---------|-------------|--------------|-------------------|\n| [`basic_usage.py`](#basic-usage) | Core functionality demonstration | None | None |\n| [`simple_direct_usage.py`](#simple-direct-usage) | Direct UTCP client usage | None | None |\n| [`simple_langgraph.py`](#simple-langgraph) | Basic LangGraph integration | LangGraph, OpenAI | OPENAI_API_KEY |\n| [`langgraph_integration.py`](#langgraph-integration) | Advanced LangGraph features | LangGraph, OpenAI | OPENAI_API_KEY |\n| [`authentication_example.py`](#authentication) | Authentication methods | None | None (demo only) |\n| [`openapi_integration.py`](#openapi-integration) | OpenAPI specification integration | None | None |\n| [`bedrock_simple.py`](#bedrock-simple) | Basic Amazon Bedrock integration | LangChain-AWS, Boto3 | AWS credentials |\n| [`bedrock_integration.py`](#bedrock-integration) | Advanced Bedrock features | LangChain-AWS, Boto3 | AWS credentials |\n| [`real_providers_example.py`](#real-providers) | Real-world API integration | None | None |\n\n## Detailed Examples\n\n### Basic Usage\n\n**File**: `basic_usage.py`  \n**Purpose**: Demonstrates core functionality of loading and using UTCP tools  \n**Requirements**: None  \n\n```bash\npython examples/basic_usage.py\n```\n\n**What it shows**:\n- Creating UTCP client\n- Registering multiple providers (Petstore, OpenLibrary)\n- Loading tools and converting to LangChain format\n- Tool search functionality\n- Provider information display\n\n### Simple Direct Usage\n\n**File**: `simple_direct_usage.py`  \n**Purpose**: Shows direct UTCP client usage without configuration files  \n**Requirements**: None  \n\n```bash\npython examples/simple_direct_usage.py\n```\n\n**What it shows**:\n- Direct provider registration\n- Tool loading from OpenLibrary API\n- Tool inspection and metadata\n\n### Simple LangGraph\n\n**File**: `simple_langgraph.py`  \n**Purpose**: Basic LangGraph agent with UTCP tools  \n**Requirements**: LangGraph, OpenAI  \n\n**Setup**:\n```bash\nexport OPENAI_API_KEY=your_key_here\npython examples/simple_langgraph.py\n```\n\n**What it shows**:\n- Creating LangGraph agents with UTCP tools\n- Agent execution with tool calling\n- Error handling for missing API keys\n\n### LangGraph Integration\n\n**File**: `langgraph_integration.py`  \n**Purpose**: Advanced LangGraph features and patterns  \n**Requirements**: LangGraph, OpenAI  \n\n**Setup**:\n```bash\nexport OPENAI_API_KEY=your_key_here\npython examples/langgraph_integration.py\n```\n\n**What it shows**:\n- Complex agent workflows\n- Multiple provider integration\n- Advanced error handling\n\n### Authentication\n\n**File**: `authentication_example.py`  \n**Purpose**: Demonstrates various authentication methods  \n**Requirements**: None (demo only)  \n\n```bash\npython examples/authentication_example.py\n```\n\n**What it shows**:\n- API key authentication\n- OAuth2 authentication\n- Basic authentication\n- Environment variable usage\n- Provider health checking\n\n**Note**: This is a demonstration only. Real authentication requires actual API keys.\n\n### OpenAPI Integration\n\n**File**: `openapi_integration.py`  \n**Purpose**: Shows automatic OpenAPI specification integration  \n**Requirements**: None  \n\n```bash\npython examples/openapi_integration.py\n```\n\n**What it shows**:\n- Automatic OpenAPI to UTCP conversion\n- Multiple OpenAPI provider integration\n- Tool discovery and search\n- Provider health monitoring\n\n**Note**: This example may take longer to run as it fetches and processes OpenAPI specifications.\n\n### Bedrock Simple\n\n**File**: `bedrock_simple.py`  \n**Purpose**: Basic Amazon Bedrock integration  \n**Requirements**: LangChain-AWS, Boto3, AWS credentials  \n\n**Setup**:\n```bash\n# Configure AWS credentials\naws configure\n\n# Or set environment variables\nexport AWS_ACCESS_KEY_ID=your_access_key\nexport AWS_SECRET_ACCESS_KEY=your_secret_key\nexport AWS_DEFAULT_REGION=us-east-1\n\npython examples/bedrock_simple.py\n```\n\n**What it shows**:\n- AWS credential verification\n- Bedrock model initialization\n- UTCP tools with Bedrock models\n- Error handling for missing credentials\n\n**Prerequisites**:\n1. AWS account with Bedrock access\n2. Model access enabled in Bedrock console\n3. Appropriate IAM permissions\n\n### Bedrock Integration\n\n**File**: `bedrock_integration.py`  \n**Purpose**: Advanced Amazon Bedrock features  \n**Requirements**: LangChain-AWS, Boto3, AWS credentials  \n\n**Setup**: Same as Bedrock Simple\n\n**What it shows**:\n- Advanced Bedrock model configuration\n- Multiple model testing\n- Tool integration patterns\n- Production-ready error handling\n\n**Note**: Tool names from OpenLibrary API may exceed Bedrock's 64-character limit, causing validation errors. This is expected behavior.\n\n### Real Providers\n\n**File**: `real_providers_example.py`  \n**Purpose**: Integration with real-world APIs  \n**Requirements**: None  \n\n```bash\npython examples/real_providers_example.py\n```\n\n**What it shows**:\n- OpenLibrary API integration\n- Tool organization by provider\n- Search functionality across providers\n- Practical tool usage examples\n- Provider health monitoring\n\n## Environment Variables\n\n### Required for OpenAI Examples\n```bash\nexport OPENAI_API_KEY=your_openai_api_key\n```\n\n### Required for Bedrock Examples\n```bash\nexport AWS_ACCESS_KEY_ID=your_access_key\nexport AWS_SECRET_ACCESS_KEY=your_secret_key\nexport AWS_DEFAULT_REGION=us-east-1\n```\n\n### Optional for Authentication Examples\n```bash\nexport API_KEY=your_api_key\nexport OAUTH_CLIENT_ID=your_client_id\nexport OAUTH_CLIENT_SECRET=your_client_secret\nexport BASIC_AUTH_USERNAME=your_username\nexport BASIC_AUTH_PASSWORD=your_password\n```\n\n## Troubleshooting\n\n### Common Issues\n\n#### 1. Missing Dependencies\n**Error**: `ModuleNotFoundError: No module named 'langgraph'`  \n**Solution**: Install optional dependencies:\n```bash\n# Using PDM\npdm install -G examples\n\n# Using pip\npip install langchain-utcp-adapters[examples]\n```\n\n#### 2. Missing API Keys\n**Error**: `OPENAI_API_KEY environment variable not set`  \n**Solution**: Set the required environment variable:\n```bash\nexport OPENAI_API_KEY=your_key_here\n```\n\n#### 3. AWS Credentials Not Found\n**Error**: `AWS credential error`  \n**Solution**: Configure AWS credentials:\n```bash\naws configure\n```\n\n#### 4. Bedrock Access Denied\n**Error**: `AccessDeniedException`  \n**Solution**: \n1. Enable model access in AWS Bedrock console\n2. Ensure proper IAM permissions\n3. Verify account has Bedrock access\n\n#### 5. Tool Name Validation Errors (Bedrock)\n**Error**: `string [...] does not match pattern ^[a-zA-Z0-9_-]{1,64}$`  \n**Solution**: This is expected behavior. Bedrock has strict tool naming requirements that some APIs don't meet.\n\n#### 6. Network Timeouts\n**Error**: Connection timeouts when loading tools  \n**Solution**: \n- Check internet connectivity\n- Some APIs may be temporarily unavailable\n- Increase timeout values if needed\n\n### Getting Help\n\n1. **Check the logs**: Most examples include detailed error messages\n2. **Verify prerequisites**: Ensure all required dependencies and credentials are set up\n3. **Test connectivity**: Try simpler examples first (e.g., `basic_usage.py`)\n4. **Check API status**: Verify that external APIs (OpenLibrary, etc.) are accessible\n\n## Development\n\n### Running All Examples\n```bash\n# Basic examples (no external dependencies)\npython examples/basic_usage.py\npython examples/simple_direct_usage.py\npython examples/authentication_example.py\npython examples/openapi_integration.py\npython examples/real_providers_example.py\n\n# OpenAI examples (requires OPENAI_API_KEY)\nexport OPENAI_API_KEY=your_key\npython examples/simple_langgraph.py\npython examples/langgraph_integration.py\n\n# Bedrock examples (requires AWS credentials)\npython examples/bedrock_simple.py\npython examples/bedrock_integration.py\n```\n\n### Creating New Examples\n\n1. **Follow the naming convention**: `your_example.py`\n2. **Include comprehensive error handling**\n3. **Add clear documentation and comments**\n4. **Test with and without optional dependencies**\n5. **Update this README with your example**\n\n### Example Template\n\n```python\n\"\"\"\nYour Example - Brief description\n\nThis example demonstrates [specific functionality].\n\"\"\"\n\nimport asyncio\nfrom utcp.client.utcp_client import UtcpClient\nfrom utcp.client.utcp_client_config import UtcpClientConfig\nfrom langchain_utcp_adapters import load_utcp_tools\n\nasync def main():\n    \"\"\"Main example function.\"\"\"\n    print(\"üöÄ Your Example\")\n    print(\"=\" * 50)\n    \n    try:\n        # Your example code here\n        pass\n    except Exception as e:\n        print(f\"‚ùå Error: {e}\")\n    \n    print(\"‚úÖ Example completed!\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n## Next Steps\n\n1. **Start with basic examples** to understand core concepts\n2. **Explore authentication patterns** for secure API integration\n3. **Try LangGraph integration** for building AI agents\n4. **Experiment with Bedrock** for enterprise AI applications\n5. **Build your own providers** using the patterns shown\n\n## Additional Resources\n\n- [LangChain Documentation](https://python.langchain.com/)\n- [LangGraph Documentation](https://langchain-ai.github.io/langgraph/)\n- [UTCP Specification](https://github.com/universal-tool-calling-protocol)\n- [Amazon Bedrock Documentation](https://docs.aws.amazon.com/bedrock/)\n- [OpenAPI Specification](https://swagger.io/specification/)\n",
      "line_count": 370,
      "word_count": 1159,
      "title": "LangChain UTCP Adapters - Examples",
      "summary": "This directory contains comprehensive examples demonstrating how to use the LangChain UTCP Adapters package to integrate Universal Tool Calling Protocol (UTCP) providers with LangChain applications. 1...",
      "key_terms": [
        "comprehensive",
        "Model",
        "clear",
        "etc",
        "display",
        "Setup",
        "providers",
        "Found",
        "Appropriate",
        "multiple",
        "model",
        "if",
        "that",
        "basic",
        "Real-world",
        "Configure",
        "strict",
        "Main",
        "how",
        "completed"
      ],
      "timestamp": "2025-12-24T18:56:08.351365"
    },
    {
      "file_path": "UPSTREAM\\langchain-utcp-adapters\\langchain_utcp_adapters\\bedrock_utils.py",
      "content_type": "code",
      "content": "\"\"\"\nBedrock-specific utilities for LangChain UTCP Adapters.\n\nThis module provides utilities for formatting UTCP tools to work with Amazon Bedrock's\nstrict tool naming requirements.\n\"\"\"\n\nimport uuid\nfrom typing import Dict, List, Tuple, Any, Optional\nfrom langchain_core.tools import BaseTool\nfrom langchain_core.runnables import RunnableConfig\n\n\ndef format_tool_name_for_bedrock(tool_name: str) -> str:\n    \"\"\"\n    Format a tool name to meet Bedrock's requirements.\n    \n    Bedrock requires tool names to:\n    - Be 64 characters or less\n    - Match pattern ^[a-zA-Z0-9_-]{1,64}$\n    \n    Args:\n        tool_name: Original tool name\n        \n    Returns:\n        Formatted tool name that meets Bedrock requirements\n    \"\"\"\n    # Replace periods with underscores (common in UTCP tool names)\n    bedrock_name = tool_name.replace(\".\", \"_\")\n    \n    # Remove any other invalid characters and replace with underscores\n    valid_chars = []\n    for char in bedrock_name:\n        if char.isalnum() or char in ['_', '-']:\n            valid_chars.append(char)\n        else:\n            valid_chars.append('_')\n    \n    bedrock_name = ''.join(valid_chars)\n    \n    # Truncate if longer than 64 characters\n    if len(bedrock_name) > 64:\n        # Use first 55 chars + underscore + 8-char UUID\n        short_uuid = str(uuid.uuid4()).replace('-', '')[:8]\n        bedrock_name = f\"{bedrock_name[:55]}_{short_uuid}\"\n    \n    return bedrock_name\n\n\ndef create_bedrock_tool_mapping(tools: List[BaseTool]) -> Tuple[List[BaseTool], Dict[str, str]]:\n    \"\"\"\n    Create Bedrock-compatible tools with name mapping.\n    \n    Args:\n        tools: List of LangChain tools with potentially incompatible names\n        \n    Returns:\n        Tuple containing:\n        - List of tools with Bedrock-compatible names\n        - Mapping from Bedrock names to original names\n    \"\"\"\n    bedrock_tools = []\n    name_mapping = {}\n    \n    for tool in tools:\n        original_name = tool.name\n        bedrock_name = format_tool_name_for_bedrock(original_name)\n        \n        # Store the mapping\n        name_mapping[bedrock_name] = original_name\n        \n        if bedrock_name == original_name:\n            # Name is already compatible, use original tool\n            bedrock_tools.append(tool)\n        else:\n            # Create a wrapper tool with the Bedrock-compatible name\n            bedrock_tool = BedrockCompatibleTool(\n                original_tool=tool,\n                bedrock_name=bedrock_name\n            )\n            bedrock_tools.append(bedrock_tool)\n    \n    return bedrock_tools, name_mapping\n\n\nclass BedrockCompatibleTool(BaseTool):\n    \"\"\"\n    A wrapper tool that provides Bedrock-compatible naming while preserving\n    all original tool functionality.\n    \"\"\"\n    \n    def __init__(self, original_tool: BaseTool, bedrock_name: str):\n        \"\"\"\n        Initialize the Bedrock-compatible tool wrapper.\n        \n        Args:\n            original_tool: The original LangChain tool\n            bedrock_name: The Bedrock-compatible name\n        \"\"\"\n        # Create metadata that includes the original name\n        metadata = dict(original_tool.metadata) if original_tool.metadata else {}\n        metadata['original_name'] = original_tool.name\n        \n        # Initialize the parent class with Bedrock-compatible name\n        super().__init__(\n            name=bedrock_name,\n            description=original_tool.description,\n            args_schema=original_tool.args_schema,\n            return_direct=getattr(original_tool, 'return_direct', False),\n            verbose=getattr(original_tool, 'verbose', False),\n            callbacks=getattr(original_tool, 'callbacks', None),\n            callback_manager=getattr(original_tool, 'callback_manager', None),\n            tags=getattr(original_tool, 'tags', None),\n            metadata=metadata,\n        )\n        \n        # Store the original tool using object.__setattr__ to bypass Pydantic validation\n        object.__setattr__(self, '_original_tool', original_tool)\n    \n    def _run(self, *args, **kwargs) -> Any:\n        \"\"\"Run the original tool synchronously (required abstract method).\"\"\"\n        # This method is required by BaseTool but we prefer to use invoke\n        return self._original_tool._run(*args, **kwargs)\n    \n    async def _arun(self, *args, **kwargs) -> Any:\n        \"\"\"Run the original tool asynchronously (required abstract method).\"\"\"\n        # This method is required by BaseTool but we prefer to use ainvoke\n        return await self._original_tool._arun(*args, **kwargs)\n    \n    def invoke(self, input: Dict[str, Any], config: Optional[RunnableConfig] = None, **kwargs) -> Any:\n        \"\"\"Invoke the original tool synchronously.\"\"\"\n        return self._original_tool.invoke(input, config, **kwargs)\n    \n    async def ainvoke(self, input: Dict[str, Any], config: Optional[RunnableConfig] = None, **kwargs) -> Any:\n        \"\"\"Invoke the original tool asynchronously.\"\"\"\n        return await self._original_tool.ainvoke(input, config, **kwargs)\n    \n    @property\n    def original_name(self) -> str:\n        \"\"\"Get the original tool name.\"\"\"\n        return self._original_tool.name\n    \n    @property\n    def original_tool(self) -> BaseTool:\n        \"\"\"Get the original tool.\"\"\"\n        return self._original_tool\n\n\ndef restore_original_tool_names(tool_calls: List[Dict], name_mapping: Dict[str, str]) -> List[Dict]:\n    \"\"\"\n    Restore original tool names in tool calls from Bedrock.\n    \n    Args:\n        tool_calls: List of tool calls with Bedrock names\n        name_mapping: Mapping from Bedrock names to original names\n        \n    Returns:\n        List of tool calls with original names restored\n    \"\"\"\n    restored_calls = []\n    \n    for call in tool_calls:\n        restored_call = call.copy()\n        \n        # Restore the original name if it exists in mapping\n        if 'name' in restored_call and restored_call['name'] in name_mapping:\n            restored_call['name'] = name_mapping[restored_call['name']]\n        \n        restored_calls.append(restored_call)\n    \n    return restored_calls\n",
      "line_count": 172,
      "word_count": 568,
      "title": "Bedrock Utils.Py",
      "summary": "Bedrock-specific utilities for LangChain UTCP Adapters. This module provides utilities for formatting UTCP tools to work with Amazon Bedrock's",
      "key_terms": [
        "we",
        "RunnableConfig",
        "async",
        "chars",
        "pattern",
        "kwargs",
        "Bedrock-specific",
        "compatible",
        "other",
        "original",
        "potentially",
        "using",
        "work",
        "if",
        "Formatted",
        "that",
        "Run",
        "super",
        "strict",
        "object"
      ],
      "timestamp": "2025-12-24T18:56:08.383320"
    },
    {
      "file_path": "UPSTREAM\\langchain-utcp-adapters\\langchain_utcp_adapters\\tools.py",
      "content_type": "code",
      "content": "\"\"\"Tools adapter for converting UTCP tools to LangChain tools.\n\nThis module provides functionality to convert UTCP tools into LangChain-compatible\ntools, handle tool execution, and manage tool conversion between the two formats.\n\"\"\"\n\nimport json\nimport logging\nfrom typing import Any, Dict, List, Optional\n\nfrom langchain_core.tools import BaseTool, StructuredTool, ToolException\nfrom pydantic import BaseModel, create_model, ConfigDict\nfrom utcp.utcp_client import UtcpClient\nfrom utcp.data.tool import Tool as UTCPTool\n\n# Configure logger for this module\nlogger = logging.getLogger(__name__)\n\n\ndef _convert_utcp_result(result: Any) -> str:\n    \"\"\"Convert UTCP tool result to LangChain tool result format.\n\n    Args:\n        result: The result from calling a UTCP tool.\n\n    Returns:\n        A string representation of the result.\n\n    Raises:\n        ToolException: If the tool call resulted in an error.\n    \"\"\"\n    if isinstance(result, dict) and result.get(\"error\"):\n        raise ToolException(str(result[\"error\"]))\n    \n    if isinstance(result, (dict, list)):\n        return json.dumps(result, indent=2)\n    \n    return str(result)\n\n\ndef _create_pydantic_model_from_schema(\n    schema: Dict[str, Any], \n    model_name: str = \"ToolInput\"\n) -> type[BaseModel]:\n    \"\"\"Create a Pydantic model from a JSON schema.\n\n    Args:\n        schema: JSON schema dictionary (from UTCP JsonSchema object)\n        model_name: Name for the generated model\n\n    Returns:\n        A Pydantic BaseModel class\n    \"\"\"\n    # Handle the case where schema has properties directly (UTCP 1.0.1+ format)\n    properties = schema.get(\"properties\", {})\n    required = schema.get(\"required\", [])\n    \n    # Handle case where the schema itself might be empty or malformed\n    if not isinstance(properties, dict):\n        properties = {}\n    \n    if not isinstance(required, list):\n        required = []\n    \n    # If no properties and schema type is not object, create a simple value model\n    if not properties and schema.get(\"type\") not in [None, \"object\"]:\n        schema_type = schema.get(\"type\", \"string\")\n        field_type = _json_schema_to_python_type({\"type\": schema_type})\n        return create_model(model_name, value=(field_type, ...))\n    \n    field_definitions = {}\n    \n    for field_name, field_schema in properties.items():\n        if not isinstance(field_schema, dict):\n            # Skip malformed field schemas\n            continue\n            \n        field_type = _json_schema_to_python_type(field_schema)\n        \n        # Determine if field is required and set appropriate default\n        if field_name in required:\n            default_value = ...  # Required field\n        else:\n            # Optional field - use None as default, but wrap type in Optional\n            field_type = Optional[field_type]\n            default_value = None\n        \n        field_definitions[field_name] = (field_type, default_value)\n    \n    # If no valid field definitions, create a model that accepts any keyword arguments\n    if not field_definitions:\n        # Create a flexible model that can accept any arguments\n        # This handles tools with no defined input schema\n        class FlexibleModel(BaseModel):\n            model_config = ConfigDict(extra=\"allow\")  # Allow additional fields\n        \n        # Dynamically set the model name\n        FlexibleModel.__name__ = model_name\n        return FlexibleModel\n    \n    return create_model(model_name, **field_definitions)\n\n\ndef _json_schema_to_python_type(schema: Dict[str, Any]) -> type:\n    \"\"\"Convert JSON schema type to Python type.\n\n    Args:\n        schema: JSON schema for a field\n\n    Returns:\n        Python type corresponding to the schema\n    \"\"\"\n    if not isinstance(schema, dict):\n        return str  # Fallback for malformed schemas\n    \n    schema_type = schema.get(\"type\", \"string\")\n    \n    # Handle None type (default to string)\n    if schema_type is None:\n        schema_type = \"string\"\n    \n    # Handle array types with items specification\n    if schema_type == \"array\":\n        items_schema = schema.get(\"items\", {\"type\": \"string\"})\n        if isinstance(items_schema, dict):\n            item_type = _json_schema_to_python_type(items_schema)\n            return List[item_type]\n        else:\n            return List[Any]  # Fallback for complex items schemas\n    \n    # Handle union types (anyOf, oneOf)\n    if \"anyOf\" in schema or \"oneOf\" in schema:\n        # For simplicity, use Any for union types\n        # In a more sophisticated implementation, we could create Union types\n        return Any\n    \n    type_mapping = {\n        \"string\": str,\n        \"integer\": int,\n        \"number\": float,\n        \"boolean\": bool,\n        \"array\": List[Any],  # Fallback if not handled above\n        \"object\": Dict[str, Any],\n        \"null\": type(None),\n    }\n    \n    return type_mapping.get(schema_type, str)  # Default to str for unknown types\n\n\ndef convert_utcp_tool_to_langchain_tool(\n    utcp_client: UtcpClient,\n    tool: UTCPTool,\n) -> BaseTool:\n    \"\"\"Convert a UTCP tool to a LangChain tool.\n\n    Args:\n        utcp_client: UTCP client instance for tool execution\n        tool: UTCP tool to convert\n\n    Returns:\n        A LangChain tool\n    \"\"\"\n    \n    async def call_tool(**arguments: Dict[str, Any]) -> str:\n        \"\"\"Execute the UTCP tool with given arguments.\"\"\"\n        try:\n            # Tool names from UTCP are already properly namespaced as 'manual_name.tool_name'\n            # The UTCP client handles the namespacing during tool registration\n            result = await utcp_client.call_tool(tool.name, arguments)\n            return _convert_utcp_result(result)\n        except Exception as e:\n            raise ToolException(f\"Error calling UTCP tool {tool.name}: {str(e)}\") from e\n\n    # Create Pydantic model from tool input schema\n    # Handle JsonSchema object from UTCP 1.0.1+\n    if hasattr(tool.inputs, 'model_dump'):\n        # JsonSchema is a Pydantic model, use model_dump()\n        schema_dict = tool.inputs.model_dump(by_alias=True, exclude_none=True)\n    elif hasattr(tool.inputs, '__dict__'):\n        # Fallback for older formats or plain objects\n        schema_dict = tool.inputs.__dict__\n    elif isinstance(tool.inputs, dict):\n        # Already a dictionary\n        schema_dict = tool.inputs\n    else:\n        # Unknown format, create empty schema\n        schema_dict = {\"type\": \"object\", \"properties\": {}}\n    \n    args_schema = _create_pydantic_model_from_schema(\n        schema_dict,\n        f\"{tool.name.replace('.', '_')}Input\"\n    )\n\n    # Extract manual call template name from the namespaced tool name\n    # UTCP tools are namespaced as 'manual_name.tool_name'\n    manual_name = tool.name.split('.')[0] if '.' in tool.name else \"unknown\"\n    \n    # Get call template type from the tool's call template with proper validation\n    call_template_type = \"unknown\"\n    if (hasattr(tool, 'tool_call_template') and \n        tool.tool_call_template is not None and \n        hasattr(tool.tool_call_template, 'call_template_type')):\n        call_template_type = tool.tool_call_template.call_template_type\n    \n    return StructuredTool(\n        name=tool.name,  # Use the full namespaced name from UTCP (manual_name.tool_name)\n        description=tool.description or f\"UTCP tool: {tool.name}\",\n        args_schema=args_schema,\n        coroutine=call_tool,\n        metadata={\n            \"manual_name\": manual_name,  # The manual/call template name\n            \"call_template\": manual_name,  # For backward compatibility\n            \"call_template_type\": call_template_type,\n            \"tags\": tool.tags,\n            \"utcp_tool\": True,\n        },\n    )\n\n\nasync def load_utcp_tools(\n    utcp_client: UtcpClient,\n    call_template_name: Optional[str] = None,\n) -> List[BaseTool]:\n    \"\"\"Load all available UTCP tools and convert them to LangChain tools.\n\n    Args:\n        utcp_client: The UTCP client instance\n        call_template_name: Optional call template name to filter tools\n\n    Returns:\n        List of LangChain tools\n    \"\"\"\n    try:\n        # Get all tools from the UTCP client using search with empty string and high limit\n        all_tools = await utcp_client.search_tools(\"\", limit=1000)\n    except Exception as e:\n        logger.error(\"Failed to load tools from UTCP client: %s\", e)\n        return []\n    \n    # Filter by call template if specified\n    if call_template_name:\n        # Improved filtering with better null checks\n        filtered_tools = []\n        for tool in all_tools:\n            if (hasattr(tool, 'tool_call_template') and \n                tool.tool_call_template is not None and\n                hasattr(tool.tool_call_template, 'name')):\n                \n                # Extract manual name from tool name for comparison\n                tool_manual_name = tool.name.split('.')[0] if '.' in tool.name else \"unknown\"\n                \n                if tool_manual_name == call_template_name:\n                    filtered_tools.append(tool)\n        \n        all_tools = filtered_tools\n    \n    # Convert each UTCP tool to a LangChain tool\n    langchain_tools = []\n    for utcp_tool in all_tools:\n        try:\n            langchain_tool = convert_utcp_tool_to_langchain_tool(utcp_client, utcp_tool)\n            langchain_tools.append(langchain_tool)\n        except Exception as e:\n            # Log the error but continue with other tools\n            logger.warning(\"Failed to convert tool %s: %s\", utcp_tool.name, e)\n    \n    return langchain_tools\n\n\nasync def search_utcp_tools(\n    utcp_client: UtcpClient,\n    query: str,\n    call_template_name: Optional[str] = None,\n    max_results: Optional[int] = None,\n) -> List[BaseTool]:\n    \"\"\"Search for UTCP tools and convert them to LangChain tools.\n\n    Args:\n        utcp_client: The UTCP client instance\n        query: Search query string\n        call_template_name: Optional call template name to filter tools\n        max_results: Maximum number of results to return\n\n    Returns:\n        List of relevant LangChain tools\n    \"\"\"\n    search_results = []\n    \n    # Try UTCP's built-in search functionality first\n    try:\n        limit = max_results if max_results is not None else 1000\n        search_results = await utcp_client.search_tools(query, limit=limit)\n    except Exception as e:\n        logger.warning(\"UTCP search failed (%s), attempting fallback methods\", e)\n        \n        # Fallback 1: Try to get all tools with empty query (sometimes works when specific queries fail)\n        try:\n            logger.info(\"Trying to get all tools with empty query...\")\n            all_tools = await utcp_client.search_tools(\"\", limit=1000)\n            \n            # Manually filter the results\n            query_lower = query.lower()\n            search_results = []\n            \n            for tool in all_tools:\n                # Search in name, description, and tags\n                if (query_lower in tool.name.lower() or \n                    query_lower in tool.description.lower() or\n                    any(query_lower in tag.lower() for tag in tool.tags)):\n                    search_results.append(tool)\n            \n            logger.info(\"Fallback search found %d matching tools\", len(search_results))\n            \n        except Exception as e2:\n            logger.warning(\"Fallback search also failed (%s)\", e2)\n            \n            # Fallback 2: Try to use load_utcp_tools and filter manually\n            try:\n                logger.info(\"Trying to load all tools via load_utcp_tools...\")\n                # Use the load function which might have different error handling\n                all_langchain_tools = await load_utcp_tools(utcp_client, call_template_name)\n                \n                # Filter the LangChain tools by query\n                query_lower = query.lower()\n                filtered_tools = []\n                \n                for tool in all_langchain_tools:\n                    if (query_lower in tool.name.lower() or \n                        query_lower in tool.description.lower() or\n                        any(query_lower in tag.lower() for tag in tool.metadata.get(\"tags\", []))):\n                        filtered_tools.append(tool)\n                \n                # Apply max_results limit if specified\n                if max_results:\n                    filtered_tools = filtered_tools[:max_results]\n                \n                logger.info(\"Final fallback found %d matching tools\", len(filtered_tools))\n                return filtered_tools\n                \n            except Exception as e3:\n                logger.error(\"All fallback methods failed (%s). Returning empty list.\", e3)\n                return []\n    \n    # Apply max_results limit if specified (for successful search)\n    if max_results and len(search_results) > max_results:\n        search_results = search_results[:max_results]\n    \n    # Filter by call template if specified\n    if call_template_name:\n        search_results = [\n            tool for tool in search_results \n            if hasattr(tool, 'tool_call_template') and \n               tool.tool_call_template is not None and\n               hasattr(tool.tool_call_template, 'name') and \n               tool.tool_call_template.name == call_template_name\n        ]\n    \n    # Convert each UTCP tool to a LangChain tool\n    langchain_tools = []\n    for utcp_tool in search_results:\n        try:\n            langchain_tool = convert_utcp_tool_to_langchain_tool(utcp_client, utcp_tool)\n            langchain_tools.append(langchain_tool)\n        except Exception as e:\n            # Log the error but continue with other tools\n            logger.warning(\"Failed to convert tool %s: %s\", utcp_tool.name, e)\n    \n    return langchain_tools\n",
      "line_count": 369,
      "word_count": 1371,
      "title": "Tools.Py",
      "summary": "\"\"\"Tools adapter for converting UTCP tools to LangChain tools. This module provides functionality to convert UTCP tools into LangChain-compatible",
      "key_terms": [
        "lower",
        "resulted",
        "we",
        "Fallback",
        "Python",
        "simplicity",
        "null",
        "async",
        "number",
        "search",
        "error",
        "StructuredTool",
        "convert",
        "If",
        "each",
        "list",
        "ToolInput",
        "info",
        "compatible",
        "format"
      ],
      "timestamp": "2025-12-24T18:56:08.414984"
    },
    {
      "file_path": "UPSTREAM\\langchain-utcp-adapters\\langchain_utcp_adapters\\__init__.py",
      "content_type": "code",
      "content": "\"\"\"LangChain UTCP Adapters.\n\nThis package provides adapters to make Universal Tool Calling Protocol (UTCP) tools\ncompatible with LangChain and LangGraph.\n\"\"\"\n\nfrom langchain_utcp_adapters.tools import (\n    convert_utcp_tool_to_langchain_tool,\n    load_utcp_tools,\n    search_utcp_tools,\n)\n\nfrom langchain_utcp_adapters.bedrock_utils import (\n    format_tool_name_for_bedrock,\n    create_bedrock_tool_mapping,\n    BedrockCompatibleTool,\n    restore_original_tool_names,\n)\n\n__version__ = \"0.1.0\"\n\n__all__ = [\n    # Core tool conversion functions\n    \"convert_utcp_tool_to_langchain_tool\", \n    \"load_utcp_tools\",\n    \"search_utcp_tools\",\n    # Bedrock compatibility utilities\n    \"format_tool_name_for_bedrock\",\n    \"create_bedrock_tool_mapping\",\n    \"BedrockCompatibleTool\",\n    \"restore_original_tool_names\",\n]\n",
      "line_count": 33,
      "word_count": 61,
      "title": "  Init  .Py",
      "summary": "\"\"\"LangChain UTCP Adapters. This package provides adapters to make Universal Tool Calling Protocol (UTCP) tools",
      "key_terms": [
        "conversion",
        "compatibility",
        "from",
        "Bedrock",
        "BedrockCompatibleTool",
        "make",
        "utcp",
        "compatible",
        "with",
        "Tool",
        "adapters",
        "utilities",
        "LangGraph",
        "tool",
        "Universal",
        "and",
        "Adapters",
        "package",
        "This",
        "UTCP"
      ],
      "timestamp": "2025-12-24T18:56:08.424362"
    },
    {
      "file_path": "UPSTREAM\\langchain-utcp-adapters\\tests\\test_providers.json",
      "content_type": "configuration",
      "content": "{\n    \"manual_call_templates\": [\n        {\n            \"name\": \"openlibrary\",\n            \"call_template_type\": \"http\",\n            \"http_method\": \"GET\",\n            \"url\": \"https://openlibrary.org/static/openapi.json\",\n            \"content_type\": \"application/json\"\n        },\n        {\n            \"name\": \"newsapi\",\n            \"call_template_type\": \"text\",\n            \"file_path\": \"./examples/newsapi_manual.json\"\n        }\n    ]\n}",
      "line_count": 16,
      "word_count": 25,
      "title": "Test Providers.Json",
      "summary": "\"manual_call_templates\": [ \"name\": \"openlibrary\",",
      "key_terms": [
        "url",
        "https",
        "GET",
        "org",
        "text",
        "api",
        "json",
        "newsapi",
        "static",
        "openlibrary",
        "openapi",
        "application",
        "method",
        "http",
        "examples",
        "name"
      ],
      "timestamp": "2025-12-24T18:56:08.430887"
    },
    {
      "file_path": "UPSTREAM\\langchain-utcp-adapters\\tests\\test_real_providers.py",
      "content_type": "code",
      "content": "#!/usr/bin/env python3\n\"\"\"Test script for LangChain UTCP Adapters with real providers.\n\nThis script tests the package with actual UTCP providers to validate \nthat real tools are loaded and working correctly.\n\"\"\"\n\nimport asyncio\nfrom utcp.utcp_client import UtcpClient\nfrom utcp.data.utcp_client_config import UtcpClientConfig\nfrom langchain_utcp_adapters import load_utcp_tools, search_utcp_tools\n\n\nasync def test_real_providers():\n    \"\"\"Test with real UTCP providers to validate functionality.\"\"\"\n    print('üß™ Testing LangChain UTCP Adapters with Real Providers')\n    print('=' * 60)\n    \n    try:\n        # Create UTCP client directly\n        print('üì° Creating UTCP client...')\n        config = UtcpClientConfig()\n        client = await UtcpClient.create(config=config)\n        print('‚úÖ Client created successfully')\n        \n        # Register a real provider (OpenLibrary)\n        print('\\nüìã Registering OpenLibrary provider...')\n        await client.register_tool_provider({\n            \"name\": \"openlibrary\",\n            \"provider_type\": \"http\",\n            \"http_method\": \"GET\",\n            \"url\": \"https://openlibrary.org/static/openapi.json\",\n            \"content_type\": \"application/json\"\n        })\n        print('‚úÖ Provider registered successfully')\n        \n        # Load tools\n        print('\\nüîß Loading tools...')\n        tools = await load_utcp_tools(client)\n        print(f'‚úÖ Successfully loaded {len(tools)} tools')\n        \n        # Validate tools\n        assert len(tools) > 0, \"Should have loaded at least one tool\"\n        \n        # Check tool properties\n        for tool in tools[:3]:  # Check first 3 tools\n            print(f'  üìñ Tool: {tool.name}')\n            print(f'     Description: {tool.description}')\n            print(f'     Provider: {tool.metadata.get(\"provider\", \"unknown\")}')\n            \n            # Validate tool has required properties\n            assert hasattr(tool, 'name'), \"Tool should have name\"\n            assert hasattr(tool, 'description'), \"Tool should have description\"\n            assert hasattr(tool, 'args_schema'), \"Tool should have args_schema\"\n            assert tool.metadata.get('utcp_tool') is True, \"Tool should be marked as UTCP tool\"\n        \n        # Test search functionality\n        print('\\nüîç Testing search functionality...')\n        search_results = await search_utcp_tools(client, \"books\", max_results=3)\n        print(f'‚úÖ Search returned {len(search_results)} results')\n        \n        # Validate search results\n        for tool in search_results:\n            print(f'  üîé Found: {tool.name}')\n            assert 'books' in tool.name.lower() or 'books' in tool.description.lower() or any('books' in tag.lower() for tag in tool.metadata.get('tags', [])), \\\n                \"Search result should be related to 'books'\"\n        \n        print('\\nüéâ All tests passed successfully!')\n        return True\n        \n    except Exception as e:\n        print(f'‚ùå Test failed with error: {e}')\n        import traceback\n        traceback.print_exc()\n        return False\n\n\n# Run the test\nif __name__ == \"__main__\":\n    success = asyncio.run(test_real_providers())\n    exit(0 if success else 1)\n",
      "line_count": 82,
      "word_count": 301,
      "title": "Test Real Providers.Py",
      "summary": "\"\"\"Test script for LangChain UTCP Adapters with real providers. This script tests the package with actual UTCP providers to validate",
      "key_terms": [
        "lower",
        "traceback",
        "async",
        "search",
        "error",
        "Utcp",
        "unknown",
        "providers",
        "Test",
        "Found",
        "except",
        "has",
        "application",
        "https",
        "if",
        "that",
        "Run",
        "books",
        "exit",
        "script"
      ],
      "timestamp": "2025-12-24T18:56:08.462666"
    },
    {
      "file_path": "UPSTREAM\\langchain-utcp-adapters\\tests\\test_tools.py",
      "content_type": "code",
      "content": "\"\"\"Tests for UTCP to LangChain tool conversion.\"\"\"\n\nimport pytest\nfrom unittest.mock import AsyncMock, MagicMock, patch\n\nfrom langchain_utcp_adapters.tools import (\n    convert_utcp_tool_to_langchain_tool,\n    load_utcp_tools,\n    search_utcp_tools,\n    _convert_utcp_result,\n    _create_pydantic_model_from_schema,\n    _json_schema_to_python_type,\n)\nfrom utcp.data.tool import Tool as UTCPTool, JsonSchema\nfrom utcp_http.http_call_template import HttpCallTemplate\n\n\nclass TestToolConversion:\n    \"\"\"Test UTCP to LangChain tool conversion.\"\"\"\n\n    def test_convert_utcp_result_string(self):\n        \"\"\"Test converting string result.\"\"\"\n        result = \"Hello, world!\"\n        converted = _convert_utcp_result(result)\n        assert converted == \"Hello, world!\"\n\n    def test_convert_utcp_result_dict(self):\n        \"\"\"Test converting dictionary result.\"\"\"\n        result = {\"message\": \"success\", \"data\": [1, 2, 3]}\n        converted = _convert_utcp_result(result)\n        # Check that the JSON contains the expected content (formatting may vary)\n        assert '\"message\"' in converted and '\"success\"' in converted\n        assert '\"data\"' in converted and '1' in converted and '2' in converted and '3' in converted\n\n    def test_convert_utcp_result_error(self):\n        \"\"\"Test converting error result.\"\"\"\n        result = {\"error\": \"Something went wrong\"}\n        with pytest.raises(Exception) as exc_info:\n            _convert_utcp_result(result)\n        assert \"Something went wrong\" in str(exc_info.value)\n\n    def test_json_schema_to_python_type(self):\n        \"\"\"Test JSON schema to Python type conversion.\"\"\"\n        assert _json_schema_to_python_type({\"type\": \"string\"}) == str\n        assert _json_schema_to_python_type({\"type\": \"integer\"}) == int\n        assert _json_schema_to_python_type({\"type\": \"number\"}) == float\n        assert _json_schema_to_python_type({\"type\": \"boolean\"}) == bool\n\n    def test_create_pydantic_model_from_schema(self):\n        \"\"\"Test creating Pydantic model from JSON schema.\"\"\"\n        schema = {\n            \"type\": \"object\",\n            \"properties\": {\n                \"name\": {\"type\": \"string\"},\n                \"age\": {\"type\": \"integer\"},\n                \"email\": {\"type\": \"string\"}\n            },\n            \"required\": [\"name\", \"age\"]\n        }\n        \n        model_class = _create_pydantic_model_from_schema(schema, \"TestModel\")\n        \n        # Test that required fields are properly set\n        model_instance = model_class(name=\"John\", age=30)\n        assert model_instance.name == \"John\"\n        assert model_instance.age == 30\n        assert model_instance.email is None\n\n    def test_create_pydantic_model_from_empty_schema(self):\n        \"\"\"Test creating Pydantic model from empty schema.\"\"\"\n        empty_schema = {\"type\": \"object\", \"properties\": {}}\n        \n        model_class = _create_pydantic_model_from_schema(empty_schema, \"EmptyModel\")\n        \n        # Test that the model can be created and accepts additional fields\n        model_instance = model_class()\n        assert model_instance is not None\n        \n        # Test that it can accept arbitrary keyword arguments\n        model_instance_with_data = model_class(arbitrary_field=\"test\")\n        assert model_instance_with_data.arbitrary_field == \"test\"\n\n    def test_create_pydantic_model_from_malformed_schema(self):\n        \"\"\"Test creating Pydantic model from malformed schema.\"\"\"\n        malformed_schema = {\"properties\": None, \"required\": \"not_a_list\"}\n        \n        model_class = _create_pydantic_model_from_schema(malformed_schema, \"MalformedModel\")\n        \n        # Should create a flexible model that doesn't crash\n        model_instance = model_class()\n        assert model_instance is not None\n\n    def test_tool_name_without_namespace(self):\n        \"\"\"Test tool name handling for tools without namespace (edge case).\"\"\"\n        from utcp_http.http_call_template import HttpCallTemplate\n        \n        provider = HttpCallTemplate(\n            name=\"test_provider\",\n            call_template_type=\"http\",\n            url=\"http://example.com/api\",\n            http_method=\"POST\"\n        )\n        \n        # Create a tool without namespace (edge case)\n        utcp_tool = UTCPTool(\n            name=\"standalone_tool\",  # No namespace\n            description=\"A standalone tool\",\n            inputs=JsonSchema(type=\"object\", properties={}),\n            outputs=JsonSchema(type=\"object\", properties={}),\n            tags=[],\n            tool_call_template=provider\n        )\n        \n        mock_client = AsyncMock()\n        langchain_tool = convert_utcp_tool_to_langchain_tool(mock_client, utcp_tool)\n        \n        # Should handle gracefully\n        assert langchain_tool.name == \"standalone_tool\"\n        assert langchain_tool.metadata[\"manual_name\"] == \"unknown\"  # Fallback for no namespace\n        assert langchain_tool.metadata[\"call_template\"] == \"unknown\"  # Fallback for backward compatibility\n\n    @pytest.mark.asyncio\n    async def test_convert_utcp_tool_to_langchain_tool(self):\n        \"\"\"Test converting UTCP tool to LangChain tool.\"\"\"\n        # Create mock UTCP client\n        mock_client = AsyncMock()\n        mock_client.call_tool.return_value = {\"result\": \"success\"}\n        \n        # Create UTCP tool\n        provider = HttpCallTemplate(\n            name=\"test_provider\",\n            call_template_type=\"http\",\n            url=\"http://example.com/api\",\n            http_method=\"POST\"\n        )\n        \n        utcp_tool = UTCPTool(\n            name=\"test_provider.test_tool\",  # Use namespaced name as UTCP would provide\n            description=\"A test tool\",\n            inputs=JsonSchema(\n                type=\"object\",\n                properties={\n                    \"input_text\": JsonSchema(type=\"string\")\n                },\n                required=[\"input_text\"]\n            ),\n            outputs=JsonSchema(\n                type=\"object\",\n                properties={\n                    \"output_text\": JsonSchema(type=\"string\")\n                }\n            ),\n            tags=[\"test\"],\n            tool_call_template=provider\n        )\n        \n        # Convert to LangChain tool\n        langchain_tool = convert_utcp_tool_to_langchain_tool(mock_client, utcp_tool)\n        \n        # Test tool properties\n        assert langchain_tool.name == \"test_provider.test_tool\"  # UTCP provides namespaced names\n        assert langchain_tool.description == \"A test tool\"\n        assert langchain_tool.metadata[\"call_template\"] == \"test_provider\"  # Extracted from tool name\n        assert langchain_tool.metadata[\"manual_name\"] == \"test_provider\"  # New explicit field\n        assert langchain_tool.metadata[\"call_template_type\"] == \"http\"\n        assert langchain_tool.metadata[\"utcp_tool\"] is True\n        \n        # Test tool execution\n        result = await langchain_tool.ainvoke({\"input_text\": \"hello\"})\n        assert \"success\" in result\n        mock_client.call_tool.assert_called_once_with(\n            \"test_provider.test_tool\",  # UTCP uses the namespaced tool name\n            {\"input_text\": \"hello\"}\n        )\n\n    @pytest.mark.asyncio\n    async def test_load_utcp_tools(self):\n        \"\"\"Test loading UTCP tools.\"\"\"\n        # Create mock UTCP client\n        mock_client = AsyncMock()\n        \n        # Create mock call template\n        provider = HttpCallTemplate(name=\"test_provider\", call_template_type=\"http\", url=\"http://example.com\")\n        \n        utcp_tool = UTCPTool(\n            name=\"test_provider.test_tool\",  # Use namespaced name\n            description=\"A test tool\",\n            inputs=JsonSchema(type=\"object\", properties={}),\n            outputs=JsonSchema(type=\"object\", properties={}),\n            tags=[],\n            tool_call_template=provider\n        )\n        \n        # Mock the search_tools method that load_utcp_tools actually uses\n        mock_client.search_tools.return_value = [utcp_tool]\n        \n        # Load tools\n        langchain_tools = await load_utcp_tools(mock_client)\n        \n        # Verify results\n        assert len(langchain_tools) == 1\n        assert langchain_tools[0].name == \"test_provider.test_tool\"\n        assert langchain_tools[0].metadata[\"utcp_tool\"] is True\n        \n        # Verify search_tools was called with empty string and high limit\n        mock_client.search_tools.assert_called_once_with(\"\", limit=1000)\n\n    @pytest.mark.asyncio\n    async def test_load_utcp_tools_with_provider_filter(self):\n        \"\"\"Test loading UTCP tools with call template filter.\"\"\"\n        # Create mock UTCP client\n        mock_client = AsyncMock()\n        \n        # Create mock call templates\n        provider1 = HttpCallTemplate(name=\"provider1\", call_template_type=\"http\", url=\"http://example1.com\")\n        provider2 = HttpCallTemplate(name=\"provider2\", call_template_type=\"http\", url=\"http://example2.com\")\n        \n        tool1 = UTCPTool(\n            name=\"provider1.tool1\",  # Use namespaced name\n            description=\"Tool 1\",\n            inputs=JsonSchema(type=\"object\", properties={}),\n            outputs=JsonSchema(type=\"object\", properties={}),\n            tags=[],\n            tool_call_template=provider1\n        )\n        \n        tool2 = UTCPTool(\n            name=\"provider2.tool2\",  # Use namespaced name\n            description=\"Tool 2\",\n            inputs=JsonSchema(type=\"object\", properties={}),\n            outputs=JsonSchema(type=\"object\", properties={}),\n            tags=[],\n            tool_call_template=provider2\n        )\n        \n        # Mock search_tools to return both tools\n        mock_client.search_tools.return_value = [tool1, tool2]\n        \n        # Load tools with call template filter\n        langchain_tools = await load_utcp_tools(mock_client, call_template_name=\"provider1\")\n        \n        # Verify only provider1 tools are returned\n        assert len(langchain_tools) == 1\n        assert langchain_tools[0].name == \"provider1.tool1\"\n\n    @pytest.mark.asyncio\n    async def test_search_utcp_tools(self):\n        \"\"\"Test searching UTCP tools.\"\"\"\n        # Create mock UTCP client\n        mock_client = AsyncMock()\n        \n        provider = HttpCallTemplate(name=\"test_provider\", call_template_type=\"http\", url=\"http://example.com\")\n        utcp_tool = UTCPTool(\n            name=\"test_provider.search_tool\",  # Use namespaced name\n            description=\"A searchable tool\",\n            inputs=JsonSchema(type=\"object\", properties={}),\n            outputs=JsonSchema(type=\"object\", properties={}),\n            tags=[],\n            tool_call_template=provider\n        )\n        \n        mock_client.search_tools.return_value = [utcp_tool]\n        \n        # Search tools\n        langchain_tools = await search_utcp_tools(mock_client, \"search query\")\n        \n        # Verify results\n        assert len(langchain_tools) == 1\n        assert langchain_tools[0].name == \"test_provider.search_tool\"\n        mock_client.search_tools.assert_called_once_with(\"search query\", limit=1000)\n\n    @pytest.mark.asyncio\n    async def test_search_utcp_tools_with_fallback(self):\n        \"\"\"Test search tools fallback logic when primary search fails.\"\"\"\n        # Create mock UTCP client\n        mock_client = AsyncMock()\n        \n        provider = HttpCallTemplate(name=\"test_provider\", call_template_type=\"http\", url=\"http://example.com\")\n        \n        utcp_tool = UTCPTool(\n            name=\"test_provider.fallback_tool\",\n            description=\"A tool for fallback testing\",\n            inputs=JsonSchema(type=\"object\", properties={}),\n            outputs=JsonSchema(type=\"object\", properties={}),\n            tags=[\"fallback\"],\n            tool_call_template=provider\n        )\n        \n        # Mock the primary search to fail, but empty search to succeed\n        def mock_search_side_effect(query, limit):\n            if query == \"fallback\":\n                raise Exception(\"Primary search failed\")\n            elif query == \"\":\n                return [utcp_tool]  # Empty search succeeds\n            else:\n                return []\n        \n        mock_client.search_tools.side_effect = mock_search_side_effect\n        \n        # Search tools - should trigger fallback\n        langchain_tools = await search_utcp_tools(mock_client, \"fallback\")\n        \n        # Verify fallback worked\n        assert len(langchain_tools) == 1\n        assert langchain_tools[0].name == \"test_provider.fallback_tool\"\n        \n        # Verify both calls were made (primary + fallback)\n        assert mock_client.search_tools.call_count == 2\n        mock_client.search_tools.assert_any_call(\"fallback\", limit=1000)  # Primary call\n        mock_client.search_tools.assert_any_call(\"\", limit=1000)  # Fallback call\n\n    @pytest.mark.asyncio\n    async def test_search_utcp_tools_complete_failure(self):\n        \"\"\"Test search tools when all methods fail.\"\"\"\n        # Create mock UTCP client that always fails\n        mock_client = AsyncMock()\n        mock_client.search_tools.side_effect = Exception(\"All search methods failed\")\n        \n        # Mock load_utcp_tools to also fail\n        with patch('langchain_utcp_adapters.tools.load_utcp_tools') as mock_load:\n            mock_load.side_effect = Exception(\"Load also failed\")\n            \n            # Search tools - should return empty list\n            langchain_tools = await search_utcp_tools(mock_client, \"test query\")\n            \n            # Verify graceful failure\n            assert len(langchain_tools) == 0\n",
      "line_count": 328,
      "word_count": 1001,
      "title": "Test Tools.Py",
      "summary": "\"\"\"Tests for UTCP to LangChain tool conversion.\"\"\" import pytest",
      "key_terms": [
        "trigger",
        "Fallback",
        "AsyncMock",
        "Python",
        "async",
        "number",
        "search",
        "error",
        "gracefully",
        "list",
        "uses",
        "primary",
        "high",
        "unknown",
        "only",
        "Test",
        "wrong",
        "string",
        "Something",
        "keyword"
      ],
      "timestamp": "2025-12-24T18:56:08.494887"
    }
  ],
  "timestamp": "2025-12-24T18:56:08.494887"
}