{
  "repository": "elixir-utcp",
  "commit_hash": "44faa5b05b27ddb78317addae14366fcf49e6266",
  "commit_timestamp": "1762880856",
  "file_count": 73,
  "extractions": [
    {
      "file_path": "UPSTREAM\\elixir-utcp\\CHANGELOG.md",
      "content_type": "documentation",
      "content": "# Changelog\n\nAll notable changes to this project will be documented in this file.\n\n## [0.3.1] - 2025-10-05\n\n### Added\n- WebRTC Transport: Peer-to-peer communication with WebRTC data channels\n- ExWebRTC library integration for W3C WebRTC API implementation\n- WebRTC connection management with signaling protocol\n- ICE candidate handling with STUN/TURN server support\n- WebRTC data channels for tool communication\n- Peer-to-peer tool calling without server intermediary\n- WebRTC signaling server client for SDP and ICE exchange\n- NAT traversal with configurable ICE servers\n- DTLS encryption for secure peer-to-peer communication\n- WebRTC streaming support with data channel multiplexing\n- 18 comprehensive WebRTC tests covering all transport features\n- WebRTC examples and documentation with setup guide\n- Sobelow security analysis tool integration\n\n### Changed\n- Updated Client module to include WebRTC transport in default transports\n- Enhanced Providers module with WebRTC provider configuration\n- Updated transport count from 7 to 8 transports\n- Improved README with updated transport coverage\n\n### Fixed\n- WebRTC provider configuration with proper ICE server defaults\n- Connection lifecycle management for WebRTC peers\n- Data channel message handling and serialization\n\n## [0.3.0] - 2025-10-04\n\n### Added\n- Monitoring and Metrics: Comprehensive monitoring system with telemetry integration\n- Telemetry events for all UTCP operations (tool calls, searches, provider registration, connections)\n- PromEx integration for Prometheus metrics collection and visualization\n- Health check system for monitoring transport and component health\n- Performance monitoring with operation timing and statistical analysis\n- Metrics collection system with counters, gauges, histograms, and summaries\n- System monitoring for memory usage, process counts, and scheduler utilization\n- Performance alerts and threshold-based monitoring\n- Custom metrics recording and aggregation\n- Monitoring dashboard configuration with PromEx\n- 15+ comprehensive monitoring tests covering all monitoring features\n- Monitoring examples and documentation\n\n### Changed\n- Enhanced Client module with monitoring and performance measurement integration\n- Added telemetry events to tool calls and search operations for performance tracking\n- Improved error handling with performance metrics for failed operations\n- Updated Client API with monitoring functions (get_monitoring_metrics, get_health_status, get_performance_summary)\n\n### Fixed\n- Performance measurement error handling with proper telemetry emission\n- Health check system robustness with fallback mechanisms\n- Metrics collection reliability with graceful degradation when services unavailable\n\n## [0.2.9] - 2025-10-04\n\n### Added\n- Advanced Search: Comprehensive search system with multiple algorithms\n- FuzzyCompare integration for advanced fuzzy string matching\n- Haystack integration for full-text search capabilities\n- TruffleHog integration for sensitive data detection in search results\n- Search algorithms: exact, fuzzy, semantic, and combined search\n- Search filters by provider, transport type, and tags\n- Search result ranking and scoring system\n- Security scanning for tools and providers with sensitive data detection\n- Search suggestions and similar tool discovery\n- 40+ comprehensive search tests covering all algorithms and features\n- Advanced search examples and documentation\n\n### Changed\n- Enhanced Client module with advanced search functionality\n- Improved search result structure with security warnings and match metadata\n- Updated search options to include security scanning and filtering\n- Enhanced tool and provider discovery with intelligent ranking\n\n### Fixed\n- Search result ranking algorithm for accurate relevance scoring\n- Fuzzy search integration with proper similarity calculations\n- Semantic search keyword extraction and matching\n- Security scanning fallback mechanisms for robust operation\n\n## [0.2.8] - 2025-10-04\n\n### Added\n- Test configuration for integration test exclusion by default\n- Proper test tagging system with @tag :integration and @tag :unit\n- TCP/UDP transport implementation with connection management and pooling\n- TCP/UDP transport streaming support with proper metadata\n- TCP/UDP transport retry logic with exponential backoff\n- TCP/UDP transport connection behaviors and testable modules\n- TCP/UDP transport integration tests for real network connections\n- TCP/UDP transport mock tests with Mox integration\n- TCP/UDP transport examples and documentation\n\n### Changed\n- Test helper configuration to exclude integration tests by default (mix test)\n- Integration tests now require explicit inclusion (mix test --include integration)\n- TCP connection tests properly tagged as integration tests\n- Improved test isolation and reliability for unit tests\n- Enhanced test documentation and organization\n\n### Fixed\n- Test suite reliability by separating unit tests from integration tests\n- TCP/UDP mock test isolation issues with unique GenServer processes\n- Test timeout issues in TCP/UDP mock tests\n- Proper categorization of network-dependent tests as integration tests\n- Test configuration to prevent flaky tests in CI/CD environments\n\n## [0.2.7] - 2025-10-03\n\n### Added\n- OpenAPI Converter: Automatic API discovery and tool generation\n- Support for OpenAPI 2.0 (Swagger) and OpenAPI 3.0 specifications\n- JSON and YAML specification parsing\n- URL and file-based specification loading\n- Authentication scheme mapping (API Key, Basic, Bearer, OAuth2, OpenID Connect)\n- Tool generation from OpenAPI operations\n- Client integration for OpenAPI conversion\n- 12 comprehensive OpenAPI Converter tests\n- OpenAPI Converter examples and documentation\n\n### Changed\n- Updated gap analysis to reflect OpenAPI Converter completion\n- Enhanced documentation with OpenAPI Converter usage examples\n- Updated test count to 272+ tests\n\n### Fixed\n- Elixir type usage patterns in OpenAPI Converter\n- Infinite recursion in schema parsing\n- Content type handling for URL-based specifications\n- Prefix duplication in tool name generation\n- Argument error in security scheme parsing\n- Authentication parameter mapping\n\n## [0.2.6] - 2024-12-19\n\n### Added\n- Comprehensive streaming support across all transports\n- Enhanced type system with stream_chunk, stream_result, stream_error, and stream_end types\n- HTTP Server-Sent Events (SSE) streaming implementation\n- Enhanced WebSocket streaming with proper metadata tracking\n- Improved GraphQL streaming with subscription support\n- Enhanced gRPC streaming with service-specific metadata\n- Improved MCP streaming with JSON-RPC 2.0 support\n- 21 comprehensive streaming unit tests\n- Complete streaming examples for all transports\n- Advanced stream processing patterns and utilities\n\n### Changed\n- HTTP transport now supports streaming (supports_streaming? returns true)\n- All transport streaming implementations enhanced with rich metadata\n- Stream result structures standardized across all transports\n- Enhanced error handling and stream termination across all transports\n\n### Fixed\n- Stream processing consistency across all transports\n- Metadata tracking and sequence numbering\n- Error handling in streaming scenarios\n- Type safety improvements for streaming operations\n\n## [0.2.5] - 2024-12-19\n\n### Added\n- Comprehensive test suite with 260+ unit tests\n- Mock-based unit testing with Mox for all transports\n- Integration test tagging for proper test separation\n- Testable modules for isolated unit testing\n- Complete test coverage for all transport implementations\n\n### Changed\n- Enhanced test architecture with proper mock injection\n- Improved test reliability and maintainability\n- Updated gap analysis to reflect 100% testing coverage\n- Enhanced documentation with protocol and library links\n- Removed decorative formatting from documentation\n\n### Fixed\n- All test failures resolved (reduced from 75 to 0 failures)\n- Proper GenServer lifecycle handling in unit tests\n- Retry logic call count expectations in tests\n- Mock verification and expectation management\n\n## [0.2.4] - 2024-12-19\n\n### Added\n- Production-ready MCP (Model Context Protocol) transport implementation\n- JSON-RPC 2.0 support for MCP communication\n- MCP connection management with pooling and lifecycle management\n- MCP authentication support for API Key, Basic, and OAuth2\n- MCP error recovery with retry logic and exponential backoff\n- MCP tool calling and streaming capabilities\n- Comprehensive MCP testing suite with 26 tests\n- MCP usage examples demonstrating all features\n\n### Changed\n- Enhanced MCP transport with production-ready features\n- Updated MCP implementation to use real HTTP connections\n- Improved error handling and retry mechanisms for MCP operations\n- Enhanced connection pooling and lifecycle management\n\n## [0.2.3] - 2025-09-29\n\n### Added\n- Production-ready GraphQL transport implementation with HTTP/HTTPS support\n- GraphQL connection management with pooling and lifecycle management\n- GraphQL authentication support for API Key, Basic, and OAuth2\n- GraphQL error recovery with retry logic and exponential backoff\n- GraphQL schema introspection for automatic tool discovery\n- GraphQL query, mutation, and subscription support\n- GraphQL streaming capabilities for real-time data\n- Comprehensive GraphQL testing suite with 18 tests\n- GraphQL usage examples demonstrating all features\n\n### Changed\n- Enhanced GraphQL transport with production-ready features\n- Updated GraphQL implementation to use real HTTP connections\n- Improved error handling and retry mechanisms for GraphQL operations\n- Enhanced connection pooling and lifecycle management\n\n## [0.2.2] - 2025-09-28\n>>>>>>> fc29827 (updated readme)\n\n### Added\n- Production-ready gRPC transport implementation with Protocol Buffer integration\n- gRPC connection management with pooling and lifecycle management\n- gRPC authentication support for API Key, Basic, and OAuth2\n- gRPC error recovery with retry logic and exponential backoff\n- gNMI integration for network management operations\n- gNMI Get, Set, and Subscribe operations with path validation\n- Protocol Buffer code generation from .proto files\n- Comprehensive gRPC testing suite with 82 tests\n- gRPC production example demonstrating all features\n\n### Changed\n- Enhanced gRPC transport with production-ready features\n- Updated gRPC implementation to use real Protocol Buffer integration\n- Improved error handling and retry mechanisms for gRPC operations\n- Enhanced connection pooling and lifecycle management\n\n\n## [0.2.1]  - 2025-09-28\n\n### Added\n- Production-ready WebSocket transport implementation with real WebSockex integration\n- WebSocket connection management with pooling and lifecycle management\n- WebSocket error recovery with retry logic and exponential backoff\n- WebSocket performance optimizations with connection reuse and message batching\n- WebSocket connection behavior for testability\n- Comprehensive WebSocket mock-based testing suite\n- WebSocket testable module for isolated unit testing\n\n### Changed\n- Enhanced WebSocket transport with production-ready features\n- Improved WebSocket testing with Mox mocks\n- Updated WebSocket implementation to use real WebSocket connections\n- Enhanced error handling and retry mechanisms for WebSocket operations\n\n\n## [0.2.0] - 2025-09-28\n\n\n### Added\n- WebSocket transport implementation for real-time bidirectional communication\n- WebSocket provider support with full configuration options\n- WebSocket streaming functionality for real-time data streaming\n- Comprehensive WebSocket test suite\n- WebSocket client and server examples\n- Enhanced provider type system with WebSocket-specific fields\n- gRPC transport implementation for high-performance RPC calls\n- gRPC provider support with Protocol Buffer integration\n- gRPC streaming functionality for real-time data streaming\n- Comprehensive gRPC test suite\n- gRPC client example\n- Protocol Buffer definition file (proto/utcp.proto)\n- Enhanced provider type system with gRPC-specific fields\n\n### Changed\n- Updated client to support WebSocket and gRPC providers\n- Enhanced provider parsing to handle WebSocket and gRPC configuration\n- Extended type definitions for WebSocket and gRPC providers\n- Updated gap analysis to reflect 33% transport coverage (4/12 types)\n\n## [0.1.0] - 2025-09-27\n\n### Added\n- Initial release of ExUtcp library\n- HTTP transport implementation\n- CLI transport implementation\n- Core UTCP client functionality\n- Tool discovery and execution\n- Provider management system\n- Authentication support (API Key, Basic, OAuth2)\n- Configuration management with variable substitution\n- Comprehensive test suite\n- Example applications and documentation\n",
      "line_count": 301,
      "word_count": 1766,
      "title": "Changelog",
      "summary": "All notable changes to this project will be documented in this file. - WebRTC Transport: Peer-to-peer communication with WebRTC data channels",
      "key_terms": [
        "comprehensive",
        "Model",
        "exclude",
        "WebSocket-specific",
        "testability",
        "Type",
        "helper",
        "providers",
        "WebSockex",
        "multiple",
        "degradation",
        "expectation",
        "termination",
        "definitions",
        "call",
        "supports",
        "WebRTC",
        "Integration",
        "calls",
        "Fuzzy"
      ],
      "timestamp": "2025-12-24T18:56:00.331909"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\README.md",
      "content_type": "documentation",
      "content": "# ExUtcp\n\n[![Hex.pm](https://img.shields.io/hexpm/v/ex_utcp.svg)](https://hex.pm/packages/ex_utcp)\n[![Hex.pm](https://img.shields.io/hexpm/dt/ex_utcp.svg)](https://hex.pm/packages/ex_utcp)\n[![Hex.pm](https://img.shields.io/hexpm/l/ex_utcp.svg)](https://hex.pm/packages/ex_utcp)\n[![HexDocs.pm](https://img.shields.io/badge/hex-docs-lightgreen.svg)](https://hexdocs.pm/ex_utcp)\n\nElixir implementation of the Universal Tool Calling Protocol (UTCP).\n\n\n<img width=\"512\" height=\"512\" alt=\"ex_utcp-2\" src=\"https://github.com/user-attachments/assets/a4f5592e-4d16-42b2-8e98-b79bd164df8b\" />\n\n\n\n\n## Introduction\n\nThe Universal Tool Calling Protocol (UTCP) is a standard for defining and interacting with tools across communication protocols. UTCP emphasizes scalability, interoperability, and ease of use.\n\nKey characteristics:\n* **Scalability**: Handles large numbers of tools and providers without performance degradation\n* **Interoperability**: Supports multiple provider types including HTTP, [WebSockets](https://tools.ietf.org/html/rfc6455), [gRPC](https://grpc.io/), and CLI tools\n* **Ease of Use**: Built on simple, well-defined patterns\n\n## Features\n\n* Transports: HTTP, CLI, WebSocket, gRPC, GraphQL, MCP, TCP/UDP, WebRTC\n* Streaming support across all transports\n* OpenAPI Converter: Automatic API discovery and tool generation\n* Variable substitution via environment variables or `.env` files\n* In-memory repository for providers and tools\n* Authentication: API Key, Basic, OAuth2\n* Connection pooling and lifecycle management\n* Test configuration with integration test exclusion by default\n* Advanced Search: Multiple algorithms with fuzzy matching and semantic search\n* Monitoring and Metrics: Telemetry, PromEx, health checks, and performance monitoring\n* Comprehensive test suite with 497+ tests\n\n## Installation\n\nAdd `ex_utcp` to your list of dependencies in `mix.exs`:\n\n```elixir\ndef deps do\n  [\n    {:ex_utcp, \"~> 0.2.0\"}\n  ]\nend\n```\n\n## Getting Started\n\n### Basic Usage\n\n```elixir\nalias ExUtcp.{Client, Config}\n\n# Create a client configuration\nconfig = Config.new(providers_file_path: \"providers.json\")\n\n# Start a UTCP client\n{:ok, client} = Client.start_link(config)\n\n# Search for tools\n{:ok, tools} = Client.search_tools(client, \"\", 10)\n\n# Call a tool\n{:ok, result} = Client.call_tool(client, \"provider.tool_name\", %{\"arg\" => \"value\"})\n```\n\n### Programmatic Provider Registration\n\n```elixir\nalias ExUtcp.{Client, Config, Providers}\n\n# Create a client\nconfig = Config.new()\n{:ok, client} = Client.start_link(config)\n\n# Create an HTTP provider\nprovider = Providers.new_http_provider([\n  name: \"my_api\",\n  url: \"https://api.example.com/tools\",\n  http_method: \"POST\"\n])\n\n# Register the provider\n{:ok, tools} = Client.register_tool_provider(client, provider)\n\n# Call a discovered tool\n{:ok, result} = Client.call_tool(client, \"my_api.echo\", %{\"message\" => \"Hello!\"})\n```\n\n### CLI Provider Example\n\n```elixir\nalias ExUtcp.{Client, Config, Providers}\n\n# Create a client\nconfig = Config.new()\n{:ok, client} = Client.start_link(config)\n\n# Create a CLI provider\nprovider = Providers.new_cli_provider([\n  name: \"my_script\",\n  command_name: \"python my_script.py\",\n  working_dir: \"/path/to/script\"\n])\n\n# Register the provider\n{:ok, tools} = Client.register_tool_provider(client, provider)\n\n# Call a tool\n{:ok, result} = Client.call_tool(client, \"my_script.greet\", %{\"name\" => \"World\"})\n```\n\n## Configuration\n\n### Provider Configuration File\n\nCreate a `providers.json` file to define your providers:\n\n```json\n{\n  \"providers\": [\n    {\n      \"name\": \"http_api\",\n      \"type\": \"http\",\n      \"http_method\": \"POST\",\n      \"url\": \"https://api.example.com/tools\",\n      \"content_type\": \"application/json\",\n      \"headers\": {\n        \"User-Agent\": \"ExUtcp/0.2.0\"\n      },\n      \"auth\": {\n        \"type\": \"api_key\",\n        \"api_key\": \"${API_KEY}\",\n        \"location\": \"header\",\n        \"var_name\": \"Authorization\"\n      }\n    },\n    {\n      \"name\": \"cli_tool\",\n      \"type\": \"cli\",\n      \"command_name\": \"python my_tool.py\",\n      \"working_dir\": \"/opt/tools\",\n      \"env_vars\": {\n        \"PYTHONPATH\": \"/opt/tools\"\n      }\n    }\n  ]\n}\n```\n\n### Variable Substitution\n\nUTCP supports variable substitution using `${VAR}` or `$VAR` syntax:\n\n```elixir\n# Load variables from .env file\n{:ok, env_vars} = Config.load_from_env_file(\".env\")\n\nconfig = Config.new(\n  variables: env_vars,\n  providers_file_path: \"providers.json\"\n)\n```\n\n## OpenAPI Converter\n\nThe OpenAPI Converter automatically discovers and converts OpenAPI specifications into UTCP tools.\n\n### Basic Usage\n\n```elixir\nalias ExUtcp.{Client, Config}\n\n# Create a client\n{:ok, client} = Client.start_link(%{providers_file_path: nil, variables: %{}})\n\n# Convert OpenAPI spec from URL\n{:ok, tools} = Client.convert_openapi(client, \"https://api.example.com/openapi.json\")\n\n# Convert OpenAPI spec from file\n{:ok, tools} = Client.convert_openapi(client, \"path/to/spec.yaml\")\n\n# Convert with options\n{:ok, tools} = Client.convert_openapi(client, spec, %{\n  prefix: \"my_api\",\n  auth: %{type: \"api_key\", api_key: \"Bearer ${API_KEY}\"}\n})\n```\n\n### Supported Formats\n\n- OpenAPI 2.0 (Swagger)\n- OpenAPI 3.0\n- JSON and YAML specifications\n- URL and file-based specifications\n\n### Authentication Mapping\n\nThe converter automatically maps OpenAPI security schemes to UTCP authentication:\n\n- API Key authentication\n- HTTP Basic authentication\n- HTTP Bearer authentication\n- OAuth2 flows\n- OpenID Connect\n\n## Architecture\n\nThe library is organized into several main components:\n\n* ExUtcp.Client - Main client interface\n* ExUtcp.Config - Configuration management\n* ExUtcp.Providers - Provider implementations for different protocols\n* ExUtcp.Transports - Transport layer implementations\n* ExUtcp.Tools - Tool definitions and management\n* ExUtcp.Repository - Tool and provider storage\n* ExUtcp.OpenApiConverter - OpenAPI specification conversion\n\n## Implementation Status\n\n### Gap Analysis: UTCP Implementations Comparison\n\n| Feature Category | Python UTCP | Go UTCP | Elixir UTCP | Elixir Coverage |\n|------------------|-------------|---------|-------------|-----------------|\n| **Core Architecture** | | | | |\n| Core Client | Complete | Complete | Complete | 100% |\n| Configuration | Complete | Complete | Enhanced | 100% |\n| Variable Substitution | Complete | Complete | Complete | 100% |\n| **Transports** | | | | |\n| HTTP/HTTPS | Complete | Complete | Complete | 100% |\n| CLI | Complete | Complete | Complete | 100% |\n| WebSocket | Complete | Complete | Complete | 100% |\n| gRPC | Complete | Complete | Complete | 100% |\n| GraphQL | Complete | Complete | Complete | 100% |\n| MCP | Complete | Complete | Complete | 100% |\n| SSE | Complete | Complete | Complete | 100% |\n| Streamable HTTP | Complete | Complete | Complete | 100% |\n| TCP/UDP | Complete | Complete | Complete | 100% |\n| WebRTC | Complete | Complete | Complete | 100% |\n| **Authentication** | | | | |\n| API Key | Complete | Complete | Complete | 100% |\n| Basic Auth | Complete | Complete | Complete | 100% |\n| OAuth2 | Complete | Complete | Complete | 100% |\n| **Advanced Features** | | | | |\n| Streaming | Complete | Complete | Complete | 100% |\n| Connection Pooling | Complete | Complete | Complete | 100% |\n| Error Recovery | Complete | Complete | Complete | 100% |\n| OpenAPI Converter | Complete | Complete | Complete | 100% |\n| Tool Discovery | Complete | Complete | Complete | 100% |\n| Search | Advanced | Advanced | Complete | 100% |\n| **Testing** | | | | |\n| Unit Tests | Complete | Complete | Complete | 100% |\n| Integration Tests | Complete | Complete | Complete | 100% |\n| Mock Testing | Complete | Complete | Complete | 100% |\n| Test Coverage | High | High | High | 100% |\n| **Performance** | | | | |\n| Connection Management | Optimized | Optimized | Optimized | 100% |\n| Memory Usage | Optimized | Optimized | Optimized | 100% |\n| Throughput | High | High | High | 100% |\n| **Monitoring** | | | | |\n| Telemetry | Complete | Complete | Complete | 100% |\n| Metrics | Complete | Complete | Complete | 100% |\n| Health Checks | Complete | Complete | Complete | 100% |\n| Performance Monitoring | Complete | Complete | Complete | 100% |\n| **Documentation** | | | | |\n| API Docs | Complete | Complete | Complete | 100% |\n| Examples | Complete | Complete | Complete | 100% |\n| Guides | Complete | Complete | Complete | 100% |\n\n### Priority Recommendations\n\n#### High Priority\n- [x] OpenAPI Converter: Automatic API discovery and tool generation\n- [x] TCP/UDP Transport: Low-level network protocols\n- [x] Advanced Search: Sophisticated search algorithms\n- [x] Monitoring: Metrics and health checks\n- [x] WebRTC Transport: Peer-to-peer communication\n\n#### Medium Priority\n- [ ] Batch Operations: Multiple tool calls\n\n#### Low Priority\n- [ ] Custom Variable Loaders: Beyond .env files\n- [ ] API Documentation Generation\n\n### Implementation Status\n\n#### Completed Features\n- 8 transports: HTTP, CLI, WebSocket, gRPC, GraphQL, MCP, TCP/UDP, WebRTC\n- Streaming support across all transports\n- OpenAPI Converter: Automatic API discovery and tool generation\n- Authentication: API Key, Basic, OAuth2\n- Connection pooling and lifecycle management\n- Error recovery with retry logic\n- Test configuration with integration test exclusion by default\n- Advanced Search: Multiple algorithms with fuzzy matching and semantic search\n- Monitoring and Metrics: Telemetry, PromEx, health checks, and performance monitoring\n- 497+ tests with comprehensive coverage\n- Production examples for all transports\n\n#### Missing Features\n- Batch Operations: Multiple tool calls\n\n### Roadmap\n\n#### Phase 1: Core Transports (Completed)\n- [x] HTTP/HTTPS, CLI, WebSocket, gRPC, GraphQL, MCP\n\n#### Phase 2: Enhanced Features (Completed)\n- [x] OpenAPI Converter\n- [x] TCP/UDP Transport\n- [x] Advanced Search\n- [x] Monitoring and Metrics\n\n#### Phase 3: Extended Protocols (Completed)\n- [x] WebRTC Transport\n\n#### Phase 4: Enterprise Features\n- [ ] Batch Operations\n- [ ] Custom Variable Loaders\n- [ ] API Documentation Generation\n\n## Supported Transports\n\n### Implemented\n- HTTP/HTTPS: REST API integration with [OpenAPI](https://swagger.io/specification/) support\n- CLI: Command-line tool integration\n- [WebSocket](https://tools.ietf.org/html/rfc6455): Real-time communication\n- [gRPC](https://grpc.io/): High-performance RPC calls with [Protocol Buffers](https://developers.google.com/protocol-buffers)\n- [GraphQL](https://graphql.org/): GraphQL API integration with HTTP/HTTPS\n- [MCP](https://modelcontextprotocol.io/): Model Context Protocol integration with [JSON-RPC 2.0](https://www.jsonrpc.org/specification)\n- [TCP/UDP](https://tools.ietf.org/html/rfc793): Low-level network protocols with connection management\n- [WebRTC](https://www.w3.org/TR/webrtc/): Peer-to-peer communication with data channels and NAT traversal\n\n### Planned\n- Additional enterprise features and optimizations\n\n## Examples\n\nSee `examples/` directory:\n- `http_client.exs` - HTTP provider\n- `cli_client.exs` - CLI provider\n- `websocket_client.exs` - WebSocket provider\n- `grpc_client.exs` - gRPC provider\n- `graphql_example.exs` - GraphQL provider\n- `mcp_example.exs` - MCP provider\n- `tcp_udp_example.exs` - TCP/UDP provider\n- `streaming_examples.exs` - Streaming examples\n- `openapi_example.exs` - OpenAPI Converter examples\n- `search_example.exs` - Advanced search examples\n- `monitoring_example.exs` - Monitoring and metrics examples\n- `webrtc_example.exs` - WebRTC peer-to-peer examples\n\n## Testing\n\n```bash\n# Unit tests only (default - excludes integration tests)\nmix test\n\n# All tests including integration tests\nmix test --include integration\n\n# Integration tests only\nmix test --only integration\n```\n\nThe test suite is configured to exclude integration tests by default for faster development cycles. Integration tests require external services and are run separately.\n\n## Advanced Search\n\nExUtcp provides sophisticated search capabilities for discovering tools and providers:\n\n### Search Algorithms\n\n- **Exact Search**: Precise matching for tool and provider names\n- **Fuzzy Search**: Approximate matching using FuzzyCompare library for handling typos and variations\n- **Semantic Search**: Intelligent matching using Haystack full-text search and keyword analysis\n- **Combined Search**: Merges results from all algorithms for comprehensive discovery\n\n### Search Features\n\n- **Multi-field Search**: Search across tool names, descriptions, parameters, and responses\n- **Advanced Filtering**: Filter by provider, transport type, tags, and capabilities\n- **Result Ranking**: Intelligent scoring based on relevance, popularity, quality, and context\n- **Security Scanning**: TruffleHog integration for detecting sensitive data in search results\n- **Search Suggestions**: Auto-complete and suggestion system for improved user experience\n- **Similar Tool Discovery**: Find related tools based on semantic similarity\n\n### Basic Usage\n\n```elixir\n# Start client\n{:ok, client} = ExUtcp.Client.start_link()\n\n# Search with different algorithms\nexact_results = ExUtcp.Client.search_tools(client, \"get_user\", %{algorithm: :exact})\nfuzzy_results = ExUtcp.Client.search_tools(client, \"get_usr\", %{algorithm: :fuzzy, threshold: 0.6})\nsemantic_results = ExUtcp.Client.search_tools(client, \"user management\", %{algorithm: :semantic})\n\n# Advanced search with filters and security scanning\nadvanced_results = ExUtcp.Client.search_tools(client, \"api\", %{\n  algorithm: :combined,\n  filters: %{transports: [:http, :websocket], providers: [\"my_api\"]},\n  security_scan: true,\n  filter_sensitive: true,\n  limit: 10\n})\n\n# Get search suggestions\nsuggestions = ExUtcp.Client.get_search_suggestions(client, \"us\", limit: 5)\n\n# Find similar tools\nsimilar_tools = ExUtcp.Client.find_similar_tools(client, \"get_user\", limit: 3)\n```\n\n## Monitoring and Metrics\n\nExUtcp provides comprehensive monitoring capabilities for production deployments:\n\n### Monitoring Features\n\n- **Telemetry Integration**: Automatic telemetry events for all UTCP operations\n- **Prometheus Metrics**: PromEx integration for metrics collection and visualization\n- **Health Checks**: System health monitoring for transports and components\n- **Performance Monitoring**: Operation timing, statistical analysis, and alerting\n- **Custom Metrics**: Support for application-specific metrics and dashboards\n\n### Telemetry Events\n\nExUtcp emits telemetry events for:\n- Tool calls with duration, success/failure, and metadata\n- Search operations with algorithm, filters, and result counts\n- Provider registration and deregistration\n- Connection establishment and lifecycle events\n- System health and performance metrics\n\n### Basic Usage\n\n```elixir\n# Start monitoring system\nExUtcp.Monitoring.start()\n\n# Get system metrics\nmetrics = ExUtcp.Client.get_monitoring_metrics(client)\n\n# Get health status\nhealth = ExUtcp.Client.get_health_status(client)\n\n# Get performance summary\nperformance = ExUtcp.Client.get_performance_summary(client)\n\n# Record custom metrics\nExUtcp.Monitoring.Performance.record_custom_metric(\"api_requests\", :counter, 1, %{endpoint: \"/users\"})\n```\n\n### Prometheus Integration\n\nConfigure PromEx in your application:\n\n```elixir\n# config/config.exs\nconfig :ex_utcp, ExUtcp.Monitoring.PromEx,\n  disabled: false,\n  manual_metrics_start_delay: :no_delay,\n  drop_metrics_groups: [],\n  grafana: [\n    host: \"http://localhost:3000\",\n    username: \"admin\",\n    password: \"admin\"\n  ]\n```\n\n## Comparison with Python UTCP\n\nExUtcp is an independent Elixir implementation of the UTCP specification. For a detailed comparison with the official Python implementation, see our [Comparison Study](docs/COMPARISON_STUDY.md).\n\n**Key Differences**:\n- **ExUtcp**: 8 transports (includes WebSocket, gRPC, GraphQL, TCP/UDP, WebRTC)\n- **Python UTCP**: 6 transports (HTTP, SSE, CLI, MCP, Text, Streamable HTTP)\n- **ExUtcp**: Advanced search, monitoring, and health checks\n- **Python UTCP**: Plugin architecture, official implementation\n\nBoth implementations follow the UTCP specification and excel in different areas.\n\n## Contributing\n\n1. Fork the repository\n2. Create a feature branch\n3. Make your changes\n4. Add tests for new functionality\n5. Run the test suite\n6. Submit a pull request\n\n## License\n\nMIT License - see [LICENSE](LICENSE) file for details.\n\n## Links\n\n- [UTCP Website](https://www.utcp.io/)\n- [Go Implementation](https://github.com/universal-tool-calling-protocol/go-utcp)\n- [Python Implementation](https://github.com/universal-tool-calling-protocol/python-utcp)\n- [Hex Package](https://hex.pm/packages/ex_utcp)\n- [HexDocs](https://hexdocs.pm/ex_utcp)\n",
      "line_count": 509,
      "word_count": 2116,
      "title": "ExUtcp",
      "summary": "[![Hex.pm](https://img.shields.io/hexpm/v/ex_utcp.svg)](https://hex.pm/packages/ex_utcp) [![Hex.pm](https://img.shields.io/hexpm/dt/ex_utcp.svg)](https://hex.pm/packages/ex_utcp)",
      "key_terms": [
        "comprehensive",
        "packages",
        "Model",
        "Architecture",
        "hexdocs",
        "exclude",
        "localhost",
        "img",
        "Optimized",
        "Record",
        "list",
        "grafana",
        "providers",
        "multiple",
        "degradation",
        "Features",
        "interface",
        "Supported",
        "failure",
        "Configure"
      ],
      "timestamp": "2025-12-24T18:56:00.378840"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\examples\\provider.json",
      "content_type": "configuration",
      "content": "{\n  \"providers\": [\n    {\n      \"name\": \"http\",\n      \"type\": \"http\",\n      \"http_method\": \"POST\",\n      \"url\": \"http://localhost:8080/tools\",\n      \"content_type\": \"application/json\",\n      \"headers\": {\n        \"User-Agent\": \"ExUtcp/0.1.0\"\n      }\n    }\n  ]\n}\n",
      "line_count": 15,
      "word_count": 22,
      "title": "Provider.Json",
      "summary": "\"providers\": [ \"name\": \"http\",",
      "key_terms": [
        "url",
        "ExUtcp",
        "providers",
        "tools",
        "User",
        "localhost",
        "headers",
        "POST",
        "json",
        "type",
        "method",
        "User-Agent",
        "application",
        "Agent",
        "Utcp",
        "http",
        "name"
      ],
      "timestamp": "2025-12-24T18:56:00.402380"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\examples\\tools.json",
      "content_type": "configuration",
      "content": "{\n  \"version\": \"1.0\",\n  \"tools\": [\n    {\n      \"name\": \"echo\",\n      \"description\": \"Echoes back the provided message\",\n      \"inputs\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"message\": {\n            \"type\": \"string\",\n            \"description\": \"The message to echo back\"\n          }\n        },\n        \"required\": [\"message\"]\n      },\n      \"outputs\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"result\": {\n            \"type\": \"string\",\n            \"description\": \"The echoed message\"\n          }\n        }\n      },\n      \"tags\": [\"utility\", \"echo\"]\n    },\n    {\n      \"name\": \"timestamp\",\n      \"description\": \"Returns the current timestamp\",\n      \"inputs\": {\n        \"type\": \"object\",\n        \"properties\": {}\n      },\n      \"outputs\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"result\": {\n            \"type\": \"string\",\n            \"description\": \"Current timestamp in RFC3339 format\"\n          }\n        }\n      },\n      \"tags\": [\"utility\", \"time\"]\n    }\n  ]\n}\n",
      "line_count": 48,
      "word_count": 96,
      "title": "Tools.Json",
      "summary": "\"version\": \"1.0\", \"name\": \"echo\",",
      "key_terms": [
        "current",
        "outputs",
        "utility",
        "format",
        "back",
        "message",
        "type",
        "string",
        "properties",
        "echoed",
        "provided",
        "version",
        "name",
        "required",
        "tags",
        "Current",
        "to",
        "result",
        "Echoes",
        "in"
      ],
      "timestamp": "2025-12-24T18:56:00.410496"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp do\n  @moduledoc \"\"\"\n  Elixir implementation of the Universal Tool Calling Protocol (UTCP).\n\n  UTCP is a modern, flexible, and scalable standard for defining and interacting\n  with tools across a wide variety of communication protocols. It is designed to\n  be easy to use, interoperable, and extensible, making it a powerful choice for\n  building and consuming tool-based services.\n\n  ## Features\n\n  * Built-in transports for HTTP, CLI, Server-Sent Events, streaming HTTP,\n    GraphQL, MCP, WebSocket, gRPC, TCP, UDP, and WebRTC\n  * Variable substitution via environment variables or `.env` files\n  * In-memory repository for storing providers and tools discovered at runtime\n  * Utilities such as `OpenApiConverter` to convert OpenAPI definitions into UTCP manuals\n  * Example programs demonstrating the client usage\n\n  ## Getting Started\n\n  ```elixir\n  alias ExUtcp.{Client, Config}\n\n  # Create a client configuration\n  config = Config.new(providers_file_path: \"providers.json\")\n\n  # Create a UTCP client\n  {:ok, client} = Client.start_link(config)\n\n  # Search for tools\n  {:ok, tools} = Client.search_tools(client, \"\", 10)\n\n  # Call a tool\n  {:ok, result} = Client.call_tool(client, \"provider.tool_name\", %{\"arg\" => \"value\"})\n  ```\n\n  ## Architecture\n\n  The library is organized into several main components:\n\n  * `ExUtcp.Client` - Main client interface\n  * `ExUtcp.Config` - Configuration management\n  * `ExUtcp.Providers` - Provider implementations for different protocols\n  * `ExUtcp.Transports` - Transport layer implementations\n  * `ExUtcp.Tools` - Tool definitions and management\n  * `ExUtcp.Repository` - Tool and provider storage\n  \"\"\"\n\n  @doc \"\"\"\n  Returns the version of the ExUtcp library.\n  \"\"\"\n  def version do\n    Application.spec(:ex_utcp, :vsn)\n    |> to_string()\n  end\nend\n",
      "line_count": 57,
      "word_count": 233,
      "title": "Ex Utcp.Ex",
      "summary": "defmodule ExUtcp do @moduledoc \"\"\"",
      "key_terms": [
        "implementations",
        "Architecture",
        "convert",
        "based",
        "Utilities",
        "WebSocket",
        "Built",
        "choice",
        "Utcp",
        "It",
        "providers",
        "designed",
        "usage",
        "Built-in",
        "version",
        "Calling",
        "Features",
        "interface",
        "easy",
        "extensible"
      ],
      "timestamp": "2025-12-24T18:56:00.442026"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\auth.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Auth do\n  @moduledoc \"\"\"\n  Authentication mechanisms for UTCP providers.\n\n  This module handles various authentication types including API key, Basic Auth, and OAuth2.\n  \"\"\"\n\n  alias ExUtcp.Types, as: T\n\n  @doc \"\"\"\n  Creates a new API key authentication configuration.\n  \"\"\"\n  @spec new_api_key_auth(keyword()) :: T.api_key_auth()\n  def new_api_key_auth(opts) do\n    %{\n      type: \"api_key\",\n      api_key: Keyword.fetch!(opts, :api_key),\n      location: Keyword.get(opts, :location, \"header\"),\n      var_name: Keyword.get(opts, :var_name, \"Authorization\")\n    }\n  end\n\n  @doc \"\"\"\n  Creates a new Basic authentication configuration.\n  \"\"\"\n  @spec new_basic_auth(keyword()) :: T.basic_auth()\n  def new_basic_auth(opts) do\n    %{\n      type: \"basic\",\n      username: Keyword.fetch!(opts, :username),\n      password: Keyword.fetch!(opts, :password)\n    }\n  end\n\n  @doc \"\"\"\n  Creates a new OAuth2 authentication configuration.\n  \"\"\"\n  @spec new_oauth2_auth(keyword()) :: T.oauth2_auth()\n  def new_oauth2_auth(opts) do\n    %{\n      type: \"oauth2\",\n      client_id: Keyword.fetch!(opts, :client_id),\n      client_secret: Keyword.fetch!(opts, :client_secret),\n      token_url: Keyword.fetch!(opts, :token_url),\n      scope: Keyword.fetch!(opts, :scope)\n    }\n  end\n\n  @doc \"\"\"\n  Applies authentication to HTTP headers based on the auth configuration.\n  \"\"\"\n  @spec apply_to_headers(T.auth(), map()) :: map()\n  def apply_to_headers(auth, headers) when is_map(auth) do\n    case auth.type do\n      \"api_key\" -> apply_api_key_auth(auth, headers)\n      \"basic\" -> apply_basic_auth(auth, headers)\n      # OAuth2 requires token exchange, handled separately\n      \"oauth2\" -> headers\n      _ -> headers\n    end\n  end\n\n  def apply_to_headers(_auth, headers), do: headers\n\n  @doc \"\"\"\n  Applies API key authentication to headers.\n  \"\"\"\n  @spec apply_api_key_auth(T.api_key_auth(), map()) :: map()\n  def apply_api_key_auth(auth, headers) do\n    case auth.location do\n      \"header\" ->\n        Map.put(headers, auth.var_name, auth.api_key)\n\n      \"query\" ->\n        # Query params are handled separately\n        headers\n\n      \"cookie\" ->\n        Map.put(headers, \"Cookie\", \"#{auth.var_name}=#{auth.api_key}\")\n\n      _ ->\n        headers\n    end\n  end\n\n  @doc \"\"\"\n  Applies Basic authentication to headers.\n  \"\"\"\n  @spec apply_basic_auth(T.basic_auth(), map()) :: map()\n  def apply_basic_auth(auth, headers) do\n    credentials = Base.encode64(\"#{auth.username}:#{auth.password}\")\n    Map.put(headers, \"Authorization\", \"Basic #{credentials}\")\n  end\n\n  @doc \"\"\"\n  Validates an authentication configuration.\n  \"\"\"\n  @spec validate_auth(T.auth()) :: :ok | {:error, String.t()}\n  def validate_auth(auth) do\n    case auth.type do\n      \"api_key\" -> validate_api_key_auth(auth)\n      \"basic\" -> validate_basic_auth(auth)\n      \"oauth2\" -> validate_oauth2_auth(auth)\n      _ -> {:error, \"Unknown authentication type: #{auth.type}\"}\n    end\n  end\n\n  defp validate_api_key_auth(auth) do\n    if valid_field?(auth.api_key) do\n      :ok\n    else\n      {:error, \"API key is required for API key authentication\"}\n    end\n  end\n\n  defp validate_basic_auth(auth) do\n    if valid_field?(auth.username) and valid_field?(auth.password) do\n      :ok\n    else\n      {:error, \"Username and password are required for Basic authentication\"}\n    end\n  end\n\n  defp validate_oauth2_auth(auth) do\n    required_fields = [auth.client_id, auth.client_secret, auth.token_url, auth.scope]\n\n    if Enum.all?(required_fields, &valid_field?/1) do\n      :ok\n    else\n      {:error, \"Client ID, client secret, token URL, and scope are required for OAuth2 authentication\"}\n    end\n  end\n\n  defp valid_field?(field), do: not is_nil(field) and field != \"\"\nend\n",
      "line_count": 136,
      "word_count": 365,
      "title": "Auth.Ex",
      "summary": "defmodule ExUtcp.Auth do @moduledoc \"\"\"",
      "key_terms": [
        "headers",
        "error",
        "based",
        "token",
        "Cookie",
        "cookie",
        "Utcp",
        "providers",
        "keyword",
        "Creates",
        "if",
        "basic",
        "mechanisms",
        "Username",
        "separately",
        "defp",
        "Query",
        "handles",
        "Unknown",
        "def"
      ],
      "timestamp": "2025-12-24T18:56:00.458098"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\client.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Client do\n  @moduledoc \"\"\"\n  Main UTCP client implementation.\n\n  This module provides the primary interface for interacting with UTCP providers\n  and tools. It manages provider registration, tool discovery, and tool execution.\n  \"\"\"\n\n  use GenServer\n\n  alias ExUtcp.Config\n  alias ExUtcp.Monitoring.Performance\n  alias ExUtcp.OpenApiConverter\n  alias ExUtcp.Providers\n  alias ExUtcp.Repository\n  alias ExUtcp.Search.Engine, as: SearchEngine\n  alias ExUtcp.Tools\n  alias ExUtcp.Types, as: T\n\n  defstruct [\n    :config,\n    :repository,\n    :transports,\n    :search_strategy\n  ]\n\n  @doc \"\"\"\n  Starts a new UTCP client with the given configuration.\n  \"\"\"\n  @spec start_link(T.client_config()) :: GenServer.on_start()\n  def start_link(config) do\n    GenServer.start_link(__MODULE__, config)\n  end\n\n  @doc \"\"\"\n  Starts a new UTCP client with the given configuration and name.\n  \"\"\"\n  @spec start_link(T.client_config(), GenServer.name()) :: GenServer.on_start()\n  def start_link(config, name) do\n    GenServer.start_link(__MODULE__, config, name: name)\n  end\n\n  @doc \"\"\"\n  Registers a tool provider and returns the discovered tools.\n  \"\"\"\n  @spec register_tool_provider(GenServer.server(), T.provider()) :: T.register_result()\n  def register_tool_provider(client, provider) do\n    GenServer.call(client, {:register_provider, provider})\n  end\n\n  @doc \"\"\"\n  Deregisters a tool provider.\n  \"\"\"\n  @spec deregister_tool_provider(GenServer.server(), String.t()) :: T.deregister_result()\n  def deregister_tool_provider(client, provider_name) do\n    GenServer.call(client, {:deregister_provider, provider_name})\n  end\n\n  @doc \"\"\"\n  Calls a specific tool with the given arguments.\n  \"\"\"\n  @spec call_tool(GenServer.server(), String.t(), map()) :: T.call_result()\n  def call_tool(client, tool_name, args \\\\ %{}) do\n    GenServer.call(client, {:call_tool, tool_name, args})\n  end\n\n  @doc \"\"\"\n  Calls a tool with streaming support.\n  \"\"\"\n  @spec call_tool_stream(GenServer.server(), String.t(), map()) ::\n          {:ok, T.stream_result()} | {:error, any()}\n  def call_tool_stream(client, tool_name, args \\\\ %{}) do\n    GenServer.call(client, {:call_tool_stream, tool_name, args})\n  end\n\n  @doc \"\"\"\n  Searches for tools using advanced search algorithms.\n\n  ## Parameters\n\n  - `client`: UTCP client\n  - `query`: Search query string\n  - `opts`: Search options including algorithm, filters, and limits\n\n  ## Options\n\n  - `:algorithm` - Search algorithm (:exact, :fuzzy, :semantic, :combined)\n  - `:filters` - Map with provider, transport, and tag filters\n  - `:limit` - Maximum number of results (default: 20)\n  - `:threshold` - Minimum similarity threshold (default: 0.1)\n  - `:security_scan` - Enable security scanning (default: false)\n  - `:filter_sensitive` - Filter out tools with sensitive data (default: false)\n\n  ## Returns\n\n  List of search results with tools, scores, and match information.\n  \"\"\"\n  @spec search_tools(GenServer.server(), String.t(), map()) :: [map()]\n  def search_tools(client, query, opts \\\\ %{}) do\n    GenServer.call(client, {:search_tools, query, opts})\n  end\n\n  @doc \"\"\"\n  Gets all available transports.\n  \"\"\"\n  @spec get_transports(GenServer.server()) :: %{String.t() => module()}\n  def get_transports(client) do\n    GenServer.call(client, :get_transports)\n  end\n\n  @doc \"\"\"\n  Gets the client configuration.\n  \"\"\"\n  @spec get_config(GenServer.server()) :: T.client_config()\n  def get_config(client) do\n    GenServer.call(client, :get_config)\n  end\n\n  @doc \"\"\"\n  Gets repository statistics.\n  \"\"\"\n  @spec get_stats(GenServer.server()) :: map()\n  def get_stats(client) do\n    GenServer.call(client, :get_stats)\n  end\n\n  # GenServer callbacks\n\n  @impl GenServer\n  def init(config) do\n    repository = Repository.new()\n    transports = default_transports()\n    search_strategy = default_search_strategy()\n\n    # Load providers from file if specified\n    state = %__MODULE__{\n      config: config,\n      repository: repository,\n      transports: transports,\n      search_strategy: search_strategy\n    }\n\n    if config.providers_file_path do\n      case load_providers_from_file(state, config.providers_file_path) do\n        {:ok, updated_state} -> {:ok, updated_state}\n        {:error, reason} -> {:stop, reason}\n      end\n    else\n      {:ok, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:register_provider, provider}, _from, state) do\n    case register_provider(state, provider) do\n      {:ok, tools, updated_state} -> {:reply, {:ok, tools}, updated_state}\n      {:error, reason} -> {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:deregister_provider, provider_name}, _from, state) do\n    case deregister_provider(state, provider_name) do\n      {:ok, updated_state} -> {:reply, :ok, updated_state}\n      {:error, reason} -> {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:call_tool, tool_name, args}, _from, state) do\n    # Measure tool call performance\n    result =\n      Performance.measure_tool_call(tool_name, \"unknown\", args, fn ->\n        call_tool_impl(state, tool_name, args)\n      end)\n\n    case result do\n      {:ok, result} -> {:reply, {:ok, result}, state}\n      {:error, reason} -> {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:call_tool_stream, tool_name, args}, _from, state) do\n    case call_tool_stream_impl(state, tool_name, args) do\n      {:ok, result} -> {:reply, {:ok, result}, state}\n      {:error, reason} -> {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:search_tools, query, opts}, _from, state) do\n    # Measure search performance\n    algorithm = Map.get(opts, :algorithm, :combined)\n    filters = Map.get(opts, :filters, %{})\n\n    results =\n      Performance.measure_search(query, algorithm, filters, fn ->\n        # Create search engine from current repository state\n        search_engine = create_search_engine_from_state(state)\n        ExUtcp.Search.search_tools(search_engine, query, opts)\n      end)\n\n    {:reply, results, state}\n  end\n\n  @impl GenServer\n  def handle_call(:get_transports, _from, state) do\n    {:reply, state.transports, state}\n  end\n\n  @impl GenServer\n  def handle_call(:get_config, _from, state) do\n    {:reply, state.config, state}\n  end\n\n  @impl GenServer\n  def handle_call(:get_stats, _from, state) do\n    stats = %{\n      tool_count: Repository.tool_count(state.repository),\n      provider_count: Repository.provider_count(state.repository)\n    }\n\n    {:reply, stats, state}\n  end\n\n  @impl GenServer\n  def handle_call(:get_monitoring_metrics, _from, state) do\n    metrics = ExUtcp.Monitoring.get_metrics()\n    {:reply, metrics, state}\n  end\n\n  @impl GenServer\n  def handle_call(:get_health_status, _from, state) do\n    health_status = ExUtcp.Monitoring.get_health_status()\n    {:reply, health_status, state}\n  end\n\n  @impl GenServer\n  def handle_call(:get_performance_summary, _from, state) do\n    performance_summary = Performance.get_performance_summary()\n    {:reply, performance_summary, state}\n  end\n\n  @impl GenServer\n  def handle_call({:convert_openapi, spec, opts}, _from, state) do\n    case convert_openapi_impl(spec, opts) do\n      {:ok, tools} ->\n        # Register all tools\n        {results, new_repo} =\n          Enum.reduce(tools, {[], state.repository}, fn tool, {acc_results, repo} ->\n            case Repository.add_tool(repo, tool) do\n              {:ok, new_repo} -> {[{:ok, tool} | acc_results], new_repo}\n              {:error, reason} -> {[{:error, reason} | acc_results], repo}\n            end\n          end)\n\n        # Check if any registration failed\n        case Enum.find(results, &match?({:error, _}, &1)) do\n          nil -> {:reply, {:ok, tools}, %{state | repository: new_repo}}\n          error -> {:reply, error, state}\n        end\n\n      error ->\n        {:reply, error, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:convert_multiple_openapi, specs, opts}, _from, state) do\n    case convert_multiple_openapi_impl(specs, opts) do\n      {:ok, tools} ->\n        # Register all tools\n        {results, new_repo} =\n          Enum.reduce(tools, {[], state.repository}, fn tool, {acc_results, repo} ->\n            case Repository.add_tool(repo, tool) do\n              {:ok, new_repo} -> {[{:ok, tool} | acc_results], new_repo}\n              {:error, reason} -> {[{:error, reason} | acc_results], repo}\n            end\n          end)\n\n        # Check if any registration failed\n        case Enum.find(results, &match?({:error, _}, &1)) do\n          nil -> {:reply, {:ok, tools}, %{state | repository: new_repo}}\n          error -> {:reply, error, state}\n        end\n\n      error ->\n        {:reply, error, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:validate_openapi, spec}, _from, state) do\n    result = OpenApiConverter.validate(spec)\n    {:reply, result, state}\n  end\n\n  @impl GenServer\n  def handle_call({:search_providers, query, opts}, _from, state) do\n    # Create search engine from current repository state\n    search_engine = create_search_engine_from_state(state)\n\n    results = ExUtcp.Search.search_providers(search_engine, query, opts)\n    {:reply, results, state}\n  end\n\n  @impl GenServer\n  def handle_call({:get_search_suggestions, partial_query, opts}, _from, state) do\n    # Create search engine from current repository state\n    search_engine = create_search_engine_from_state(state)\n\n    suggestions = ExUtcp.Search.get_suggestions(search_engine, partial_query, opts)\n    {:reply, suggestions, state}\n  end\n\n  @impl GenServer\n  def handle_call({:find_similar_tools, tool_name, opts}, _from, state) do\n    case Repository.get_tool(state.repository, tool_name) do\n      {:ok, tool} ->\n        # Create search engine from current repository state\n        search_engine = create_search_engine_from_state(state)\n\n        similar_tools = ExUtcp.Search.suggest_similar_tools(search_engine, tool, opts)\n        {:reply, similar_tools, state}\n\n      {:error, reason} ->\n        {:reply, {:error, reason}, state}\n    end\n  end\n\n  # Private functions\n\n  defp default_transports do\n    %{\n      \"http\" => ExUtcp.Transports.Http,\n      \"cli\" => ExUtcp.Transports.Cli,\n      \"websocket\" => ExUtcp.Transports.WebSocket,\n      \"grpc\" => ExUtcp.Transports.Grpc,\n      \"graphql\" => ExUtcp.Transports.Graphql,\n      \"mcp\" => ExUtcp.Transports.Mcp,\n      \"webrtc\" => ExUtcp.Transports.WebRTC\n      # Add more transports as they are implemented\n    }\n  end\n\n  defp default_search_strategy do\n    # Simple search strategy - can be enhanced later\n    fn repository, query, limit ->\n      Repository.search_tools(repository, query, limit)\n    end\n  end\n\n  defp load_providers_from_file(state, file_path) do\n    # Validate file path to prevent directory traversal\n    with {:ok, validated_path} <- validate_file_path(file_path),\n         {:ok, content} <- File.read(validated_path),\n         {:ok, data} <- Jason.decode(content) do\n      parse_and_register_providers(state, data)\n    else\n      {:error, :invalid_path} -> {:error, \"Invalid file path\"}\n      {:error, %Jason.DecodeError{} = reason} -> {:error, \"Failed to parse JSON: #{inspect(reason)}\"}\n      {:error, reason} -> {:error, \"Failed to read file: #{inspect(reason)}\"}\n    end\n  end\n\n  defp validate_file_path(file_path) do\n    # Resolve to absolute path and check for directory traversal\n    abs_path = Path.expand(file_path)\n\n    # Check if path contains directory traversal patterns\n    cond do\n      String.contains?(file_path, [\"../\", \"..\\\\\"]) ->\n        {:error, :invalid_path}\n\n      # Ensure the path doesn't escape the current working directory\n      String.contains?(abs_path, \"..\") ->\n        {:error, :invalid_path}\n\n      # Check if file exists and is readable\n      not File.exists?(abs_path) ->\n        {:error, :file_not_found}\n\n      true ->\n        {:ok, abs_path}\n    end\n  end\n\n  defp parse_and_register_providers(state, data) do\n    providers_data =\n      case data do\n        %{\"providers\" => providers} when is_list(providers) -> providers\n        %{\"providers\" => provider} when is_map(provider) -> [provider]\n        providers when is_list(providers) -> providers\n        provider when is_map(provider) -> [provider]\n        _ -> []\n      end\n\n    updated_state =\n      Enum.reduce(providers_data, state, fn provider_data, acc_state ->\n        case parse_provider(provider_data) do\n          {:ok, provider} ->\n            case register_provider(acc_state, provider) do\n              {:ok, _tools, new_state} -> new_state\n              {:error, _reason} -> acc_state\n            end\n\n          {:error, _reason} ->\n            acc_state\n        end\n      end)\n\n    {:ok, updated_state}\n  end\n\n  defp parse_provider(provider_data) do\n    provider_type = Map.get(provider_data, \"type\") || Map.get(provider_data, \"provider_type\")\n\n    case provider_type do\n      \"http\" -> parse_http_provider(provider_data)\n      \"cli\" -> parse_cli_provider(provider_data)\n      \"websocket\" -> parse_websocket_provider(provider_data)\n      \"grpc\" -> parse_grpc_provider(provider_data)\n      \"graphql\" -> parse_graphql_provider(provider_data)\n      \"mcp\" -> parse_mcp_provider(provider_data)\n      _ -> {:error, \"Unknown provider type: #{provider_type}\"}\n    end\n  end\n\n  defp parse_http_provider(data) do\n    provider =\n      Providers.new_http_provider(\n        name: Map.get(data, \"name\", \"\"),\n        http_method: Map.get(data, \"http_method\", \"GET\"),\n        url: Map.get(data, \"url\", \"\"),\n        content_type: Map.get(data, \"content_type\", \"application/json\"),\n        auth: parse_auth(Map.get(data, \"auth\")),\n        headers: Map.get(data, \"headers\", %{}),\n        body_field: Map.get(data, \"body_field\"),\n        header_fields: Map.get(data, \"header_fields\", [])\n      )\n\n    {:ok, provider}\n  end\n\n  defp parse_cli_provider(data) do\n    provider =\n      Providers.new_cli_provider(\n        name: Map.get(data, \"name\", \"\"),\n        command_name: Map.get(data, \"command_name\", \"\"),\n        working_dir: Map.get(data, \"working_dir\"),\n        env_vars: Map.get(data, \"env_vars\", %{})\n      )\n\n    {:ok, provider}\n  end\n\n  defp parse_websocket_provider(data) do\n    provider =\n      Providers.new_websocket_provider(\n        name: Map.get(data, \"name\", \"\"),\n        url: Map.get(data, \"url\", \"\"),\n        protocol: Map.get(data, \"protocol\"),\n        keep_alive: Map.get(data, \"keep_alive\", false),\n        auth: parse_auth(Map.get(data, \"auth\")),\n        headers: Map.get(data, \"headers\", %{}),\n        header_fields: Map.get(data, \"header_fields\", [])\n      )\n\n    {:ok, provider}\n  end\n\n  defp parse_grpc_provider(data) do\n    provider =\n      Providers.new_grpc_provider(\n        name: Map.get(data, \"name\", \"\"),\n        host: Map.get(data, \"host\", \"127.0.0.1\"),\n        port: Map.get(data, \"port\", 9339),\n        service_name: Map.get(data, \"service_name\", \"UTCPService\"),\n        method_name: Map.get(data, \"method_name\", \"CallTool\"),\n        target: Map.get(data, \"target\"),\n        use_ssl: Map.get(data, \"use_ssl\", false),\n        auth: parse_auth(Map.get(data, \"auth\"))\n      )\n\n    {:ok, provider}\n  end\n\n  defp parse_graphql_provider(data) do\n    provider =\n      Providers.new_graphql_provider(\n        name: Map.get(data, \"name\", \"\"),\n        url: Map.get(data, \"url\", \"\"),\n        auth: parse_auth(Map.get(data, \"auth\")),\n        headers: Map.get(data, \"headers\", %{})\n      )\n\n    {:ok, provider}\n  end\n\n  defp parse_mcp_provider(data) do\n    provider =\n      Providers.new_mcp_provider(\n        name: Map.get(data, \"name\", \"\"),\n        url: Map.get(data, \"url\", \"\"),\n        auth: parse_auth(Map.get(data, \"auth\"))\n      )\n\n    {:ok, provider}\n  end\n\n  defp parse_auth(nil), do: nil\n\n  defp parse_auth(auth_data) do\n    case Map.get(auth_data, \"type\") || Map.get(auth_data, \"auth_type\") do\n      \"api_key\" -> ExUtcp.Auth.new_api_key_auth(auth_data)\n      \"basic\" -> ExUtcp.Auth.new_basic_auth(auth_data)\n      \"oauth2\" -> ExUtcp.Auth.new_oauth2_auth(auth_data)\n      _ -> nil\n    end\n  end\n\n  defp register_provider(state, provider) do\n    # Apply variable substitution\n    substituted_provider = Config.substitute_variables(state.config, provider)\n\n    # Normalize provider name\n    normalized_name = Providers.normalize_name(Providers.get_name(substituted_provider))\n    substituted_provider = Providers.set_name(substituted_provider, normalized_name)\n\n    # Get transport\n    transport_module = Map.get(state.transports, to_string(substituted_provider.type))\n\n    if is_nil(transport_module) do\n      {:error, \"No transport available for provider type: #{substituted_provider.type}\"}\n    else\n      # Register with transport\n      case transport_module.register_tool_provider(substituted_provider) do\n        {:ok, tools} ->\n          # Normalize tool names\n          normalized_tools =\n            Enum.map(tools, fn tool ->\n              normalized_name = Tools.normalize_name(tool.name, normalized_name)\n              Map.put(tool, :name, normalized_name)\n            end)\n\n          # Save to repository\n          updated_repository =\n            Repository.save_provider_with_tools(\n              state.repository,\n              substituted_provider,\n              normalized_tools\n            )\n\n          updated_state = %{state | repository: updated_repository}\n          {:ok, normalized_tools, updated_state}\n\n        {:error, reason} ->\n          {:error, reason}\n      end\n    end\n  end\n\n  defp deregister_provider(state, provider_name) do\n    case Repository.get_provider(state.repository, provider_name) do\n      nil ->\n        {:error, \"Provider not found: #{provider_name}\"}\n\n      provider ->\n        # Get transport\n        transport_module = Map.get(state.transports, to_string(provider.type))\n\n        if is_nil(transport_module) do\n          {:error, \"No transport available for provider type: #{provider.type}\"}\n        else\n          # Deregister with transport\n          transport_module.deregister_tool_provider(provider)\n\n          # Remove from repository\n          updated_repository = Repository.remove_provider(state.repository, provider_name)\n          updated_state = %{state | repository: updated_repository}\n          {:ok, updated_state}\n        end\n    end\n  end\n\n  defp call_tool_impl(state, tool_name, args) do\n    with {:ok, _tool} <- get_tool_or_error(state.repository, tool_name),\n         provider_name = Tools.extract_provider_name(tool_name),\n         {:ok, provider} <- get_provider_or_error(state.repository, provider_name),\n         {:ok, transport_module} <- get_transport_or_error(state.transports, provider.type) do\n      call_name = extract_call_name(provider.type, tool_name)\n      _transport = transport_module.new()\n      transport_module.call_tool(call_name, args, provider)\n    end\n  end\n\n  defp get_tool_or_error(repository, tool_name) do\n    case Repository.get_tool(repository, tool_name) do\n      nil -> {:error, \"Tool not found: #{tool_name}\"}\n      tool -> {:ok, tool}\n    end\n  end\n\n  defp get_provider_or_error(repository, provider_name) do\n    case Repository.get_provider(repository, provider_name) do\n      nil -> {:error, \"Provider not found: #{provider_name}\"}\n      provider -> {:ok, provider}\n    end\n  end\n\n  defp get_transport_or_error(transports, provider_type) do\n    case Map.get(transports, to_string(provider_type)) do\n      nil -> {:error, \"No transport available for provider type: #{provider_type}\"}\n      transport_module -> {:ok, transport_module}\n    end\n  end\n\n  defp extract_call_name(provider_type, tool_name) do\n    if provider_type in [:mcp, :text] do\n      Tools.extract_tool_name(tool_name)\n    else\n      tool_name\n    end\n  end\n\n  defp call_tool_stream_impl(state, tool_name, args) do\n    with {:ok, _tool} <- get_tool_or_error(state.repository, tool_name),\n         provider_name = Tools.extract_provider_name(tool_name),\n         {:ok, provider} <- get_provider_or_error(state.repository, provider_name),\n         {:ok, transport_module} <- get_transport_or_error(state.transports, provider.type) do\n      call_name = extract_call_name(provider.type, tool_name)\n      _transport = transport_module.new()\n      transport_module.call_tool_stream(call_name, args, provider)\n    end\n  end\n\n  @doc \"\"\"\n  Converts an OpenAPI specification to UTCP tools and registers them.\n\n  ## Parameters\n\n  - `client`: UTCP client\n  - `spec`: OpenAPI specification (map, URL, or file path)\n  - `opts`: Conversion options\n\n  ## Returns\n\n  `{:ok, tools}` on success, `{:error, reason}` on failure.\n  \"\"\"\n  @spec convert_openapi(GenServer.server(), map() | String.t(), keyword()) :: T.register_result()\n  def convert_openapi(client, spec, opts \\\\ []) do\n    GenServer.call(client, {:convert_openapi, spec, opts})\n  end\n\n  @doc \"\"\"\n  Converts multiple OpenAPI specifications to UTCP tools and registers them.\n\n  ## Parameters\n\n  - `client`: UTCP client\n  - `specs`: List of OpenAPI specifications\n  - `opts`: Conversion options\n\n  ## Returns\n\n  `{:ok, tools}` on success, `{:error, reason}` on failure.\n  \"\"\"\n  @spec convert_multiple_openapi(GenServer.server(), list(), keyword()) :: T.register_result()\n  def convert_multiple_openapi(client, specs, opts \\\\ []) do\n    GenServer.call(client, {:convert_multiple_openapi, specs, opts})\n  end\n\n  @doc \"\"\"\n  Validates an OpenAPI specification.\n\n  ## Parameters\n\n  - `client`: UTCP client\n  - `spec`: OpenAPI specification\n\n  ## Returns\n\n  `{:ok, validation_result}` on success, `{:error, reason}` on failure.\n  \"\"\"\n  @spec validate_openapi(GenServer.server(), map()) :: {:ok, map()} | {:error, term()}\n  def validate_openapi(client, spec) do\n    GenServer.call(client, {:validate_openapi, spec})\n  end\n\n  @doc \"\"\"\n  Searches for providers using advanced search algorithms.\n\n  ## Parameters\n\n  - `client`: UTCP client\n  - `query`: Search query string\n  - `opts`: Search options\n\n  ## Returns\n\n  List of search results with providers, scores, and match information.\n  \"\"\"\n  @spec search_providers(GenServer.server(), String.t(), map()) :: [map()]\n  def search_providers(client, query, opts \\\\ %{}) do\n    GenServer.call(client, {:search_providers, query, opts})\n  end\n\n  @doc \"\"\"\n  Gets search suggestions based on partial query.\n\n  ## Parameters\n\n  - `client`: UTCP client\n  - `partial_query`: Partial search query\n  - `opts`: Suggestion options\n\n  ## Returns\n\n  List of suggested search terms.\n  \"\"\"\n  @spec get_search_suggestions(GenServer.server(), String.t(), keyword()) :: [String.t()]\n  def get_search_suggestions(client, partial_query, opts \\\\ []) do\n    GenServer.call(client, {:get_search_suggestions, partial_query, opts})\n  end\n\n  @doc \"\"\"\n  Finds similar tools based on a reference tool.\n\n  ## Parameters\n\n  - `client`: UTCP client\n  - `tool_name`: Name of the reference tool\n  - `opts`: Similarity search options\n\n  ## Returns\n\n  List of similar tools with similarity scores.\n  \"\"\"\n  @spec find_similar_tools(GenServer.server(), String.t(), keyword()) :: [map()]\n  def find_similar_tools(client, tool_name, opts \\\\ []) do\n    GenServer.call(client, {:find_similar_tools, tool_name, opts})\n  end\n\n  @doc \"\"\"\n  Gets monitoring metrics for the client.\n\n  ## Parameters\n\n  - `client`: UTCP client\n\n  ## Returns\n\n  Map containing current metrics and performance data.\n  \"\"\"\n  @spec get_monitoring_metrics(GenServer.server()) :: map()\n  def get_monitoring_metrics(client) do\n    GenServer.call(client, :get_monitoring_metrics)\n  end\n\n  @doc \"\"\"\n  Gets health status for the client and its components.\n\n  ## Parameters\n\n  - `client`: UTCP client\n\n  ## Returns\n\n  Map containing health status information.\n  \"\"\"\n  @spec get_health_status(GenServer.server()) :: map()\n  def get_health_status(client) do\n    GenServer.call(client, :get_health_status)\n  end\n\n  @doc \"\"\"\n  Gets performance summary for client operations.\n\n  ## Parameters\n\n  - `client`: UTCP client\n\n  ## Returns\n\n  Map containing performance statistics and alerts.\n  \"\"\"\n  @spec get_performance_summary(GenServer.server()) :: map()\n  def get_performance_summary(client) do\n    GenServer.call(client, :get_performance_summary)\n  end\n\n  # Private functions\n\n  defp create_search_engine_from_state(state) do\n    # Create a search engine and populate it with current tools and providers\n    search_engine = SearchEngine.new()\n\n    # Add all tools from repository\n    tools = Repository.get_tools(state.repository)\n\n    search_engine =\n      Enum.reduce(tools, search_engine, fn tool, acc ->\n        SearchEngine.add_tool(acc, tool)\n      end)\n\n    # Add all providers from repository\n    providers = Repository.get_providers(state.repository)\n\n    search_engine =\n      Enum.reduce(providers, search_engine, fn provider, acc ->\n        SearchEngine.add_provider(acc, provider)\n      end)\n\n    search_engine\n  end\n\n  defp convert_openapi_impl(spec, opts) when is_map(spec) do\n    OpenApiConverter.convert(spec, opts)\n  end\n\n  defp convert_openapi_impl(url, opts) when is_binary(url) do\n    if String.starts_with?(url, \"http\") do\n      OpenApiConverter.convert_from_url(url, opts)\n    else\n      OpenApiConverter.convert_from_file(url, opts)\n    end\n  end\n\n  defp convert_multiple_openapi_impl(specs, opts) do\n    OpenApiConverter.convert_multiple(specs, opts)\n  end\nend\n",
      "line_count": 834,
      "word_count": 2347,
      "title": "Client.Ex",
      "summary": "defmodule ExUtcp.Client do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "suggested",
        "grpc",
        "threshold",
        "search",
        "number",
        "File",
        "error",
        "headers",
        "convert",
        "check",
        "based",
        "list",
        "WebSocket",
        "primary",
        "websocket",
        "available",
        "unknown",
        "suggestions",
        "Apply"
      ],
      "timestamp": "2025-12-24T18:56:00.501647"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\config.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Config do\n  @moduledoc \"\"\"\n  Configuration management for UTCP client.\n\n  Handles variable substitution, environment variable loading, and provider configuration.\n  \"\"\"\n\n  alias ExUtcp.Types, as: T\n\n  @doc \"\"\"\n  Creates a new client configuration with default values.\n  \"\"\"\n  @spec new(keyword()) :: T.client_config()\n  def new(opts \\\\ []) do\n    %{\n      variables: Keyword.get(opts, :variables, %{}),\n      providers_file_path: Keyword.get(opts, :providers_file_path, nil),\n      load_variables_from: Keyword.get(opts, :load_variables_from, [])\n    }\n  end\n\n  @doc \"\"\"\n  Loads variables from a .env file.\n  \"\"\"\n  @spec load_from_env_file(String.t()) :: {:ok, %{String.t() => String.t()}} | {:error, any()}\n  def load_from_env_file(path) do\n    case Dotenvy.source(path) do\n      {:ok, env_vars} -> {:ok, env_vars}\n      {:error, reason} -> {:error, reason}\n    end\n  end\n\n  @doc \"\"\"\n  Gets a variable value from the configuration, checking in order:\n  1. Inline variables\n  2. Loaded variable sources\n  3. System environment variables\n  \"\"\"\n  @spec get_variable(T.client_config(), String.t()) ::\n          {:ok, String.t()} | {:error, T.variable_not_found()}\n  def get_variable(config, key) do\n    # Check inline variables first\n    case Map.get(config.variables, key) do\n      nil ->\n        # Check loaded variable sources\n        case get_from_loaders(config.load_variables_from, key) do\n          {:ok, value} ->\n            {:ok, value}\n\n          :error ->\n            # Check system environment\n            case System.get_env(key) do\n              nil -> {:error, %{__exception__: true, variable_name: key}}\n              value -> {:ok, value}\n            end\n        end\n\n      value ->\n        {:ok, value}\n    end\n  end\n\n  @doc \"\"\"\n  Substitutes variables in a value using the pattern ${VAR} or $VAR.\n  \"\"\"\n  @spec substitute_variables(T.client_config(), any()) :: any()\n  def substitute_variables(config, value) when is_binary(value) do\n    Regex.replace(~r/\\$\\{(\\w+)\\}|\\$(\\w+)/, value, fn match, var1, var2 ->\n      var_name = if var1 == \"\", do: var2, else: var1\n\n      case get_variable(config, var_name) do\n        {:ok, replacement} -> replacement\n        {:error, _} -> match\n      end\n    end)\n  end\n\n  def substitute_variables(config, value) when is_list(value) do\n    Enum.map(value, &substitute_variables(config, &1))\n  end\n\n  def substitute_variables(config, value) when is_map(value) do\n    Map.new(value, fn {k, v} -> {k, substitute_variables(config, v)} end)\n  end\n\n  def substitute_variables(_config, value), do: value\n\n  # Private helper to get variable from loaders\n  defp get_from_loaders(loaders, key) do\n    Enum.reduce_while(loaders, :error, fn loader, _acc ->\n      case loader.get(key) do\n        {:ok, value} when value != \"\" -> {:halt, {:ok, value}}\n        _ -> {:cont, :error}\n      end\n    end)\n  end\nend\n",
      "line_count": 98,
      "word_count": 313,
      "title": "Config.Ex",
      "summary": "defmodule ExUtcp.Config do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "Substitutes",
        "cont",
        "error",
        "pattern",
        "Utcp",
        "helper",
        "loaders",
        "Loaded",
        "sources",
        "keyword",
        "using",
        "Creates",
        "replacement",
        "path",
        "if",
        "system",
        "Inline",
        "true",
        "Config"
      ],
      "timestamp": "2025-12-24T18:56:00.521341"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\monitoring.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Monitoring do\n  @moduledoc \"\"\"\n  Monitoring and metrics system for ExUtcp.\n\n  Provides comprehensive monitoring capabilities including:\n  - Telemetry events for all UTCP operations\n  - Prometheus metrics integration\n  - Health checks for transports and providers\n  - Performance monitoring and alerting\n  - Custom metrics and dashboards\n  \"\"\"\n\n  require Logger\n\n  @doc \"\"\"\n  Starts the monitoring system.\n  \"\"\"\n  @spec start() :: :ok\n  def start do\n    # Attach telemetry handlers\n    attach_telemetry_handlers()\n\n    # Start Prometheus metrics\n    start_prometheus_metrics()\n\n    # Start health check system\n    start_health_checks()\n\n    Logger.info(\"ExUtcp monitoring system started\")\n    :ok\n  end\n\n  @doc \"\"\"\n  Stops the monitoring system.\n  \"\"\"\n  @spec stop() :: :ok\n  def stop do\n    # Detach telemetry handlers\n    detach_telemetry_handlers()\n\n    Logger.info(\"ExUtcp monitoring system stopped\")\n    :ok\n  end\n\n  @doc \"\"\"\n  Emits a telemetry event for tool call operations.\n  \"\"\"\n  @spec emit_tool_call_event(String.t(), String.t(), map(), integer(), :success | :error, any()) ::\n          :ok\n  def emit_tool_call_event(tool_name, provider_name, args, duration_ms, status, result_or_error) do\n    metadata = %{\n      tool_name: tool_name,\n      provider_name: provider_name,\n      args_count: map_size(args),\n      status: status,\n      result_size: calculate_result_size(result_or_error)\n    }\n\n    measurements = %{\n      duration: duration_ms,\n      timestamp: System.system_time(:millisecond)\n    }\n\n    :telemetry.execute([:ex_utcp, :tool_call], measurements, metadata)\n  end\n\n  @doc \"\"\"\n  Emits a telemetry event for search operations.\n  \"\"\"\n  @spec emit_search_event(String.t(), atom(), map(), integer(), integer()) :: :ok\n  def emit_search_event(query, algorithm, filters, duration_ms, result_count) do\n    metadata = %{\n      query_length: String.length(query),\n      algorithm: algorithm,\n      filter_count: count_active_filters(filters),\n      result_count: result_count\n    }\n\n    measurements = %{\n      duration: duration_ms,\n      timestamp: System.system_time(:millisecond)\n    }\n\n    :telemetry.execute([:ex_utcp, :search], measurements, metadata)\n  end\n\n  @doc \"\"\"\n  Emits a telemetry event for provider registration.\n  \"\"\"\n  @spec emit_provider_event(String.t(), atom(), :register | :deregister, integer()) :: :ok\n  def emit_provider_event(provider_name, transport_type, action, tool_count) do\n    metadata = %{\n      provider_name: provider_name,\n      transport_type: transport_type,\n      action: action,\n      tool_count: tool_count\n    }\n\n    measurements = %{\n      timestamp: System.system_time(:millisecond)\n    }\n\n    :telemetry.execute([:ex_utcp, :provider], measurements, metadata)\n  end\n\n  @doc \"\"\"\n  Emits a telemetry event for connection operations.\n  \"\"\"\n  @spec emit_connection_event(String.t(), atom(), :connect | :disconnect | :error, integer()) ::\n          :ok\n  def emit_connection_event(provider_name, transport_type, event, duration_ms \\\\ 0) do\n    metadata = %{\n      provider_name: provider_name,\n      transport_type: transport_type,\n      event: event\n    }\n\n    measurements = %{\n      duration: duration_ms,\n      timestamp: System.system_time(:millisecond)\n    }\n\n    :telemetry.execute([:ex_utcp, :connection], measurements, metadata)\n  end\n\n  @doc \"\"\"\n  Gets current system metrics.\n  \"\"\"\n  @spec get_metrics() :: map()\n  def get_metrics do\n    %{\n      system: get_system_metrics(),\n      utcp: get_utcp_metrics(),\n      timestamp: System.system_time(:millisecond)\n    }\n  end\n\n  @doc \"\"\"\n  Gets health status for all components.\n  \"\"\"\n  @spec get_health_status() :: map()\n  def get_health_status do\n    %{\n      overall: :healthy,\n      components: %{\n        telemetry: check_telemetry_health(),\n        prometheus: check_prometheus_health(),\n        transports: check_transports_health()\n      },\n      timestamp: System.system_time(:millisecond)\n    }\n  end\n\n  # Private functions\n\n  defp attach_telemetry_handlers do\n    # Attach handlers for tool call metrics\n    :telemetry.attach_many(\n      \"ex_utcp_tool_calls\",\n      [\n        [:ex_utcp, :tool_call]\n      ],\n      &handle_tool_call_event/4,\n      nil\n    )\n\n    # Attach handlers for search metrics\n    :telemetry.attach_many(\n      \"ex_utcp_search\",\n      [\n        [:ex_utcp, :search]\n      ],\n      &handle_search_event/4,\n      nil\n    )\n\n    # Attach handlers for provider metrics\n    :telemetry.attach_many(\n      \"ex_utcp_providers\",\n      [\n        [:ex_utcp, :provider]\n      ],\n      &handle_provider_event/4,\n      nil\n    )\n\n    # Attach handlers for connection metrics\n    :telemetry.attach_many(\n      \"ex_utcp_connections\",\n      [\n        [:ex_utcp, :connection]\n      ],\n      &handle_connection_event/4,\n      nil\n    )\n  end\n\n  defp detach_telemetry_handlers do\n    :telemetry.detach(\"ex_utcp_tool_calls\")\n    :telemetry.detach(\"ex_utcp_search\")\n    :telemetry.detach(\"ex_utcp_providers\")\n    :telemetry.detach(\"ex_utcp_connections\")\n  end\n\n  defp start_prometheus_metrics do\n    # PromEx will be configured in application.ex\n    :ok\n  end\n\n  defp start_health_checks do\n    # Health checks will be implemented as a separate GenServer\n    :ok\n  end\n\n  defp handle_tool_call_event([:ex_utcp, :tool_call], measurements, metadata, _config) do\n    Logger.info(\n      \"Tool call: #{metadata.tool_name} (#{metadata.provider_name}) - #{metadata.status} in #{measurements.duration}ms\"\n    )\n\n    # Update counters and histograms\n    :telemetry.execute(\n      [:prom_ex, :plugin, :application, :tool_calls_total],\n      %{},\n      %{\n        tool_name: metadata.tool_name,\n        provider_name: metadata.provider_name,\n        status: metadata.status\n      }\n    )\n\n    :telemetry.execute(\n      [:prom_ex, :plugin, :application, :tool_call_duration_milliseconds],\n      %{duration: measurements.duration},\n      %{\n        tool_name: metadata.tool_name,\n        provider_name: metadata.provider_name\n      }\n    )\n  end\n\n  defp handle_search_event([:ex_utcp, :search], measurements, metadata, _config) do\n    Logger.debug(\n      \"Search: '#{String.slice((metadata.query_length > 0 && \"query\") || \"empty\", 0, 20)}' (#{metadata.algorithm}) - #{metadata.result_count} results in #{measurements.duration}ms\"\n    )\n\n    # Update search metrics\n    :telemetry.execute(\n      [:prom_ex, :plugin, :application, :searches_total],\n      %{},\n      %{algorithm: metadata.algorithm}\n    )\n\n    :telemetry.execute(\n      [:prom_ex, :plugin, :application, :search_duration_milliseconds],\n      %{duration: measurements.duration},\n      %{algorithm: metadata.algorithm}\n    )\n  end\n\n  defp handle_provider_event([:ex_utcp, :provider], _measurements, metadata, _config) do\n    Logger.info(\n      \"Provider #{metadata.action}: #{metadata.provider_name} (#{metadata.transport_type}) with #{metadata.tool_count} tools\"\n    )\n\n    # Update provider metrics\n    :telemetry.execute(\n      [:prom_ex, :plugin, :application, :providers_total],\n      %{},\n      %{\n        transport_type: metadata.transport_type,\n        action: metadata.action\n      }\n    )\n  end\n\n  defp handle_connection_event([:ex_utcp, :connection], measurements, metadata, _config) do\n    Logger.debug(\n      \"Connection #{metadata.event}: #{metadata.provider_name} (#{metadata.transport_type}) in #{measurements.duration}ms\"\n    )\n\n    # Update connection metrics\n    :telemetry.execute(\n      [:prom_ex, :plugin, :application, :connections_total],\n      %{},\n      %{\n        transport_type: metadata.transport_type,\n        event: metadata.event\n      }\n    )\n\n    if measurements.duration > 0 do\n      :telemetry.execute(\n        [:prom_ex, :plugin, :application, :connection_duration_milliseconds],\n        %{duration: measurements.duration},\n        %{transport_type: metadata.transport_type}\n      )\n    end\n  end\n\n  defp calculate_result_size(result) when is_binary(result), do: byte_size(result)\n  defp calculate_result_size(result) when is_map(result), do: map_size(result)\n  defp calculate_result_size(result) when is_list(result), do: length(result)\n  defp calculate_result_size(_), do: 0\n\n  defp count_active_filters(filters) when is_map(filters) do\n    filters\n    |> Enum.count(fn {_key, value} ->\n      case value do\n        list when is_list(list) -> not Enum.empty?(list)\n        _ -> value != nil\n      end\n    end)\n  end\n\n  defp count_active_filters(_), do: 0\n\n  defp get_system_metrics do\n    %{\n      memory: %{\n        total: :erlang.memory(:total),\n        processes: :erlang.memory(:processes),\n        system: :erlang.memory(:system),\n        atom: :erlang.memory(:atom),\n        binary: :erlang.memory(:binary),\n        ets: :erlang.memory(:ets)\n      },\n      processes: %{\n        count: :erlang.system_info(:process_count),\n        limit: :erlang.system_info(:process_limit)\n      },\n      schedulers: %{\n        online: :erlang.system_info(:schedulers_online),\n        total: :erlang.system_info(:schedulers)\n      }\n    }\n  end\n\n  defp get_utcp_metrics do\n    # These would be populated from actual usage statistics\n    %{\n      tool_calls: %{\n        total: 0,\n        success: 0,\n        error: 0,\n        avg_duration: 0.0\n      },\n      searches: %{\n        total: 0,\n        by_algorithm: %{\n          exact: 0,\n          fuzzy: 0,\n          semantic: 0,\n          combined: 0\n        }\n      },\n      providers: %{\n        total: 0,\n        by_transport: %{\n          http: 0,\n          websocket: 0,\n          grpc: 0,\n          graphql: 0,\n          mcp: 0,\n          tcp: 0,\n          udp: 0,\n          cli: 0\n        }\n      },\n      connections: %{\n        active: 0,\n        total: 0,\n        failed: 0\n      }\n    }\n  end\n\n  # Check if telemetry is working\n  defp check_telemetry_health do\n    :telemetry.execute([:ex_utcp, :health_check], %{}, %{component: :telemetry})\n    :healthy\n  rescue\n    _ -> :unhealthy\n  end\n\n  # Check if Prometheus metrics are working\n  defp check_prometheus_health do\n    # This would check if PromEx is running and accessible\n    :healthy\n  rescue\n    _ -> :unhealthy\n  end\n\n  defp check_transports_health do\n    # Check health of all transport modules\n    transports = [\n      ExUtcp.Transports.Http,\n      ExUtcp.Transports.Cli,\n      ExUtcp.Transports.WebSocket,\n      ExUtcp.Transports.Grpc,\n      ExUtcp.Transports.Graphql,\n      ExUtcp.Transports.Mcp,\n      ExUtcp.Transports.TcpUdp\n    ]\n\n    transport_health =\n      Enum.map(transports, fn transport ->\n        transport_name = transport.transport_name()\n        health_status = check_transport_health(transport)\n        {transport_name, health_status}\n      end)\n      |> Map.new()\n\n    overall_health =\n      if Enum.all?(Map.values(transport_health), &(&1 == :healthy)) do\n        :healthy\n      else\n        :degraded\n      end\n\n    %{\n      overall: overall_health,\n      transports: transport_health\n    }\n  end\n\n  defp check_transport_health(transport) do\n    # Check if transport module is loaded and has required functions\n    if function_exported?(transport, :transport_name, 0) and\n         function_exported?(transport, :supports_streaming?, 0) do\n      :healthy\n    else\n      :unhealthy\n    end\n  rescue\n    _ -> :unhealthy\n  end\nend\n",
      "line_count": 438,
      "word_count": 957,
      "title": "Monitoring.Ex",
      "summary": "defmodule ExUtcp.Monitoring do @moduledoc \"\"\"",
      "key_terms": [
        "integration",
        "comprehensive",
        "grpc",
        "populated",
        "search",
        "Detach",
        "error",
        "check",
        "list",
        "WebSocket",
        "info",
        "started",
        "websocket",
        "Utcp",
        "disconnect",
        "connect",
        "providers",
        "usage",
        "has",
        "application"
      ],
      "timestamp": "2025-12-24T18:56:00.552734"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\openapi_converter.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.OpenApiConverter do\n  @moduledoc \"\"\"\n  OpenAPI Converter for automatic API discovery and tool generation.\n\n  Converts OpenAPI 2.0 and 3.0 specifications into UTCP tools, enabling\n  AI agents to interact with existing APIs directly without server modifications.\n\n  ## Features\n\n  - OpenAPI 2.0 and 3.0 support\n  - Automatic tool generation from API operations\n  - Authentication scheme mapping\n  - Parameter and response schema handling\n  - Variable substitution support\n  - Batch processing of multiple specs\n\n  ## Usage\n\n      # Convert from URL\n      {:ok, manual} = OpenApiConverter.convert_from_url(\"https://api.github.com/openapi.json\")\n\n      # Convert from local file\n      {:ok, manual} = OpenApiConverter.convert_from_file(\"path/to/spec.json\")\n\n      # Convert from map\n      {:ok, manual} = OpenApiConverter.convert(spec_map)\n\n      # Convert with custom options\n      {:ok, manual} = OpenApiConverter.convert(spec_map, %{\n        base_url: \"https://api.example.com\",\n        auth: %{type: \"api_key\", api_key: \"Bearer ${API_KEY}\"},\n        prefix: \"github\"\n      })\n  \"\"\"\n\n  alias ExUtcp.OpenApiConverter.Generator\n  alias ExUtcp.OpenApiConverter.Parser\n\n  @doc \"\"\"\n  Converts an OpenAPI specification to a UTCP manual.\n\n  ## Parameters\n\n  - `spec`: OpenAPI specification as a map\n  - `opts`: Optional configuration map with keys:\n    - `:base_url` - Override base URL from spec\n    - `:auth` - Authentication configuration\n    - `:prefix` - Prefix for tool names\n    - `:include_deprecated` - Include deprecated operations (default: false)\n    - `:filter_tags` - Only include operations with these tags\n    - `:exclude_tags` - Exclude operations with these tags\n\n  ## Returns\n\n  `{:ok, manual}` on success, `{:error, reason}` on failure.\n  \"\"\"\n  @spec convert(map(), keyword()) :: {:ok, map()} | {:error, term()}\n  def convert(spec, opts \\\\ []) do\n    with {:ok, parsed_spec} <- Parser.parse(spec),\n         {:ok, tools} <- Generator.generate_tools(parsed_spec, opts) do\n      manual = %{\n        name: parsed_spec.info.title || \"OpenAPI Tools\",\n        description: parsed_spec.info.description || \"Tools generated from OpenAPI specification\",\n        tools: tools\n      }\n\n      {:ok, manual}\n    end\n  end\n\n  @doc \"\"\"\n  Converts an OpenAPI specification from a URL.\n\n  ## Parameters\n\n  - `url`: URL to the OpenAPI specification\n  - `opts`: Optional configuration (same as convert/2)\n\n  ## Returns\n\n  `{:ok, manual}` on success, `{:error, reason}` on failure.\n  \"\"\"\n  @spec convert_from_url(String.t(), keyword()) :: {:ok, map()} | {:error, term()}\n  def convert_from_url(url, opts \\\\ []) do\n    with {:ok, response} <- fetch_spec_from_url(url),\n         {:ok, spec} <- parse_spec_content(response.body, response.content_type) do\n      convert(spec, opts)\n    end\n  end\n\n  @doc \"\"\"\n  Converts an OpenAPI specification from a local file.\n\n  ## Parameters\n\n  - `file_path`: Path to the OpenAPI specification file\n  - `opts`: Optional configuration (same as convert/2)\n\n  ## Returns\n\n  `{:ok, manual}` on success, `{:error, reason}` on failure.\n  \"\"\"\n  @spec convert_from_file(String.t(), keyword()) :: {:ok, map()} | {:error, term()}\n  def convert_from_file(file_path, opts \\\\ []) do\n    with {:ok, validated_path} <- validate_openapi_file_path(file_path),\n         {:ok, content} <- File.read(validated_path),\n         {:ok, spec} <- parse_spec_content(content, content_type_from_path(validated_path)) do\n      convert(spec, opts)\n    else\n      {:error, :invalid_path} -> {:error, \"Invalid file path\"}\n      {:error, :enoent} -> {:error, \"File not found: #{file_path}\"}\n      {:error, reason} -> {:error, \"Failed to read file: #{inspect(reason)}\"}\n    end\n  end\n\n  defp validate_openapi_file_path(file_path) do\n    # Resolve to absolute path and check for directory traversal\n    abs_path = Path.expand(file_path)\n\n    # Check if path contains directory traversal patterns\n    cond do\n      String.contains?(file_path, [\"../\", \"..\\\\\"]) ->\n        {:error, :invalid_path}\n\n      # Ensure the path doesn't escape the current working directory\n      String.contains?(abs_path, \"..\") ->\n        {:error, :invalid_path}\n\n      # Validate file extension\n      not String.ends_with?(abs_path, [\".json\", \".yaml\", \".yml\"]) ->\n        {:error, :invalid_file_type}\n\n      # Check if file exists and is readable\n      not File.exists?(abs_path) ->\n        {:error, :file_not_found}\n\n      true ->\n        {:ok, abs_path}\n    end\n  end\n\n  @doc \"\"\"\n  Converts multiple OpenAPI specifications and merges them into a single manual.\n\n  ## Parameters\n\n  - `specs`: List of specification sources (maps, URLs, or file paths)\n  - `opts`: Optional configuration (same as convert/2)\n\n  ## Returns\n\n  `{:ok, manual}` on success, `{:error, reason}` on failure.\n  \"\"\"\n  @spec convert_multiple(list(), keyword()) :: {:ok, map()} | {:error, term()}\n  def convert_multiple(specs, opts \\\\ []) do\n    results = Enum.map(specs, &convert_single_spec/1)\n\n    case Enum.find(results, fn {status, _} -> status == :error end) do\n      nil ->\n        {_status, manuals} = Enum.unzip(results)\n        merged_manual = merge_manuals(manuals, opts)\n        {:ok, merged_manual}\n\n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\n\n  @doc \"\"\"\n  Validates an OpenAPI specification without converting it.\n\n  ## Parameters\n\n  - `spec`: OpenAPI specification as a map\n\n  ## Returns\n\n  `{:ok, validation_result}` on success, `{:error, reason}` on failure.\n  \"\"\"\n  @spec validate(map()) :: {:ok, map()} | {:error, term()}\n  def validate(spec) do\n    Parser.validate(spec)\n  end\n\n  # Private functions\n\n  defp convert_single_spec(spec) when is_map(spec) do\n    convert(spec)\n  end\n\n  defp convert_single_spec(url) when is_binary(url) do\n    convert_from_url(url)\n  end\n\n  defp convert_single_spec(file_path) when is_binary(file_path) do\n    convert_from_file(file_path)\n  end\n\n  defp fetch_spec_from_url(url) do\n    case Req.get(url, receive_timeout: 30_000) do\n      {:ok, response} ->\n        # Extract content type from headers\n        content_type =\n          case response.headers[\"content-type\"] do\n            [content_type | _] -> content_type\n            content_type when is_binary(content_type) -> content_type\n            _ -> \"application/json\"\n          end\n\n        {:ok, %{body: response.body, content_type: content_type}}\n\n      {:error, reason} ->\n        {:error, \"Failed to fetch spec from URL: #{inspect(reason)}\"}\n    end\n  end\n\n  defp parse_spec_content(content, content_type) do\n    content_str = ensure_string(content)\n\n    case content_type do\n      \"application/json\" -> parse_json(content_str)\n      \"application/yaml\" -> parse_yaml(content_str)\n      _ -> try_parse_both_formats(content_str)\n    end\n  end\n\n  defp ensure_string(content) do\n    if is_binary(content), do: content, else: inspect(content)\n  end\n\n  defp parse_json(content_str) do\n    case Jason.decode(content_str) do\n      {:ok, spec} -> {:ok, spec}\n      {:error, reason} -> {:error, \"Invalid JSON: #{inspect(reason)}\"}\n    end\n  end\n\n  defp parse_yaml(content_str) do\n    case YamlElixir.read_from_string(content_str) do\n      {:ok, spec} -> {:ok, spec}\n      {:error, reason} -> {:error, \"Invalid YAML: #{inspect(reason)}\"}\n    end\n  end\n\n  defp try_parse_both_formats(content_str) do\n    case parse_json(content_str) do\n      {:ok, spec} -> {:ok, spec}\n      {:error, _} -> parse_yaml_or_error(content_str)\n    end\n  end\n\n  defp parse_yaml_or_error(content_str) do\n    case YamlElixir.read_from_string(content_str) do\n      {:ok, spec} -> {:ok, spec}\n      {:error, reason} -> {:error, \"Invalid spec format: #{inspect(reason)}\"}\n    end\n  end\n\n  defp content_type_from_path(path) do\n    case Path.extname(path) do\n      \".yaml\" -> \"application/yaml\"\n      \".yml\" -> \"application/yaml\"\n      _ -> \"application/json\"\n    end\n  end\n\n  defp merge_manuals(manuals, opts) do\n    all_tools = Enum.flat_map(manuals, & &1.tools)\n    prefix = Keyword.get(opts, :prefix, \"\")\n\n    prefixed_tools =\n      if prefix == \"\" do\n        all_tools\n      else\n        Enum.map(all_tools, fn tool ->\n          %{tool | name: \"#{prefix}.#{tool.name}\"}\n        end)\n      end\n\n    %{\n      name: \"Merged OpenAPI Tools\",\n      description: \"Tools generated from multiple OpenAPI specifications\",\n      tools: prefixed_tools\n    }\n  end\nend\n",
      "line_count": 287,
      "word_count": 884,
      "title": "Openapi Converter.Ex",
      "summary": "defmodule ExUtcp.OpenApiConverter do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "paths",
        "File",
        "yaml",
        "error",
        "headers",
        "convert",
        "extension",
        "check",
        "list",
        "info",
        "format",
        "Utcp",
        "same",
        "Jason",
        "found",
        "AI",
        "sources",
        "multiple",
        "application"
      ],
      "timestamp": "2025-12-24T18:56:00.583962"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\providers.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Providers do\n  @moduledoc \"\"\"\n  Provider implementations for different protocols.\n\n  This module contains the data structures and functions for various provider types\n  including HTTP, CLI, WebSocket, gRPC, GraphQL, TCP, UDP, WebRTC, MCP, and Text providers.\n  \"\"\"\n\n  alias ExUtcp.Types, as: T\n\n  @doc \"\"\"\n  Creates a new HTTP provider.\n  \"\"\"\n  @spec new_http_provider(keyword()) :: T.http_provider()\n  def new_http_provider(opts) do\n    %{\n      name: Keyword.fetch!(opts, :name),\n      type: :http,\n      http_method: Keyword.get(opts, :http_method, \"GET\"),\n      url: Keyword.fetch!(opts, :url),\n      content_type: Keyword.get(opts, :content_type, \"application/json\"),\n      auth: Keyword.get(opts, :auth, nil),\n      headers: Keyword.get(opts, :headers, %{}),\n      body_field: Keyword.get(opts, :body_field, nil),\n      header_fields: Keyword.get(opts, :header_fields, [])\n    }\n  end\n\n  @doc \"\"\"\n  Creates a new CLI provider.\n  \"\"\"\n  @spec new_cli_provider(keyword()) :: T.cli_provider()\n  def new_cli_provider(opts) do\n    %{\n      name: Keyword.fetch!(opts, :name),\n      type: :cli,\n      command_name: Keyword.fetch!(opts, :command_name),\n      working_dir: Keyword.get(opts, :working_dir, nil),\n      env_vars: Keyword.get(opts, :env_vars, %{})\n    }\n  end\n\n  @doc \"\"\"\n  Creates a new WebSocket provider.\n  \"\"\"\n  @spec new_websocket_provider(keyword()) :: T.websocket_provider()\n  def new_websocket_provider(opts) do\n    %{\n      name: Keyword.fetch!(opts, :name),\n      type: :websocket,\n      url: Keyword.fetch!(opts, :url),\n      protocol: Keyword.get(opts, :protocol, nil),\n      keep_alive: Keyword.get(opts, :keep_alive, false),\n      auth: Keyword.get(opts, :auth, nil),\n      headers: Keyword.get(opts, :headers, %{}),\n      header_fields: Keyword.get(opts, :header_fields, [])\n    }\n  end\n\n  @doc \"\"\"\n  Creates a new gRPC provider.\n  \"\"\"\n  @spec new_grpc_provider(keyword()) :: T.grpc_provider()\n  def new_grpc_provider(opts) do\n    %{\n      name: Keyword.fetch!(opts, :name),\n      type: :grpc,\n      host: Keyword.get(opts, :host, \"127.0.0.1\"),\n      port: Keyword.get(opts, :port, 9339),\n      service_name: Keyword.get(opts, :service_name, \"UTCPService\"),\n      method_name: Keyword.get(opts, :method_name, \"CallTool\"),\n      target: Keyword.get(opts, :target, nil),\n      use_ssl: Keyword.get(opts, :use_ssl, false),\n      auth: Keyword.get(opts, :auth, nil)\n    }\n  end\n\n  @doc \"\"\"\n  Creates a new GraphQL provider.\n  \"\"\"\n  @spec new_graphql_provider(keyword()) :: T.graphql_provider()\n  def new_graphql_provider(opts) do\n    %{\n      name: Keyword.fetch!(opts, :name),\n      type: :graphql,\n      url: Keyword.fetch!(opts, :url),\n      auth: Keyword.get(opts, :auth, nil),\n      headers: Keyword.get(opts, :headers, %{})\n    }\n  end\n\n  @doc \"\"\"\n  Creates a new WebRTC provider.\n  \"\"\"\n  @spec new_webrtc_provider(keyword()) :: T.webrtc_provider()\n  def new_webrtc_provider(opts) do\n    %{\n      name: Keyword.fetch!(opts, :name),\n      type: :webrtc,\n      peer_id: Keyword.get(opts, :peer_id),\n      signaling_server: Keyword.get(opts, :signaling_server, \"wss://signaling.example.com\"),\n      ice_servers:\n        Keyword.get(opts, :ice_servers, [\n          %{urls: [\"stun:stun.l.google.com:19302\"]}\n        ]),\n      timeout: Keyword.get(opts, :timeout, 30_000),\n      tools: Keyword.get(opts, :tools, [])\n    }\n  end\n\n  @doc \"\"\"\n  Creates a new MCP provider.\n  \"\"\"\n  @spec new_mcp_provider(keyword()) :: T.mcp_provider()\n  def new_mcp_provider(opts) do\n    %{\n      name: Keyword.fetch!(opts, :name),\n      type: :mcp,\n      url: Keyword.fetch!(opts, :url),\n      auth: Keyword.get(opts, :auth, nil)\n    }\n  end\n\n  @doc \"\"\"\n  Creates a new TCP provider.\n  \"\"\"\n  @spec new_tcp_provider(keyword()) :: T.tcp_provider()\n  def new_tcp_provider(opts) do\n    %{\n      name: Keyword.fetch!(opts, :name),\n      type: :tcp,\n      protocol: :tcp,\n      host: Keyword.fetch!(opts, :host),\n      port: Keyword.fetch!(opts, :port),\n      timeout: Keyword.get(opts, :timeout, 5000),\n      auth: Keyword.get(opts, :auth, nil)\n    }\n  end\n\n  @doc \"\"\"\n  Creates a new UDP provider.\n  \"\"\"\n  @spec new_udp_provider(keyword()) :: T.udp_provider()\n  def new_udp_provider(opts) do\n    %{\n      name: Keyword.fetch!(opts, :name),\n      type: :udp,\n      protocol: :udp,\n      host: Keyword.fetch!(opts, :host),\n      port: Keyword.fetch!(opts, :port),\n      timeout: Keyword.get(opts, :timeout, 5000),\n      auth: Keyword.get(opts, :auth, nil)\n    }\n  end\n\n  @doc \"\"\"\n  Creates a new Text provider.\n  \"\"\"\n  @spec new_text_provider(keyword()) :: T.text_provider()\n  def new_text_provider(opts) do\n    %{\n      name: Keyword.fetch!(opts, :name),\n      type: :text,\n      file_path: Keyword.fetch!(opts, :file_path)\n    }\n  end\n\n  @doc \"\"\"\n  Creates a new SSE provider.\n  \"\"\"\n  @spec new_sse_provider(keyword()) :: T.sse_provider()\n  def new_sse_provider(opts) do\n    %{\n      name: Keyword.fetch!(opts, :name),\n      type: :sse,\n      url: Keyword.fetch!(opts, :url),\n      auth: Keyword.get(opts, :auth, nil),\n      headers: Keyword.get(opts, :headers, %{})\n    }\n  end\n\n  @doc \"\"\"\n  Creates a new Streamable HTTP provider.\n  \"\"\"\n  @spec new_streamable_http_provider(keyword()) :: T.streamable_http_provider()\n  def new_streamable_http_provider(opts) do\n    %{\n      name: Keyword.fetch!(opts, :name),\n      type: :http_stream,\n      url: Keyword.fetch!(opts, :url),\n      auth: Keyword.get(opts, :auth, nil),\n      headers: Keyword.get(opts, :headers, %{})\n    }\n  end\n\n  @doc \"\"\"\n  Gets the provider name from a provider struct.\n  \"\"\"\n  @spec get_name(T.provider()) :: String.t()\n  def get_name(provider) do\n    Map.get(provider, :name, \"\")\n  end\n\n  @doc \"\"\"\n  Gets the provider type from a provider struct.\n  \"\"\"\n  @spec get_type(T.provider()) :: T.provider_type()\n  def get_type(provider) do\n    Map.get(provider, :type, :http)\n  end\n\n  @doc \"\"\"\n  Sets the provider name.\n  \"\"\"\n  @spec set_name(T.provider(), String.t()) :: T.provider()\n  def set_name(provider, name) do\n    Map.put(provider, :name, name)\n  end\n\n  @doc \"\"\"\n  Validates a provider configuration.\n  \"\"\"\n  @spec validate_provider(T.provider()) :: :ok | {:error, String.t()}\n  def validate_provider(provider) do\n    cond do\n      is_nil(Map.get(provider, :name)) or Map.get(provider, :name) == \"\" ->\n        {:error, \"Provider name is required\"}\n\n      is_nil(Map.get(provider, :type)) ->\n        {:error, \"Provider type is required\"}\n\n      true ->\n        :ok\n    end\n  end\n\n  @doc \"\"\"\n  Normalizes provider name by replacing dots with underscores.\n  \"\"\"\n  @spec normalize_name(String.t()) :: String.t()\n  def normalize_name(name) do\n    String.replace(name, \".\", \"_\")\n  end\nend\n",
      "line_count": 245,
      "word_count": 635,
      "title": "Providers.Ex",
      "summary": "defmodule ExUtcp.Providers do @moduledoc \"\"\"",
      "key_terms": [
        "implementations",
        "grpc",
        "headers",
        "error",
        "WebSocket",
        "Utcp",
        "websocket",
        "providers",
        "application",
        "keyword",
        "Sets",
        "Creates",
        "sse",
        "true",
        "struct",
        "UDP",
        "CLI",
        "google",
        "UTCPService",
        "function"
      ],
      "timestamp": "2025-12-24T18:56:00.615737"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\repository.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Repository do\n  @moduledoc \"\"\"\n  In-memory repository for storing providers and tools.\n\n  This module provides a simple in-memory storage solution for UTCP providers and tools.\n  In a production environment, you might want to implement a persistent storage backend.\n  \"\"\"\n\n  alias ExUtcp.Types, as: T\n\n  @doc \"\"\"\n  Creates a new in-memory tool repository.\n  \"\"\"\n  @spec new() :: T.tool_repository()\n  def new do\n    %{\n      tools: %{},\n      providers: %{}\n    }\n  end\n\n  @doc \"\"\"\n  Saves a provider with its associated tools.\n  \"\"\"\n  @spec save_provider_with_tools(T.tool_repository(), T.provider(), [T.tool()]) ::\n          T.tool_repository()\n  def save_provider_with_tools(repo, provider, tools) do\n    provider_name = ExUtcp.Providers.get_name(provider)\n\n    repo\n    |> Map.put(:providers, Map.put(repo.providers, provider_name, provider))\n    |> Map.put(:tools, Map.put(repo.tools, provider_name, tools))\n  end\n\n  @doc \"\"\"\n  Gets a provider by name.\n  \"\"\"\n  @spec get_provider(T.tool_repository(), String.t()) :: T.provider() | nil\n  def get_provider(repo, provider_name) do\n    Map.get(repo.providers, provider_name)\n  end\n\n  @doc \"\"\"\n  Gets all providers.\n  \"\"\"\n  @spec get_providers(T.tool_repository()) :: [T.provider()]\n  def get_providers(repo) do\n    Map.values(repo.providers)\n  end\n\n  @doc \"\"\"\n  Adds a tool to the repository.\n  \"\"\"\n  @spec add_tool(T.tool_repository(), T.tool()) ::\n          {:ok, T.tool_repository()} | {:error, String.t()}\n  def add_tool(repo, tool) do\n    provider_name = tool.provider_name\n\n    # Check if provider exists\n    case Map.get(repo.providers, provider_name) do\n      nil ->\n        {:error, \"Provider #{provider_name} not found\"}\n\n      _provider ->\n        # Add tool to the provider's tools\n        existing_tools = Map.get(repo.tools, provider_name, [])\n        updated_tools = [tool | existing_tools]\n        new_repo = Map.put(repo, :tools, Map.put(repo.tools, provider_name, updated_tools))\n        {:ok, new_repo}\n    end\n  end\n\n  @doc \"\"\"\n  Gets a tool by name.\n  \"\"\"\n  @spec get_tool(T.tool_repository(), String.t()) :: T.tool() | nil\n  def get_tool(repo, tool_name) do\n    repo.tools\n    |> Map.values()\n    |> List.flatten()\n    |> Enum.find(&(&1.name == tool_name))\n  end\n\n  @doc \"\"\"\n  Gets all tools.\n  \"\"\"\n  @spec get_tools(T.tool_repository()) :: [T.tool()]\n  def get_tools(repo) do\n    Map.values(repo.tools) |> List.flatten()\n  end\n\n  @doc \"\"\"\n  Gets tools by provider name.\n  \"\"\"\n  @spec get_tools_by_provider(T.tool_repository(), String.t()) :: [T.tool()]\n  def get_tools_by_provider(repo, provider_name) do\n    Map.get(repo.tools, provider_name, [])\n  end\n\n  @doc \"\"\"\n  Removes a provider and its tools.\n  \"\"\"\n  @spec remove_provider(T.tool_repository(), String.t()) :: T.tool_repository()\n  def remove_provider(repo, provider_name) do\n    repo\n    |> Map.put(:providers, Map.delete(repo.providers, provider_name))\n    |> Map.put(:tools, Map.delete(repo.tools, provider_name))\n  end\n\n  @doc \"\"\"\n  Removes a specific tool.\n  \"\"\"\n  @spec remove_tool(T.tool_repository(), String.t()) :: T.tool_repository()\n  def remove_tool(repo, tool_name) do\n    updated_tools =\n      repo.tools\n      |> Map.new(fn {provider_name, tools} ->\n        filtered_tools = Enum.reject(tools, &(&1.name == tool_name))\n        {provider_name, filtered_tools}\n      end)\n\n    Map.put(repo, :tools, updated_tools)\n  end\n\n  @doc \"\"\"\n  Searches for tools matching a query.\n  \"\"\"\n  @spec search_tools(T.tool_repository(), String.t(), integer()) :: [T.tool()]\n  def search_tools(repo, query, limit) do\n    repo\n    |> get_tools()\n    |> Enum.filter(&ExUtcp.Tools.matches_query?(&1, query))\n    |> Enum.take(limit)\n  end\n\n  @doc \"\"\"\n  Gets the count of tools in the repository.\n  \"\"\"\n  @spec tool_count(T.tool_repository()) :: integer()\n  def tool_count(repo) do\n    repo.tools\n    |> Map.values()\n    |> List.flatten()\n    |> length()\n  end\n\n  @doc \"\"\"\n  Gets the count of providers in the repository.\n  \"\"\"\n  @spec provider_count(T.tool_repository()) :: integer()\n  def provider_count(repo) do\n    map_size(repo.providers)\n  end\n\n  @doc \"\"\"\n  Checks if a provider exists.\n  \"\"\"\n  @spec has_provider?(T.tool_repository(), String.t()) :: boolean()\n  def has_provider?(repo, provider_name) do\n    Map.has_key?(repo.providers, provider_name)\n  end\n\n  @doc \"\"\"\n  Checks if a tool exists.\n  \"\"\"\n  @spec has_tool?(T.tool_repository(), String.t()) :: boolean()\n  def has_tool?(repo, tool_name) do\n    get_tool(repo, tool_name) != nil\n  end\n\n  @doc \"\"\"\n  Clears all providers and tools from the repository.\n  \"\"\"\n  @spec clear(T.tool_repository()) :: T.tool_repository()\n  def clear(_repo) do\n    new()\n  end\nend\n",
      "line_count": 179,
      "word_count": 480,
      "title": "Repository.Ex",
      "summary": "defmodule ExUtcp.Repository do @moduledoc \"\"\"",
      "key_terms": [
        "clear",
        "error",
        "Utcp",
        "providers",
        "repo",
        "found",
        "associated",
        "reject",
        "Creates",
        "if",
        "production",
        "In",
        "backend",
        "Saves",
        "memory",
        "Searches",
        "Add",
        "might",
        "implement",
        "def"
      ],
      "timestamp": "2025-12-24T18:56:00.631648"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\search.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Search do\n  @moduledoc \"\"\"\n  Advanced search functionality for UTCP tools and providers.\n\n  Provides multiple search algorithms including:\n  - Exact matching\n  - Fuzzy search with similarity scoring\n  - Semantic search based on descriptions\n  - Tag-based filtering\n  - Provider-based filtering\n  - Transport-based filtering\n  \"\"\"\n\n  alias ExUtcp.Search.Engine\n  alias ExUtcp.Search.Filters\n  alias ExUtcp.Search.Fuzzy\n  alias ExUtcp.Search.Ranking\n  alias ExUtcp.Search.Security\n  alias ExUtcp.Search.Semantic\n  alias ExUtcp.Types\n\n  @type search_options :: %{\n          algorithm: :exact | :fuzzy | :semantic | :combined,\n          filters: %{\n            providers: [String.t()],\n            transports: [atom()],\n            tags: [String.t()]\n          },\n          limit: integer(),\n          threshold: float(),\n          include_descriptions: boolean(),\n          use_haystack: boolean(),\n          security_scan: boolean(),\n          filter_sensitive: boolean()\n        }\n\n  @type search_result :: %{\n          tool: Types.tool(),\n          score: float(),\n          match_type: :exact | :fuzzy | :semantic,\n          matched_fields: [String.t()],\n          security_warnings: [map()]\n        }\n\n  @doc \"\"\"\n  Creates a new search engine with default configuration.\n  \"\"\"\n  @spec new(keyword()) :: Engine.t()\n  def new(opts \\\\ []) do\n    Engine.new(opts)\n  end\n\n  @doc \"\"\"\n  Searches for tools using the specified query and options.\n  \"\"\"\n  @spec search_tools(Engine.t(), String.t(), search_options()) :: [search_result()]\n  def search_tools(engine, query, opts \\\\ %{}) do\n    opts = merge_default_options(opts)\n\n    tools = Engine.get_all_tools(engine)\n\n    # Apply filters first to reduce search space\n    filtered_tools = Filters.apply_filters(tools, opts.filters)\n\n    # Apply search algorithm\n    results =\n      case opts.algorithm do\n        :exact -> search_exact(filtered_tools, query, opts)\n        :fuzzy -> search_fuzzy(filtered_tools, query, opts)\n        :semantic -> search_semantic(filtered_tools, query, opts)\n        :combined -> search_combined(filtered_tools, query, opts)\n      end\n\n    # Rank and limit results\n    ranked_results =\n      results\n      |> Ranking.rank_results(query, opts)\n      |> Enum.take(opts.limit)\n\n    # Apply security scanning if requested\n    if Map.get(opts, :security_scan, false) do\n      ranked_results = Security.add_security_warnings(ranked_results)\n\n      if Map.get(opts, :filter_sensitive, false) do\n        Security.filter_secure_results(ranked_results)\n      else\n        ranked_results\n      end\n    else\n      # Add empty security warnings for consistency\n      Enum.map(ranked_results, &Map.put(&1, :security_warnings, []))\n    end\n  end\n\n  @doc \"\"\"\n  Searches for providers using the specified query and options.\n  \"\"\"\n  @spec search_providers(Engine.t(), String.t(), search_options()) :: [map()]\n  def search_providers(engine, query, opts \\\\ %{}) do\n    opts = merge_default_options(opts)\n\n    providers = Engine.get_all_providers(engine)\n\n    # Apply filters\n    filtered_providers = Filters.apply_provider_filters(providers, opts.filters)\n\n    # Apply search algorithm\n    results =\n      case opts.algorithm do\n        :exact -> search_providers_exact(filtered_providers, query, opts)\n        :fuzzy -> search_providers_fuzzy(filtered_providers, query, opts)\n        :semantic -> search_providers_semantic(filtered_providers, query, opts)\n        :combined -> search_providers_combined(filtered_providers, query, opts)\n      end\n\n    # Rank and limit results\n    results\n    |> Ranking.rank_provider_results(query, opts)\n    |> Enum.take(opts.limit)\n  end\n\n  @doc \"\"\"\n  Suggests similar tools based on a given tool.\n  \"\"\"\n  @spec suggest_similar_tools(Engine.t(), Types.tool(), keyword()) :: [search_result()]\n  def suggest_similar_tools(engine, tool, opts \\\\ []) do\n    limit = Keyword.get(opts, :limit, 5)\n    threshold = Keyword.get(opts, :threshold, 0.3)\n\n    all_tools =\n      Engine.get_all_tools(engine)\n      |> Enum.reject(&(&1.name == tool.name))\n\n    # Use semantic similarity based on descriptions and tags\n    Semantic.find_similar_tools(tool, all_tools, threshold)\n    |> Enum.take(limit)\n  end\n\n  @doc \"\"\"\n  Gets search suggestions based on partial query.\n  \"\"\"\n  @spec get_suggestions(Engine.t(), String.t(), keyword()) :: [String.t()]\n  def get_suggestions(engine, partial_query, opts \\\\ []) do\n    limit = Keyword.get(opts, :limit, 10)\n    min_length = Keyword.get(opts, :min_length, 2)\n\n    if String.length(partial_query) < min_length do\n      []\n    else\n      tools = Engine.get_all_tools(engine)\n      providers = Engine.get_all_providers(engine)\n\n      # Get suggestions from tool names, descriptions, and provider names\n      tool_suggestions =\n        Enum.flat_map(tools, fn tool ->\n          [tool.name | extract_keywords(tool.definition.description)]\n        end)\n\n      provider_suggestions = Enum.map(providers, & &1.name)\n\n      all_suggestions = tool_suggestions ++ provider_suggestions\n\n      all_suggestions\n      |> Enum.filter(&String.contains?(String.downcase(&1), String.downcase(partial_query)))\n      |> Enum.uniq()\n      |> Enum.take(limit)\n    end\n  end\n\n  # Private functions\n\n  defp merge_default_options(opts) do\n    defaults = %{\n      algorithm: :combined,\n      filters: %{\n        providers: [],\n        transports: [],\n        tags: []\n      },\n      limit: 20,\n      threshold: 0.1,\n      include_descriptions: true,\n      use_haystack: true,\n      security_scan: false,\n      filter_sensitive: false\n    }\n\n    Map.merge(defaults, opts)\n  end\n\n  defp search_exact(tools, query, opts) do\n    query_lower = String.downcase(query)\n\n    Enum.filter(tools, fn tool ->\n      name_match = String.downcase(tool.name) == query_lower\n\n      desc_match =\n        opts.include_descriptions and\n          String.contains?(String.downcase(tool.definition.description), query_lower)\n\n      name_match or desc_match\n    end)\n    |> Enum.map(fn tool ->\n      match_type = if String.downcase(tool.name) == query_lower, do: :exact, else: :exact\n      matched_fields = get_matched_fields(tool, query, :exact)\n\n      %{\n        tool: tool,\n        score: 1.0,\n        match_type: match_type,\n        matched_fields: matched_fields\n      }\n    end)\n  end\n\n  defp search_fuzzy(tools, query, opts) do\n    # Use enhanced fuzzy search with FuzzyCompare\n    threshold = Map.get(opts, :threshold, 0.6)\n\n    tools\n    |> Enum.map(fn tool ->\n      name_similarity = Fuzzy.best_similarity(tool.name, query)\n\n      desc_similarity =\n        if opts.include_descriptions do\n          Fuzzy.best_similarity(tool.definition.description, query)\n        else\n          0.0\n        end\n\n      max_similarity = max(name_similarity, desc_similarity)\n\n      if max_similarity >= threshold do\n        matched_fields = []\n\n        matched_fields =\n          if name_similarity >= threshold, do: [\"name\" | matched_fields], else: matched_fields\n\n        matched_fields =\n          if desc_similarity >= threshold,\n            do: [\"description\" | matched_fields],\n            else: matched_fields\n\n        %{\n          tool: tool,\n          score: max_similarity,\n          match_type: :fuzzy,\n          matched_fields: matched_fields\n        }\n      end\n    end)\n    |> Enum.reject(&is_nil/1)\n    |> Enum.sort_by(& &1.score, :desc)\n  end\n\n  defp search_semantic(tools, query, opts) do\n    Semantic.search_tools(tools, query, opts)\n  end\n\n  defp search_combined(tools, query, opts) do\n    # Combine exact, fuzzy, and semantic search results\n    exact_results = search_exact(tools, query, opts)\n    fuzzy_results = search_fuzzy(tools, query, opts)\n    semantic_results = search_semantic(tools, query, opts)\n\n    # Merge and deduplicate results\n    all_results = exact_results ++ fuzzy_results ++ semantic_results\n\n    all_results\n    |> Enum.group_by(& &1.tool.name)\n    |> Enum.map(fn {_name, results} ->\n      # Take the best result for each tool\n      Enum.max_by(results, & &1.score)\n    end)\n  end\n\n  defp search_providers_exact(providers, query, _opts) do\n    query_lower = String.downcase(query)\n\n    Enum.filter(providers, fn provider ->\n      String.downcase(provider.name) == query_lower or\n        Atom.to_string(provider.type) == query_lower\n    end)\n    |> Enum.map(fn provider ->\n      %{\n        provider: provider,\n        score: 1.0,\n        match_type: :exact,\n        matched_fields: [\"name\"]\n      }\n    end)\n  end\n\n  defp search_providers_fuzzy(providers, query, opts) do\n    Fuzzy.search_providers(providers, query, opts)\n  end\n\n  defp search_providers_semantic(providers, query, opts) do\n    Semantic.search_providers(providers, query, opts)\n  end\n\n  defp search_providers_combined(providers, query, opts) do\n    # Combine exact, fuzzy, and semantic search results for providers\n    exact_results = search_providers_exact(providers, query, opts)\n    fuzzy_results = search_providers_fuzzy(providers, query, opts)\n    semantic_results = search_providers_semantic(providers, query, opts)\n\n    # Merge and deduplicate results\n    all_results = exact_results ++ fuzzy_results ++ semantic_results\n\n    all_results\n    |> Enum.group_by(& &1.provider.name)\n    |> Enum.map(fn {_name, results} ->\n      # Take the best result for each provider\n      Enum.max_by(results, & &1.score)\n    end)\n  end\n\n  defp get_matched_fields(tool, query, match_type) do\n    query_lower = String.downcase(query)\n    fields = []\n\n    fields =\n      if String.contains?(String.downcase(tool.name), query_lower) do\n        [\"name\" | fields]\n      else\n        fields\n      end\n\n    fields =\n      if String.contains?(String.downcase(tool.definition.description), query_lower) do\n        [\"description\" | fields]\n      else\n        fields\n      end\n\n    case match_type do\n      :exact -> fields\n      _ -> fields\n    end\n  end\n\n  defp extract_keywords(text) do\n    text\n    |> String.downcase()\n    |> String.split(~r/[^\\w]+/, trim: true)\n    |> Enum.filter(&(String.length(&1) > 2))\n    |> Enum.uniq()\n  end\nend\n",
      "line_count": 351,
      "word_count": 915,
      "title": "Search.Ex",
      "summary": "defmodule ExUtcp.Search do @moduledoc \"\"\"",
      "key_terms": [
        "Filters",
        "Transport-based",
        "threshold",
        "search",
        "each",
        "based",
        "merge",
        "Utcp",
        "Apply",
        "trim",
        "suggestions",
        "specified",
        "providers",
        "reject",
        "Exact",
        "multiple",
        "keyword",
        "consistency",
        "using",
        "Creates"
      ],
      "timestamp": "2025-12-24T18:56:00.663445"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\tools.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Tools do\n  @moduledoc \"\"\"\n  Tool definitions and management for UTCP.\n\n  This module handles tool schemas, registration, and discovery.\n  \"\"\"\n\n  alias ExUtcp.Types, as: T\n\n  @doc \"\"\"\n  Creates a new tool input/output schema.\n  \"\"\"\n  @spec new_schema(keyword()) :: T.tool_input_output_schema()\n  def new_schema(opts \\\\ []) do\n    %{\n      type: Keyword.get(opts, :type, \"object\"),\n      properties: Keyword.get(opts, :properties, %{}),\n      required: Keyword.get(opts, :required, []),\n      description: Keyword.get(opts, :description, \"\"),\n      title: Keyword.get(opts, :title, \"\"),\n      items: Keyword.get(opts, :items, %{}),\n      enum: Keyword.get(opts, :enum, []),\n      minimum: Keyword.get(opts, :minimum, nil),\n      maximum: Keyword.get(opts, :maximum, nil),\n      format: Keyword.get(opts, :format, \"\")\n    }\n  end\n\n  @doc \"\"\"\n  Creates a new tool definition.\n  \"\"\"\n  @spec new_tool(keyword()) :: T.tool()\n  def new_tool(opts) do\n    %{\n      name: Keyword.fetch!(opts, :name),\n      description: Keyword.get(opts, :description, \"\"),\n      inputs: Keyword.get(opts, :inputs, new_schema()),\n      outputs: Keyword.get(opts, :outputs, new_schema()),\n      tags: Keyword.get(opts, :tags, []),\n      average_response_size: Keyword.get(opts, :average_response_size, nil),\n      provider: Keyword.fetch!(opts, :provider)\n    }\n  end\n\n  @doc \"\"\"\n  Validates a tool definition.\n  \"\"\"\n  @spec validate_tool(T.tool()) :: :ok | {:error, String.t()}\n  def validate_tool(tool) do\n    cond do\n      is_nil(tool.name) or tool.name == \"\" ->\n        {:error, \"Tool name is required\"}\n\n      is_nil(tool.provider) ->\n        {:error, \"Tool provider is required\"}\n\n      true ->\n        :ok\n    end\n  end\n\n  @doc \"\"\"\n  Checks if a tool matches a search query.\n  \"\"\"\n  @spec matches_query?(T.tool(), String.t()) :: boolean()\n  def matches_query?(_tool, query) when query == \"\" or is_nil(query), do: true\n\n  def matches_query?(tool, query) do\n    query_lower = String.downcase(query)\n\n    String.downcase(tool.name) |> String.contains?(query_lower) or\n      String.downcase(tool.description) |> String.contains?(query_lower) or\n      Enum.any?(tool.tags, &(String.downcase(&1) |> String.contains?(query_lower)))\n  end\n\n  @doc \"\"\"\n  Normalizes tool name by ensuring it has a provider prefix.\n  \"\"\"\n  @spec normalize_name(String.t(), String.t()) :: String.t()\n  def normalize_name(tool_name, provider_name) do\n    case String.split(tool_name, \".\", parts: 2) do\n      [^provider_name, _suffix] -> tool_name\n      [suffix] -> \"#{provider_name}.#{suffix}\"\n      [prefix, suffix] when prefix != provider_name -> \"#{provider_name}.#{suffix}\"\n    end\n  end\n\n  @doc \"\"\"\n  Extracts the tool name without provider prefix.\n  \"\"\"\n  @spec extract_tool_name(String.t()) :: String.t()\n  def extract_tool_name(full_name) do\n    case String.split(full_name, \".\", parts: 2) do\n      [_provider, tool_name] -> tool_name\n      [tool_name] -> tool_name\n    end\n  end\n\n  @doc \"\"\"\n  Extracts the provider name from a full tool name.\n  \"\"\"\n  @spec extract_provider_name(String.t()) :: String.t()\n  def extract_provider_name(full_name) do\n    case String.split(full_name, \".\", parts: 2) do\n      [provider_name, _tool] -> provider_name\n      [_tool] -> \"\"\n    end\n  end\nend\n",
      "line_count": 110,
      "word_count": 330,
      "title": "Tools.Ex",
      "summary": "defmodule ExUtcp.Tools do @moduledoc \"\"\"",
      "key_terms": [
        "output",
        "search",
        "error",
        "format",
        "Utcp",
        "has",
        "keyword",
        "Creates",
        "if",
        "true",
        "object",
        "description",
        "definitions",
        "suffix",
        "title",
        "handles",
        "any",
        "discovery",
        "Extracts",
        "items"
      ],
      "timestamp": "2025-12-24T18:56:00.703554"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\types.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Types do\n  @moduledoc \"\"\"\n  Core types and data structures for the UTCP protocol.\n  \"\"\"\n\n  @type provider_type ::\n          :http\n          | :sse\n          | :http_stream\n          | :cli\n          | :websocket\n          | :grpc\n          | :graphql\n          | :tcp\n          | :udp\n          | :webrtc\n          | :mcp\n          | :text\n\n  @type tool_input_output_schema :: %{\n          type: String.t(),\n          properties: %{String.t() => any()},\n          required: [String.t()],\n          description: String.t(),\n          title: String.t(),\n          items: %{String.t() => any()},\n          enum: [any()],\n          minimum: float() | nil,\n          maximum: float() | nil,\n          format: String.t()\n        }\n\n  @type tool :: %{\n          name: String.t(),\n          description: String.t(),\n          inputs: tool_input_output_schema(),\n          outputs: tool_input_output_schema(),\n          tags: [String.t()],\n          average_response_size: integer() | nil,\n          provider: provider()\n        }\n\n  @type provider :: %{\n          name: String.t(),\n          type: provider_type(),\n          __struct__: module()\n        }\n\n  @type auth :: %{\n          type: String.t(),\n          __struct__: module()\n        }\n\n  @type api_key_auth :: %{\n          type: String.t(),\n          api_key: String.t(),\n          location: String.t(),\n          var_name: String.t()\n        }\n\n  @type basic_auth :: %{\n          type: String.t(),\n          username: String.t(),\n          password: String.t()\n        }\n\n  @type oauth2_auth :: %{\n          type: String.t(),\n          client_id: String.t(),\n          client_secret: String.t(),\n          token_url: String.t(),\n          scope: String.t()\n        }\n\n  @type http_provider :: %{\n          name: String.t(),\n          type: :http,\n          http_method: String.t(),\n          url: String.t(),\n          content_type: String.t(),\n          auth: auth() | nil,\n          headers: %{String.t() => String.t()},\n          body_field: String.t() | nil,\n          header_fields: [String.t()]\n        }\n\n  @type cli_provider :: %{\n          name: String.t(),\n          type: :cli,\n          command_name: String.t(),\n          working_dir: String.t() | nil,\n          env_vars: %{String.t() => String.t()}\n        }\n\n  @type websocket_provider :: %{\n          name: String.t(),\n          type: :websocket,\n          url: String.t(),\n          protocol: String.t() | nil,\n          keep_alive: boolean(),\n          auth: auth() | nil,\n          headers: %{String.t() => String.t()},\n          header_fields: [String.t()]\n        }\n\n  @type grpc_provider :: %{\n          name: String.t(),\n          type: :grpc,\n          host: String.t(),\n          port: integer(),\n          service_name: String.t(),\n          method_name: String.t(),\n          target: String.t() | nil,\n          use_ssl: boolean(),\n          auth: auth() | nil\n        }\n\n  @type graphql_provider :: %{\n          name: String.t(),\n          type: :graphql,\n          url: String.t(),\n          auth: auth() | nil,\n          headers: %{String.t() => String.t()}\n        }\n\n  @type tcp_provider :: %{\n          name: String.t(),\n          type: :tcp,\n          protocol: :tcp,\n          host: String.t(),\n          port: integer(),\n          timeout: integer(),\n          auth: auth() | nil\n        }\n\n  @type udp_provider :: %{\n          name: String.t(),\n          type: :udp,\n          protocol: :udp,\n          host: String.t(),\n          port: integer(),\n          timeout: integer(),\n          auth: auth() | nil\n        }\n\n  @type webrtc_provider :: %{\n          name: String.t(),\n          type: :webrtc,\n          url: String.t(),\n          auth: auth() | nil\n        }\n\n  @type mcp_provider :: %{\n          name: String.t(),\n          type: :mcp,\n          url: String.t(),\n          auth: auth() | nil\n        }\n\n  @type text_provider :: %{\n          name: String.t(),\n          type: :text,\n          file_path: String.t()\n        }\n\n  @type sse_provider :: %{\n          name: String.t(),\n          type: :sse,\n          url: String.t(),\n          auth: auth() | nil,\n          headers: %{String.t() => String.t()}\n        }\n\n  @type streamable_http_provider :: %{\n          name: String.t(),\n          type: :http_stream,\n          url: String.t(),\n          auth: auth() | nil,\n          headers: %{String.t() => String.t()}\n        }\n\n  @type variable_not_found :: %{\n          __exception__: true,\n          variable_name: String.t()\n        }\n\n  @type client_config :: %{\n          variables: %{String.t() => String.t()},\n          providers_file_path: String.t() | nil,\n          load_variables_from: [module()]\n        }\n\n  @type tool_repository :: %{\n          tools: %{String.t() => [tool()]},\n          providers: %{String.t() => provider()}\n        }\n\n  @type transport :: module()\n\n  @type stream_chunk :: %{\n          data: any(),\n          metadata: %{String.t() => any()} | nil,\n          timestamp: integer() | nil,\n          sequence: integer() | nil\n        }\n\n  @type stream_result :: %{\n          type: :stream,\n          data: [stream_chunk()] | Enumerable.t(),\n          metadata: %{String.t() => any()} | nil\n        }\n\n  @type stream_error :: %{\n          type: :error,\n          error: String.t(),\n          code: integer() | nil,\n          metadata: %{String.t() => any()} | nil\n        }\n\n  @type stream_end :: %{\n          type: :end,\n          metadata: %{String.t() => any()} | nil\n        }\n\n  @type stream_event :: stream_chunk() | stream_error() | stream_end()\n\n  @type call_result :: {:ok, any()} | {:error, any()}\n\n  @type stream_call_result :: {:ok, stream_result()} | {:error, any()}\n\n  @type search_result :: {:ok, [tool()]} | {:error, any()}\n\n  @type register_result :: {:ok, [tool()]} | {:error, any()}\n\n  @type deregister_result :: :ok | {:error, any()}\n\n  @type manual :: %{\n          name: String.t(),\n          description: String.t(),\n          tools: [tool()]\n        }\nend\n",
      "line_count": 243,
      "word_count": 566,
      "title": "Types.Ex",
      "summary": "defmodule ExUtcp.Types do @moduledoc \"\"\"",
      "key_terms": [
        "grpc",
        "headers",
        "error",
        "format",
        "Utcp",
        "websocket",
        "providers",
        "sse",
        "true",
        "description",
        "title",
        "any",
        "items",
        "tool",
        "float",
        "password",
        "type",
        "url",
        "enum",
        "cli"
      ],
      "timestamp": "2025-12-24T18:56:00.727030"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\grpcpb\\empty.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Grpcpb.Empty do\n  @moduledoc false\n  use Protobuf, syntax: :proto3\nend\n",
      "line_count": 5,
      "word_count": 10,
      "title": "Empty.Ex",
      "summary": "defmodule ExUtcp.Grpcpb.Empty do @moduledoc false",
      "key_terms": [
        "ExUtcp",
        "defmodule",
        "Protobuf",
        "moduledoc",
        "Grpcpb",
        "do",
        "Empty",
        "syntax",
        "end",
        "use",
        "Utcp",
        "false"
      ],
      "timestamp": "2025-12-24T18:56:00.754096"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\grpcpb\\manual.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Grpcpb.Manual do\n  @moduledoc false\n  use Protobuf, syntax: :proto3\n\n  field(:version, 1, type: :string)\n  field(:tools, 2, repeated: true, type: ExUtcp.Grpcpb.Tool)\nend\n",
      "line_count": 8,
      "word_count": 20,
      "title": "Manual.Ex",
      "summary": "defmodule ExUtcp.Grpcpb.Manual do @moduledoc false",
      "key_terms": [
        "ExUtcp",
        "end",
        "Tool",
        "Utcp",
        "type",
        "Grpcpb",
        "do",
        "syntax",
        "string",
        "Manual",
        "use",
        "version",
        "false",
        "moduledoc",
        "repeated",
        "true",
        "field",
        "defmodule",
        "Protobuf",
        "tools"
      ],
      "timestamp": "2025-12-24T18:56:00.770335"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\grpcpb\\tool.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Grpcpb.Tool do\n  @moduledoc false\n  use Protobuf, syntax: :proto3\n\n  field(:name, 1, type: :string)\n  field(:description, 2, type: :string)\n  field(:inputs, 3, type: :string)\n  field(:outputs, 4, type: :string)\n  field(:tags, 5, repeated: true, type: :string)\nend\n",
      "line_count": 11,
      "word_count": 32,
      "title": "Tool.Ex",
      "summary": "defmodule ExUtcp.Grpcpb.Tool do @moduledoc false",
      "key_terms": [
        "ExUtcp",
        "outputs",
        "end",
        "Tool",
        "Utcp",
        "type",
        "Grpcpb",
        "do",
        "syntax",
        "string",
        "use",
        "false",
        "name",
        "moduledoc",
        "tags",
        "repeated",
        "field",
        "true",
        "defmodule",
        "Protobuf"
      ],
      "timestamp": "2025-12-24T18:56:00.790695"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\grpcpb\\tool_call_request.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Grpcpb.ToolCallRequest do\n  @moduledoc false\n  use Protobuf, syntax: :proto3\n\n  field(:tool, 1, type: :string)\n  field(:args_json, 2, type: :string)\nend\n",
      "line_count": 8,
      "word_count": 18,
      "title": "Tool Call Request.Ex",
      "summary": "defmodule ExUtcp.Grpcpb.ToolCallRequest do @moduledoc false",
      "key_terms": [
        "ExUtcp",
        "ToolCallRequest",
        "defmodule",
        "Protobuf",
        "moduledoc",
        "Grpcpb",
        "do",
        "syntax",
        "string",
        "end",
        "use",
        "Utcp",
        "false",
        "tool",
        "field",
        "type"
      ],
      "timestamp": "2025-12-24T18:56:00.813211"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\grpcpb\\tool_call_response.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Grpcpb.ToolCallResponse do\n  @moduledoc false\n  use Protobuf, syntax: :proto3\n\n  field(:result_json, 1, type: :string)\nend\n",
      "line_count": 7,
      "word_count": 14,
      "title": "Tool Call Response.Ex",
      "summary": "defmodule ExUtcp.Grpcpb.ToolCallResponse do @moduledoc false",
      "key_terms": [
        "ExUtcp",
        "ToolCallResponse",
        "defmodule",
        "Protobuf",
        "moduledoc",
        "Grpcpb",
        "do",
        "syntax",
        "string",
        "end",
        "use",
        "Utcp",
        "false",
        "field",
        "type"
      ],
      "timestamp": "2025-12-24T18:56:00.822292"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\grpcpb\\utcp_service.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Grpcpb.UTCPService do\n  @moduledoc false\n  use GRPC.Service, name: \"grpcpb.UTCPService\"\n\n  rpc(:get_manual, ExUtcp.Grpcpb.Empty, ExUtcp.Grpcpb.Manual)\n  rpc(:call_tool, ExUtcp.Grpcpb.ToolCallRequest, ExUtcp.Grpcpb.ToolCallResponse)\n  rpc(:call_tool_stream, ExUtcp.Grpcpb.ToolCallRequest, stream(ExUtcp.Grpcpb.ToolCallResponse))\nend\n\ndefmodule ExUtcp.Grpcpb.UTCPService.Stub do\n  @moduledoc false\n  use GRPC.Stub, service: ExUtcp.Grpcpb.UTCPService\nend\n",
      "line_count": 14,
      "word_count": 29,
      "title": "Utcp Service.Ex",
      "summary": "defmodule ExUtcp.Grpcpb.UTCPService do @moduledoc false",
      "key_terms": [
        "ExUtcp",
        "service",
        "end",
        "stream",
        "Utcp",
        "rpc",
        "ToolCallRequest",
        "Grpcpb",
        "do",
        "UTCP",
        "Manual",
        "use",
        "false",
        "name",
        "Stub",
        "moduledoc",
        "GRPC",
        "Empty",
        "Service",
        "ToolCallResponse"
      ],
      "timestamp": "2025-12-24T18:56:00.854904"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\monitoring\\health_check.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Monitoring.HealthCheck do\n  @moduledoc \"\"\"\n  Health check system for ExUtcp components.\n\n  Monitors the health of transports, providers, and connections.\n  \"\"\"\n\n  use GenServer\n\n  require Logger\n\n  @enforce_keys [:check_interval, :checks, :status]\n  defstruct [:check_interval, :checks, :status, :last_check]\n\n  @type health_status :: :healthy | :degraded | :unhealthy\n  @type check_result :: %{\n          name: String.t(),\n          status: health_status(),\n          message: String.t(),\n          duration_ms: integer(),\n          timestamp: integer()\n        }\n\n  @doc \"\"\"\n  Starts the health check system.\n  \"\"\"\n  @spec start_link(keyword()) :: {:ok, pid()} | {:error, term()}\n  def start_link(opts \\\\ []) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  @doc \"\"\"\n  Gets the current health status.\n  \"\"\"\n  @spec get_health_status() :: map()\n  def get_health_status do\n    GenServer.call(__MODULE__, :get_health_status)\n  end\n\n  @doc \"\"\"\n  Forces a health check run.\n  \"\"\"\n  @spec run_health_checks() :: map()\n  def run_health_checks do\n    GenServer.call(__MODULE__, :run_health_checks)\n  end\n\n  @doc \"\"\"\n  Registers a custom health check.\n  \"\"\"\n  @spec register_check(String.t(), (-> check_result())) :: :ok\n  def register_check(name, check_function) do\n    GenServer.call(__MODULE__, {:register_check, name, check_function})\n  end\n\n  @doc \"\"\"\n  Unregisters a health check.\n  \"\"\"\n  @spec unregister_check(String.t()) :: :ok\n  def unregister_check(name) do\n    GenServer.call(__MODULE__, {:unregister_check, name})\n  end\n\n  # GenServer callbacks\n\n  @impl GenServer\n  def init(opts) do\n    # 30 seconds\n    check_interval = Keyword.get(opts, :check_interval, 30_000)\n\n    # Register default health checks\n    default_checks = %{\n      \"telemetry\" => &check_telemetry/0,\n      \"prometheus\" => &check_prometheus/0,\n      \"transports\" => &check_transports/0,\n      \"memory\" => &check_memory/0,\n      \"processes\" => &check_processes/0\n    }\n\n    state = %__MODULE__{\n      check_interval: check_interval,\n      checks: default_checks,\n      status: %{},\n      last_check: nil\n    }\n\n    # Schedule first health check\n    Process.send_after(self(), :run_health_checks, 1000)\n\n    {:ok, state}\n  end\n\n  @impl GenServer\n  def handle_call(:get_health_status, _from, state) do\n    {:reply, build_health_response(state), state}\n  end\n\n  @impl GenServer\n  def handle_call(:run_health_checks, _from, state) do\n    {new_status, duration} = run_all_checks(state.checks)\n\n    new_state = %{state | status: new_status, last_check: System.system_time(:millisecond)}\n\n    # Emit telemetry event\n    :telemetry.execute(\n      [:ex_utcp, :health_check],\n      %{duration: duration},\n      %{overall_status: calculate_overall_status(new_status)}\n    )\n\n    response = build_health_response(new_state)\n    {:reply, response, new_state}\n  end\n\n  @impl GenServer\n  def handle_call({:register_check, name, check_function}, _from, state) do\n    new_checks = Map.put(state.checks, name, check_function)\n    new_state = %{state | checks: new_checks}\n    {:reply, :ok, new_state}\n  end\n\n  @impl GenServer\n  def handle_call({:unregister_check, name}, _from, state) do\n    new_checks = Map.delete(state.checks, name)\n    new_state = %{state | checks: new_checks}\n    {:reply, :ok, new_state}\n  end\n\n  @impl GenServer\n  def handle_info(:run_health_checks, state) do\n    {new_status, _duration} = run_all_checks(state.checks)\n\n    new_state = %{state | status: new_status, last_check: System.system_time(:millisecond)}\n\n    # Schedule next health check\n    Process.send_after(self(), :run_health_checks, state.check_interval)\n\n    {:noreply, new_state}\n  end\n\n  # Private functions\n\n  defp run_all_checks(checks) do\n    start_time = System.monotonic_time(:millisecond)\n\n    status =\n      Enum.map(checks, fn {name, check_function} ->\n        result = run_single_check(name, check_function)\n        {name, result}\n      end)\n      |> Map.new()\n\n    end_time = System.monotonic_time(:millisecond)\n    duration = end_time - start_time\n\n    {status, duration}\n  end\n\n  defp run_single_check(name, check_function) do\n    start_time = System.monotonic_time(:millisecond)\n\n    try do\n      result = check_function.()\n      end_time = System.monotonic_time(:millisecond)\n\n      %{\n        name: name,\n        status: result.status,\n        message: result.message,\n        duration_ms: end_time - start_time,\n        timestamp: System.system_time(:millisecond)\n      }\n    rescue\n      error ->\n        end_time = System.monotonic_time(:millisecond)\n\n        %{\n          name: name,\n          status: :unhealthy,\n          message: \"Health check failed: #{inspect(error)}\",\n          duration_ms: end_time - start_time,\n          timestamp: System.system_time(:millisecond)\n        }\n    end\n  end\n\n  defp build_health_response(state) do\n    overall_status = calculate_overall_status(state.status)\n\n    %{\n      status: overall_status,\n      checks: state.status,\n      last_check: state.last_check,\n      check_interval: state.check_interval,\n      timestamp: System.system_time(:millisecond)\n    }\n  end\n\n  defp calculate_overall_status(status) when map_size(status) == 0, do: :unknown\n\n  defp calculate_overall_status(status) do\n    statuses = Map.values(status) |> Enum.map(& &1.status)\n\n    cond do\n      Enum.all?(statuses, &(&1 == :healthy)) -> :healthy\n      Enum.any?(statuses, &(&1 == :unhealthy)) -> :unhealthy\n      true -> :degraded\n    end\n  end\n\n  # Default health check functions\n\n  defp check_telemetry do\n    # Test telemetry by emitting a test event\n    :telemetry.execute([:ex_utcp, :health_check, :telemetry], %{}, %{})\n\n    %{\n      status: :healthy,\n      message: \"Telemetry system operational\"\n    }\n  rescue\n    error ->\n      %{\n        status: :unhealthy,\n        message: \"Telemetry system error: #{inspect(error)}\"\n      }\n  end\n\n  defp check_prometheus do\n    # Check if PromEx is running\n    case Process.whereis(ExUtcp.Monitoring.PromEx) do\n      nil ->\n        %{\n          status: :degraded,\n          message: \"PromEx not running\"\n        }\n\n      _pid ->\n        %{\n          status: :healthy,\n          message: \"Prometheus metrics operational\"\n        }\n    end\n  rescue\n    error ->\n      %{\n        status: :unhealthy,\n        message: \"Prometheus system error: #{inspect(error)}\"\n      }\n  end\n\n  defp check_transports do\n    transports = [\n      {\"http\", ExUtcp.Transports.Http},\n      {\"cli\", ExUtcp.Transports.Cli},\n      {\"websocket\", ExUtcp.Transports.WebSocket},\n      {\"grpc\", ExUtcp.Transports.Grpc},\n      {\"graphql\", ExUtcp.Transports.Graphql},\n      {\"mcp\", ExUtcp.Transports.Mcp},\n      {\"tcp_udp\", ExUtcp.Transports.TcpUdp}\n    ]\n\n    transport_results =\n      Enum.map(transports, fn {name, module} ->\n        status =\n          if Code.ensure_loaded?(module) and\n               function_exported?(module, :transport_name, 0) do\n            :healthy\n          else\n            :unhealthy\n          end\n\n        {name, status}\n      end)\n\n    healthy_count = Enum.count(transport_results, fn {_name, status} -> status == :healthy end)\n    total_count = length(transport_results)\n\n    overall_status =\n      cond do\n        healthy_count == total_count -> :healthy\n        healthy_count > total_count / 2 -> :degraded\n        true -> :unhealthy\n      end\n\n    %{\n      status: overall_status,\n      message: \"#{healthy_count}/#{total_count} transports healthy\"\n    }\n  end\n\n  defp check_memory do\n    memory_info = :erlang.memory()\n    total_memory = memory_info[:total]\n\n    # Check if memory usage is reasonable (less than 1GB for this example)\n    # 1GB\n    memory_limit = 1_000_000_000\n\n    status =\n      if total_memory < memory_limit do\n        :healthy\n      else\n        :degraded\n      end\n\n    %{\n      status: status,\n      message: \"Memory usage: #{Float.round(total_memory / 1_000_000, 2)} MB\"\n    }\n  end\n\n  defp check_processes do\n    process_count = :erlang.system_info(:process_count)\n    process_limit = :erlang.system_info(:process_limit)\n\n    usage_percentage = process_count / process_limit * 100\n\n    status =\n      cond do\n        usage_percentage < 50 -> :healthy\n        usage_percentage < 80 -> :degraded\n        true -> :unhealthy\n      end\n\n    %{\n      status: status,\n      message: \"Process usage: #{round(usage_percentage)}% (#{process_count}/#{process_limit})\"\n    }\n  end\nend\n",
      "line_count": 332,
      "word_count": 762,
      "title": "Health Check.Ex",
      "summary": "defmodule ExUtcp.Monitoring.HealthCheck do @moduledoc \"\"\"",
      "key_terms": [
        "grpc",
        "error",
        "Code",
        "check",
        "WebSocket",
        "Utcp",
        "websocket",
        "unknown",
        "Float",
        "providers",
        "reply",
        "Test",
        "usage",
        "Forces",
        "keyword",
        "if",
        "status",
        "system",
        "duration",
        "true"
      ],
      "timestamp": "2025-12-24T18:56:00.886708"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\monitoring\\metrics.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Monitoring.Metrics do\n  @moduledoc \"\"\"\n  Metrics collection and aggregation for ExUtcp operations.\n\n  Provides utilities for collecting, storing, and reporting metrics.\n  \"\"\"\n\n  use GenServer\n\n  require Logger\n\n  @enforce_keys [:metrics, :config]\n  defstruct [:metrics, :config, :start_time]\n\n  @type metric_type :: :counter | :gauge | :histogram | :summary\n  @type metric_value :: number() | [number()]\n\n  @doc \"\"\"\n  Starts the metrics collector.\n  \"\"\"\n  @spec start_link(keyword()) :: {:ok, pid()} | {:error, term()}\n  def start_link(opts \\\\ []) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  @doc \"\"\"\n  Increments a counter metric.\n  \"\"\"\n  @spec increment_counter(String.t(), map()) :: :ok\n  def increment_counter(metric_name, labels \\\\ %{}) do\n    GenServer.cast(__MODULE__, {:increment_counter, metric_name, labels})\n  end\n\n  @doc \"\"\"\n  Sets a gauge metric value.\n  \"\"\"\n  @spec set_gauge(String.t(), number(), map()) :: :ok\n  def set_gauge(metric_name, value, labels \\\\ %{}) do\n    GenServer.cast(__MODULE__, {:set_gauge, metric_name, value, labels})\n  end\n\n  @doc \"\"\"\n  Records a histogram observation.\n  \"\"\"\n  @spec observe_histogram(String.t(), number(), map()) :: :ok\n  def observe_histogram(metric_name, value, labels \\\\ %{}) do\n    GenServer.cast(__MODULE__, {:observe_histogram, metric_name, value, labels})\n  end\n\n  @doc \"\"\"\n  Records a summary observation.\n  \"\"\"\n  @spec observe_summary(String.t(), number(), map()) :: :ok\n  def observe_summary(metric_name, value, labels \\\\ %{}) do\n    GenServer.cast(__MODULE__, {:observe_summary, metric_name, value, labels})\n  end\n\n  @doc \"\"\"\n  Gets all collected metrics.\n  \"\"\"\n  @spec get_metrics() :: map()\n  def get_metrics do\n    GenServer.call(__MODULE__, :get_metrics)\n  end\n\n  @doc \"\"\"\n  Gets metrics for a specific metric name.\n  \"\"\"\n  @spec get_metric(String.t()) :: map() | nil\n  def get_metric(metric_name) do\n    GenServer.call(__MODULE__, {:get_metric, metric_name})\n  end\n\n  @doc \"\"\"\n  Resets all metrics.\n  \"\"\"\n  @spec reset_metrics() :: :ok\n  def reset_metrics do\n    GenServer.call(__MODULE__, :reset_metrics)\n  end\n\n  @doc \"\"\"\n  Gets metrics summary for reporting.\n  \"\"\"\n  @spec get_metrics_summary() :: map()\n  def get_metrics_summary do\n    GenServer.call(__MODULE__, :get_metrics_summary)\n  end\n\n  # GenServer callbacks\n\n  @impl GenServer\n  def init(opts) do\n    config = %{\n      # 1 hour\n      retention_period: Keyword.get(opts, :retention_period, 3600),\n      max_metrics: Keyword.get(opts, :max_metrics, 1000),\n      enable_cleanup: Keyword.get(opts, :enable_cleanup, true)\n    }\n\n    state = %__MODULE__{\n      metrics: %{},\n      config: config,\n      start_time: System.system_time(:millisecond)\n    }\n\n    # Schedule periodic cleanup if enabled\n    if config.enable_cleanup do\n      Process.send_after(self(), :cleanup_metrics, config.retention_period * 1000)\n    end\n\n    {:ok, state}\n  end\n\n  @impl GenServer\n  def handle_cast({:increment_counter, metric_name, labels}, state) do\n    new_metrics = update_counter(state.metrics, metric_name, labels)\n    {:noreply, %{state | metrics: new_metrics}}\n  end\n\n  @impl GenServer\n  def handle_cast({:set_gauge, metric_name, value, labels}, state) do\n    new_metrics = update_gauge(state.metrics, metric_name, value, labels)\n    {:noreply, %{state | metrics: new_metrics}}\n  end\n\n  @impl GenServer\n  def handle_cast({:observe_histogram, metric_name, value, labels}, state) do\n    new_metrics = update_histogram(state.metrics, metric_name, value, labels)\n    {:noreply, %{state | metrics: new_metrics}}\n  end\n\n  @impl GenServer\n  def handle_cast({:observe_summary, metric_name, value, labels}, state) do\n    new_metrics = update_summary(state.metrics, metric_name, value, labels)\n    {:noreply, %{state | metrics: new_metrics}}\n  end\n\n  @impl GenServer\n  def handle_call(:get_metrics, _from, state) do\n    {:reply, state.metrics, state}\n  end\n\n  @impl GenServer\n  def handle_call({:get_metric, metric_name}, _from, state) do\n    metric = Map.get(state.metrics, metric_name)\n    {:reply, metric, state}\n  end\n\n  @impl GenServer\n  def handle_call(:reset_metrics, _from, state) do\n    new_state = %{state | metrics: %{}}\n    {:reply, :ok, new_state}\n  end\n\n  @impl GenServer\n  def handle_call(:get_metrics_summary, _from, state) do\n    summary = build_metrics_summary(state)\n    {:reply, summary, state}\n  end\n\n  @impl GenServer\n  def handle_info(:cleanup_metrics, state) do\n    new_metrics = cleanup_old_metrics(state.metrics, state.config.retention_period)\n    new_state = %{state | metrics: new_metrics}\n\n    # Schedule next cleanup\n    Process.send_after(self(), :cleanup_metrics, state.config.retention_period * 1000)\n\n    {:noreply, new_state}\n  end\n\n  # Private functions\n\n  defp update_counter(metrics, metric_name, labels) do\n    key = build_metric_key(metric_name, labels)\n    current_value = get_in(metrics, [metric_name, key, :value]) || 0\n\n    # Ensure the metric_name key exists in the metrics map\n    metrics = Map.put_new(metrics, metric_name, %{})\n\n    put_in(metrics, [metric_name, key], %{\n      type: :counter,\n      value: current_value + 1,\n      labels: labels,\n      timestamp: System.system_time(:millisecond)\n    })\n  end\n\n  defp update_gauge(metrics, metric_name, value, labels) do\n    key = build_metric_key(metric_name, labels)\n\n    # Ensure the metric_name key exists in the metrics map\n    metrics = Map.put_new(metrics, metric_name, %{})\n\n    put_in(metrics, [metric_name, key], %{\n      type: :gauge,\n      value: value,\n      labels: labels,\n      timestamp: System.system_time(:millisecond)\n    })\n  end\n\n  defp update_histogram(metrics, metric_name, value, labels) do\n    key = build_metric_key(metric_name, labels)\n    current_values = get_in(metrics, [metric_name, key, :values]) || []\n\n    # Ensure the metric_name key exists in the metrics map\n    metrics = Map.put_new(metrics, metric_name, %{})\n\n    put_in(metrics, [metric_name, key], %{\n      type: :histogram,\n      # Keep last 1000 values\n      values: [value | current_values] |> Enum.take(1000),\n      labels: labels,\n      timestamp: System.system_time(:millisecond)\n    })\n  end\n\n  defp update_summary(metrics, metric_name, value, labels) do\n    key = build_metric_key(metric_name, labels)\n    current_values = get_in(metrics, [metric_name, key, :values]) || []\n\n    # Ensure the metric_name key exists in the metrics map\n    metrics = Map.put_new(metrics, metric_name, %{})\n\n    put_in(metrics, [metric_name, key], %{\n      type: :summary,\n      # Keep last 1000 values\n      values: [value | current_values] |> Enum.take(1000),\n      labels: labels,\n      timestamp: System.system_time(:millisecond)\n    })\n  end\n\n  defp build_metric_key(metric_name, labels) do\n    labels_string =\n      labels\n      |> Enum.sort()\n      |> Enum.map_join(\",\", fn {k, v} -> \"#{k}=#{v}\" end)\n\n    \"#{metric_name}[#{labels_string}]\"\n  end\n\n  defp cleanup_old_metrics(metrics, retention_period_seconds) do\n    cutoff_time = System.system_time(:millisecond) - retention_period_seconds * 1000\n\n    Enum.map(metrics, fn {metric_name, metric_data} ->\n      cleaned_data =\n        Enum.filter(metric_data, fn {_key, data} ->\n          data.timestamp > cutoff_time\n        end)\n        |> Map.new()\n\n      {metric_name, cleaned_data}\n    end)\n    |> Map.new()\n  end\n\n  defp build_metrics_summary(state) do\n    uptime = System.system_time(:millisecond) - state.start_time\n\n    %{\n      uptime_ms: uptime,\n      total_metrics: map_size(state.metrics),\n      config: state.config,\n      memory_usage: :erlang.memory(:total),\n      process_count: :erlang.system_info(:process_count)\n    }\n  end\nend\n",
      "line_count": 272,
      "word_count": 750,
      "title": "Metrics.Ex",
      "summary": "defmodule ExUtcp.Monitoring.Metrics do @moduledoc \"\"\"",
      "key_terms": [
        "number",
        "cast",
        "error",
        "cleanup",
        "Utcp",
        "reply",
        "keyword",
        "Sets",
        "Provides",
        "if",
        "enabled",
        "true",
        "term",
        "hour",
        "function",
        "call",
        "defp",
        "memory",
        "state",
        "def"
      ],
      "timestamp": "2025-12-24T18:56:00.918140"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\monitoring\\performance.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Monitoring.Performance do\n  @moduledoc \"\"\"\n  Performance monitoring for ExUtcp operations.\n\n  Tracks performance metrics, identifies bottlenecks, and provides alerts.\n  \"\"\"\n\n  use GenServer\n\n  alias ExUtcp.Monitoring.Metrics\n\n  require Logger\n\n  @enforce_keys [:config, :start_time]\n  defstruct [:config, :start_time, :metrics]\n\n  @type metric_type :: :counter | :gauge | :histogram | :summary\n  @type metric_value :: number() | [number()]\n\n  @doc \"\"\"\n  Starts the performance monitor.\n  \"\"\"\n  @spec start_link(keyword()) :: {:ok, pid()} | {:error, term()}\n  def start_link(opts \\\\ []) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  @doc \"\"\"\n  Measures the execution time of a function and emits telemetry.\n  \"\"\"\n  @spec measure(String.t(), map(), (-> any())) :: any()\n  def measure(operation_name, metadata \\\\ %{}, fun) do\n    start_time = System.monotonic_time(:millisecond)\n\n    try do\n      result = fun.()\n      end_time = System.monotonic_time(:millisecond)\n      duration = end_time - start_time\n\n      # Emit telemetry event\n      :telemetry.execute(\n        [:ex_utcp, :performance, :operation],\n        %{duration: duration},\n        Map.merge(metadata, %{operation: operation_name, status: :success})\n      )\n\n      # Record metrics\n      Metrics.observe_histogram(\"operation_duration_ms\", duration, %{\n        operation: operation_name,\n        status: \"success\"\n      })\n\n      result\n    rescue\n      error ->\n        end_time = System.monotonic_time(:millisecond)\n        duration = end_time - start_time\n\n        # Emit telemetry event for error\n        :telemetry.execute(\n          [:ex_utcp, :performance, :operation],\n          %{duration: duration},\n          Map.merge(metadata, %{operation: operation_name, status: :error, error: inspect(error)})\n        )\n\n        # Record error metrics\n        Metrics.observe_histogram(\"operation_duration_ms\", duration, %{\n          operation: operation_name,\n          status: \"error\"\n        })\n\n        Metrics.increment_counter(\"operation_errors_total\", %{\n          operation: operation_name,\n          error_type: error.__struct__ |> to_string()\n        })\n\n        reraise error, __STACKTRACE__\n    end\n  end\n\n  @doc \"\"\"\n  Measures tool call performance.\n  \"\"\"\n  @spec measure_tool_call(String.t(), String.t(), map(), (-> any())) :: any()\n  def measure_tool_call(tool_name, provider_name, args, fun) do\n    metadata = %{\n      tool_name: tool_name,\n      provider_name: provider_name,\n      args_count: map_size(args)\n    }\n\n    measure(\"tool_call\", metadata, fun)\n  end\n\n  @doc \"\"\"\n  Measures search performance.\n  \"\"\"\n  @spec measure_search(String.t(), atom(), map(), (-> any())) :: any()\n  def measure_search(query, algorithm, filters, fun) do\n    metadata = %{\n      query_length: String.length(query),\n      algorithm: algorithm,\n      filter_count: count_active_filters(filters)\n    }\n\n    result = measure(\"search\", metadata, fun)\n\n    # Additional search-specific metrics\n    if is_list(result) do\n      Metrics.observe_histogram(\"search_results_count\", length(result), %{\n        algorithm: algorithm\n      })\n    end\n\n    result\n  end\n\n  @doc \"\"\"\n  Measures connection performance.\n  \"\"\"\n  @spec measure_connection(String.t(), atom(), (-> any())) :: any()\n  def measure_connection(provider_name, transport_type, fun) do\n    metadata = %{\n      provider_name: provider_name,\n      transport_type: transport_type\n    }\n\n    measure(\"connection\", metadata, fun)\n  end\n\n  @doc \"\"\"\n  Gets performance statistics for a specific operation.\n  \"\"\"\n  @spec get_operation_stats(String.t()) :: map()\n  def get_operation_stats(operation_name) do\n    histogram_data = Metrics.get_metric(\"operation_duration_ms\")\n\n    case histogram_data do\n      nil ->\n        %{operation: operation_name, stats: :no_data}\n\n      data ->\n        # Calculate statistics from histogram data\n        operation_data =\n          data\n          |> Enum.filter(fn {_key, metric} ->\n            metric.labels[:operation] == operation_name\n          end)\n\n        if Enum.empty?(operation_data) do\n          %{operation: operation_name, stats: :no_data}\n        else\n          values =\n            Enum.flat_map(operation_data, fn {_key, metric} ->\n              metric.values || [metric.value]\n            end)\n\n          %{\n            operation: operation_name,\n            stats: calculate_statistics(values)\n          }\n        end\n    end\n  rescue\n    _ -> %{operation: operation_name, stats: :unavailable}\n  end\n\n  @doc \"\"\"\n  Gets performance summary for all operations.\n  \"\"\"\n  @spec get_performance_summary() :: map()\n  def get_performance_summary do\n    metrics = Metrics.get_metrics()\n\n    %{\n      operations: get_all_operation_stats(metrics),\n      system: get_system_performance(),\n      alerts: get_performance_alerts(metrics),\n      timestamp: System.system_time(:millisecond)\n    }\n  rescue\n    _ ->\n      %{\n        operations: %{},\n        system: get_system_performance(),\n        alerts: [],\n        timestamp: System.system_time(:millisecond),\n        status: :metrics_unavailable\n      }\n  end\n\n  @doc \"\"\"\n  Checks for performance alerts based on thresholds.\n  \"\"\"\n  @spec get_performance_alerts(map()) :: [map()]\n  def get_performance_alerts(metrics \\\\ nil) do\n    metrics = metrics || Metrics.get_metrics()\n    alerts = []\n\n    # Check for slow operations\n    alerts = alerts ++ check_slow_operations(metrics)\n\n    # Check for high error rates\n    alerts = alerts ++ check_error_rates(metrics)\n\n    # Check for memory usage\n    alerts = alerts ++ check_memory_alerts()\n\n    alerts\n  rescue\n    _ -> []\n  end\n\n  @doc \"\"\"\n  Records a custom performance metric.\n  \"\"\"\n  @spec record_custom_metric(String.t(), metric_type(), metric_value(), map()) :: :ok\n  def record_custom_metric(name, type, value, labels \\\\ %{}) do\n    case type do\n      :counter -> Metrics.increment_counter(name, labels)\n      :gauge -> Metrics.set_gauge(name, value, labels)\n      :histogram -> Metrics.observe_histogram(name, value, labels)\n      :summary -> Metrics.observe_summary(name, value, labels)\n    end\n  end\n\n  # GenServer callbacks\n\n  @impl GenServer\n  def init(opts) do\n    config = %{\n      alert_thresholds: %{\n        slow_operation_ms: Keyword.get(opts, :slow_operation_threshold, 5000),\n        high_error_rate: Keyword.get(opts, :high_error_rate, 0.1),\n        high_memory_mb: Keyword.get(opts, :high_memory_threshold, 500)\n      },\n      # 5 minutes\n      cleanup_interval: Keyword.get(opts, :cleanup_interval, 300_000)\n    }\n\n    state = %__MODULE__{\n      config: config,\n      start_time: System.system_time(:millisecond),\n      metrics: %{}\n    }\n\n    # Schedule periodic cleanup\n    Process.send_after(self(), :cleanup_old_data, config.cleanup_interval)\n\n    {:ok, state}\n  end\n\n  @impl GenServer\n  def handle_cast({:increment_counter, metric_name, labels}, state) do\n    :ok = Metrics.increment_counter(metric_name, labels)\n    {:noreply, state}\n  end\n\n  @impl GenServer\n  def handle_cast({:set_gauge, metric_name, value, labels}, state) do\n    :ok = Metrics.set_gauge(metric_name, value, labels)\n    {:noreply, state}\n  end\n\n  @impl GenServer\n  def handle_cast({:observe_histogram, metric_name, value, labels}, state) do\n    :ok = Metrics.observe_histogram(metric_name, value, labels)\n    {:noreply, state}\n  end\n\n  @impl GenServer\n  def handle_cast({:observe_summary, metric_name, value, labels}, state) do\n    :ok = Metrics.observe_summary(metric_name, value, labels)\n    {:noreply, state}\n  end\n\n  @impl GenServer\n  def handle_call(:get_metrics, _from, state) do\n    metrics = Metrics.get_metrics()\n    {:reply, metrics, state}\n  end\n\n  @impl GenServer\n  def handle_call({:get_metric, metric_name}, _from, state) do\n    metric = Metrics.get_metric(metric_name)\n    {:reply, metric, state}\n  end\n\n  @impl GenServer\n  def handle_call(:reset_metrics, _from, state) do\n    :ok = Metrics.reset_metrics()\n    {:reply, :ok, state}\n  end\n\n  @impl GenServer\n  def handle_call(:get_metrics_summary, _from, state) do\n    summary = get_performance_summary()\n    {:reply, summary, state}\n  end\n\n  @impl GenServer\n  def handle_info(:cleanup_old_data, state) do\n    # Perform cleanup operations\n    Logger.debug(\"Performing metrics cleanup\")\n\n    # Schedule next cleanup\n    Process.send_after(self(), :cleanup_old_data, state.config.cleanup_interval)\n\n    {:noreply, state}\n  end\n\n  # Private helper functions\n\n  defp count_active_filters(filters) when is_map(filters) do\n    filters\n    |> Enum.count(fn {_key, value} ->\n      case value do\n        list when is_list(list) -> not Enum.empty?(list)\n        _ -> value != nil\n      end\n    end)\n  end\n\n  defp count_active_filters(_), do: 0\n\n  defp calculate_statistics([]), do: %{count: 0}\n\n  defp calculate_statistics(values) do\n    sorted_values = Enum.sort(values)\n    count = length(values)\n    sum = Enum.sum(values)\n\n    %{\n      count: count,\n      sum: sum,\n      min: Enum.min(values),\n      max: Enum.max(values),\n      mean: sum / count,\n      median: calculate_median(sorted_values),\n      p95: calculate_percentile(sorted_values, 0.95),\n      p99: calculate_percentile(sorted_values, 0.99)\n    }\n  end\n\n  defp calculate_median(sorted_values) do\n    count = length(sorted_values)\n\n    if rem(count, 2) == 0 do\n      mid1 = Enum.at(sorted_values, div(count, 2) - 1)\n      mid2 = Enum.at(sorted_values, div(count, 2))\n      (mid1 + mid2) / 2\n    else\n      Enum.at(sorted_values, div(count, 2))\n    end\n  end\n\n  defp calculate_percentile(sorted_values, percentile) do\n    count = length(sorted_values)\n    index = round(count * percentile) - 1\n    index = max(0, min(index, count - 1))\n    Enum.at(sorted_values, index)\n  end\n\n  defp get_all_operation_stats(_metrics) do\n    # Extract operation statistics from metrics\n    %{\n      tool_calls: get_operation_stats(\"tool_call\"),\n      searches: get_operation_stats(\"search\"),\n      connections: get_operation_stats(\"connection\")\n    }\n  end\n\n  defp get_system_performance do\n    memory = :erlang.memory()\n\n    %{\n      memory_mb: Float.round(memory[:total] / 1_000_000, 2),\n      process_count: :erlang.system_info(:process_count),\n      scheduler_utilization: get_scheduler_utilization(),\n      garbage_collection: get_gc_stats()\n    }\n  end\n\n  defp get_scheduler_utilization do\n    # Get scheduler utilization (simplified)\n    schedulers = :erlang.system_info(:schedulers_online)\n\n    %{\n      schedulers_online: schedulers,\n      # Would require more complex calculation\n      utilization: \"N/A\"\n    }\n  end\n\n  defp get_gc_stats do\n    # Get garbage collection statistics\n    {gc_count, gc_words_reclaimed, _} = :erlang.statistics(:garbage_collection)\n\n    %{\n      collections: gc_count,\n      words_reclaimed: gc_words_reclaimed\n    }\n  end\n\n  defp check_slow_operations(_metrics) do\n    # Check for operations that exceed threshold\n    # This would analyze histogram data for slow operations\n    []\n  end\n\n  defp check_error_rates(_metrics) do\n    # Check for high error rates\n    # This would analyze counter data for error rates\n    []\n  end\n\n  defp check_memory_alerts do\n    memory = :erlang.memory(:total)\n    memory_mb = memory / 1_000_000\n\n    if memory_mb > 500 do\n      [\n        %{\n          type: :memory,\n          severity: :warning,\n          message: \"High memory usage: #{Float.round(memory_mb, 2)} MB\",\n          timestamp: System.system_time(:millisecond)\n        }\n      ]\n    else\n      []\n    end\n  end\nend\n",
      "line_count": 435,
      "word_count": 1053,
      "title": "Performance.Ex",
      "summary": "defmodule ExUtcp.Monitoring.Performance do @moduledoc \"\"\"",
      "key_terms": [
        "threshold",
        "search",
        "number",
        "error",
        "monitor",
        "Calculate",
        "Record",
        "based",
        "analyze",
        "merge",
        "list",
        "index",
        "cleanup",
        "Utcp",
        "helper",
        "high",
        "Float",
        "reply",
        "High",
        "usage"
      ],
      "timestamp": "2025-12-24T18:56:00.949882"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\monitoring\\prom_ex.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Monitoring.PromEx do\n  @moduledoc \"\"\"\n  PromEx configuration for ExUtcp metrics.\n\n  Defines Prometheus metrics for monitoring UTCP operations.\n  \"\"\"\n\n  use PromEx, otp_app: :ex_utcp\n\n  alias PromEx.Plugins\n\n  @impl true\n  def plugins do\n    [\n      # Built-in PromEx plugins\n      Plugins.Application,\n      Plugins.Beam,\n\n      # Custom ExUtcp plugin\n      {ExUtcp.Monitoring.PromEx.Plugin, []}\n    ]\n  end\n\n  @impl true\n  def dashboard_assigns do\n    [\n      datasource_id: \"prometheus\",\n      default_selected_interval: \"30s\"\n    ]\n  end\n\n  @impl true\n  def dashboards do\n    [\n      # Custom ExUtcp dashboard\n      {:prom_ex, \"ex_utcp.json\"}\n    ]\n  end\nend\n\ndefmodule ExUtcp.Monitoring.PromEx.Plugin do\n  @moduledoc \"\"\"\n  Custom PromEx plugin for ExUtcp-specific metrics.\n  \"\"\"\n\n  use PromEx.Plugin\n\n  @impl true\n  def polling_metrics(opts) do\n    poll_rate = Keyword.get(opts, :poll_rate, 5_000)\n\n    [\n      # System metrics polling\n      {\n        [:ex_utcp, :system],\n        [\n          # Memory usage metrics\n          last_value(\"ex_utcp.system.memory.total.bytes\",\n            event_name: [:ex_utcp, :system, :memory],\n            measurement: :total,\n            description: \"Total memory usage\",\n            unit: :byte\n          ),\n          last_value(\"ex_utcp.system.memory.processes.bytes\",\n            event_name: [:ex_utcp, :system, :memory],\n            measurement: :processes,\n            description: \"Process memory usage\",\n            unit: :byte\n          ),\n\n          # Process count metrics\n          last_value(\"ex_utcp.system.processes.count\",\n            event_name: [:ex_utcp, :system, :processes],\n            measurement: :count,\n            description: \"Number of processes\"\n          )\n        ],\n        poll_rate\n      }\n    ]\n  end\n\n  @impl true\n  def event_metrics(_opts) do\n    [\n      # Tool call metrics\n      counter(\n        \"ex_utcp.tool_calls.total\",\n        event_name: [:ex_utcp, :tool_call],\n        description: \"Total number of tool calls\",\n        tags: [:tool_name, :provider_name, :status]\n      ),\n      distribution(\n        \"ex_utcp.tool_call.duration.milliseconds\",\n        event_name: [:ex_utcp, :tool_call],\n        measurement: :duration,\n        description: \"Tool call duration\",\n        tags: [:tool_name, :provider_name],\n        unit: :millisecond,\n        buckets: [10, 50, 100, 500, 1000, 5000, 10_000]\n      ),\n\n      # Search metrics\n      counter(\n        \"ex_utcp.searches.total\",\n        event_name: [:ex_utcp, :search],\n        description: \"Total number of searches\",\n        tags: [:algorithm]\n      ),\n      distribution(\n        \"ex_utcp.search.duration.milliseconds\",\n        event_name: [:ex_utcp, :search],\n        measurement: :duration,\n        description: \"Search duration\",\n        tags: [:algorithm],\n        unit: :millisecond,\n        buckets: [1, 5, 10, 50, 100, 500, 1000]\n      ),\n      distribution(\n        \"ex_utcp.search.results.count\",\n        event_name: [:ex_utcp, :search],\n        measurement: :result_count,\n        description: \"Number of search results\",\n        tags: [:algorithm],\n        buckets: [0, 1, 5, 10, 20, 50, 100]\n      ),\n\n      # Provider metrics\n      counter(\n        \"ex_utcp.providers.total\",\n        event_name: [:ex_utcp, :provider],\n        description: \"Total provider operations\",\n        tags: [:transport_type, :action]\n      ),\n\n      # Connection metrics\n      counter(\n        \"ex_utcp.connections.total\",\n        event_name: [:ex_utcp, :connection],\n        description: \"Total connection events\",\n        tags: [:transport_type, :event]\n      ),\n      distribution(\n        \"ex_utcp.connection.duration.milliseconds\",\n        event_name: [:ex_utcp, :connection],\n        measurement: :duration,\n        description: \"Connection establishment duration\",\n        tags: [:transport_type],\n        unit: :millisecond,\n        buckets: [10, 50, 100, 500, 1000, 5000]\n      )\n    ]\n  end\n\n  @impl true\n  def manual_metrics(_opts) do\n    [\n      # Manual metrics that can be updated programmatically\n      last_value(\n        \"ex_utcp.active_connections.count\",\n        description: \"Number of active connections\"\n      ),\n      last_value(\n        \"ex_utcp.registered_tools.count\",\n        description: \"Number of registered tools\"\n      ),\n      last_value(\n        \"ex_utcp.registered_providers.count\",\n        description: \"Number of registered providers\"\n      )\n    ]\n  end\nend\n",
      "line_count": 174,
      "word_count": 368,
      "title": "Prom Ex.Ex",
      "summary": "defmodule ExUtcp.Monitoring.PromEx do @moduledoc \"\"\"",
      "key_terms": [
        "Total",
        "search",
        "number",
        "Built",
        "Utcp",
        "providers",
        "usage",
        "Built-in",
        "byte",
        "buckets",
        "that",
        "status",
        "system",
        "Connection",
        "duration",
        "true",
        "establishment",
        "description",
        "Defines",
        "call"
      ],
      "timestamp": "2025-12-24T18:56:00.965642"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\openapi_converter\\auth_mapper.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.OpenApiConverter.AuthMapper do\n  @moduledoc \"\"\"\n  Maps OpenAPI security schemes to UTCP authentication configurations.\n  \"\"\"\n\n  alias ExUtcp.OpenApiConverter.Types, as: T\n\n  @doc \"\"\"\n  Maps OpenAPI security schemes to UTCP authentication.\n\n  ## Parameters\n\n  - `security_requirement`: OpenAPI security requirement\n  - `security_schemes`: Available security schemes\n\n  ## Returns\n\n  UTCP authentication configuration or nil.\n  \"\"\"\n  @spec map_security_requirement(map(), map()) :: map() | nil\n  def map_security_requirement(security_requirement, security_schemes) do\n    case Map.keys(security_requirement) do\n      [] ->\n        nil\n\n      [scheme_name | _] ->\n        case Map.get(security_schemes, scheme_name) do\n          nil -> nil\n          scheme -> map_security_scheme(scheme)\n        end\n    end\n  end\n\n  @doc \"\"\"\n  Maps a single OpenAPI security scheme to UTCP authentication.\n\n  ## Parameters\n\n  - `scheme`: OpenAPI security scheme\n\n  ## Returns\n\n  UTCP authentication configuration or nil.\n  \"\"\"\n  @spec map_security_scheme(T.ParsedSecurityScheme.t()) :: map() | nil\n  def map_security_scheme(scheme) do\n    case scheme.type do\n      \"apiKey\" -> map_api_key_auth(scheme)\n      \"http\" -> map_http_auth(scheme)\n      \"oauth2\" -> map_oauth2_auth(scheme)\n      \"openIdConnect\" -> map_openid_connect_auth(scheme)\n      _ -> nil\n    end\n  end\n\n  # Private functions\n\n  defp map_api_key_auth(scheme) do\n    location =\n      case scheme.in do\n        \"header\" -> :header\n        \"query\" -> :query\n        \"cookie\" -> :cookie\n        _ -> :header\n      end\n\n    %{\n      type: :api_key,\n      api_key: \"${API_KEY}\",\n      location: location,\n      var_name: scheme.name || \"X-API-Key\"\n    }\n  end\n\n  defp map_http_auth(scheme) do\n    case scheme.scheme do\n      \"bearer\" -> map_bearer_auth(scheme)\n      \"basic\" -> map_basic_auth(scheme)\n      _ -> nil\n    end\n  end\n\n  defp map_bearer_auth(_scheme) do\n    %{\n      type: :api_key,\n      api_key: \"Bearer ${API_KEY}\",\n      location: :header,\n      var_name: \"Authorization\"\n    }\n  end\n\n  defp map_basic_auth(_scheme) do\n    %{\n      type: :basic,\n      username: \"${USERNAME}\",\n      password: \"${PASSWORD}\"\n    }\n  end\n\n  defp map_oauth2_auth(scheme) do\n    case scheme.flows do\n      nil ->\n        nil\n\n      flows ->\n        # Prefer client_credentials flow for API usage\n        cond do\n          flows.client_credentials -> map_client_credentials_flow(flows.client_credentials)\n          flows.authorization_code -> map_authorization_code_flow(flows.authorization_code)\n          flows.password -> map_password_flow(flows.password)\n          flows.implicit -> map_implicit_flow(flows.implicit)\n          true -> nil\n        end\n    end\n  end\n\n  defp map_client_credentials_flow(flow) do\n    %{\n      type: :oauth2,\n      token_url: flow.token_url || \"${TOKEN_URL}\",\n      client_id: \"${CLIENT_ID}\",\n      client_secret: \"${CLIENT_SECRET}\",\n      scope: get_default_scope(flow.scopes),\n      grant_type: \"client_credentials\"\n    }\n  end\n\n  defp map_authorization_code_flow(flow) do\n    %{\n      type: :oauth2,\n      token_url: flow.token_url || \"${TOKEN_URL}\",\n      client_id: \"${CLIENT_ID}\",\n      client_secret: \"${CLIENT_SECRET}\",\n      scope: get_default_scope(flow.scopes),\n      grant_type: \"authorization_code\",\n      authorization_url: flow.authorization_url || \"${AUTHORIZATION_URL}\"\n    }\n  end\n\n  defp map_password_flow(flow) do\n    %{\n      type: :oauth2,\n      token_url: flow.token_url || \"${TOKEN_URL}\",\n      client_id: \"${CLIENT_ID}\",\n      client_secret: \"${CLIENT_SECRET}\",\n      scope: get_default_scope(flow.scopes),\n      grant_type: \"password\",\n      username: \"${USERNAME}\",\n      password: \"${PASSWORD}\"\n    }\n  end\n\n  defp map_implicit_flow(flow) do\n    %{\n      type: :oauth2,\n      client_id: \"${CLIENT_ID}\",\n      scope: get_default_scope(flow.scopes),\n      grant_type: \"implicit\",\n      authorization_url: flow.authorization_url || \"${AUTHORIZATION_URL}\"\n    }\n  end\n\n  defp map_openid_connect_auth(_scheme) do\n    # OpenID Connect is not directly supported in UTCP auth types\n    # Map to OAuth2 with OpenID Connect discovery\n    %{\n      type: :oauth2,\n      token_url: \"${TOKEN_URL}\",\n      client_id: \"${CLIENT_ID}\",\n      client_secret: \"${CLIENT_SECRET}\",\n      scope: \"openid\",\n      grant_type: \"authorization_code\",\n      authorization_url: \"${AUTHORIZATION_URL}\"\n    }\n  end\n\n  defp get_default_scope(scopes) when is_map(scopes) do\n    case Map.keys(scopes) do\n      [] -> \"\"\n      [scope | _] -> scope\n    end\n  end\n\n  defp get_default_scope(_), do: \"\"\n\n  @doc \"\"\"\n  Maps multiple security schemes to a list of authentication options.\n\n  ## Parameters\n\n  - `security_schemes`: Map of security schemes\n\n  ## Returns\n\n  List of UTCP authentication configurations.\n  \"\"\"\n  @spec map_all_security_schemes(map()) :: [map()]\n  def map_all_security_schemes(security_schemes) do\n    Enum.map(security_schemes, fn {_name, scheme} ->\n      map_security_scheme(scheme)\n    end)\n    |> Enum.reject(&is_nil/1)\n  end\n\n  @doc \"\"\"\n  Creates authentication configuration for tools that require auth.\n\n  ## Parameters\n\n  - `security_schemes`: Available security schemes\n  - `operation_security`: Security requirements for the operation\n\n  ## Returns\n\n  UTCP authentication configuration or nil.\n  \"\"\"\n  @spec create_tool_auth(map(), list()) :: map() | nil\n  def create_tool_auth(security_schemes, operation_security) do\n    case operation_security do\n      [] ->\n        nil\n\n      [security_requirement | _] ->\n        map_security_requirement(security_requirement, security_schemes)\n    end\n  end\n\n  @doc \"\"\"\n  Validates authentication configuration against OpenAPI security schemes.\n\n  ## Parameters\n\n  - `auth`: UTCP authentication configuration\n  - `security_schemes`: Available security schemes\n\n  ## Returns\n\n  `{:ok, validated_auth}` or `{:error, reason}`.\n  \"\"\"\n  @spec validate_auth(map(), map()) :: {:ok, map()} | {:error, term()}\n  def validate_auth(auth, security_schemes) do\n    case auth do\n      %{type: :api_key} -> validate_api_key_auth(auth, security_schemes)\n      %{type: :basic} -> validate_basic_auth(auth, security_schemes)\n      %{type: :oauth2} -> validate_oauth2_auth(auth, security_schemes)\n      _ -> {:error, \"Unsupported authentication type\"}\n    end\n  end\n\n  defp validate_api_key_auth(auth, security_schemes) do\n    # Check if there's a matching API key security scheme\n    has_api_key_scheme =\n      Enum.any?(security_schemes, fn {_name, scheme} ->\n        scheme.type == \"apiKey\"\n      end)\n\n    if has_api_key_scheme do\n      {:ok, auth}\n    else\n      {:error, \"No API key security scheme found in OpenAPI spec\"}\n    end\n  end\n\n  defp validate_basic_auth(auth, security_schemes) do\n    # Check if there's a matching HTTP basic security scheme\n    has_basic_scheme =\n      Enum.any?(security_schemes, fn {_name, scheme} ->\n        scheme.type == \"http\" && scheme.scheme == \"basic\"\n      end)\n\n    if has_basic_scheme do\n      {:ok, auth}\n    else\n      {:error, \"No HTTP basic security scheme found in OpenAPI spec\"}\n    end\n  end\n\n  defp validate_oauth2_auth(auth, security_schemes) do\n    # Check if there's a matching OAuth2 security scheme\n    has_oauth2_scheme =\n      Enum.any?(security_schemes, fn {_name, scheme} ->\n        scheme.type == \"oauth2\"\n      end)\n\n    if has_oauth2_scheme do\n      {:ok, auth}\n    else\n      {:error, \"No OAuth2 security scheme found in OpenAPI spec\"}\n    end\n  end\nend\n",
      "line_count": 292,
      "word_count": 704,
      "title": "Auth Mapper.Ex",
      "summary": "defmodule ExUtcp.OpenApiConverter.AuthMapper do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "ParsedSecurityScheme",
        "error",
        "list",
        "Available",
        "cookie",
        "Utcp",
        "Unsupported",
        "found",
        "reject",
        "usage",
        "multiple",
        "there",
        "Creates",
        "if",
        "that",
        "supported",
        "basic",
        "true",
        "term"
      ],
      "timestamp": "2025-12-24T18:56:01.005994"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\openapi_converter\\generator.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.OpenApiConverter.Generator do\n  @moduledoc \"\"\"\n  Generates UTCP tools from parsed OpenAPI specifications.\n  \"\"\"\n\n  alias ExUtcp.OpenApiConverter.AuthMapper\n  alias ExUtcp.OpenApiConverter.Types, as: T\n\n  @doc \"\"\"\n  Generates UTCP tools from a parsed OpenAPI specification.\n\n  ## Parameters\n\n  - `parsed_spec`: Parsed OpenAPI specification\n  - `opts`: Conversion options\n\n  ## Returns\n\n  `{:ok, tools}` on success, `{:error, reason}` on failure.\n  \"\"\"\n  @spec generate_tools(T.ParsedSpec.t(), keyword()) :: {:ok, [map()]} | {:error, term()}\n  def generate_tools(parsed_spec, opts \\\\ []) do\n    conversion_opts = build_conversion_options(opts)\n\n    tools =\n      parsed_spec.paths\n      |> Enum.flat_map(&generate_tools_from_path(&1, parsed_spec, conversion_opts))\n      |> Enum.filter(&filter_tool(&1, conversion_opts))\n      |> Enum.map(&apply_prefix(&1, conversion_opts.prefix))\n\n    {:ok, tools}\n  rescue\n    error -> {:error, \"Failed to generate tools: #{inspect(error)}\"}\n  end\n\n  # Private functions\n\n  defp build_conversion_options(opts) do\n    %T.ConversionOptions{\n      base_url: Keyword.get(opts, :base_url),\n      auth: Keyword.get(opts, :auth),\n      prefix: Keyword.get(opts, :prefix, \"\"),\n      include_deprecated: Keyword.get(opts, :include_deprecated, false),\n      filter_tags: Keyword.get(opts, :filter_tags, []),\n      exclude_tags: Keyword.get(opts, :exclude_tags, []),\n      custom_headers: Keyword.get(opts, :custom_headers, %{}),\n      timeout: Keyword.get(opts, :timeout, 30_000)\n    }\n  end\n\n  defp generate_tools_from_path(path, parsed_spec, opts) do\n    Enum.map(path.operations, fn operation ->\n      generate_tool_from_operation(operation, parsed_spec, opts)\n    end)\n  end\n\n  defp generate_tool_from_operation(operation, parsed_spec, opts) do\n    tool_name = generate_tool_name(operation, opts.prefix)\n\n    %{\n      name: tool_name,\n      description: build_tool_description(operation),\n      input_schema: build_input_schema(operation),\n      output_schema: build_output_schema(operation),\n      provider: build_provider(operation, parsed_spec, opts)\n    }\n  end\n\n  defp generate_tool_name(operation, _prefix) do\n    operation.operation_id ||\n      \"#{operation.method}_#{sanitize_path(operation.path)}\"\n  end\n\n  defp sanitize_path(path) do\n    path\n    |> String.replace(~r/[{}]/, \"\")\n    |> String.replace(~r/[^a-zA-Z0-9]/, \"_\")\n    |> String.downcase()\n  end\n\n  defp build_tool_description(operation) do\n    description_parts = []\n\n    description_parts =\n      if operation.summary do\n        [operation.summary | description_parts]\n      else\n        description_parts\n      end\n\n    description_parts =\n      if operation.description do\n        [operation.description | description_parts]\n      else\n        description_parts\n      end\n\n    description_parts =\n      if operation.deprecated do\n        [\"[DEPRECATED]\" | description_parts]\n      else\n        description_parts\n      end\n\n    case description_parts do\n      [] -> \"#{String.upcase(operation.method)} #{operation.path}\"\n      parts -> Enum.join(Enum.reverse(parts), \" - \")\n    end\n  end\n\n  defp build_input_schema(operation) do\n    properties = %{}\n    required = []\n\n    # Add path parameters\n    {properties, required} = add_path_parameters(operation, properties, required)\n\n    # Add query parameters\n    {properties, required} = add_query_parameters(operation, properties, required)\n\n    # Add header parameters\n    {properties, required} = add_header_parameters(operation, properties, required)\n\n    # Add request body\n    {properties, required} = add_request_body(operation, properties, required)\n\n    %{\n      \"type\" => \"object\",\n      \"properties\" => properties,\n      \"required\" => required\n    }\n  end\n\n  defp add_path_parameters(operation, properties, required) do\n    path_params = Enum.filter(operation.parameters, &(&1.in == \"path\"))\n\n    {new_properties, new_required} =\n      Enum.reduce(path_params, {properties, required}, fn param, {props, req} ->\n        param_schema = build_parameter_schema(param)\n        new_props = Map.put(props, param.name, param_schema)\n        new_req = if param.required, do: [param.name | req], else: req\n        {new_props, new_req}\n      end)\n\n    {new_properties, new_required}\n  end\n\n  defp add_query_parameters(operation, properties, required) do\n    query_params = Enum.filter(operation.parameters, &(&1.in == \"query\"))\n\n    {new_properties, new_required} =\n      Enum.reduce(query_params, {properties, required}, fn param, {props, req} ->\n        param_schema = build_parameter_schema(param)\n        new_props = Map.put(props, param.name, param_schema)\n        new_req = if param.required, do: [param.name | req], else: req\n        {new_props, new_req}\n      end)\n\n    {new_properties, new_required}\n  end\n\n  defp add_header_parameters(operation, properties, required) do\n    header_params = Enum.filter(operation.parameters, &(&1.in == \"header\"))\n\n    {new_properties, new_required} =\n      Enum.reduce(header_params, {properties, required}, fn param, {props, req} ->\n        param_schema = build_parameter_schema(param)\n        new_props = Map.put(props, param.name, param_schema)\n        new_req = if param.required, do: [param.name | req], else: req\n        {new_props, new_req}\n      end)\n\n    {new_properties, new_required}\n  end\n\n  defp add_request_body(operation, properties, required) do\n    case operation.request_body do\n      nil ->\n        {properties, required}\n\n      request_body ->\n        body_schema = build_request_body_schema(request_body)\n        new_props = Map.put(properties, \"body\", body_schema)\n        new_req = if request_body.required, do: [\"body\" | required], else: required\n        {new_props, new_req}\n    end\n  end\n\n  defp build_parameter_schema(param) do\n    base_schema =\n      case param.schema do\n        nil -> %{\"type\" => \"string\"}\n        schema -> convert_schema_to_json_schema(schema)\n      end\n\n    base_schema\n    |> Map.put(\"description\", param.description)\n    |> Map.put(\"example\", param.example)\n  end\n\n  defp build_request_body_schema(request_body) do\n    case request_body.schema do\n      nil -> %{\"type\" => \"object\"}\n      schema -> convert_schema_to_json_schema(schema)\n    end\n    |> Map.put(\"description\", request_body.description)\n  end\n\n  defp convert_schema_to_json_schema(nil), do: %{\"type\" => \"string\"}\n\n  defp convert_schema_to_json_schema(schema) do\n    base_schema = %{\n      \"type\" => schema.type || \"string\",\n      \"description\" => schema.description,\n      \"example\" => schema.example\n    }\n\n    base_schema =\n      if schema.format do\n        Map.put(base_schema, \"format\", schema.format)\n      else\n        base_schema\n      end\n\n    base_schema =\n      if schema.enum do\n        Map.put(base_schema, \"enum\", schema.enum)\n      else\n        base_schema\n      end\n\n    base_schema =\n      if schema.properties && map_size(schema.properties) > 0 do\n        converted_props =\n          Enum.map(schema.properties, fn {name, prop_schema} ->\n            {name, convert_schema_to_json_schema(prop_schema)}\n          end)\n          |> Map.new()\n\n        base_schema\n        |> Map.put(\"properties\", converted_props)\n        |> Map.put(\"required\", schema.required || [])\n      else\n        base_schema\n      end\n\n    base_schema =\n      if schema.items do\n        Map.put(base_schema, \"items\", convert_schema_to_json_schema(schema.items))\n      else\n        base_schema\n      end\n\n    base_schema\n  end\n\n  defp build_output_schema(operation) do\n    case operation.responses do\n      [] ->\n        %{\"type\" => \"object\"}\n\n      responses ->\n        # Find the first successful response (2xx)\n        success_response =\n          Enum.find(responses, fn response ->\n            String.starts_with?(response.status_code, \"2\")\n          end)\n\n        case success_response do\n          nil -> %{\"type\" => \"object\"}\n          response -> build_response_schema(response)\n        end\n    end\n  end\n\n  defp build_response_schema(response) do\n    case response.schema do\n      nil -> %{\"type\" => \"object\"}\n      schema -> convert_schema_to_json_schema(schema)\n    end\n    |> Map.put(\"description\", response.description)\n  end\n\n  defp build_provider(operation, parsed_spec, opts) do\n    base_url = opts.base_url || get_base_url(parsed_spec)\n    auth = opts.auth || build_auth_from_security(operation, parsed_spec)\n\n    %{\n      name: \"openapi_#{operation.operation_id}\",\n      type: :http,\n      http_method: String.upcase(operation.method),\n      url: build_url(base_url, operation.path),\n      content_type: \"application/json\",\n      auth: auth,\n      headers: opts.custom_headers\n    }\n  end\n\n  defp get_base_url(parsed_spec) do\n    case parsed_spec.servers do\n      [server | _] -> server.url\n      [] -> \"http://localhost\"\n    end\n  end\n\n  defp build_url(base_url, path) do\n    base_url\n    |> String.trim_trailing(\"/\")\n    |> Kernel.<>(path)\n  end\n\n  defp build_auth_from_security(operation, parsed_spec) do\n    case operation.security do\n      [] ->\n        nil\n\n      [security_requirement | _] ->\n        AuthMapper.map_security_requirement(\n          security_requirement,\n          parsed_spec.components.security_schemes\n        )\n\n      _ ->\n        nil\n    end\n  end\n\n  defp filter_tool(tool, opts) do\n    # Check if tool should be included based on tags\n    tool_tags = extract_tool_tags(tool)\n\n    # Check filter_tags\n    if opts.filter_tags == [] do\n      true\n    else\n      if Enum.any?(opts.filter_tags, &(&1 in tool_tags)) do\n        true\n      else\n        false\n      end\n    end\n    |> then(fn include_by_filter ->\n      # Check exclude_tags\n      if opts.exclude_tags == [] do\n        include_by_filter\n      else\n        if Enum.any?(opts.exclude_tags, &(&1 in tool_tags)) do\n          false\n        else\n          include_by_filter\n        end\n      end\n    end)\n    |> then(fn include_by_tags ->\n      # Check deprecated\n      if opts.include_deprecated do\n        include_by_tags\n      else\n        include_by_tags && !String.contains?(tool.description, \"[DEPRECATED]\")\n      end\n    end)\n  end\n\n  defp extract_tool_tags(_tool) do\n    # Extract tags from tool name or description\n    # This is a simplified implementation\n    []\n  end\n\n  defp apply_prefix(tool, \"\"), do: tool\n\n  defp apply_prefix(tool, prefix) do\n    %{tool | name: \"#{prefix}.#{tool.name}\"}\n  end\nend\n",
      "line_count": 376,
      "word_count": 879,
      "title": "Generator.Ex",
      "summary": "defmodule ExUtcp.OpenApiConverter.Generator do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "paths",
        "localhost",
        "error",
        "headers",
        "based",
        "format",
        "Utcp",
        "req",
        "Conversion",
        "string",
        "application",
        "keyword",
        "parameters",
        "path",
        "if",
        "failure",
        "true",
        "term",
        "object"
      ],
      "timestamp": "2025-12-24T18:56:01.028527"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\openapi_converter\\parser.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.OpenApiConverter.Parser do\n  @moduledoc \"\"\"\n  OpenAPI specification parser for both 2.0 and 3.0 versions.\n  \"\"\"\n\n  alias ExUtcp.OpenApiConverter.Types, as: T\n\n  @doc \"\"\"\n  Parses an OpenAPI specification into a normalized structure.\n\n  ## Parameters\n\n  - `spec`: OpenAPI specification as a map\n\n  ## Returns\n\n  `{:ok, parsed_spec}` on success, `{:error, reason}` on failure.\n  \"\"\"\n  @spec parse(map()) :: {:ok, T.ParsedSpec.t()} | {:error, term()}\n  def parse(spec) do\n    case detect_version(spec) do\n      \"2.0\" -> parse_swagger_2_0(spec)\n      \"3.0\" -> parse_openapi_3_0(spec)\n      version -> {:error, \"Unsupported OpenAPI version: #{version}\"}\n    end\n  end\n\n  @doc \"\"\"\n  Validates an OpenAPI specification.\n\n  ## Parameters\n\n  - `spec`: OpenAPI specification as a map\n\n  ## Returns\n\n  `{:ok, validation_result}` on success, `{:error, reason}` on failure.\n  \"\"\"\n  @spec validate(map()) :: {:ok, T.ValidationResult.t()} | {:error, term()}\n  def validate(spec) do\n    case parse(spec) do\n      {:ok, parsed_spec} ->\n        validation_result = %T.ValidationResult{\n          valid: true,\n          errors: [],\n          warnings: [],\n          version: parsed_spec.version,\n          operations_count: count_operations(parsed_spec),\n          security_schemes_count: count_security_schemes(parsed_spec)\n        }\n\n        {:ok, validation_result}\n\n      {:error, reason} ->\n        validation_result = %T.ValidationResult{\n          valid: false,\n          errors: [%T.ValidationError{path: \"\", message: inspect(reason), code: \"PARSE_ERROR\"}],\n          warnings: [],\n          version: nil,\n          operations_count: 0,\n          security_schemes_count: 0\n        }\n\n        {:ok, validation_result}\n    end\n  end\n\n  # Private functions\n\n  defp detect_version(spec) do\n    cond do\n      Map.has_key?(spec, \"openapi\") -> \"3.0\"\n      Map.has_key?(spec, \"swagger\") -> \"2.0\"\n      true -> \"unknown\"\n    end\n  end\n\n  defp parse_swagger_2_0(spec) do\n    parsed_spec = %T.ParsedSpec{\n      version: \"2.0\",\n      info: parse_swagger_info(spec[\"info\"] || %{}),\n      servers: parse_swagger_servers(spec),\n      paths: parse_swagger_paths(spec[\"paths\"] || %{}),\n      components: parse_swagger_components(spec),\n      security: parse_swagger_security(spec[\"security\"] || []),\n      tags: parse_swagger_tags(spec[\"tags\"] || []),\n      external_docs: parse_external_docs(spec[\"externalDocs\"])\n    }\n\n    {:ok, parsed_spec}\n  rescue\n    error ->\n      {:error, \"Failed to parse Swagger 2.0 spec: #{Exception.message(error)}\"}\n  end\n\n  defp parse_openapi_3_0(spec) do\n    parsed_spec = %T.ParsedSpec{\n      version: \"3.0\",\n      info: parse_openapi_info(spec[\"info\"] || %{}),\n      servers: parse_openapi_servers(spec[\"servers\"] || []),\n      paths: parse_openapi_paths(spec[\"paths\"] || %{}),\n      components: parse_openapi_components(spec[\"components\"] || %{}),\n      security: parse_openapi_security(spec[\"security\"] || []),\n      tags: parse_openapi_tags(spec[\"tags\"] || []),\n      external_docs: parse_external_docs(spec[\"externalDocs\"])\n    }\n\n    {:ok, parsed_spec}\n  rescue\n    error -> {:error, \"Failed to parse OpenAPI 3.0 spec: #{Exception.message(error)}\"}\n  end\n\n  # Swagger 2.0 parsing functions\n\n  defp parse_swagger_info(info) do\n    %T.ParsedInfo{\n      title: info[\"title\"] || \"API\",\n      description: info[\"description\"],\n      version: info[\"version\"] || \"1.0.0\",\n      contact: parse_contact(info[\"contact\"]),\n      license: parse_license(info[\"license\"])\n    }\n  end\n\n  defp parse_swagger_servers(spec) do\n    host = spec[\"host\"] || \"localhost\"\n    base_path = spec[\"basePath\"] || \"\"\n    schemes = spec[\"schemes\"] || [\"http\"]\n\n    Enum.map(schemes, fn scheme ->\n      %T.ParsedServer{\n        url: \"#{scheme}://#{host}#{base_path}\",\n        description: nil,\n        variables: %{}\n      }\n    end)\n  end\n\n  defp parse_swagger_paths(paths) do\n    Enum.map(paths, fn {path, path_item} ->\n      operations = parse_swagger_operations(path, path_item)\n      %T.ParsedPath{path: path, operations: operations}\n    end)\n  end\n\n  defp parse_swagger_operations(path, path_item) do\n    operations = []\n\n    operations =\n      if path_item[\"get\"] do\n        [parse_swagger_operation(\"GET\", path, path_item[\"get\"]) | operations]\n      else\n        operations\n      end\n\n    operations =\n      if path_item[\"post\"] do\n        [parse_swagger_operation(\"POST\", path, path_item[\"post\"]) | operations]\n      else\n        operations\n      end\n\n    operations =\n      if path_item[\"put\"] do\n        [parse_swagger_operation(\"PUT\", path, path_item[\"put\"]) | operations]\n      else\n        operations\n      end\n\n    operations =\n      if path_item[\"delete\"] do\n        [parse_swagger_operation(\"DELETE\", path, path_item[\"delete\"]) | operations]\n      else\n        operations\n      end\n\n    operations =\n      if path_item[\"patch\"] do\n        [parse_swagger_operation(\"PATCH\", path, path_item[\"patch\"]) | operations]\n      else\n        operations\n      end\n\n    operations =\n      if path_item[\"head\"] do\n        [parse_swagger_operation(\"HEAD\", path, path_item[\"head\"]) | operations]\n      else\n        operations\n      end\n\n    operations =\n      if path_item[\"options\"] do\n        [parse_swagger_operation(\"OPTIONS\", path, path_item[\"options\"]) | operations]\n      else\n        operations\n      end\n\n    Enum.reverse(operations)\n  end\n\n  defp parse_swagger_operation(method, path, operation) do\n    %T.ParsedOperation{\n      method: String.downcase(method),\n      path: path,\n      operation_id: operation[\"operationId\"] || generate_operation_id(method, path),\n      summary: operation[\"summary\"],\n      description: operation[\"description\"],\n      tags: operation[\"tags\"] || [],\n      parameters: parse_swagger_parameters(operation[\"parameters\"] || []),\n      # Swagger 2.0 doesn't have request body\n      request_body: nil,\n      responses: parse_swagger_responses(operation[\"responses\"] || %{}),\n      security: parse_swagger_operation_security(operation[\"security\"]),\n      deprecated: operation[\"deprecated\"] || false\n    }\n  end\n\n  defp parse_swagger_parameters(parameters) do\n    Enum.map(parameters, fn param ->\n      %T.ParsedParameter{\n        name: param[\"name\"],\n        in: param[\"in\"],\n        description: param[\"description\"],\n        required: param[\"required\"] || false,\n        schema: parse_swagger_schema(param[\"schema\"] || %{\"type\" => param[\"type\"]}),\n        style: nil,\n        explode: nil,\n        example: param[\"example\"]\n      }\n    end)\n  end\n\n  defp parse_swagger_responses(responses) do\n    Enum.map(responses, fn {status_code, response} ->\n      %T.ParsedResponse{\n        status_code: status_code,\n        description: response[\"description\"],\n        # Swagger 2.0 default\n        content_types: [\"application/json\"],\n        schema: parse_swagger_schema(response[\"schema\"])\n      }\n    end)\n  end\n\n  defp parse_swagger_schema(schema) when is_map(schema) do\n    items = if schema[\"items\"], do: parse_swagger_schema(schema[\"items\"])\n\n    %T.OpenApiSchema{\n      type: schema[\"type\"],\n      format: schema[\"format\"],\n      title: schema[\"title\"],\n      description: schema[\"description\"],\n      required: schema[\"required\"] || [],\n      properties: parse_swagger_properties(schema[\"properties\"] || %{}),\n      items: items,\n      enum: schema[\"enum\"],\n      example: schema[\"example\"]\n    }\n  end\n\n  defp parse_swagger_schema(_), do: nil\n\n  defp parse_swagger_properties(properties) do\n    Enum.map(properties, fn {name, schema} ->\n      {name, parse_swagger_schema(schema)}\n    end)\n    |> Map.new()\n  end\n\n  defp parse_swagger_components(spec) do\n    %{\n      security_schemes: parse_swagger_security_definitions(spec[\"securityDefinitions\"] || %{})\n    }\n  end\n\n  defp parse_swagger_security_definitions(security_definitions) do\n    Enum.map(security_definitions, fn {name, scheme} ->\n      {name,\n       %T.ParsedSecurityScheme{\n         name: scheme[\"name\"],\n         type: scheme[\"type\"],\n         description: scheme[\"description\"],\n         in: scheme[\"in\"],\n         scheme: scheme[\"scheme\"],\n         bearer_format: scheme[\"bearerFormat\"],\n         flows: nil\n       }}\n    end)\n    |> Map.new()\n  end\n\n  defp parse_swagger_security(security) do\n    Enum.map(security, fn security_requirement ->\n      Enum.map(security_requirement, fn {name, scopes} ->\n        {name, scopes || []}\n      end)\n      |> Map.new()\n    end)\n  end\n\n  defp parse_swagger_operation_security(nil), do: []\n  defp parse_swagger_operation_security(security), do: parse_swagger_security(security)\n\n  defp parse_swagger_tags(tags) do\n    Enum.map(tags, fn tag ->\n      %T.Tag{\n        name: tag[\"name\"],\n        description: tag[\"description\"],\n        external_docs: parse_external_docs(tag[\"externalDocs\"])\n      }\n    end)\n  end\n\n  # OpenAPI 3.0 parsing functions\n\n  defp parse_openapi_info(info) do\n    %T.ParsedInfo{\n      title: info[\"title\"] || \"API\",\n      description: info[\"description\"],\n      version: info[\"version\"] || \"1.0.0\",\n      contact: parse_contact(info[\"contact\"]),\n      license: parse_license(info[\"license\"])\n    }\n  end\n\n  defp parse_openapi_servers(servers) do\n    Enum.map(servers, fn server ->\n      %T.ParsedServer{\n        url: server[\"url\"] || \"/\",\n        description: server[\"description\"],\n        variables: server[\"variables\"] || %{}\n      }\n    end)\n  end\n\n  defp parse_openapi_paths(paths) do\n    Enum.map(paths, fn {path, path_item} ->\n      operations = parse_openapi_operations(path, path_item)\n      %T.ParsedPath{path: path, operations: operations}\n    end)\n  end\n\n  defp parse_openapi_operations(path, path_item) do\n    operations = []\n\n    operations =\n      if path_item[\"get\"] do\n        [parse_openapi_operation(\"GET\", path, path_item[\"get\"]) | operations]\n      else\n        operations\n      end\n\n    operations =\n      if path_item[\"post\"] do\n        [parse_openapi_operation(\"POST\", path, path_item[\"post\"]) | operations]\n      else\n        operations\n      end\n\n    operations =\n      if path_item[\"put\"] do\n        [parse_openapi_operation(\"PUT\", path, path_item[\"put\"]) | operations]\n      else\n        operations\n      end\n\n    operations =\n      if path_item[\"delete\"] do\n        [parse_openapi_operation(\"DELETE\", path, path_item[\"delete\"]) | operations]\n      else\n        operations\n      end\n\n    operations =\n      if path_item[\"patch\"] do\n        [parse_openapi_operation(\"PATCH\", path, path_item[\"patch\"]) | operations]\n      else\n        operations\n      end\n\n    operations =\n      if path_item[\"head\"] do\n        [parse_openapi_operation(\"HEAD\", path, path_item[\"head\"]) | operations]\n      else\n        operations\n      end\n\n    operations =\n      if path_item[\"options\"] do\n        [parse_openapi_operation(\"OPTIONS\", path, path_item[\"options\"]) | operations]\n      else\n        operations\n      end\n\n    operations =\n      if path_item[\"trace\"] do\n        [parse_openapi_operation(\"TRACE\", path, path_item[\"trace\"]) | operations]\n      else\n        operations\n      end\n\n    Enum.reverse(operations)\n  end\n\n  defp parse_openapi_operation(method, path, operation) do\n    %T.ParsedOperation{\n      method: String.downcase(method),\n      path: path,\n      operation_id: operation[\"operationId\"] || generate_operation_id(method, path),\n      summary: operation[\"summary\"],\n      description: operation[\"description\"],\n      tags: operation[\"tags\"] || [],\n      parameters: parse_openapi_parameters(operation[\"parameters\"] || []),\n      request_body: parse_openapi_request_body(operation[\"requestBody\"]),\n      responses: parse_openapi_responses(operation[\"responses\"] || %{}),\n      security: parse_openapi_operation_security(operation[\"security\"]),\n      deprecated: operation[\"deprecated\"] || false\n    }\n  end\n\n  defp parse_openapi_parameters(parameters) do\n    Enum.map(parameters, fn param ->\n      %T.ParsedParameter{\n        name: param[\"name\"],\n        in: param[\"in\"],\n        description: param[\"description\"],\n        required: param[\"required\"] || false,\n        schema: parse_openapi_schema(param[\"schema\"]),\n        style: param[\"style\"],\n        explode: param[\"explode\"],\n        example: param[\"example\"]\n      }\n    end)\n  end\n\n  defp parse_openapi_request_body(nil), do: nil\n\n  defp parse_openapi_request_body(request_body) do\n    %T.ParsedRequestBody{\n      description: request_body[\"description\"],\n      required: request_body[\"required\"] || false,\n      content_types: Map.keys(request_body[\"content\"] || %{}),\n      schema: parse_openapi_media_types(request_body[\"content\"] || %{})\n    }\n  end\n\n  defp parse_openapi_responses(responses) do\n    Enum.map(responses, fn {status_code, response} ->\n      %T.ParsedResponse{\n        status_code: status_code,\n        description: response[\"description\"],\n        content_types: Map.keys(response[\"content\"] || %{}),\n        schema: parse_openapi_media_types(response[\"content\"] || %{})\n      }\n    end)\n  end\n\n  defp parse_openapi_media_types(content) do\n    case Map.values(content) do\n      [media_type | _] -> parse_openapi_schema(media_type[\"schema\"])\n      [] -> nil\n    end\n  end\n\n  defp parse_openapi_schema(nil), do: nil\n\n  defp parse_openapi_schema(schema) when is_map(schema) do\n    %T.OpenApiSchema{\n      type: schema[\"type\"],\n      format: schema[\"format\"],\n      title: schema[\"title\"],\n      description: schema[\"description\"],\n      required: schema[\"required\"] || [],\n      properties: parse_openapi_properties(schema[\"properties\"] || %{}),\n      items: parse_openapi_schema(schema[\"items\"]),\n      enum: schema[\"enum\"],\n      example: schema[\"example\"]\n    }\n  end\n\n  defp parse_openapi_properties(properties) do\n    Enum.map(properties, fn {name, schema} ->\n      {name, parse_openapi_schema(schema)}\n    end)\n    |> Map.new()\n  end\n\n  defp parse_openapi_components(components) do\n    %{\n      security_schemes: parse_openapi_security_schemes(components[\"securitySchemes\"] || %{})\n    }\n  end\n\n  defp parse_openapi_security_schemes(security_schemes) do\n    Enum.map(security_schemes, fn {name, scheme} ->\n      %T.ParsedSecurityScheme{\n        name: name,\n        type: scheme[\"type\"],\n        description: scheme[\"description\"],\n        in: scheme[\"in\"],\n        scheme: scheme[\"scheme\"],\n        bearer_format: scheme[\"bearerFormat\"],\n        flows: parse_oauth_flows(scheme[\"flows\"])\n      }\n    end)\n    |> Map.new()\n  end\n\n  defp parse_oauth_flows(nil), do: nil\n\n  defp parse_oauth_flows(flows) do\n    %T.OpenApiOAuthFlows{\n      implicit: parse_oauth_flow(flows[\"implicit\"]),\n      password: parse_oauth_flow(flows[\"password\"]),\n      client_credentials: parse_oauth_flow(flows[\"clientCredentials\"]),\n      authorization_code: parse_oauth_flow(flows[\"authorizationCode\"])\n    }\n  end\n\n  defp parse_oauth_flow(nil), do: nil\n\n  defp parse_oauth_flow(flow) do\n    %T.OpenApiOAuthFlow{\n      authorization_url: flow[\"authorizationUrl\"],\n      token_url: flow[\"tokenUrl\"],\n      refresh_url: flow[\"refreshUrl\"],\n      scopes: flow[\"scopes\"] || %{}\n    }\n  end\n\n  defp parse_openapi_security(security) do\n    Enum.map(security, fn security_requirement ->\n      Enum.map(security_requirement, fn {name, scopes} ->\n        {name, scopes || []}\n      end)\n      |> Map.new()\n    end)\n  end\n\n  defp parse_openapi_operation_security(nil), do: []\n  defp parse_openapi_operation_security(security), do: parse_openapi_security(security)\n\n  defp parse_openapi_tags(tags) do\n    Enum.map(tags, fn tag ->\n      %T.Tag{\n        name: tag[\"name\"],\n        description: tag[\"description\"],\n        external_docs: parse_external_docs(tag[\"externalDocs\"])\n      }\n    end)\n  end\n\n  # Common parsing functions\n\n  defp parse_contact(nil), do: nil\n\n  defp parse_contact(contact) do\n    %T.Contact{\n      name: contact[\"name\"],\n      url: contact[\"url\"],\n      email: contact[\"email\"]\n    }\n  end\n\n  defp parse_license(nil), do: nil\n\n  defp parse_license(license) do\n    %T.License{\n      name: license[\"name\"],\n      url: license[\"url\"]\n    }\n  end\n\n  defp parse_external_docs(nil), do: nil\n\n  defp parse_external_docs(external_docs) do\n    %T.ExternalDocs{\n      description: external_docs[\"description\"],\n      url: external_docs[\"url\"]\n    }\n  end\n\n  defp generate_operation_id(method, path) do\n    path\n    |> String.replace(~r/[{}]/, \"\")\n    |> String.replace(~r/[^a-zA-Z0-9]/, \"_\")\n    # Replace multiple underscores with single underscore\n    |> String.replace(~r/_{2,}/, \"_\")\n    # Remove leading/trailing underscores\n    |> String.replace(~r/^_|_$/, \"\")\n    |> String.downcase()\n    |> then(&\"#{String.downcase(method)}_#{&1}\")\n  end\n\n  defp count_operations(parsed_spec) do\n    Enum.reduce(parsed_spec.paths, 0, fn path, acc ->\n      acc + length(path.operations)\n    end)\n  end\n\n  defp count_security_schemes(parsed_spec) do\n    map_size(parsed_spec.components.security_schemes)\n  end\nend\n",
      "line_count": 605,
      "word_count": 1283,
      "title": "Parser.Ex",
      "summary": "defmodule ExUtcp.OpenApiConverter.Parser do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "leading",
        "ParsedSecurityScheme",
        "paths",
        "localhost",
        "error",
        "info",
        "format",
        "Utcp",
        "Unsupported",
        "unknown",
        "ParsedParameter",
        "refreshUrl",
        "ValidationResult",
        "requestBody",
        "multiple",
        "application",
        "version",
        "parameters",
        "path"
      ],
      "timestamp": "2025-12-24T18:56:01.060097"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\openapi_converter\\types.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.OpenApiConverter.Types do\n  @moduledoc \"\"\"\n  Types and data structures for OpenAPI Converter.\n  \"\"\"\n\n  # OpenAPI 2.0 (Swagger) Types\n\n  defmodule SwaggerSpec do\n    @moduledoc \"OpenAPI 2.0 (Swagger) specification structure\"\n    defstruct [\n      :swagger,\n      :info,\n      :host,\n      :base_path,\n      :schemes,\n      :consumes,\n      :produces,\n      :paths,\n      :definitions,\n      :parameters,\n      :responses,\n      :security_definitions,\n      :security,\n      :tags,\n      :external_docs\n    ]\n  end\n\n  defmodule SwaggerInfo do\n    @moduledoc \"OpenAPI 2.0 info section\"\n    defstruct [\n      :title,\n      :description,\n      :terms_of_service,\n      :contact,\n      :license,\n      :version\n    ]\n  end\n\n  defmodule SwaggerPath do\n    @moduledoc \"OpenAPI 2.0 path item\"\n    defstruct [\n      :get,\n      :put,\n      :post,\n      :delete,\n      :options,\n      :head,\n      :patch,\n      :parameters\n    ]\n  end\n\n  defmodule SwaggerOperation do\n    @moduledoc \"OpenAPI 2.0 operation\"\n    defstruct [\n      :tags,\n      :summary,\n      :description,\n      :external_docs,\n      :operation_id,\n      :consumes,\n      :produces,\n      :parameters,\n      :responses,\n      :schemes,\n      :deprecated,\n      :security\n    ]\n  end\n\n  defmodule SwaggerParameter do\n    @moduledoc \"OpenAPI 2.0 parameter\"\n    defstruct [\n      :name,\n      :in,\n      :description,\n      :required,\n      :schema,\n      :type,\n      :format,\n      :allow_empty_value,\n      :items,\n      :collection_format,\n      :default,\n      :maximum,\n      :exclusive_maximum,\n      :minimum,\n      :exclusive_minimum,\n      :max_length,\n      :min_length,\n      :pattern,\n      :max_items,\n      :min_items,\n      :unique_items,\n      :enum,\n      :multiple_of\n    ]\n  end\n\n  defmodule SwaggerResponse do\n    @moduledoc \"OpenAPI 2.0 response\"\n    defstruct [\n      :description,\n      :schema,\n      :headers,\n      :examples\n    ]\n  end\n\n  defmodule SwaggerSchema do\n    @moduledoc \"OpenAPI 2.0 schema\"\n    defstruct [\n      :type,\n      :format,\n      :title,\n      :description,\n      :default,\n      :multiple_of,\n      :maximum,\n      :exclusive_maximum,\n      :minimum,\n      :exclusive_minimum,\n      :max_length,\n      :min_length,\n      :pattern,\n      :max_items,\n      :min_items,\n      :unique_items,\n      :max_properties,\n      :min_properties,\n      :required,\n      :enum,\n      :properties,\n      :items,\n      :all_of,\n      :one_of,\n      :any_of,\n      :not,\n      :additional_properties,\n      :discriminator,\n      :read_only,\n      :xml,\n      :external_docs,\n      :example\n    ]\n  end\n\n  defmodule SwaggerSecurityDefinition do\n    @moduledoc \"OpenAPI 2.0 security definition\"\n    defstruct [\n      :type,\n      :description,\n      :name,\n      :in,\n      :flow,\n      :authorization_url,\n      :token_url,\n      :scopes\n    ]\n  end\n\n  # OpenAPI 3.0 Types\n\n  defmodule OpenApiSpec do\n    @moduledoc \"OpenAPI 3.0 specification structure\"\n    defstruct [\n      :openapi,\n      :info,\n      :servers,\n      :paths,\n      :components,\n      :security,\n      :tags,\n      :external_docs\n    ]\n  end\n\n  defmodule OpenApiInfo do\n    @moduledoc \"OpenAPI 3.0 info section\"\n    defstruct [\n      :title,\n      :description,\n      :terms_of_service,\n      :contact,\n      :license,\n      :version\n    ]\n  end\n\n  defmodule OpenApiServer do\n    @moduledoc \"OpenAPI 3.0 server\"\n    defstruct [\n      :url,\n      :description,\n      :variables\n    ]\n  end\n\n  defmodule OpenApiPathItem do\n    @moduledoc \"OpenAPI 3.0 path item\"\n    defstruct [\n      :summary,\n      :description,\n      :get,\n      :put,\n      :post,\n      :delete,\n      :options,\n      :head,\n      :patch,\n      :trace,\n      :servers,\n      :parameters\n    ]\n  end\n\n  defmodule OpenApiOperation do\n    @moduledoc \"OpenAPI 3.0 operation\"\n    defstruct [\n      :tags,\n      :summary,\n      :description,\n      :external_docs,\n      :operation_id,\n      :parameters,\n      :request_body,\n      :responses,\n      :callbacks,\n      :deprecated,\n      :security,\n      :servers\n    ]\n  end\n\n  defmodule OpenApiParameter do\n    @moduledoc \"OpenAPI 3.0 parameter\"\n    defstruct [\n      :name,\n      :in,\n      :description,\n      :required,\n      :deprecated,\n      :allow_empty_value,\n      :style,\n      :explode,\n      :allow_reserved,\n      :schema,\n      :example,\n      :examples\n    ]\n  end\n\n  defmodule OpenApiRequestBody do\n    @moduledoc \"OpenAPI 3.0 request body\"\n    defstruct [\n      :description,\n      :content,\n      :required\n    ]\n  end\n\n  defmodule OpenApiResponse do\n    @moduledoc \"OpenAPI 3.0 response\"\n    defstruct [\n      :description,\n      :headers,\n      :content,\n      :links\n    ]\n  end\n\n  defmodule OpenApiMediaType do\n    @moduledoc \"OpenAPI 3.0 media type\"\n    defstruct [\n      :schema,\n      :example,\n      :examples,\n      :encoding\n    ]\n  end\n\n  defmodule OpenApiSchema do\n    @moduledoc \"OpenAPI 3.0 schema\"\n    defstruct [\n      :type,\n      :format,\n      :title,\n      :description,\n      :default,\n      :multiple_of,\n      :maximum,\n      :exclusive_maximum,\n      :minimum,\n      :exclusive_minimum,\n      :max_length,\n      :min_length,\n      :pattern,\n      :max_items,\n      :min_items,\n      :unique_items,\n      :max_properties,\n      :min_properties,\n      :required,\n      :enum,\n      :properties,\n      :items,\n      :all_of,\n      :one_of,\n      :any_of,\n      :not,\n      :additional_properties,\n      :discriminator,\n      :read_only,\n      :write_only,\n      :xml,\n      :external_docs,\n      :example,\n      :deprecated\n    ]\n  end\n\n  defmodule OpenApiComponents do\n    @moduledoc \"OpenAPI 3.0 components\"\n    defstruct [\n      :schemas,\n      :responses,\n      :parameters,\n      :examples,\n      :request_bodies,\n      :headers,\n      :security_schemes,\n      :links,\n      :callbacks\n    ]\n  end\n\n  defmodule OpenApiSecurityScheme do\n    @moduledoc \"OpenAPI 3.0 security scheme\"\n    defstruct [\n      :type,\n      :description,\n      :name,\n      :in,\n      :scheme,\n      :bearer_format,\n      :flows,\n      :open_id_connect_url\n    ]\n  end\n\n  defmodule OpenApiOAuthFlows do\n    @moduledoc \"OpenAPI 3.0 OAuth flows\"\n    defstruct [\n      :implicit,\n      :password,\n      :client_credentials,\n      :authorization_code\n    ]\n  end\n\n  defmodule OpenApiOAuthFlow do\n    @moduledoc \"OpenAPI 3.0 OAuth flow\"\n    defstruct [\n      :authorization_url,\n      :token_url,\n      :refresh_url,\n      :scopes\n    ]\n  end\n\n  # Common types\n\n  defmodule Contact do\n    @moduledoc \"Contact information\"\n    defstruct [\n      :name,\n      :url,\n      :email\n    ]\n  end\n\n  defmodule License do\n    @moduledoc \"License information\"\n    defstruct [\n      :name,\n      :url\n    ]\n  end\n\n  defmodule ExternalDocs do\n    @moduledoc \"External documentation\"\n    defstruct [\n      :description,\n      :url\n    ]\n  end\n\n  defmodule Tag do\n    @moduledoc \"Tag information\"\n    defstruct [\n      :name,\n      :description,\n      :external_docs\n    ]\n  end\n\n  # Parsed specification structure\n\n  defmodule ParsedSpec do\n    @moduledoc \"Parsed OpenAPI specification\"\n    defstruct [\n      :version,\n      :info,\n      :servers,\n      :paths,\n      :components,\n      :security,\n      :tags,\n      :external_docs\n    ]\n  end\n\n  defmodule ParsedInfo do\n    @moduledoc \"Parsed info section\"\n    defstruct [\n      :title,\n      :description,\n      :version,\n      :contact,\n      :license\n    ]\n  end\n\n  defmodule ParsedServer do\n    @moduledoc \"Parsed server information\"\n    defstruct [\n      :url,\n      :description,\n      :variables\n    ]\n  end\n\n  defmodule ParsedPath do\n    @moduledoc \"Parsed path information\"\n    defstruct [\n      :path,\n      :operations\n    ]\n  end\n\n  defmodule ParsedOperation do\n    @moduledoc \"Parsed operation information\"\n    defstruct [\n      :method,\n      :path,\n      :operation_id,\n      :summary,\n      :description,\n      :tags,\n      :parameters,\n      :request_body,\n      :responses,\n      :security,\n      :deprecated\n    ]\n  end\n\n  defmodule ParsedParameter do\n    @moduledoc \"Parsed parameter information\"\n    defstruct [\n      :name,\n      :in,\n      :description,\n      :required,\n      :schema,\n      :style,\n      :explode,\n      :example\n    ]\n  end\n\n  defmodule ParsedRequestBody do\n    @moduledoc \"Parsed request body information\"\n    defstruct [\n      :description,\n      :required,\n      :content_types,\n      :schema\n    ]\n  end\n\n  defmodule ParsedResponse do\n    @moduledoc \"Parsed response information\"\n    defstruct [\n      :status_code,\n      :description,\n      :content_types,\n      :schema\n    ]\n  end\n\n  defmodule ParsedSecurityScheme do\n    @moduledoc \"Parsed security scheme information\"\n    defstruct [\n      :name,\n      :type,\n      :description,\n      :in,\n      :scheme,\n      :bearer_format,\n      :flows\n    ]\n  end\n\n  # Conversion options\n\n  defmodule ConversionOptions do\n    @moduledoc \"OpenAPI conversion options\"\n    defstruct [\n      :base_url,\n      :auth,\n      :prefix,\n      :include_deprecated,\n      :filter_tags,\n      :exclude_tags,\n      :custom_headers,\n      :timeout\n    ]\n  end\n\n  # Validation results\n\n  defmodule ValidationResult do\n    @moduledoc \"OpenAPI validation result\"\n    defstruct [\n      :valid,\n      :errors,\n      :warnings,\n      :version,\n      :operations_count,\n      :security_schemes_count\n    ]\n  end\n\n  defmodule ValidationError do\n    @moduledoc \"Validation error\"\n    defstruct [\n      :path,\n      :message,\n      :code\n    ]\n  end\nend\n",
      "line_count": 556,
      "word_count": 774,
      "title": "Types.Ex",
      "summary": "defmodule ExUtcp.OpenApiConverter.Types do @moduledoc \"\"\"",
      "key_terms": [
        "ParsedSecurityScheme",
        "paths",
        "headers",
        "error",
        "pattern",
        "OpenApiSecurityScheme",
        "OpenApiPathItem",
        "media",
        "info",
        "format",
        "Utcp",
        "ParsedParameter",
        "ValidationResult",
        "Conversion",
        "version",
        "parameters",
        "path",
        "SwaggerOperation",
        "Contact",
        "ExternalDocs"
      ],
      "timestamp": "2025-12-24T18:56:01.091767"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\search\\engine.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Search.Engine do\n  @moduledoc \"\"\"\n  Search engine for managing and indexing UTCP tools and providers.\n\n  The engine maintains an in-memory index of tools and providers for fast searching.\n  \"\"\"\n\n  use GenServer\n\n  alias ExUtcp.Types\n\n  @enforce_keys [:tools_index, :providers_index, :config]\n  defstruct [:tools_index, :providers_index, :config]\n\n  @type t :: %__MODULE__{\n          tools_index: %{String.t() => Types.tool()},\n          providers_index: %{String.t() => Types.provider_config()},\n          config: map()\n        }\n\n  @doc \"\"\"\n  Creates a new search engine.\n  \"\"\"\n  @spec new(keyword()) :: t()\n  def new(opts \\\\ []) do\n    config = %{\n      fuzzy_threshold: Keyword.get(opts, :fuzzy_threshold, 0.6),\n      semantic_threshold: Keyword.get(opts, :semantic_threshold, 0.3),\n      max_results: Keyword.get(opts, :max_results, 100),\n      enable_caching: Keyword.get(opts, :enable_caching, true)\n    }\n\n    %__MODULE__{\n      tools_index: %{},\n      providers_index: %{},\n      config: config\n    }\n  end\n\n  @doc \"\"\"\n  Starts the search engine as a GenServer.\n  \"\"\"\n  @spec start_link(keyword()) :: {:ok, pid()} | {:error, term()}\n  def start_link(opts \\\\ []) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  @doc \"\"\"\n  Adds a tool to the search index.\n  \"\"\"\n  @spec add_tool(t() | pid(), Types.tool()) :: t() | :ok\n  def add_tool(engine_or_pid, tool)\n\n  def add_tool(%__MODULE__{} = engine, tool) do\n    new_tools_index = Map.put(engine.tools_index, tool.name, tool)\n    %{engine | tools_index: new_tools_index}\n  end\n\n  def add_tool(pid, tool) when is_pid(pid) do\n    GenServer.call(pid, {:add_tool, tool})\n  end\n\n  @doc \"\"\"\n  Adds a provider to the search index.\n  \"\"\"\n  @spec add_provider(t() | pid(), Types.provider_config()) :: t() | :ok\n  def add_provider(engine_or_pid, provider)\n\n  def add_provider(%__MODULE__{} = engine, provider) do\n    new_providers_index = Map.put(engine.providers_index, provider.name, provider)\n    %{engine | providers_index: new_providers_index}\n  end\n\n  def add_provider(pid, provider) when is_pid(pid) do\n    GenServer.call(pid, {:add_provider, provider})\n  end\n\n  @doc \"\"\"\n  Removes a tool from the search index.\n  \"\"\"\n  @spec remove_tool(t() | pid(), String.t()) :: t() | :ok\n  def remove_tool(engine_or_pid, tool_name)\n\n  def remove_tool(%__MODULE__{} = engine, tool_name) do\n    new_tools_index = Map.delete(engine.tools_index, tool_name)\n    %{engine | tools_index: new_tools_index}\n  end\n\n  def remove_tool(pid, tool_name) when is_pid(pid) do\n    GenServer.call(pid, {:remove_tool, tool_name})\n  end\n\n  @doc \"\"\"\n  Removes a provider from the search index.\n  \"\"\"\n  @spec remove_provider(t() | pid(), String.t()) :: t() | :ok\n  def remove_provider(engine_or_pid, provider_name)\n\n  def remove_provider(%__MODULE__{} = engine, provider_name) do\n    new_providers_index = Map.delete(engine.providers_index, provider_name)\n    %{engine | providers_index: new_providers_index}\n  end\n\n  def remove_provider(pid, provider_name) when is_pid(pid) do\n    GenServer.call(pid, {:remove_provider, provider_name})\n  end\n\n  @doc \"\"\"\n  Gets all tools from the search index.\n  \"\"\"\n  @spec get_all_tools(t() | pid()) :: [Types.tool()]\n  def get_all_tools(engine_or_pid)\n\n  def get_all_tools(%__MODULE__{} = engine) do\n    Map.values(engine.tools_index)\n  end\n\n  def get_all_tools(pid) when is_pid(pid) do\n    GenServer.call(pid, :get_all_tools)\n  end\n\n  @doc \"\"\"\n  Gets all providers from the search index.\n  \"\"\"\n  @spec get_all_providers(t() | pid()) :: [Types.provider_config()]\n  def get_all_providers(engine_or_pid)\n\n  def get_all_providers(%__MODULE__{} = engine) do\n    Map.values(engine.providers_index)\n  end\n\n  def get_all_providers(pid) when is_pid(pid) do\n    GenServer.call(pid, :get_all_providers)\n  end\n\n  @doc \"\"\"\n  Gets a tool by name.\n  \"\"\"\n  @spec get_tool(t() | pid(), String.t()) :: Types.tool() | nil\n  def get_tool(engine_or_pid, tool_name)\n\n  def get_tool(%__MODULE__{} = engine, tool_name) do\n    Map.get(engine.tools_index, tool_name)\n  end\n\n  def get_tool(pid, tool_name) when is_pid(pid) do\n    GenServer.call(pid, {:get_tool, tool_name})\n  end\n\n  @doc \"\"\"\n  Gets a provider by name.\n  \"\"\"\n  @spec get_provider(t() | pid(), String.t()) :: Types.provider_config() | nil\n  def get_provider(engine_or_pid, provider_name)\n\n  def get_provider(%__MODULE__{} = engine, provider_name) do\n    Map.get(engine.providers_index, provider_name)\n  end\n\n  def get_provider(pid, provider_name) when is_pid(pid) do\n    GenServer.call(pid, {:get_provider, provider_name})\n  end\n\n  @doc \"\"\"\n  Clears all tools and providers from the search index.\n  \"\"\"\n  @spec clear(t() | pid()) :: t() | :ok\n  def clear(engine_or_pid)\n\n  def clear(%__MODULE__{} = engine) do\n    %{engine | tools_index: %{}, providers_index: %{}}\n  end\n\n  def clear(pid) when is_pid(pid) do\n    GenServer.call(pid, :clear)\n  end\n\n  @doc \"\"\"\n  Gets search engine statistics.\n  \"\"\"\n  @spec stats(t() | pid()) :: map()\n  def stats(engine_or_pid)\n\n  def stats(%__MODULE__{} = engine) do\n    %{\n      tools_count: map_size(engine.tools_index),\n      providers_count: map_size(engine.providers_index),\n      config: engine.config\n    }\n  end\n\n  def stats(pid) when is_pid(pid) do\n    GenServer.call(pid, :stats)\n  end\n\n  # GenServer callbacks\n\n  @impl GenServer\n  def init(opts) do\n    engine = new(opts)\n    {:ok, engine}\n  end\n\n  @impl GenServer\n  def handle_call({:add_tool, tool}, _from, engine) do\n    new_engine = add_tool(engine, tool)\n    {:reply, :ok, new_engine}\n  end\n\n  @impl GenServer\n  def handle_call({:add_provider, provider}, _from, engine) do\n    new_engine = add_provider(engine, provider)\n    {:reply, :ok, new_engine}\n  end\n\n  @impl GenServer\n  def handle_call({:remove_tool, tool_name}, _from, engine) do\n    new_engine = remove_tool(engine, tool_name)\n    {:reply, :ok, new_engine}\n  end\n\n  @impl GenServer\n  def handle_call({:remove_provider, provider_name}, _from, engine) do\n    new_engine = remove_provider(engine, provider_name)\n    {:reply, :ok, new_engine}\n  end\n\n  @impl GenServer\n  def handle_call(:get_all_tools, _from, engine) do\n    tools = get_all_tools(engine)\n    {:reply, tools, engine}\n  end\n\n  @impl GenServer\n  def handle_call(:get_all_providers, _from, engine) do\n    providers = get_all_providers(engine)\n    {:reply, providers, engine}\n  end\n\n  @impl GenServer\n  def handle_call({:get_tool, tool_name}, _from, engine) do\n    tool = get_tool(engine, tool_name)\n    {:reply, tool, engine}\n  end\n\n  @impl GenServer\n  def handle_call({:get_provider, provider_name}, _from, engine) do\n    provider = get_provider(engine, provider_name)\n    {:reply, provider, engine}\n  end\n\n  @impl GenServer\n  def handle_call(:clear, _from, engine) do\n    new_engine = clear(engine)\n    {:reply, :ok, new_engine}\n  end\n\n  @impl GenServer\n  def handle_call(:stats, _from, engine) do\n    statistics = stats(engine)\n    {:reply, statistics, engine}\n  end\nend\n",
      "line_count": 264,
      "word_count": 710,
      "title": "Engine.Ex",
      "summary": "defmodule ExUtcp.Search.Engine do @moduledoc \"\"\"",
      "key_terms": [
        "clear",
        "search",
        "error",
        "index",
        "Utcp",
        "providers",
        "reply",
        "keyword",
        "fast",
        "Creates",
        "indexing",
        "maintains",
        "true",
        "term",
        "Engine",
        "call",
        "memory",
        "def",
        "Map",
        "managing"
      ],
      "timestamp": "2025-12-24T18:56:01.122986"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\search\\filters.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Search.Filters do\n  @moduledoc \"\"\"\n  Search filters for UTCP tools and providers.\n\n  Provides filtering capabilities based on various criteria.\n  \"\"\"\n\n  alias ExUtcp.Types\n\n  @doc \"\"\"\n  Applies filters to a list of tools.\n  \"\"\"\n  @spec apply_filters([Types.tool()], map()) :: [Types.tool()]\n  def apply_filters(tools, filters) do\n    tools\n    |> filter_by_providers(Map.get(filters, :providers, []))\n    |> filter_by_transports(Map.get(filters, :transports, []))\n    |> filter_by_tags(Map.get(filters, :tags, []))\n  end\n\n  @doc \"\"\"\n  Applies filters to a list of providers.\n  \"\"\"\n  @spec apply_provider_filters([Types.provider_config()], map()) :: [Types.provider_config()]\n  def apply_provider_filters(providers, filters) do\n    providers\n    |> filter_providers_by_names(Map.get(filters, :providers, []))\n    |> filter_providers_by_transports(Map.get(filters, :transports, []))\n  end\n\n  @doc \"\"\"\n  Filters tools by provider names.\n  \"\"\"\n  @spec filter_by_providers([Types.tool()], [String.t()]) :: [Types.tool()]\n  def filter_by_providers(tools, []), do: tools\n\n  def filter_by_providers(tools, provider_names) do\n    provider_set = MapSet.new(provider_names)\n\n    Enum.filter(tools, fn tool ->\n      MapSet.member?(provider_set, tool.provider_name)\n    end)\n  end\n\n  @doc \"\"\"\n  Filters tools by transport types.\n  \"\"\"\n  @spec filter_by_transports([Types.tool()], [atom()]) :: [Types.tool()]\n  def filter_by_transports(tools, []), do: tools\n\n  def filter_by_transports(tools, transport_types) do\n    transport_set = MapSet.new(transport_types)\n\n    # This would require access to provider information\n    # For now, we'll implement a basic filter based on provider naming conventions\n    Enum.filter(tools, fn tool ->\n      # Extract transport type from provider name or use a lookup\n      provider_transport = infer_transport_from_provider(tool.provider_name)\n      MapSet.member?(transport_set, provider_transport)\n    end)\n  end\n\n  @doc \"\"\"\n  Filters tools by tags.\n  \"\"\"\n  @spec filter_by_tags([Types.tool()], [String.t()]) :: [Types.tool()]\n  def filter_by_tags(tools, []), do: tools\n\n  def filter_by_tags(tools, tags) do\n    tag_set = MapSet.new(tags)\n\n    Enum.filter(tools, fn tool ->\n      tool_tags = extract_tool_tags(tool)\n      not MapSet.disjoint?(tag_set, MapSet.new(tool_tags))\n    end)\n  end\n\n  @doc \"\"\"\n  Filters providers by names.\n  \"\"\"\n  @spec filter_providers_by_names([Types.provider_config()], [String.t()]) :: [\n          Types.provider_config()\n        ]\n  def filter_providers_by_names(providers, []), do: providers\n\n  def filter_providers_by_names(providers, names) do\n    name_set = MapSet.new(names)\n\n    Enum.filter(providers, fn provider ->\n      MapSet.member?(name_set, provider.name)\n    end)\n  end\n\n  @doc \"\"\"\n  Filters providers by transport types.\n  \"\"\"\n  @spec filter_providers_by_transports([Types.provider_config()], [atom()]) :: [\n          Types.provider_config()\n        ]\n  def filter_providers_by_transports(providers, []), do: providers\n\n  def filter_providers_by_transports(providers, transport_types) do\n    transport_set = MapSet.new(transport_types)\n\n    Enum.filter(providers, fn provider ->\n      MapSet.member?(transport_set, provider.type)\n    end)\n  end\n\n  @doc \"\"\"\n  Creates a filter for tools with specific capabilities.\n  \"\"\"\n  @spec capability_filter([String.t()]) :: (Types.tool() -> boolean())\n  def capability_filter(capabilities) do\n    capability_set = MapSet.new(capabilities)\n\n    fn tool ->\n      tool_capabilities = extract_tool_capabilities(tool)\n      not MapSet.disjoint?(capability_set, MapSet.new(tool_capabilities))\n    end\n  end\n\n  @doc \"\"\"\n  Creates a filter for tools with specific parameter types.\n  \"\"\"\n  @spec parameter_type_filter([String.t()]) :: (Types.tool() -> boolean())\n  def parameter_type_filter(param_types) do\n    type_set = MapSet.new(param_types)\n\n    fn tool ->\n      tool_param_types = extract_parameter_types(tool)\n      not MapSet.disjoint?(type_set, MapSet.new(tool_param_types))\n    end\n  end\n\n  @doc \"\"\"\n  Creates a filter for tools with specific response types.\n  \"\"\"\n  @spec response_type_filter([String.t()]) :: (Types.tool() -> boolean())\n  def response_type_filter(response_types) do\n    type_set = MapSet.new(response_types)\n\n    fn tool ->\n      tool_response_types = extract_response_types(tool)\n      not MapSet.disjoint?(type_set, MapSet.new(tool_response_types))\n    end\n  end\n\n  # Private functions\n\n  defp infer_transport_from_provider(provider_name) do\n    cond do\n      String.contains?(provider_name, \"http\") ->\n        :http\n\n      String.contains?(provider_name, \"websocket\") or String.contains?(provider_name, \"ws\") ->\n        :websocket\n\n      String.contains?(provider_name, \"grpc\") ->\n        :grpc\n\n      String.contains?(provider_name, \"graphql\") ->\n        :graphql\n\n      String.contains?(provider_name, \"mcp\") ->\n        :mcp\n\n      String.contains?(provider_name, \"tcp\") ->\n        :tcp\n\n      String.contains?(provider_name, \"udp\") ->\n        :udp\n\n      String.contains?(provider_name, \"cli\") ->\n        :cli\n\n      true ->\n        :unknown\n    end\n  end\n\n  defp extract_tool_tags(tool) do\n    # Extract tags from tool definition or infer from description\n    tags = []\n\n    # Check if tool definition has explicit tags\n    tags =\n      case tool.definition do\n        %{tags: explicit_tags} when is_list(explicit_tags) -> explicit_tags\n        _ -> tags\n      end\n\n    # Infer tags from description if no explicit tags\n    if Enum.empty?(tags) do\n      infer_tags_from_description(tool.definition.description)\n    else\n      tags\n    end\n  end\n\n  defp extract_tool_capabilities(tool) do\n    # Extract capabilities from tool definition\n    capabilities = []\n\n    # Infer capabilities from parameters and responses\n    capabilities =\n      if Map.has_key?(tool.definition, :parameters) do\n        param_capabilities = infer_capabilities_from_parameters(tool.definition.parameters)\n        capabilities ++ param_capabilities\n      else\n        capabilities\n      end\n\n    capabilities =\n      if Map.has_key?(tool.definition, :response) do\n        response_capabilities = infer_capabilities_from_response(tool.definition.response)\n        capabilities ++ response_capabilities\n      else\n        capabilities\n      end\n\n    capabilities\n  end\n\n  defp extract_parameter_types(tool) do\n    case tool.definition do\n      %{parameters: %{\"properties\" => properties}} ->\n        properties\n        |> Enum.map(fn {_name, param_def} ->\n          Map.get(param_def, \"type\", \"unknown\")\n        end)\n        |> Enum.uniq()\n\n      _ ->\n        []\n    end\n  end\n\n  defp extract_response_types(tool) do\n    case tool.definition do\n      %{response: %{\"properties\" => properties}} ->\n        properties\n        |> Enum.map(fn {_name, field_def} ->\n          Map.get(field_def, \"type\", \"unknown\")\n        end)\n        |> Enum.uniq()\n\n      _ ->\n        []\n    end\n  end\n\n  defp infer_tags_from_description(description) do\n    # Simple tag inference based on common patterns\n    description_lower = String.downcase(description)\n\n    tags = []\n\n    tags =\n      if String.contains?(description_lower, [\"file\", \"document\", \"pdf\", \"image\"]) do\n        [\"file-processing\" | tags]\n      else\n        tags\n      end\n\n    tags =\n      if String.contains?(description_lower, [\"api\", \"http\", \"request\", \"endpoint\"]) do\n        [\"api\" | tags]\n      else\n        tags\n      end\n\n    tags =\n      if String.contains?(description_lower, [\"data\", \"database\", \"query\", \"sql\"]) do\n        [\"data\" | tags]\n      else\n        tags\n      end\n\n    tags =\n      if String.contains?(description_lower, [\"text\", \"string\", \"parse\", \"format\"]) do\n        [\"text-processing\" | tags]\n      else\n        tags\n      end\n\n    tags =\n      if String.contains?(description_lower, [\"network\", \"connection\", \"socket\", \"tcp\", \"udp\"]) do\n        [\"network\" | tags]\n      else\n        tags\n      end\n\n    tags\n  end\n\n  defp infer_capabilities_from_parameters(parameters) when is_map(parameters) do\n    properties = Map.get(parameters, \"properties\", %{})\n\n    capabilities = []\n\n    # Infer capabilities from parameter names and types\n    capabilities =\n      if Map.has_key?(properties, \"file\") or Map.has_key?(properties, \"path\") do\n        [\"file-handling\" | capabilities]\n      else\n        capabilities\n      end\n\n    capabilities =\n      if Map.has_key?(properties, \"url\") or Map.has_key?(properties, \"endpoint\") do\n        [\"web-requests\" | capabilities]\n      else\n        capabilities\n      end\n\n    capabilities =\n      if Map.has_key?(properties, \"query\") or Map.has_key?(properties, \"search\") do\n        [\"search\" | capabilities]\n      else\n        capabilities\n      end\n\n    capabilities\n  end\n\n  defp infer_capabilities_from_parameters(_), do: []\n\n  defp infer_capabilities_from_response(response) when is_map(response) do\n    properties = Map.get(response, \"properties\", %{})\n\n    capabilities = []\n\n    # Infer capabilities from response structure\n    capabilities =\n      if Map.has_key?(properties, \"data\") or Map.has_key?(properties, \"result\") do\n        [\"data-retrieval\" | capabilities]\n      else\n        capabilities\n      end\n\n    capabilities =\n      if Map.has_key?(properties, \"status\") or Map.has_key?(properties, \"success\") do\n        [\"status-reporting\" | capabilities]\n      else\n        capabilities\n      end\n\n    capabilities\n  end\n\n  defp infer_capabilities_from_response(_), do: []\nend\n",
      "line_count": 354,
      "word_count": 828,
      "title": "Filters.Ex",
      "summary": "defmodule ExUtcp.Search.Filters do @moduledoc \"\"\"",
      "key_terms": [
        "Filters",
        "we",
        "grpc",
        "search",
        "MapSet",
        "based",
        "list",
        "format",
        "Utcp",
        "websocket",
        "unknown",
        "providers",
        "string",
        "data-retrieval",
        "has",
        "image",
        "Creates",
        "parameters",
        "path",
        "Provides"
      ],
      "timestamp": "2025-12-24T18:56:01.157955"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\search\\fuzzy.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Search.Fuzzy do\n  @moduledoc \"\"\"\n  Fuzzy search implementation for UTCP tools and providers.\n\n  Uses FuzzyCompare library for advanced string similarity algorithms.\n  \"\"\"\n\n  alias FuzzyCompare\n\n  @doc \"\"\"\n  Searches tools using fuzzy matching.\n  \"\"\"\n  @spec search_tools(list(), String.t(), map()) :: list()\n  def search_tools(tools, query, opts) do\n    threshold = Map.get(opts, :threshold, 0.6)\n\n    tools\n    |> Enum.map(fn tool ->\n      name_similarity = string_similarity(tool.name, query)\n\n      desc_similarity =\n        if opts.include_descriptions do\n          string_similarity(tool.definition.description, query)\n        else\n          0.0\n        end\n\n      max_similarity = max(name_similarity, desc_similarity)\n\n      if max_similarity >= threshold do\n        matched_fields = []\n\n        matched_fields =\n          if name_similarity >= threshold, do: [\"name\" | matched_fields], else: matched_fields\n\n        matched_fields =\n          if desc_similarity >= threshold,\n            do: [\"description\" | matched_fields],\n            else: matched_fields\n\n        %{\n          tool: tool,\n          score: max_similarity,\n          match_type: :fuzzy,\n          matched_fields: matched_fields\n        }\n      end\n    end)\n    |> Enum.reject(&is_nil/1)\n    |> Enum.sort_by(& &1.score, :desc)\n  end\n\n  @doc \"\"\"\n  Searches providers using fuzzy matching.\n  \"\"\"\n  @spec search_providers(list(), String.t(), map()) :: list()\n  def search_providers(providers, query, opts) do\n    threshold = Map.get(opts, :threshold, 0.6)\n\n    providers\n    |> Enum.map(fn provider ->\n      name_similarity = string_similarity(provider.name, query)\n      type_similarity = string_similarity(Atom.to_string(provider.type), query)\n\n      max_similarity = max(name_similarity, type_similarity)\n\n      if max_similarity >= threshold do\n        matched_fields = []\n\n        matched_fields =\n          if name_similarity >= threshold, do: [\"name\" | matched_fields], else: matched_fields\n\n        matched_fields =\n          if type_similarity >= threshold, do: [\"type\" | matched_fields], else: matched_fields\n\n        %{\n          provider: provider,\n          score: max_similarity,\n          match_type: :fuzzy,\n          matched_fields: matched_fields\n        }\n      end\n    end)\n    |> Enum.reject(&is_nil/1)\n    |> Enum.sort_by(& &1.score, :desc)\n  end\n\n  @doc \"\"\"\n  Calculates string similarity using FuzzyCompare algorithms.\n  \"\"\"\n  @spec string_similarity(String.t(), String.t()) :: float()\n  def string_similarity(str1, str2) do\n    str1_lower = String.downcase(str1)\n    str2_lower = String.downcase(str2)\n\n    cond do\n      str1_lower == str2_lower ->\n        1.0\n\n      String.contains?(str1_lower, str2_lower) ->\n        0.8\n\n      String.contains?(str2_lower, str1_lower) ->\n        0.8\n\n      true ->\n        # Use FuzzyCompare for advanced similarity calculation\n        case FuzzyCompare.similarity(str1_lower, str2_lower) do\n          {:ok, similarity} -> similarity\n          _ -> levenshtein_similarity(str1_lower, str2_lower)\n        end\n    end\n  end\n\n  @doc \"\"\"\n  Calculates multiple similarity metrics and returns the best score using FuzzyCompare.\n  \"\"\"\n  @spec best_similarity(String.t(), String.t()) :: float()\n  def best_similarity(str1, str2) do\n    # Use FuzzyCompare's main similarity function\n    FuzzyCompare.similarity(str1, str2)\n  end\n\n  @doc \"\"\"\n  Calculates Levenshtein distance (fallback implementation).\n  \"\"\"\n  @spec levenshtein_distance(String.t(), String.t()) :: integer()\n  def levenshtein_distance(str1, str2) do\n    # Simple Levenshtein implementation as fallback\n    str1_chars = String.graphemes(str1)\n    str2_chars = String.graphemes(str2)\n\n    levenshtein_distance_impl(str1_chars, str2_chars)\n  end\n\n  @doc \"\"\"\n  Calculates similarity score based on Levenshtein distance.\n  \"\"\"\n  @spec levenshtein_similarity(String.t(), String.t()) :: float()\n  def levenshtein_similarity(str1, str2) do\n    max_length = max(String.length(str1), String.length(str2))\n\n    if max_length == 0 do\n      1.0\n    else\n      distance = levenshtein_distance(str1, str2)\n      1.0 - distance / max_length\n    end\n  end\n\n  # Private functions\n\n  defp levenshtein_distance_impl(str1_chars, str2_chars) do\n    len1 = length(str1_chars)\n    len2 = length(str2_chars)\n\n    # Initialize distance matrix\n    matrix =\n      for i <- 0..len1, into: %{} do\n        {i, %{0 => i}}\n      end\n\n    matrix =\n      for j <- 0..len2, reduce: matrix do\n        acc -> put_in(acc, [0, j], j)\n      end\n\n    # Fill the matrix\n    matrix =\n      for i <- 1..len1, j <- 1..len2, reduce: matrix do\n        acc ->\n          char1 = Enum.at(str1_chars, i - 1)\n          char2 = Enum.at(str2_chars, j - 1)\n\n          cost = if char1 == char2, do: 0, else: 1\n\n          min_val =\n            min(\n              # deletion\n              acc[i - 1][j] + 1,\n              min(\n                # insertion\n                acc[i][j - 1] + 1,\n                # substitution\n                acc[i - 1][j - 1] + cost\n              )\n            )\n\n          put_in(acc, [i, j], min_val)\n      end\n\n    matrix[len1][len2]\n  end\nend\n",
      "line_count": 195,
      "word_count": 506,
      "title": "Fuzzy.Ex",
      "summary": "defmodule ExUtcp.Search.Fuzzy do @moduledoc \"\"\"",
      "key_terms": [
        "threshold",
        "search",
        "insertion",
        "based",
        "Levenshtein",
        "list",
        "Utcp",
        "providers",
        "reject",
        "string",
        "multiple",
        "using",
        "if",
        "true",
        "description",
        "function",
        "Uses",
        "desc",
        "defp",
        "Searches"
      ],
      "timestamp": "2025-12-24T18:56:01.186333"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\search\\ranking.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Search.Ranking do\n  @moduledoc \"\"\"\n  Search result ranking and scoring for UTCP tools and providers.\n\n  Provides sophisticated ranking algorithms to order search results by relevance.\n  \"\"\"\n\n  @doc \"\"\"\n  Ranks search results based on relevance and query context.\n  \"\"\"\n  @spec rank_results([map()], String.t(), map()) :: [map()]\n  def rank_results(results, query, opts) do\n    results\n    |> Enum.map(&calculate_final_score(&1, query, opts))\n    |> Enum.sort_by(& &1.score, :desc)\n  end\n\n  @doc \"\"\"\n  Ranks provider search results.\n  \"\"\"\n  @spec rank_provider_results([map()], String.t(), map()) :: [map()]\n  def rank_provider_results(results, query, opts) do\n    results\n    |> Enum.map(&calculate_provider_final_score(&1, query, opts))\n    |> Enum.sort_by(& &1.score, :desc)\n  end\n\n  @doc \"\"\"\n  Calculates popularity score based on usage patterns.\n  \"\"\"\n  @spec popularity_score(map()) :: float()\n  def popularity_score(result) do\n    # In a real implementation, this would be based on actual usage statistics\n    # For now, we'll use simple heuristics\n\n    base_score = 0.5\n\n    # Get name from either tool or provider\n    name_lower =\n      case result do\n        %{tool: tool} -> String.downcase(tool.name || \"\")\n        %{provider: provider} -> String.downcase(provider.name || \"\")\n        _ -> \"\"\n      end\n\n    cond do\n      String.contains?(name_lower, [\"get\", \"list\", \"fetch\", \"retrieve\"]) -> base_score + 0.3\n      String.contains?(name_lower, [\"create\", \"post\", \"add\", \"insert\"]) -> base_score + 0.2\n      String.contains?(name_lower, [\"update\", \"put\", \"modify\", \"edit\"]) -> base_score + 0.2\n      String.contains?(name_lower, [\"delete\", \"remove\", \"destroy\"]) -> base_score + 0.1\n      true -> base_score\n    end\n  end\n\n  @doc \"\"\"\n  Calculates recency score based on when the tool was last used or updated.\n  \"\"\"\n  @spec recency_score(map()) :: float()\n  def recency_score(_result) do\n    # In a real implementation, this would be based on actual timestamps\n    # For now, return a neutral score\n    0.5\n  end\n\n  @doc \"\"\"\n  Calculates quality score based on tool definition completeness.\n  \"\"\"\n  @spec quality_score(map()) :: float()\n  def quality_score(%{tool: tool}) do\n    base_score = 0.5\n\n    # Check for description quality\n    desc_score =\n      if String.length(tool.definition.description) > 50 do\n        0.2\n      else\n        0.0\n      end\n\n    # Check for parameter documentation\n    param_score =\n      case tool.definition do\n        %{parameters: %{\"properties\" => properties}} ->\n          documented_params =\n            properties\n            |> Enum.count(fn {_name, param_def} ->\n              Map.has_key?(param_def, \"description\") and\n                String.length(param_def[\"description\"]) > 10\n            end)\n\n          total_params = map_size(properties)\n          if total_params > 0, do: documented_params / total_params * 0.2, else: 0.0\n\n        _ ->\n          0.0\n      end\n\n    # Check for response documentation\n    response_score =\n      case tool.definition do\n        %{response: %{\"properties\" => properties}} ->\n          documented_responses =\n            properties\n            |> Enum.count(fn {_name, field_def} ->\n              Map.has_key?(field_def, \"description\") and\n                String.length(field_def[\"description\"]) > 10\n            end)\n\n          total_responses = map_size(properties)\n          if total_responses > 0, do: documented_responses / total_responses * 0.1, else: 0.0\n\n        _ ->\n          0.0\n      end\n\n    base_score + desc_score + param_score + response_score\n  end\n\n  def quality_score(%{provider: _provider}) do\n    # Provider quality score based on configuration completeness\n    0.5\n  end\n\n  def quality_score(_), do: 0.5\n\n  @doc \"\"\"\n  Calculates context relevance score based on query context.\n  \"\"\"\n  @spec context_relevance_score(map(), String.t()) :: float()\n  def context_relevance_score(result, query) do\n    query_lower = String.downcase(query)\n\n    # Boost score for exact matches in important fields\n    exact_name_match =\n      case result do\n        %{tool: tool} -> String.downcase(tool.name) == query_lower\n        %{provider: provider} -> String.downcase(provider.name) == query_lower\n        _ -> false\n      end\n\n    if exact_name_match do\n      1.0\n    else\n      # Calculate based on matched fields\n      matched_fields = Map.get(result, :matched_fields, [])\n\n      cond do\n        \"name\" in matched_fields -> 0.8\n        \"description\" in matched_fields -> 0.6\n        \"type\" in matched_fields -> 0.4\n        true -> 0.2\n      end\n    end\n  end\n\n  @doc \"\"\"\n  Applies boost factors based on search preferences.\n  \"\"\"\n  @spec apply_boost_factors(map(), map()) :: map()\n  def apply_boost_factors(result, opts) do\n    boost_factors = Map.get(opts, :boost_factors, %{})\n\n    # Apply transport-specific boosts\n    transport_boost =\n      case result do\n        %{tool: tool} ->\n          transport = infer_transport_from_tool(tool)\n          Map.get(boost_factors, transport, 1.0)\n\n        %{provider: provider} ->\n          Map.get(boost_factors, provider.type, 1.0)\n\n        _ ->\n          1.0\n      end\n\n    # Apply match type boosts\n    match_type_boost =\n      case result.match_type do\n        :exact -> Map.get(boost_factors, :exact_match, 1.2)\n        :fuzzy -> Map.get(boost_factors, :fuzzy_match, 1.0)\n        :semantic -> Map.get(boost_factors, :semantic_match, 0.9)\n      end\n\n    boosted_score = result.score * transport_boost * match_type_boost\n    %{result | score: boosted_score}\n  end\n\n  # Private functions\n\n  defp calculate_final_score(result, query, opts) do\n    # Combine multiple scoring factors\n    base_score = result.score\n    popularity = popularity_score(result)\n    recency = recency_score(result)\n    quality = quality_score(result)\n    context_relevance = context_relevance_score(result, query)\n\n    # Weighted combination\n    weights = %{\n      base: 0.4,\n      popularity: 0.2,\n      recency: 0.1,\n      quality: 0.2,\n      context: 0.1\n    }\n\n    final_score =\n      base_score * weights.base +\n        popularity * weights.popularity +\n        recency * weights.recency +\n        quality * weights.quality +\n        context_relevance * weights.context\n\n    result = %{result | score: final_score}\n\n    # Apply boost factors\n    apply_boost_factors(result, opts)\n  end\n\n  defp calculate_provider_final_score(result, query, opts) do\n    # Simpler scoring for providers\n    base_score = result.score\n    popularity = popularity_score(result)\n    context_relevance = context_relevance_score(result, query)\n\n    # Weighted combination\n    final_score = base_score * 0.6 + popularity * 0.2 + context_relevance * 0.2\n\n    result = %{result | score: final_score}\n\n    # Apply boost factors\n    apply_boost_factors(result, opts)\n  end\n\n  defp infer_transport_from_tool(tool) do\n    # Infer transport type from provider name\n    provider_name_lower = String.downcase(tool.provider_name)\n\n    cond do\n      String.contains?(provider_name_lower, \"http\") -> :http\n      String.contains?(provider_name_lower, \"websocket\") -> :websocket\n      String.contains?(provider_name_lower, \"grpc\") -> :grpc\n      String.contains?(provider_name_lower, \"graphql\") -> :graphql\n      String.contains?(provider_name_lower, \"mcp\") -> :mcp\n      String.contains?(provider_name_lower, \"tcp\") -> :tcp\n      String.contains?(provider_name_lower, \"udp\") -> :udp\n      String.contains?(provider_name_lower, \"cli\") -> :cli\n      true -> :unknown\n    end\n  end\nend\n",
      "line_count": 253,
      "word_count": 768,
      "title": "Ranking.Ex",
      "summary": "defmodule ExUtcp.Search.Ranking do @moduledoc \"\"\"",
      "key_terms": [
        "we",
        "grpc",
        "search",
        "either",
        "based",
        "Calculate",
        "list",
        "Ranks",
        "Utcp",
        "websocket",
        "Apply",
        "unknown",
        "providers",
        "usage",
        "multiple",
        "boosts",
        "parameters",
        "Provides",
        "if",
        "destroy"
      ],
      "timestamp": "2025-12-24T18:56:01.217891"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\search\\security.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Search.Security do\n  @moduledoc \"\"\"\n  Security scanning for search results using TruffleHog.\n\n  Scans tool definitions and provider configurations for sensitive data\n  and provides warnings or filtering capabilities.\n  \"\"\"\n\n  alias ExUtcp.Types\n  alias TruffleHog\n\n  @doc \"\"\"\n  Scans tools for sensitive data and returns security warnings.\n  \"\"\"\n  @spec scan_tools([Types.tool()]) :: %{String.t() => [map()]}\n  def scan_tools(tools) do\n    tools\n    |> Enum.reduce(%{}, fn tool, acc ->\n      warnings = scan_tool(tool)\n\n      if Enum.empty?(warnings) do\n        acc\n      else\n        Map.put(acc, tool.name, warnings)\n      end\n    end)\n  end\n\n  @doc \"\"\"\n  Scans a single tool for sensitive data.\n  \"\"\"\n  @spec scan_tool(Types.tool()) :: [map()]\n  def scan_tool(tool) do\n    warnings = []\n\n    # Scan tool name\n    warnings = warnings ++ scan_text(tool.name, \"tool_name\")\n\n    # Scan tool description\n    warnings = warnings ++ scan_text(tool.definition.description, \"description\")\n\n    # Scan parameters\n    warnings =\n      if Map.has_key?(tool.definition, :parameters) do\n        param_text = Jason.encode!(tool.definition.parameters)\n        warnings ++ scan_text(param_text, \"parameters\")\n      else\n        warnings\n      end\n\n    # Scan response schema\n    warnings =\n      if Map.has_key?(tool.definition, :response) do\n        response_text = Jason.encode!(tool.definition.response)\n        warnings ++ scan_text(response_text, \"response\")\n      else\n        warnings\n      end\n\n    warnings\n  end\n\n  @doc \"\"\"\n  Scans providers for sensitive data.\n  \"\"\"\n  @spec scan_providers([Types.provider_config()]) :: %{String.t() => [map()]}\n  def scan_providers(providers) do\n    providers\n    |> Enum.reduce(%{}, fn provider, acc ->\n      warnings = scan_provider(provider)\n\n      if Enum.empty?(warnings) do\n        acc\n      else\n        Map.put(acc, provider.name, warnings)\n      end\n    end)\n  end\n\n  @doc \"\"\"\n  Scans a single provider for sensitive data.\n  \"\"\"\n  @spec scan_provider(Types.provider_config()) :: [map()]\n  def scan_provider(provider) do\n    warnings = []\n\n    # Scan provider name\n    warnings = warnings ++ scan_text(provider.name, \"provider_name\")\n\n    # Scan URL if present\n    warnings =\n      if Map.has_key?(provider, :url) do\n        warnings ++ scan_text(provider.url, \"url\")\n      else\n        warnings\n      end\n\n    # Scan headers if present\n    warnings =\n      if Map.has_key?(provider, :headers) do\n        headers_text = Jason.encode!(provider.headers)\n        warnings ++ scan_text(headers_text, \"headers\")\n      else\n        warnings\n      end\n\n    # Scan authentication if present\n    warnings =\n      if Map.has_key?(provider, :auth) and provider.auth do\n        auth_text = Jason.encode!(provider.auth)\n        warnings ++ scan_text(auth_text, \"auth\")\n      else\n        warnings\n      end\n\n    warnings\n  end\n\n  @doc \"\"\"\n  Filters search results to exclude tools with sensitive data warnings.\n  \"\"\"\n  @spec filter_secure_results([map()]) :: [map()]\n  def filter_secure_results(search_results) do\n    tools = Enum.map(search_results, & &1.tool)\n    security_warnings = scan_tools(tools)\n\n    Enum.filter(search_results, fn result ->\n      not Map.has_key?(security_warnings, result.tool.name)\n    end)\n  end\n\n  @doc \"\"\"\n  Adds security warnings to search results.\n  \"\"\"\n  @spec add_security_warnings([map()]) :: [map()]\n  def add_security_warnings(search_results) do\n    tools = Enum.map(search_results, & &1.tool)\n    security_warnings = scan_tools(tools)\n\n    Enum.map(search_results, fn result ->\n      warnings = Map.get(security_warnings, result.tool.name, [])\n      Map.put(result, :security_warnings, warnings)\n    end)\n  end\n\n  @doc \"\"\"\n  Checks if a search result contains sensitive data.\n  \"\"\"\n  @spec has_sensitive_data?(map()) :: boolean()\n  def has_sensitive_data?(search_result) do\n    warnings = scan_tool(search_result.tool)\n    not Enum.empty?(warnings)\n  end\n\n  # Private functions\n\n  defp scan_text(text, field_name) do\n    # Use TruffleHog to find sensitive data matches\n    matches = TruffleHog.find_matches(text, :all, %{})\n\n    Enum.map(matches, fn match ->\n      %{\n        field: field_name,\n        type: match.type || \"unknown\",\n        value: String.slice(match.value || \"\", 0, 10) <> \"...\",\n        confidence: match.confidence || 0.8,\n        line: match.line || 1\n      }\n    end)\n  rescue\n    _ ->\n      # Fallback to basic pattern matching if TruffleHog fails\n      scan_text_basic(text, field_name)\n  end\n\n  defp scan_text_basic(text, field_name) do\n    # Basic patterns for common sensitive data\n    patterns = [\n      {~r/(?i)api[_-]?key[_-]?[:=]\\s*[\"\\']?([a-zA-Z0-9_-]{20,})[\"\\']?/, \"api_key\"},\n      {~r/(?i)password[_-]?[:=]\\s*[\"\\']?([^\\s\"']{8,})[\"\\']?/, \"password\"},\n      {~r/(?i)secret[_-]?[:=]\\s*[\"\\']?([a-zA-Z0-9_-]{20,})[\"\\']?/, \"secret\"},\n      {~r/(?i)token[_-]?[:=]\\s*[\"\\']?([a-zA-Z0-9_-]{20,})[\"\\']?/, \"token\"},\n      {~r/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/, \"email\"}\n    ]\n\n    Enum.flat_map(patterns, fn {pattern, type} ->\n      scan_pattern(pattern, text, type, field_name)\n    end)\n  end\n\n  defp scan_pattern(pattern, text, type, field_name) do\n    case Regex.scan(pattern, text, capture: :all_but_first) do\n      [] -> []\n      matches -> build_security_findings(matches, type, field_name)\n    end\n  end\n\n  defp build_security_findings(matches, type, field_name) do\n    Enum.map(matches, fn match ->\n      value = extract_match_value(match)\n\n      %{\n        field: field_name,\n        type: type,\n        # Truncate for security\n        value: String.slice(value, 0, 10) <> \"...\",\n        confidence: 0.8,\n        line: 1\n      }\n    end)\n  end\n\n  defp extract_match_value(match) do\n    case match do\n      [val] -> val\n      val when is_binary(val) -> val\n      _ -> \"unknown\"\n    end\n  end\nend\n",
      "line_count": 221,
      "word_count": 562,
      "title": "Security.Ex",
      "summary": "defmodule ExUtcp.Search.Security do @moduledoc \"\"\"",
      "key_terms": [
        "Filters",
        "Fallback",
        "exclude",
        "search",
        "headers",
        "pattern",
        "token",
        "Utcp",
        "unknown",
        "providers",
        "Jason",
        "using",
        "parameters",
        "if",
        "basic",
        "Scan",
        "scanning",
        "description",
        "function",
        "definitions"
      ],
      "timestamp": "2025-12-24T18:56:01.249414"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\search\\semantic.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Search.Semantic do\n  @moduledoc \"\"\"\n  Semantic search implementation for UTCP tools and providers.\n\n  Uses Haystack for full-text search and keyword extraction for intelligent tool discovery.\n  \"\"\"\n\n  alias ExUtcp.Types\n\n  @doc \"\"\"\n  Creates a Haystack index from tools for full-text search.\n  \"\"\"\n  @spec create_tools_index([Types.tool()]) :: Haystack.t()\n  def create_tools_index(tools) do\n    # Create Haystack index with tool documents\n    documents =\n      Enum.map(tools, fn tool ->\n        %{\n          id: tool.name,\n          title: tool.name,\n          content: tool.definition.description,\n          provider_name: tool.provider_name,\n          parameters: Jason.encode!(tool.definition.parameters || %{}),\n          response: Jason.encode!(tool.definition.response || %{})\n        }\n      end)\n\n    # Create Haystack index with documents\n    Haystack.new(documents)\n  end\n\n  @doc \"\"\"\n  Searches tools using Haystack full-text search and semantic matching.\n  \"\"\"\n  @spec search_tools(list(), String.t(), map()) :: list()\n  def search_tools(tools, query, opts) do\n    use_haystack = Map.get(opts, :use_haystack, true)\n\n    if use_haystack and length(tools) > 10 do\n      # Use Haystack for large tool sets\n      search_tools_with_haystack(tools, query, opts)\n    else\n      # Use keyword-based semantic search for smaller sets\n      search_tools_with_keywords(tools, query, opts)\n    end\n  end\n\n  @doc \"\"\"\n  Searches tools using Haystack full-text search.\n  \"\"\"\n  @spec search_tools_with_haystack([Types.tool()], String.t(), map()) :: list()\n  def search_tools_with_haystack(tools, query, opts) do\n    threshold = Map.get(opts, :threshold, 0.3)\n    limit = Map.get(opts, :limit, 20)\n\n    try do\n      # Create Haystack index\n      index = create_tools_index(tools)\n\n      # Perform search using Haystack.index/3\n      results = Haystack.index(index, query, limit)\n\n      results\n      |> Enum.take(limit)\n      |> Enum.map(fn result ->\n        # Find the original tool by ID\n        tool = Enum.find(tools, &(&1.name == result.id))\n\n        if tool and result.score >= threshold do\n          %{\n            tool: tool,\n            score: result.score,\n            match_type: :semantic,\n            matched_fields: [\"content\", \"title\"]\n          }\n        end\n      end)\n      |> Enum.reject(&is_nil/1)\n    rescue\n      _ ->\n        # Fallback to keyword-based search if Haystack fails\n        search_tools_with_keywords(tools, query, opts)\n    end\n  end\n\n  @doc \"\"\"\n  Searches tools using keyword-based semantic matching.\n  \"\"\"\n  @spec search_tools_with_keywords([Types.tool()], String.t(), map()) :: list()\n  def search_tools_with_keywords(tools, query, opts) do\n    threshold = Map.get(opts, :threshold, 0.3)\n    query_keywords = extract_keywords(query)\n\n    tools\n    |> Enum.map(fn tool ->\n      score = calculate_semantic_score(tool, query_keywords, opts)\n\n      if score >= threshold do\n        %{\n          tool: tool,\n          score: score,\n          match_type: :semantic,\n          matched_fields: get_semantic_matched_fields(tool, query_keywords)\n        }\n      end\n    end)\n    |> Enum.reject(&is_nil/1)\n    |> Enum.sort_by(& &1.score, :desc)\n  end\n\n  @doc \"\"\"\n  Searches providers using semantic matching.\n  \"\"\"\n  @spec search_providers(list(), String.t(), map()) :: list()\n  def search_providers(providers, query, opts) do\n    threshold = Map.get(opts, :threshold, 0.3)\n    query_keywords = extract_keywords(query)\n\n    providers\n    |> Enum.map(fn provider ->\n      score = calculate_provider_semantic_score(provider, query_keywords)\n\n      if score >= threshold do\n        %{\n          provider: provider,\n          score: score,\n          match_type: :semantic,\n          matched_fields: get_provider_semantic_matched_fields(provider, query_keywords)\n        }\n      end\n    end)\n    |> Enum.reject(&is_nil/1)\n    |> Enum.sort_by(& &1.score, :desc)\n  end\n\n  @doc \"\"\"\n  Finds similar tools based on semantic similarity.\n  \"\"\"\n  @spec find_similar_tools(Types.tool(), [Types.tool()], float()) :: list()\n  def find_similar_tools(reference_tool, candidate_tools, threshold \\\\ 0.3) do\n    reference_keywords = extract_keywords(reference_tool.definition.description)\n\n    candidate_tools\n    |> Enum.map(fn tool ->\n      score = calculate_tool_similarity(reference_tool, tool, reference_keywords)\n\n      if score >= threshold do\n        %{\n          tool: tool,\n          score: score,\n          match_type: :semantic,\n          matched_fields: [\"description\", \"name\"]\n        }\n      end\n    end)\n    |> Enum.reject(&is_nil/1)\n    |> Enum.sort_by(& &1.score, :desc)\n  end\n\n  @doc \"\"\"\n  Extracts keywords from text for semantic analysis.\n  \"\"\"\n  @spec extract_keywords(String.t()) :: [String.t()]\n  def extract_keywords(text) do\n    # Common stop words to filter out\n    stop_words =\n      MapSet.new([\n        \"a\",\n        \"an\",\n        \"and\",\n        \"are\",\n        \"as\",\n        \"at\",\n        \"be\",\n        \"by\",\n        \"for\",\n        \"from\",\n        \"has\",\n        \"he\",\n        \"in\",\n        \"is\",\n        \"it\",\n        \"its\",\n        \"of\",\n        \"on\",\n        \"that\",\n        \"the\",\n        \"to\",\n        \"was\",\n        \"will\",\n        \"with\",\n        \"or\",\n        \"but\",\n        \"not\",\n        \"this\",\n        \"can\",\n        \"have\",\n        \"do\",\n        \"does\",\n        \"get\",\n        \"set\",\n        \"use\",\n        \"using\",\n        \"used\"\n      ])\n\n    text\n    |> String.downcase()\n    |> String.replace(~r/[^\\w\\s]/, \" \")\n    |> String.split(~r/\\s+/, trim: true)\n    |> Enum.reject(fn word ->\n      String.length(word) < 3 || MapSet.member?(stop_words, word)\n    end)\n    |> Enum.uniq()\n  end\n\n  @doc \"\"\"\n  Calculates semantic similarity between two sets of keywords.\n  \"\"\"\n  @spec keyword_similarity([String.t()], [String.t()]) :: float()\n  def keyword_similarity(keywords1, keywords2) do\n    if Enum.empty?(keywords1) or Enum.empty?(keywords2) do\n      0.0\n    else\n      set1 = MapSet.new(keywords1)\n      set2 = MapSet.new(keywords2)\n\n      intersection_size = MapSet.intersection(set1, set2) |> MapSet.size()\n      union_size = MapSet.union(set1, set2) |> MapSet.size()\n\n      if union_size == 0 do\n        0.0\n      else\n        intersection_size / union_size\n      end\n    end\n  end\n\n  @doc \"\"\"\n  Calculates contextual similarity based on tool categories and domains.\n  \"\"\"\n  @spec contextual_similarity(Types.tool(), [String.t()]) :: float()\n  def contextual_similarity(tool, query_keywords) do\n    # Extract domain-specific keywords from tool definition\n    tool_context = extract_tool_context(tool)\n\n    # Calculate similarity with query context\n    keyword_similarity(tool_context, query_keywords)\n  end\n\n  # Private functions\n\n  defp calculate_semantic_score(tool, query_keywords, opts) do\n    # Extract keywords from tool name and description\n    name_keywords = extract_keywords(tool.name)\n\n    desc_keywords =\n      if Map.get(opts, :include_descriptions, true) do\n        extract_keywords(tool.definition.description)\n      else\n        []\n      end\n\n    # Calculate different types of similarity\n    contextual_sim = contextual_similarity(tool, query_keywords)\n\n    # Weighted combination\n    name_weight = 0.4\n    desc_weight = 0.4\n    context_weight = 0.2\n\n    name_sim = keyword_similarity(name_keywords, query_keywords)\n    desc_sim = keyword_similarity(desc_keywords, query_keywords)\n\n    name_sim * name_weight + desc_sim * desc_weight + contextual_sim * context_weight\n  end\n\n  defp calculate_provider_semantic_score(provider, query_keywords) do\n    # Extract keywords from provider name and type\n    name_keywords = extract_keywords(provider.name)\n    type_keywords = [Atom.to_string(provider.type)]\n\n    all_provider_keywords = name_keywords ++ type_keywords\n\n    keyword_similarity(all_provider_keywords, query_keywords)\n  end\n\n  defp calculate_tool_similarity(tool1, tool2, reference_keywords) do\n    tool2_keywords = extract_keywords(tool2.definition.description)\n\n    # Calculate similarity between descriptions\n    desc_similarity = keyword_similarity(reference_keywords, tool2_keywords)\n\n    # Calculate name similarity\n    name_similarity =\n      keyword_similarity(\n        extract_keywords(tool1.name),\n        extract_keywords(tool2.name)\n      )\n\n    # Weighted combination\n    desc_similarity * 0.7 + name_similarity * 0.3\n  end\n\n  defp get_semantic_matched_fields(tool, query_keywords) do\n    fields = []\n\n    name_keywords = extract_keywords(tool.name)\n    desc_keywords = extract_keywords(tool.definition.description)\n\n    fields =\n      if keyword_similarity(name_keywords, query_keywords) > 0.1 do\n        [\"name\" | fields]\n      else\n        fields\n      end\n\n    fields =\n      if keyword_similarity(desc_keywords, query_keywords) > 0.1 do\n        [\"description\" | fields]\n      else\n        fields\n      end\n\n    fields\n  end\n\n  defp get_provider_semantic_matched_fields(provider, query_keywords) do\n    fields = []\n\n    name_keywords = extract_keywords(provider.name)\n    type_keywords = [Atom.to_string(provider.type)]\n\n    fields =\n      if keyword_similarity(name_keywords, query_keywords) > 0.1 do\n        [\"name\" | fields]\n      else\n        fields\n      end\n\n    fields =\n      if keyword_similarity(type_keywords, query_keywords) > 0.1 do\n        [\"type\" | fields]\n      else\n        fields\n      end\n\n    fields\n  end\n\n  defp extract_tool_context(tool) do\n    # Extract contextual keywords from tool definition\n    context_keywords = []\n\n    # Add keywords from parameters\n    context_keywords =\n      if Map.has_key?(tool.definition, :parameters) do\n        param_keywords = extract_parameter_keywords(tool.definition.parameters)\n        context_keywords ++ param_keywords\n      else\n        context_keywords\n      end\n\n    # Add keywords from response schema\n    context_keywords =\n      if Map.has_key?(tool.definition, :response) do\n        response_keywords = extract_response_keywords(tool.definition.response)\n        context_keywords ++ response_keywords\n      else\n        context_keywords\n      end\n\n    context_keywords\n  end\n\n  defp extract_parameter_keywords(parameters) when is_map(parameters) do\n    # Extract keywords from parameter names and descriptions\n    parameters\n    |> Map.get(\"properties\", %{})\n    |> Enum.flat_map(fn {param_name, param_def} ->\n      name_keywords = extract_keywords(param_name)\n\n      desc_keywords =\n        case param_def do\n          %{\"description\" => desc} -> extract_keywords(desc)\n          _ -> []\n        end\n\n      name_keywords ++ desc_keywords\n    end)\n  end\n\n  defp extract_parameter_keywords(_), do: []\n\n  defp extract_response_keywords(response) when is_map(response) do\n    # Extract keywords from response schema\n    response\n    |> Map.get(\"properties\", %{})\n    |> Enum.flat_map(fn {field_name, field_def} ->\n      name_keywords = extract_keywords(field_name)\n\n      desc_keywords =\n        case field_def do\n          %{\"description\" => desc} -> extract_keywords(desc)\n          _ -> []\n        end\n\n      name_keywords ++ desc_keywords\n    end)\n  end\n\n  defp extract_response_keywords(_), do: []\nend\n",
      "line_count": 414,
      "word_count": 999,
      "title": "Semantic.Ex",
      "summary": "defmodule ExUtcp.Search.Semantic do @moduledoc \"\"\"",
      "key_terms": [
        "Fallback",
        "threshold",
        "search",
        "MapSet",
        "Calculate",
        "based",
        "list",
        "id",
        "index",
        "Utcp",
        "trim",
        "providers",
        "Jason",
        "reject",
        "has",
        "keyword",
        "original",
        "using",
        "Creates",
        "parameters"
      ],
      "timestamp": "2025-12-24T18:56:01.280940"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\behaviour.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Behaviour do\n  @moduledoc \"\"\"\n  Behaviour definition for UTCP transports.\n\n  All transport implementations must implement this behaviour to ensure\n  consistent interface across different communication protocols.\n  \"\"\"\n\n  alias ExUtcp.Types, as: T\n\n  @doc \"\"\"\n  Registers a tool provider and returns the discovered tools.\n  \"\"\"\n  @callback register_tool_provider(T.provider()) :: T.register_result()\n\n  @doc \"\"\"\n  Deregisters a tool provider.\n  \"\"\"\n  @callback deregister_tool_provider(T.provider()) :: T.deregister_result()\n\n  @doc \"\"\"\n  Calls a specific tool with the given arguments.\n  \"\"\"\n  @callback call_tool(String.t(), map(), T.provider()) :: T.call_result()\n\n  @doc \"\"\"\n  Calls a tool with streaming support.\n  \"\"\"\n  @callback call_tool_stream(String.t(), map(), T.provider()) :: T.stream_call_result()\n\n  @doc \"\"\"\n  Closes the transport and cleans up resources.\n  \"\"\"\n  @callback close() :: :ok | {:error, any()}\n\n  @doc \"\"\"\n  Gets the transport name.\n  \"\"\"\n  @callback transport_name() :: String.t()\n\n  @doc \"\"\"\n  Checks if the transport supports streaming.\n  \"\"\"\n  @callback supports_streaming?() :: boolean()\n\n  defmacro __using__(_opts) do\n    quote do\n      @behaviour ExUtcp.Transports.Behaviour\n    end\n  end\nend\n",
      "line_count": 52,
      "word_count": 140,
      "title": "Behaviour.Ex",
      "summary": "defmodule ExUtcp.Transports.Behaviour do @moduledoc \"\"\"",
      "key_terms": [
        "implementations",
        "ExUtcp",
        "transports",
        "close",
        "up",
        "any",
        "Types",
        "specific",
        "Closes",
        "implement",
        "error",
        "discovered",
        "end",
        "support",
        "Transports",
        "behaviour",
        "as",
        "with",
        "Utcp",
        "different"
      ],
      "timestamp": "2025-12-24T18:56:01.296976"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\cli.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Cli do\n  @moduledoc \"\"\"\n  CLI transport implementation for UTCP.\n\n  This transport handles command-line based tool providers, executing external\n  commands to discover and call tools.\n  \"\"\"\n\n  use ExUtcp.Transports.Behaviour\n\n  defstruct [\n    :logger\n  ]\n\n  @doc \"\"\"\n  Creates a new CLI transport.\n  \"\"\"\n  @spec new(keyword()) :: %__MODULE__{}\n  def new(opts \\\\ []) do\n    %__MODULE__{\n      logger: Keyword.get(opts, :logger, &IO.puts/1)\n    }\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def register_tool_provider(provider) do\n    case provider.type do\n      :cli -> discover_tools(provider)\n      _ -> {:error, \"CLI transport can only be used with CLI providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def deregister_tool_provider(_provider) do\n    :ok\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def call_tool(tool_name, args, provider) do\n    case provider.type do\n      :cli -> execute_tool_call(tool_name, args, provider)\n      _ -> {:error, \"CLI transport can only be used with CLI providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def call_tool_stream(_tool_name, _args, _provider) do\n    {:error, \"Streaming not supported by CLI transport\"}\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def close do\n    :ok\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def transport_name do\n    \"cli\"\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def supports_streaming? do\n    false\n  end\n\n  # Private functions\n\n  defp discover_tools(provider) do\n    with {:ok, output} <- execute_discovery_command(provider) do\n      parse_discovery_output(output, provider)\n    end\n  end\n\n  defp execute_tool_call(tool_name, args, provider) do\n    with {:ok, output} <- execute_tool_command(tool_name, args, provider) do\n      parse_tool_output(output)\n    end\n  end\n\n  defp execute_discovery_command(provider) do\n    command_parts = String.split(provider.command_name, \" \", trim: true)\n    [cmd_path | cmd_args] = command_parts\n\n    # Validate command path to prevent command injection\n    case validate_command_path(cmd_path) do\n      {:ok, validated_cmd} ->\n        env = prepare_environment(provider)\n        working_dir = provider.working_dir\n\n        cmd_opts = [\n          env: env,\n          stderr_to_stdout: true\n        ]\n\n        cmd_opts = if working_dir, do: [{:cd, working_dir} | cmd_opts], else: cmd_opts\n\n        case System.cmd(validated_cmd, cmd_args, cmd_opts) do\n          {output, 0} -> {:ok, output}\n          {output, exit_code} -> {:error, \"Command failed with exit code #{exit_code}: #{output}\"}\n        end\n\n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\n\n  defp execute_tool_command(tool_name, args, provider) do\n    command_parts = String.split(provider.command_name, \" \", trim: true)\n    [cmd_path | _] = command_parts\n\n    # Validate command path to prevent command injection\n    case validate_command_path(cmd_path) do\n      {:ok, validated_cmd} ->\n        # Build command args: call <provider> <tool> [--flags]\n        cmd_args = [\"call\", provider.name, tool_name] ++ format_arguments(args)\n\n        env = prepare_environment(provider)\n        working_dir = provider.working_dir\n\n        # Prepare JSON payload for stdin\n        input =\n          case Jason.encode(args) do\n            {:ok, json} -> json\n            {:error, _} -> \"\"\n          end\n\n        cmd_opts = [\n          env: env,\n          input: input,\n          stderr_to_stdout: true\n        ]\n\n        cmd_opts = if working_dir, do: [{:cd, working_dir} | cmd_opts], else: cmd_opts\n\n        case System.cmd(validated_cmd, cmd_args, cmd_opts) do\n          {output, 0} -> {:ok, output}\n          {output, exit_code} -> {:error, \"Command failed with exit code #{exit_code}: #{output}\"}\n        end\n\n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\n\n  defp validate_command_path(cmd_path) do\n    # Prevent command injection by validating the command path\n    cond do\n      # Check for shell metacharacters\n      Regex.match?(~r/[;&|`$()<>]/, cmd_path) ->\n        {:error, \"Invalid command path: contains shell metacharacters\"}\n\n      # Check for command chaining attempts\n      String.contains?(cmd_path, [\"&&\", \"||\", \";\", \"|\"]) ->\n        {:error, \"Invalid command path: contains command chaining\"}\n\n      # Only allow alphanumeric, dash, underscore, dot, and forward slash\n      not Regex.match?(~r/^[a-zA-Z0-9_\\-\\.\\/]+$/, cmd_path) ->\n        {:error, \"Invalid command path: contains unsafe characters\"}\n\n      # Prevent directory traversal in command path\n      String.contains?(cmd_path, \"..\") ->\n        {:error, \"Invalid command path: contains directory traversal\"}\n\n      # Command path should not be empty\n      String.trim(cmd_path) == \"\" ->\n        {:error, \"Invalid command path: empty path\"}\n\n      true ->\n        {:ok, cmd_path}\n    end\n  end\n\n  defp prepare_environment(provider) do\n    base_env = System.get_env()\n    Map.merge(base_env, provider.env_vars)\n  end\n\n  defp format_arguments(args) do\n    args\n    |> Enum.sort_by(fn {key, _} -> key end)\n    |> Enum.flat_map(fn {key, value} -> format_argument(key, value) end)\n  end\n\n  defp format_argument(key, value) do\n    case value do\n      true ->\n        [\"--#{key}\"]\n\n      false ->\n        []\n\n      values when is_list(values) ->\n        Enum.flat_map(values, fn v -> [\"--#{key}\", to_string(v)] end)\n\n      _ ->\n        [\"--#{key}\", to_string(value)]\n    end\n  end\n\n  defp parse_discovery_output(output, provider) do\n    output = String.trim(output)\n\n    # Remove surrounding quotes if present\n    output =\n      if String.starts_with?(output, \"'\") and String.ends_with?(output, \"'\") do\n        String.slice(output, 1..-2//1)\n      else\n        output\n      end\n\n    cond do\n      output == \"\" ->\n        {:ok, []}\n\n      String.starts_with?(output, \"{\") and String.ends_with?(output, \"}\") ->\n        parse_utcp_manual(output, provider)\n\n      true ->\n        parse_line_by_line(output, provider)\n    end\n  end\n\n  defp parse_tool_output(output) do\n    output = String.trim(output)\n\n    cond do\n      output == \"\" ->\n        {:ok, \"\"}\n\n      String.starts_with?(output, \"{\") and String.ends_with?(output, \"}\") ->\n        case Jason.decode(output) do\n          {:ok, data} -> {:ok, data}\n          {:error, _} -> {:ok, output}\n        end\n\n      true ->\n        {:ok, output}\n    end\n  end\n\n  defp parse_utcp_manual(output, provider) do\n    case Jason.decode(output) do\n      {:ok, data} ->\n        case data do\n          %{\"tools\" => tools} when is_list(tools) ->\n            normalized_tools = Enum.map(tools, &normalize_tool(&1, provider))\n            {:ok, normalized_tools}\n\n          %{\"name\" => _} ->\n            # Single tool\n            normalized_tool = normalize_tool(data, provider)\n            {:ok, [normalized_tool]}\n\n          _ ->\n            {:ok, []}\n        end\n\n      {:error, _reason} ->\n        {:ok, []}\n    end\n  end\n\n  defp parse_line_by_line(output, provider) do\n    tools =\n      output\n      |> String.split(\"\\n\")\n      |> Enum.filter(fn line ->\n        String.starts_with?(line, \"{\") && String.ends_with?(line, \"}\")\n      end)\n      |> Enum.flat_map(fn line ->\n        case Jason.decode(line) do\n          {:ok, data} -> [normalize_tool(data, provider)]\n          {:error, _} -> []\n        end\n      end)\n\n    {:ok, tools}\n  end\n\n  defp normalize_tool(tool_data, provider) do\n    ExUtcp.Tools.new_tool(\n      name: Map.get(tool_data, \"name\", \"\"),\n      description: Map.get(tool_data, \"description\", \"\"),\n      inputs: parse_schema(Map.get(tool_data, \"inputs\", %{})),\n      outputs: parse_schema(Map.get(tool_data, \"outputs\", %{})),\n      tags: Map.get(tool_data, \"tags\", []),\n      average_response_size: Map.get(tool_data, \"average_response_size\"),\n      provider: provider\n    )\n  end\n\n  defp parse_schema(schema_data) do\n    ExUtcp.Tools.new_schema(\n      type: Map.get(schema_data, \"type\", \"object\"),\n      properties: Map.get(schema_data, \"properties\", %{}),\n      required: Map.get(schema_data, \"required\", []),\n      description: Map.get(schema_data, \"description\", \"\"),\n      title: Map.get(schema_data, \"title\", \"\"),\n      items: Map.get(schema_data, \"items\", %{}),\n      enum: Map.get(schema_data, \"enum\", []),\n      minimum: Map.get(schema_data, \"minimum\"),\n      maximum: Map.get(schema_data, \"maximum\"),\n      format: Map.get(schema_data, \"format\", \"\")\n    )\n  end\nend\n",
      "line_count": 307,
      "word_count": 815,
      "title": "Cli.Ex",
      "summary": "defmodule ExUtcp.Transports.Cli do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "executing",
        "close",
        "output",
        "puts",
        "error",
        "IO",
        "based",
        "flags",
        "merge",
        "Prepare",
        "alphanumeric",
        "format",
        "Utcp",
        "trim",
        "only",
        "metacharacters",
        "providers",
        "logger",
        "Jason"
      ],
      "timestamp": "2025-12-24T18:56:01.315655"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\graphql.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Graphql do\n  @moduledoc \"\"\"\n  Production-ready GraphQL transport implementation for UTCP.\n\n  This transport handles GraphQL-based tool providers with:\n  - Real GraphQL queries, mutations, and subscriptions\n  - Connection management and pooling\n  - Authentication support (API Key, Basic, OAuth2)\n  - Error recovery with retry logic\n  - Real-time subscription support\n  - Schema introspection and validation\n  \"\"\"\n\n  use ExUtcp.Transports.Behaviour\n  use GenServer\n\n  alias ExUtcp.Transports.Graphql.{Connection, Pool, Schema}\n\n  require Logger\n\n  defstruct [\n    :logger,\n    :connection_timeout,\n    :pool_opts,\n    :retry_config,\n    :max_retries,\n    :retry_delay\n  ]\n\n  @doc \"\"\"\n  Creates a new GraphQL transport.\n  \"\"\"\n  @spec new(keyword()) :: %__MODULE__{}\n  def new(opts \\\\ []) do\n    %__MODULE__{\n      logger: Keyword.get(opts, :logger, &Logger.info/1),\n      connection_timeout: Keyword.get(opts, :connection_timeout, 30_000),\n      pool_opts: Keyword.get(opts, :pool_opts, []),\n      retry_config: %{\n        max_retries: Keyword.get(opts, :max_retries, 3),\n        retry_delay: Keyword.get(opts, :retry_delay, 1000),\n        backoff_multiplier: Keyword.get(opts, :backoff_multiplier, 2)\n      },\n      max_retries: Keyword.get(opts, :max_retries, 3),\n      retry_delay: Keyword.get(opts, :retry_delay, 1000)\n    }\n  end\n\n  @doc \"\"\"\n  Starts the GraphQL transport GenServer.\n  \"\"\"\n  @spec start_link(keyword()) :: {:ok, pid()} | {:error, term()}\n  def start_link(opts \\\\ []) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def register_tool_provider(provider) do\n    case provider.type do\n      :graphql ->\n        case GenServer.call(__MODULE__, {:register_tool_provider, provider}) do\n          {:ok, tools} -> {:ok, tools}\n          {:error, reason} -> {:error, reason}\n        end\n\n      _ ->\n        {:error, \"GraphQL transport can only be used with GraphQL providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def deregister_tool_provider(provider) do\n    case provider.type do\n      :graphql ->\n        GenServer.call(__MODULE__, {:deregister_tool_provider, provider})\n\n      _ ->\n        {:error, \"GraphQL transport can only be used with GraphQL providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def call_tool(tool_name, args, provider) do\n    case provider.type do\n      :graphql ->\n        case GenServer.call(__MODULE__, {:call_tool, tool_name, args, provider}) do\n          {:ok, result} -> {:ok, result}\n          {:error, reason} -> {:error, reason}\n        end\n\n      _ ->\n        {:error, \"GraphQL transport can only be used with GraphQL providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def call_tool_stream(tool_name, args, provider) do\n    case provider.type do\n      :graphql ->\n        case GenServer.call(__MODULE__, {:call_tool_stream, tool_name, args, provider}) do\n          {:ok, result} -> {:ok, result}\n          {:error, reason} -> {:error, reason}\n        end\n\n      _ ->\n        {:error, \"GraphQL transport can only be used with GraphQL providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def close do\n    GenServer.call(__MODULE__, :close)\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def transport_name do\n    \"graphql\"\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def supports_streaming? do\n    true\n  end\n\n  @doc \"\"\"\n  Executes a GraphQL query.\n  \"\"\"\n  @spec query(pid(), String.t(), map(), keyword()) :: {:ok, map()} | {:error, term()}\n  def query(provider, query_string, variables \\\\ %{}, opts \\\\ []) do\n    case GenServer.call(__MODULE__, {:query, provider, query_string, variables, opts}) do\n      {:ok, result} -> {:ok, result}\n      {:error, reason} -> {:error, reason}\n    end\n  end\n\n  @doc \"\"\"\n  Executes a GraphQL mutation.\n  \"\"\"\n  @spec mutation(pid(), String.t(), map(), keyword()) :: {:ok, map()} | {:error, term()}\n  def mutation(provider, mutation_string, variables \\\\ %{}, opts \\\\ []) do\n    case GenServer.call(__MODULE__, {:mutation, provider, mutation_string, variables, opts}) do\n      {:ok, result} -> {:ok, result}\n      {:error, reason} -> {:error, reason}\n    end\n  end\n\n  @doc \"\"\"\n  Executes a GraphQL subscription.\n  \"\"\"\n  @spec subscription(pid(), String.t(), map(), keyword()) :: {:ok, [map()]} | {:error, term()}\n  def subscription(provider, subscription_string, variables \\\\ %{}, opts \\\\ []) do\n    case GenServer.call(\n           __MODULE__,\n           {:subscription, provider, subscription_string, variables, opts}\n         ) do\n      {:ok, result} -> {:ok, result}\n      {:error, reason} -> {:error, reason}\n    end\n  end\n\n  @doc \"\"\"\n  Introspects the GraphQL schema.\n  \"\"\"\n  @spec introspect_schema(pid(), keyword()) :: {:ok, map()} | {:error, term()}\n  def introspect_schema(provider, opts \\\\ []) do\n    case GenServer.call(__MODULE__, {:introspect_schema, provider, opts}) do\n      {:ok, result} -> {:ok, result}\n      {:error, reason} -> {:error, reason}\n    end\n  end\n\n  # GenServer callbacks\n\n  @impl GenServer\n  def init(opts) do\n    state = new(opts)\n\n    # Start the connection pool\n    case Pool.start_link(state.pool_opts) do\n      {:ok, _pool_pid} ->\n        {:ok, state}\n\n      {:error, reason} ->\n        {:stop, reason}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:register_tool_provider, provider}, _from, state) do\n    case discover_tools(provider, state) do\n      {:ok, tools} -> {:reply, {:ok, tools}, state}\n      {:error, reason} -> {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:deregister_tool_provider, _provider}, _from, state) do\n    # For now, just return ok. In a real implementation, we might want to\n    # close the specific connection or clean up resources.\n    {:reply, :ok, state}\n  end\n\n  @impl GenServer\n  def handle_call({:call_tool, tool_name, args, provider}, _from, state) do\n    case execute_tool_call(tool_name, args, provider, state) do\n      {:ok, result} -> {:reply, {:ok, result}, state}\n      {:error, reason} -> {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:call_tool_stream, tool_name, args, provider}, _from, state) do\n    case execute_tool_stream(tool_name, args, provider, state) do\n      {:ok, result} -> {:reply, {:ok, result}, state}\n      {:error, reason} -> {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:query, provider, query_string, variables, opts}, _from, state) do\n    case get_connection_and_execute(\n           provider,\n           fn conn ->\n             Connection.query(conn, query_string, variables, opts)\n           end,\n           state\n         ) do\n      {:ok, result} -> {:reply, {:ok, result}, state}\n      {:error, reason} -> {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:mutation, provider, mutation_string, variables, opts}, _from, state) do\n    case get_connection_and_execute(\n           provider,\n           fn conn ->\n             Connection.mutation(conn, mutation_string, variables, opts)\n           end,\n           state\n         ) do\n      {:ok, result} -> {:reply, {:ok, result}, state}\n      {:error, reason} -> {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:subscription, provider, subscription_string, variables, opts}, _from, state) do\n    case get_connection_and_execute(\n           provider,\n           fn conn ->\n             Connection.subscription(conn, subscription_string, variables, opts)\n           end,\n           state\n         ) do\n      {:ok, result} -> {:reply, {:ok, result}, state}\n      {:error, reason} -> {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:introspect_schema, provider, opts}, _from, state) do\n    case get_connection_and_execute(\n           provider,\n           fn conn ->\n             Connection.introspect_schema(conn, opts)\n           end,\n           state\n         ) do\n      {:ok, result} -> {:reply, {:ok, result}, state}\n      {:error, reason} -> {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call(:close, _from, state) do\n    Pool.close_all_connections()\n    {:reply, :ok, state}\n  end\n\n  # Private functions\n\n  defp discover_tools(provider, state) do\n    with_retry(\n      fn ->\n        case Pool.get_connection(provider) do\n          {:ok, conn} ->\n            case Connection.introspect_schema(conn, timeout: state.connection_timeout) do\n              {:ok, schema} ->\n                tools = Schema.extract_tools(schema)\n                {:ok, tools}\n\n              {:error, reason} ->\n                {:error, \"Failed to discover tools: #{inspect(reason)}\"}\n            end\n\n          {:error, reason} ->\n            {:error, \"Failed to get connection: #{inspect(reason)}\"}\n        end\n      end,\n      state.retry_config\n    )\n  end\n\n  defp execute_tool_call(tool_name, args, provider, state) do\n    with_retry(\n      fn ->\n        case Pool.get_connection(provider) do\n          {:ok, conn} ->\n            # Convert tool call to GraphQL query\n            case build_graphql_operation(tool_name, args) do\n              {:query, query_string, variables} ->\n                case Connection.query(conn, query_string, variables, timeout: state.connection_timeout) do\n                  {:ok, result} -> {:ok, result}\n                  {:error, reason} -> {:error, \"Failed to execute query: #{inspect(reason)}\"}\n                end\n            end\n\n          {:error, reason} ->\n            {:error, \"Failed to get connection: #{inspect(reason)}\"}\n        end\n      end,\n      state.retry_config\n    )\n  end\n\n  defp execute_tool_stream(tool_name, args, provider, state) do\n    with_retry(\n      fn ->\n        case Pool.get_connection(provider) do\n          {:ok, conn} ->\n            # Convert tool stream to GraphQL subscription\n            case build_graphql_subscription(tool_name, args) do\n              {:subscription, subscription_string, variables} ->\n                case Connection.subscription(conn, subscription_string, variables, timeout: state.connection_timeout) do\n                  {:ok, results} ->\n                    # Create a proper streaming result with enhanced metadata\n                    stream = create_graphql_stream(results, tool_name, provider)\n\n                    {:ok,\n                     %{\n                       type: :stream,\n                       data: stream,\n                       metadata: %{\n                         \"transport\" => \"graphql\",\n                         \"tool\" => tool_name,\n                         \"subscription\" => true\n                       }\n                     }}\n\n                  {:error, reason} ->\n                    {:error, \"Failed to execute subscription: #{inspect(reason)}\"}\n                end\n            end\n\n          {:error, reason} ->\n            {:error, \"Failed to get connection: #{inspect(reason)}\"}\n        end\n      end,\n      state.retry_config\n    )\n  end\n\n  defp create_graphql_stream(results, tool_name, provider) do\n    Stream.with_index(results, 0)\n    |> Stream.map(fn {result, index} ->\n      %{\n        data: result,\n        metadata: %{\n          \"sequence\" => index,\n          \"timestamp\" => System.monotonic_time(:millisecond),\n          \"tool\" => tool_name,\n          \"provider\" => provider.name\n        },\n        timestamp: System.monotonic_time(:millisecond),\n        sequence: index\n      }\n    end)\n  end\n\n  defp get_connection_and_execute(provider, fun, state) do\n    with_retry(\n      fn ->\n        case Pool.get_connection(provider) do\n          {:ok, conn} ->\n            fun.(conn)\n\n          {:error, reason} ->\n            {:error, \"Failed to get connection: #{inspect(reason)}\"}\n        end\n      end,\n      state.retry_config\n    )\n  end\n\n  defp build_graphql_operation(tool_name, args) do\n    # Simple implementation - in a real system, this would be more sophisticated\n    # For now, we'll treat all tool calls as queries\n    # In a real implementation, this would determine operation type based on tool name or configuration\n    query_string = \"\"\"\n    query #{String.replace(tool_name, \".\", \"_\")}($input: JSON!) {\n      #{String.replace(tool_name, \".\", \"_\")}(input: $input) {\n        result\n        success\n        error\n      }\n    }\n    \"\"\"\n\n    variables = %{\"input\" => args}\n    {:query, query_string, variables}\n  end\n\n  defp build_graphql_subscription(tool_name, args) do\n    # Simple implementation - in a real system, this would be more sophisticated\n    subscription_string = \"\"\"\n    subscription #{String.replace(tool_name, \".\", \"_\")}($input: JSON!) {\n      #{String.replace(tool_name, \".\", \"_\")}(input: $input) {\n        data\n        timestamp\n      }\n    }\n    \"\"\"\n\n    variables = %{\"input\" => args}\n    {:subscription, subscription_string, variables}\n  end\n\n  defp with_retry(fun, retry_config, attempt \\\\ 0) do\n    case fun.() do\n      {:ok, result} ->\n        {:ok, result}\n\n      {:error, _reason} when attempt < retry_config.max_retries ->\n        delay = retry_config.retry_delay * :math.pow(retry_config.backoff_multiplier, attempt)\n        :timer.sleep(round(delay))\n        with_retry(fun, retry_config, attempt + 1)\n\n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\nend\n",
      "line_count": 444,
      "word_count": 1289,
      "title": "Graphql.Ex",
      "summary": "defmodule ExUtcp.Transports.Graphql do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "close",
        "we",
        "up",
        "timer",
        "error",
        "based",
        "info",
        "index",
        "Utcp",
        "only",
        "providers",
        "reply",
        "logger",
        "treat",
        "Error",
        "keyword",
        "Creates",
        "Executes",
        "enhanced"
      ],
      "timestamp": "2025-12-24T18:56:01.359323"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\grpc.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Grpc do\n  @moduledoc \"\"\"\n  Production-ready gRPC transport implementation for UTCP.\n\n  This transport handles gRPC-based tool providers with:\n  - Real gRPC connections using Protocol Buffers\n  - Connection pooling and lifecycle management\n  - Authentication support (API Key, Basic, OAuth2)\n  - Error recovery with retry logic\n  - gNMI integration for network management\n  - High-performance streaming capabilities\n  \"\"\"\n\n  use ExUtcp.Transports.Behaviour\n  use GenServer\n\n  alias ExUtcp.Transports.Grpc.Connection\n  alias ExUtcp.Transports.Grpc.Gnmi\n  alias ExUtcp.Transports.Grpc.Pool\n\n  require Logger\n\n  defstruct [\n    :logger,\n    :connection_timeout,\n    :pool_opts,\n    :retry_config,\n    :max_retries,\n    :retry_delay\n  ]\n\n  @doc \"\"\"\n  Creates a new gRPC transport.\n  \"\"\"\n  @spec new(keyword()) :: %__MODULE__{}\n  def new(opts \\\\ []) do\n    %__MODULE__{\n      logger: Keyword.get(opts, :logger, &Logger.info/1),\n      connection_timeout: Keyword.get(opts, :connection_timeout, 30_000),\n      pool_opts: Keyword.get(opts, :pool_opts, []),\n      retry_config: %{\n        max_retries: Keyword.get(opts, :max_retries, 3),\n        retry_delay: Keyword.get(opts, :retry_delay, 1000),\n        backoff_multiplier: Keyword.get(opts, :backoff_multiplier, 2)\n      },\n      max_retries: Keyword.get(opts, :max_retries, 3),\n      retry_delay: Keyword.get(opts, :retry_delay, 1000)\n    }\n  end\n\n  @doc \"\"\"\n  Starts the gRPC transport GenServer.\n  \"\"\"\n  @spec start_link(keyword()) :: {:ok, pid()} | {:error, term()}\n  def start_link(opts \\\\ []) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def register_tool_provider(provider) do\n    case provider.type do\n      :grpc ->\n        case GenServer.call(__MODULE__, {:register_tool_provider, provider}) do\n          {:ok, tools} -> {:ok, tools}\n          {:error, reason} -> {:error, reason}\n        end\n\n      _ ->\n        {:error, \"gRPC transport can only be used with gRPC providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def deregister_tool_provider(provider) do\n    case provider.type do\n      :grpc ->\n        GenServer.call(__MODULE__, {:deregister_tool_provider, provider})\n\n      _ ->\n        {:error, \"gRPC transport can only be used with gRPC providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def call_tool(tool_name, args, provider) do\n    case provider.type do\n      :grpc ->\n        case GenServer.call(__MODULE__, {:call_tool, tool_name, args, provider}) do\n          {:ok, result} -> {:ok, result}\n          {:error, reason} -> {:error, reason}\n        end\n\n      _ ->\n        {:error, \"gRPC transport can only be used with gRPC providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def call_tool_stream(tool_name, args, provider) do\n    case provider.type do\n      :grpc ->\n        case GenServer.call(__MODULE__, {:call_tool_stream, tool_name, args, provider}) do\n          {:ok, result} -> {:ok, result}\n          {:error, reason} -> {:error, reason}\n        end\n\n      _ ->\n        {:error, \"gRPC transport can only be used with gRPC providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def close do\n    GenServer.call(__MODULE__, :close)\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def transport_name do\n    \"grpc\"\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def supports_streaming? do\n    true\n  end\n\n  @doc \"\"\"\n  Performs a gNMI Get operation.\n  \"\"\"\n  @spec gnmi_get(pid(), [String.t()], keyword()) :: {:ok, map()} | {:error, term()}\n  def gnmi_get(provider, paths, opts \\\\ []) do\n    case GenServer.call(__MODULE__, {:gnmi_get, provider, paths, opts}) do\n      {:ok, result} -> {:ok, result}\n      {:error, reason} -> {:error, reason}\n    end\n  end\n\n  @doc \"\"\"\n  Performs a gNMI Set operation.\n  \"\"\"\n  @spec gnmi_set(pid(), [map()], keyword()) :: {:ok, map()} | {:error, term()}\n  def gnmi_set(provider, updates, opts \\\\ []) do\n    case GenServer.call(__MODULE__, {:gnmi_set, provider, updates, opts}) do\n      {:ok, result} -> {:ok, result}\n      {:error, reason} -> {:error, reason}\n    end\n  end\n\n  @doc \"\"\"\n  Performs a gNMI Subscribe operation.\n  \"\"\"\n  @spec gnmi_subscribe(pid(), [String.t()], keyword()) :: {:ok, [map()]} | {:error, term()}\n  def gnmi_subscribe(provider, paths, opts \\\\ []) do\n    case GenServer.call(__MODULE__, {:gnmi_subscribe, provider, paths, opts}) do\n      {:ok, result} -> {:ok, result}\n      {:error, reason} -> {:error, reason}\n    end\n  end\n\n  # GenServer callbacks\n\n  @impl GenServer\n  def init(opts) do\n    state = new(opts)\n\n    # Start the connection pool\n    case Pool.start_link(state.pool_opts) do\n      {:ok, _pool_pid} ->\n        {:ok, state}\n\n      {:error, reason} ->\n        {:stop, reason}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:register_tool_provider, provider}, _from, state) do\n    case discover_tools(provider, state) do\n      {:ok, tools} -> {:reply, {:ok, tools}, state}\n      {:error, reason} -> {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:deregister_tool_provider, _provider}, _from, state) do\n    # For now, just return ok. In a real implementation, we might want to\n    # close the specific connection or clean up resources.\n    {:reply, :ok, state}\n  end\n\n  @impl GenServer\n  def handle_call({:call_tool, tool_name, args, provider}, _from, state) do\n    case execute_tool_call(tool_name, args, provider, state) do\n      {:ok, result} -> {:reply, {:ok, result}, state}\n      {:error, reason} -> {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:call_tool_stream, tool_name, args, provider}, _from, state) do\n    case execute_tool_stream(tool_name, args, provider, state) do\n      {:ok, result} -> {:reply, {:ok, result}, state}\n      {:error, reason} -> {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:gnmi_get, provider, paths, opts}, _from, state) do\n    case get_connection_and_execute(\n           provider,\n           fn conn ->\n             Gnmi.get(conn, paths, opts)\n           end,\n           state\n         ) do\n      {:ok, result} -> {:reply, {:ok, result}, state}\n      {:error, reason} -> {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:gnmi_set, provider, updates, opts}, _from, state) do\n    case get_connection_and_execute(\n           provider,\n           fn conn ->\n             Gnmi.set(conn, updates, opts)\n           end,\n           state\n         ) do\n      {:ok, result} -> {:reply, {:ok, result}, state}\n      {:error, reason} -> {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:gnmi_subscribe, provider, paths, opts}, _from, state) do\n    case get_connection_and_execute(\n           provider,\n           fn conn ->\n             Gnmi.subscribe(conn, paths, opts)\n           end,\n           state\n         ) do\n      {:ok, result} -> {:reply, {:ok, result}, state}\n      {:error, reason} -> {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call(:close, _from, state) do\n    Pool.close_all_connections()\n    {:reply, :ok, state}\n  end\n\n  # Private functions\n\n  defp discover_tools(provider, state) do\n    with_retry(\n      fn ->\n        case Pool.get_connection(provider) do\n          {:ok, conn} ->\n            case Connection.get_manual(conn, state.connection_timeout) do\n              {:ok, tools} -> {:ok, tools}\n              {:error, reason} -> {:error, \"Failed to discover tools: #{inspect(reason)}\"}\n            end\n\n          {:error, reason} ->\n            {:error, \"Failed to get connection: #{inspect(reason)}\"}\n        end\n      end,\n      state.retry_config\n    )\n  end\n\n  defp execute_tool_call(tool_name, args, provider, state) do\n    with_retry(\n      fn ->\n        case Pool.get_connection(provider) do\n          {:ok, conn} ->\n            case Connection.call_tool(conn, tool_name, args, state.connection_timeout) do\n              {:ok, result} -> {:ok, result}\n              {:error, reason} -> {:error, \"Failed to call tool: #{inspect(reason)}\"}\n            end\n\n          {:error, reason} ->\n            {:error, \"Failed to get connection: #{inspect(reason)}\"}\n        end\n      end,\n      state.retry_config\n    )\n  end\n\n  defp execute_tool_stream(tool_name, args, provider, state) do\n    with_retry(\n      fn ->\n        case Pool.get_connection(provider) do\n          {:ok, conn} ->\n            case Connection.call_tool_stream(conn, tool_name, args, state.connection_timeout) do\n              {:ok, results} ->\n                # Enhance the stream with proper gRPC streaming metadata\n                enhanced_stream = create_grpc_stream(results, tool_name, provider)\n\n                {:ok,\n                 %{\n                   type: :stream,\n                   data: enhanced_stream,\n                   metadata: %{\"transport\" => \"grpc\", \"tool\" => tool_name, \"protocol\" => \"grpc\"}\n                 }}\n\n              {:error, reason} ->\n                {:error, \"Failed to call tool stream: #{inspect(reason)}\"}\n            end\n\n          {:error, reason} ->\n            {:error, \"Failed to get connection: #{inspect(reason)}\"}\n        end\n      end,\n      state.retry_config\n    )\n  end\n\n  defp create_grpc_stream(results, tool_name, provider) do\n    Stream.with_index(results, 0)\n    |> Stream.map(fn {result, index} ->\n      %{\n        data: result,\n        metadata: %{\n          \"sequence\" => index,\n          \"timestamp\" => System.monotonic_time(:millisecond),\n          \"tool\" => tool_name,\n          \"provider\" => provider.name,\n          \"protocol\" => \"grpc\",\n          \"service\" => provider.service_name\n        },\n        timestamp: System.monotonic_time(:millisecond),\n        sequence: index\n      }\n    end)\n  end\n\n  defp get_connection_and_execute(provider, fun, state) do\n    with_retry(\n      fn ->\n        case Pool.get_connection(provider) do\n          {:ok, conn} ->\n            fun.(conn)\n\n          {:error, reason} ->\n            {:error, \"Failed to get connection: #{inspect(reason)}\"}\n        end\n      end,\n      state.retry_config\n    )\n  end\n\n  defp with_retry(fun, retry_config, attempt \\\\ 0) do\n    case fun.() do\n      {:ok, result} ->\n        {:ok, result}\n\n      {:error, _reason} when attempt < retry_config.max_retries ->\n        delay = retry_config.retry_delay * :math.pow(retry_config.backoff_multiplier, attempt)\n        :timer.sleep(round(delay))\n        with_retry(fun, retry_config, attempt + 1)\n\n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\nend\n",
      "line_count": 371,
      "word_count": 1046,
      "title": "Grpc.Ex",
      "summary": "defmodule ExUtcp.Transports.Grpc do @moduledoc \"\"\"",
      "key_terms": [
        "integration",
        "reason",
        "close",
        "grpc",
        "we",
        "up",
        "paths",
        "timer",
        "error",
        "based",
        "info",
        "index",
        "Utcp",
        "only",
        "providers",
        "reply",
        "logger",
        "High",
        "subscribe",
        "Error"
      ],
      "timestamp": "2025-12-24T18:56:01.377201"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\http.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Http do\n  @moduledoc \"\"\"\n  HTTP transport implementation for UTCP.\n\n  This transport handles HTTP/HTTPS based tool providers, including REST APIs\n  and OpenAPI specification discovery.\n  \"\"\"\n\n  use ExUtcp.Transports.Behaviour\n\n  alias ExUtcp.Auth\n\n  defstruct [\n    :http_client,\n    :oauth_tokens,\n    :logger\n  ]\n\n  @doc \"\"\"\n  Creates a new HTTP transport.\n  \"\"\"\n  @spec new(keyword()) :: %__MODULE__{}\n  def new(opts \\\\ []) do\n    %__MODULE__{\n      http_client: Keyword.get(opts, :http_client, Req.new()),\n      oauth_tokens: %{},\n      logger: Keyword.get(opts, :logger, &IO.puts/1)\n    }\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def register_tool_provider(provider) do\n    case provider.type do\n      :http -> discover_tools(provider)\n      _ -> {:error, \"HTTP transport can only be used with HTTP providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def deregister_tool_provider(_provider) do\n    :ok\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def call_tool(tool_name, args, provider) do\n    case provider.type do\n      :http -> execute_tool_call(tool_name, args, provider)\n      _ -> {:error, \"HTTP transport can only be used with HTTP providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def call_tool_stream(tool_name, args, provider) do\n    case provider.type do\n      :http -> execute_tool_stream(tool_name, args, provider)\n      _ -> {:error, \"HTTP transport can only be used with HTTP providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def close do\n    :ok\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def transport_name do\n    \"http\"\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def supports_streaming? do\n    true\n  end\n\n  # Private functions\n\n  defp discover_tools(provider) do\n    with {:ok, response} <- make_request(provider, provider.http_method, provider.url, %{}) do\n      parse_discovery_response(response, provider)\n    end\n  end\n\n  defp execute_tool_call(_tool_name, args, provider) do\n    # Handle URL template substitution for path parameters\n    url_template = substitute_url_params(provider.url, args)\n    remaining_args = remove_url_params(args, provider.url)\n\n    with {:ok, response} <- make_tool_request(provider, url_template, remaining_args) do\n      parse_tool_response(response)\n    end\n  end\n\n  defp make_request(provider, method, url, body) do\n    headers = build_headers(provider)\n    headers = Auth.apply_to_headers(provider.auth, headers)\n\n    request_opts = [\n      method: String.downcase(method),\n      url: url,\n      headers: headers,\n      json: body,\n      receive_timeout: 30_000\n    ]\n\n    case Req.request(request_opts) do\n      {:ok, response} -> {:ok, response}\n      {:error, reason} -> {:error, reason}\n    end\n  end\n\n  defp make_tool_request(provider, url, args) do\n    headers = build_headers(provider)\n    headers = Auth.apply_to_headers(provider.auth, headers)\n\n    request_opts = [\n      method: String.downcase(provider.http_method),\n      url: url,\n      headers: headers,\n      json: args,\n      receive_timeout: 30_000\n    ]\n\n    case Req.request(request_opts) do\n      {:ok, response} -> {:ok, response}\n      {:error, reason} -> {:error, reason}\n    end\n  end\n\n  defp build_headers(provider) do\n    base_headers = %{\n      \"Content-Type\" => provider.content_type,\n      \"Accept\" => \"application/json\"\n    }\n\n    Map.merge(base_headers, provider.headers)\n  end\n\n  defp substitute_url_params(url, args) do\n    Enum.reduce(args, url, fn {key, value}, acc_url ->\n      placeholder = \"{#{key}}\"\n\n      if String.contains?(acc_url, placeholder) do\n        String.replace(acc_url, placeholder, to_string(value))\n      else\n        acc_url\n      end\n    end)\n  end\n\n  defp remove_url_params(args, url) do\n    url_params = extract_url_params(url)\n    Map.drop(args, url_params)\n  end\n\n  defp extract_url_params(url) do\n    Regex.scan(~r/\\{(\\w+)\\}/, url)\n    |> Enum.map(fn [_, param] -> param end)\n  end\n\n  defp parse_discovery_response(response, provider) do\n    case response.status do\n      status when status >= 200 and status < 300 ->\n        case Jason.decode(response.body) do\n          {:ok, data} -> parse_utcp_manual(data, provider)\n          {:error, reason} -> {:error, \"Failed to parse JSON response: #{reason}\"}\n        end\n\n      status ->\n        {:error, \"HTTP error: #{status}\"}\n    end\n  end\n\n  defp parse_tool_response(response) do\n    case response.status do\n      status when status >= 200 and status < 300 ->\n        case Jason.decode(response.body) do\n          {:ok, data} -> {:ok, data}\n          {:error, reason} -> {:error, \"Failed to parse JSON response: #{reason}\"}\n        end\n\n      status ->\n        {:error, \"HTTP error: #{status}\"}\n    end\n  end\n\n  defp parse_utcp_manual(data, provider) do\n    case data do\n      %{\"version\" => _} ->\n        # UTCP manual format\n        tools = Map.get(data, \"tools\", [])\n        {:ok, Enum.map(tools, &normalize_tool(&1, provider))}\n\n      _ ->\n        # Try OpenAPI conversion\n        case convert_openapi(data, provider) do\n          {:ok, tools} -> {:ok, tools}\n        end\n    end\n  end\n\n  defp convert_openapi(_data, _provider) do\n    # This would integrate with an OpenAPI converter\n    # For now, return empty tools\n    {:ok, []}\n  end\n\n  defp normalize_tool(tool_data, provider) do\n    ExUtcp.Tools.new_tool(\n      name: Map.get(tool_data, \"name\", \"\"),\n      description: Map.get(tool_data, \"description\", \"\"),\n      inputs: parse_schema(Map.get(tool_data, \"inputs\", %{})),\n      outputs: parse_schema(Map.get(tool_data, \"outputs\", %{})),\n      tags: Map.get(tool_data, \"tags\", []),\n      average_response_size: Map.get(tool_data, \"average_response_size\"),\n      provider: provider\n    )\n  end\n\n  defp execute_tool_stream(tool_name, args, provider) do\n    # Handle URL template substitution for path parameters\n    url_template = substitute_url_params(provider.url, args)\n    remaining_args = remove_url_params(args, provider.url)\n\n    case make_streaming_request(provider, url_template, remaining_args) do\n      {:ok, stream} ->\n        {:ok, %{type: :stream, data: stream, metadata: %{\"transport\" => \"http\", \"tool\" => tool_name}}}\n\n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\n\n  defp make_streaming_request(provider, url, args) do\n    headers = build_headers(provider)\n    headers = Auth.apply_to_headers(provider.auth, headers)\n    headers = Map.put(headers, \"Accept\", \"text/event-stream\")\n    headers = Map.put(headers, \"Cache-Control\", \"no-cache\")\n\n    request_opts = [\n      method: String.downcase(provider.http_method),\n      url: url,\n      headers: headers,\n      json: args,\n      receive_timeout: :infinity,\n      stream_to: self()\n    ]\n\n    case Req.request(request_opts) do\n      {:ok, response} ->\n        if response.status == 200 do\n          stream = create_sse_stream(response)\n          {:ok, stream}\n        else\n          {:error, \"HTTP #{response.status}: #{inspect(response.body)}\"}\n        end\n\n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\n\n  defp create_sse_stream(response) do\n    Stream.resource(\n      fn ->\n        # Initialize stream state\n        %{response: response, buffer: \"\", sequence: 0}\n      end,\n      fn state ->\n        case read_sse_chunk(state) do\n          {:ok, chunk, new_state} ->\n            {[chunk], new_state}\n\n          {:error, :end} ->\n            {:halt, state}\n\n          {:error, reason} ->\n            {[%{type: :error, error: reason, code: 500}], state}\n        end\n      end,\n      fn _state -> :ok end\n    )\n  end\n\n  defp read_sse_chunk(state) do\n    # For Req streaming, we receive messages via the process mailbox\n    # when using stream_to: self()\n    receive do\n      {:data, data} ->\n        buffer = state.buffer <> data\n        {chunks, remaining_buffer} = parse_sse_data(buffer)\n\n        new_state = %{state | buffer: remaining_buffer}\n\n        case chunks do\n          [] ->\n            read_sse_chunk(new_state)\n\n          [chunk | _rest] ->\n            processed_chunk = process_sse_chunk(chunk, state.sequence)\n            new_state = %{new_state | sequence: state.sequence + 1}\n            {:ok, processed_chunk, new_state}\n        end\n\n      {:done, _ref} ->\n        {:error, :end}\n\n      {:error, _ref, reason} ->\n        {:error, reason}\n    after\n      5_000 ->\n        {:error, :timeout}\n    end\n  end\n\n  defp parse_sse_data(buffer) do\n    lines = String.split(buffer, \"\\n\", trim: true)\n    {chunks, remaining} = parse_sse_lines(lines, [])\n    {chunks, remaining}\n  end\n\n  defp parse_sse_lines(lines, acc) do\n    case lines do\n      [] ->\n        {Enum.reverse(acc), \"\"}\n\n      [line | rest] ->\n        case parse_sse_line(line) do\n          {:ok, chunk} -> parse_sse_lines(rest, [chunk | acc])\n          :continue -> {Enum.reverse(acc), Enum.join([line | rest], \"\\n\")}\n        end\n    end\n  end\n\n  defp parse_sse_line(line) do\n    case String.trim(line) do\n      \"\" ->\n        :continue\n\n      \"data: [DONE]\" ->\n        {:ok, %{type: :end}}\n\n      \"data: \" <> data ->\n        case Jason.decode(data) do\n          {:ok, json_data} -> {:ok, %{type: :data, content: json_data}}\n          {:error, _} -> {:ok, %{type: :data, content: data}}\n        end\n\n      \"event: \" <> _event ->\n        :continue\n\n      \"id: \" <> _id ->\n        :continue\n\n      \"retry: \" <> _retry ->\n        :continue\n\n      _ ->\n        :continue\n    end\n  end\n\n  defp process_sse_chunk(chunk, sequence) do\n    case chunk do\n      %{type: :data, content: content} ->\n        %{\n          data: content,\n          metadata: %{\"sequence\" => sequence, \"timestamp\" => System.monotonic_time(:millisecond)},\n          timestamp: System.monotonic_time(:millisecond),\n          sequence: sequence\n        }\n\n      %{type: :end} ->\n        %{type: :end, metadata: %{\"sequence\" => sequence}}\n\n      other ->\n        other\n    end\n  end\n\n  defp parse_schema(schema_data) do\n    ExUtcp.Tools.new_schema(\n      type: Map.get(schema_data, \"type\", \"object\"),\n      properties: Map.get(schema_data, \"properties\", %{}),\n      required: Map.get(schema_data, \"required\", []),\n      description: Map.get(schema_data, \"description\", \"\"),\n      title: Map.get(schema_data, \"title\", \"\"),\n      items: Map.get(schema_data, \"items\", %{}),\n      enum: Map.get(schema_data, \"enum\", []),\n      minimum: Map.get(schema_data, \"minimum\"),\n      maximum: Map.get(schema_data, \"maximum\"),\n      format: Map.get(schema_data, \"format\", \"\")\n    )\n  end\nend\n",
      "line_count": 395,
      "word_count": 1009,
      "title": "Http.Ex",
      "summary": "defmodule ExUtcp.Transports.Http do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "close",
        "puts",
        "we",
        "error",
        "headers",
        "IO",
        "Type",
        "based",
        "id",
        "merge",
        "receive",
        "format",
        "Utcp",
        "trim",
        "only",
        "providers",
        "logger",
        "Jason",
        "other"
      ],
      "timestamp": "2025-12-24T18:56:01.416464"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\mcp.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Mcp do\n  @moduledoc \"\"\"\n  Production-ready MCP (Model Context Protocol) transport implementation for UTCP.\n\n  MCP is a protocol for connecting AI assistants to external data sources and tools.\n  This transport supports JSON-RPC 2.0 communication over HTTP/HTTPS with SSE support.\n  \"\"\"\n\n  use ExUtcp.Transports.Behaviour\n  use GenServer\n\n  alias ExUtcp.Transports.Mcp.Connection\n  alias ExUtcp.Transports.Mcp.Pool\n\n  require Logger\n\n  defstruct [\n    :logger,\n    :connection_timeout,\n    :pool_opts,\n    :retry_config,\n    :max_retries,\n    :retry_delay\n  ]\n\n  @doc \"\"\"\n  Creates a new MCP transport with the given options.\n  \"\"\"\n  @spec new(keyword()) :: %__MODULE__{}\n  def new(opts \\\\ []) do\n    %__MODULE__{\n      logger: Keyword.get(opts, :logger, &Logger.info/1),\n      connection_timeout: Keyword.get(opts, :connection_timeout, 30_000),\n      pool_opts: Keyword.get(opts, :pool_opts, []),\n      retry_config:\n        Keyword.get(opts, :retry_config, %{\n          max_retries: 3,\n          base_delay: 1000,\n          max_delay: 10_000,\n          backoff_multiplier: 2\n        }),\n      max_retries: Keyword.get(opts, :max_retries, 3),\n      retry_delay: Keyword.get(opts, :retry_delay, 1000)\n    }\n  end\n\n  @doc \"\"\"\n  Starts the MCP transport GenServer.\n  \"\"\"\n  @spec start_link(keyword()) :: GenServer.on_start()\n  def start_link(opts \\\\ []) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  @doc \"\"\"\n  Returns the transport name.\n  \"\"\"\n  @spec transport_name() :: String.t()\n  @impl true\n  def transport_name, do: \"mcp\"\n\n  @doc \"\"\"\n  Returns whether this transport supports streaming.\n  \"\"\"\n  @spec supports_streaming?() :: boolean()\n  @impl true\n  def supports_streaming?, do: true\n\n  @doc \"\"\"\n  Registers a tool provider with the MCP transport.\n  \"\"\"\n  @spec register_tool_provider(ExUtcp.Types.mcp_provider()) :: :ok | {:error, String.t()}\n  @impl true\n  def register_tool_provider(provider) do\n    case provider.type do\n      :mcp ->\n        case GenServer.call(__MODULE__, {:register_tool_provider, provider}) do\n          {:ok, tools} -> {:ok, tools}\n          {:error, reason} -> {:error, reason}\n        end\n\n      _ ->\n        {:error, \"MCP transport can only be used with MCP providers\"}\n    end\n  end\n\n  @doc \"\"\"\n  Deregisters a tool provider from the MCP transport.\n  \"\"\"\n  @spec deregister_tool_provider(ExUtcp.Types.mcp_provider()) :: :ok | {:error, String.t()}\n  @impl true\n  def deregister_tool_provider(provider) do\n    case provider.type do\n      :mcp ->\n        GenServer.call(__MODULE__, {:deregister_tool_provider, provider})\n\n      _ ->\n        {:error, \"MCP transport can only be used with MCP providers\"}\n    end\n  end\n\n  @doc \"\"\"\n  Calls a tool using the MCP transport.\n  \"\"\"\n  @spec call_tool(String.t(), map(), ExUtcp.Types.mcp_provider()) :: ExUtcp.Types.call_result()\n  @impl true\n  def call_tool(tool_name, args, provider) do\n    GenServer.call(__MODULE__, {:call_tool, tool_name, args, provider})\n  end\n\n  @doc \"\"\"\n  Calls a tool with streaming support using the MCP transport.\n  \"\"\"\n  @spec call_tool_stream(String.t(), map(), ExUtcp.Types.mcp_provider()) ::\n          ExUtcp.Types.call_result()\n  @impl true\n  def call_tool_stream(tool_name, args, provider) do\n    GenServer.call(__MODULE__, {:call_tool_stream, tool_name, args, provider})\n  end\n\n  @doc \"\"\"\n  Sends a JSON-RPC request to the MCP server.\n  \"\"\"\n  @spec send_request(String.t(), map(), ExUtcp.Types.mcp_provider()) :: ExUtcp.Types.call_result()\n  def send_request(method, params, provider) do\n    GenServer.call(__MODULE__, {:send_request, method, params, provider})\n  end\n\n  @doc \"\"\"\n  Sends a JSON-RPC notification to the MCP server.\n  \"\"\"\n  @spec send_notification(String.t(), map(), ExUtcp.Types.mcp_provider()) ::\n          :ok | {:error, String.t()}\n  def send_notification(method, params, provider) do\n    GenServer.call(__MODULE__, {:send_notification, method, params, provider})\n  end\n\n  @doc \"\"\"\n  Closes the MCP transport.\n  \"\"\"\n  @spec close() :: :ok\n  @impl true\n  def close do\n    GenServer.call(__MODULE__, :close)\n  end\n\n  # GenServer callbacks\n\n  @impl GenServer\n  def init(opts) do\n    state = new(opts)\n\n    case Pool.start_link(state.pool_opts) do\n      {:ok, _pool_pid} -> {:ok, state}\n      {:error, reason} -> {:stop, reason}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:register_tool_provider, provider}, _from, state) do\n    case validate_provider(provider) do\n      :ok ->\n        Logger.info(\"MCP transport registered provider: #{provider.name}\")\n        {:reply, :ok, state}\n\n      {:error, reason} ->\n        {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:deregister_tool_provider, _provider}, _from, state) do\n    Logger.info(\"MCP transport deregistered provider\")\n    {:reply, :ok, state}\n  end\n\n  @impl GenServer\n  def handle_call({:call_tool, tool_name, args, provider}, _from, state) do\n    result = execute_tool_call(tool_name, args, provider, state)\n    {:reply, result, state}\n  end\n\n  @impl GenServer\n  def handle_call({:call_tool_stream, tool_name, args, provider}, _from, state) do\n    result = execute_tool_stream(tool_name, args, provider, state)\n    {:reply, result, state}\n  end\n\n  @impl GenServer\n  def handle_call({:send_request, method, params, provider}, _from, state) do\n    result = execute_request(method, params, provider, state)\n    {:reply, result, state}\n  end\n\n  @impl GenServer\n  def handle_call({:send_notification, method, params, provider}, _from, state) do\n    result = execute_notification(method, params, provider, state)\n    {:reply, result, state}\n  end\n\n  @impl GenServer\n  def handle_call(:close, _from, state) do\n    Pool.close_all_connections()\n    {:reply, :ok, state}\n  end\n\n  # Private functions\n\n  defp validate_provider(provider) do\n    cond do\n      provider.type != :mcp ->\n        {:error, \"Invalid provider type for MCP transport\"}\n\n      is_nil(provider.url) or provider.url == \"\" ->\n        {:error, \"MCP provider URL is required\"}\n\n      true ->\n        :ok\n    end\n  end\n\n  defp execute_tool_call(tool_name, args, provider, state) do\n    with_retry(\n      fn ->\n        case Pool.get_connection(provider) do\n          {:ok, conn} ->\n            case Connection.call_tool(conn, tool_name, args, timeout: state.connection_timeout) do\n              {:ok, result} -> {:ok, result}\n              {:error, reason} -> {:error, \"Failed to call tool: #{inspect(reason)}\"}\n            end\n\n          {:error, reason} ->\n            {:error, \"Failed to get connection: #{inspect(reason)}\"}\n        end\n      end,\n      state.retry_config\n    )\n  end\n\n  defp execute_tool_stream(tool_name, args, provider, state) do\n    with_retry(\n      fn ->\n        case Pool.get_connection(provider) do\n          {:ok, conn} ->\n            case Connection.call_tool_stream(conn, tool_name, args, timeout: state.connection_timeout) do\n              {:ok, stream} ->\n                # Enhance the stream with proper MCP streaming metadata\n                enhanced_stream = create_mcp_stream(stream, tool_name, provider)\n\n                {:ok,\n                 %{\n                   type: :stream,\n                   data: enhanced_stream,\n                   metadata: %{\n                     \"transport\" => \"mcp\",\n                     \"tool\" => tool_name,\n                     \"protocol\" => \"json-rpc-2.0\"\n                   }\n                 }}\n\n              {:error, reason} ->\n                {:error, \"Failed to call tool stream: #{inspect(reason)}\"}\n            end\n\n          {:error, reason} ->\n            {:error, \"Failed to get connection: #{inspect(reason)}\"}\n        end\n      end,\n      state.retry_config\n    )\n  end\n\n  defp create_mcp_stream(stream, tool_name, provider) do\n    Stream.with_index(stream, 0)\n    |> Stream.map(fn {chunk, index} ->\n      case chunk do\n        %{type: :stream, data: data} ->\n          %{\n            data: data,\n            metadata: %{\n              \"sequence\" => index,\n              \"timestamp\" => System.monotonic_time(:millisecond),\n              \"tool\" => tool_name,\n              \"provider\" => provider.name,\n              \"protocol\" => \"json-rpc-2.0\"\n            },\n            timestamp: System.monotonic_time(:millisecond),\n            sequence: index\n          }\n\n        %{type: :error, error: error} ->\n          %{type: :error, error: error, code: 500, metadata: %{\"sequence\" => index}}\n\n        %{type: :end} ->\n          %{type: :end, metadata: %{\"sequence\" => index}}\n\n        other ->\n          %{\n            data: other,\n            metadata: %{\n              \"sequence\" => index,\n              \"timestamp\" => System.monotonic_time(:millisecond),\n              \"tool\" => tool_name,\n              \"provider\" => provider.name\n            },\n            timestamp: System.monotonic_time(:millisecond),\n            sequence: index\n          }\n      end\n    end)\n  end\n\n  defp execute_request(method, params, provider, state) do\n    with_retry(\n      fn ->\n        case Pool.get_connection(provider) do\n          {:ok, conn} ->\n            case Connection.send_request(conn, method, params, timeout: state.connection_timeout) do\n              {:ok, result} -> {:ok, result}\n              {:error, reason} -> {:error, \"Failed to send request: #{inspect(reason)}\"}\n            end\n\n          {:error, reason} ->\n            {:error, \"Failed to get connection: #{inspect(reason)}\"}\n        end\n      end,\n      state.retry_config\n    )\n  end\n\n  defp execute_notification(method, params, provider, state) do\n    with_retry(\n      fn ->\n        case Pool.get_connection(provider) do\n          {:ok, conn} ->\n            case Connection.send_notification(conn, method, params, timeout: state.connection_timeout) do\n              :ok -> :ok\n              {:error, reason} -> {:error, \"Failed to send notification: #{inspect(reason)}\"}\n            end\n\n          {:error, reason} ->\n            {:error, \"Failed to get connection: #{inspect(reason)}\"}\n        end\n      end,\n      state.retry_config\n    )\n  end\n\n  defp with_retry(fun, retry_config) do\n    max_retries = Map.get(retry_config, :max_retries, 3)\n    base_delay = Map.get(retry_config, :base_delay, 1000)\n    max_delay = Map.get(retry_config, :max_delay, 10_000)\n    backoff_multiplier = Map.get(retry_config, :backoff_multiplier, 2)\n\n    with_retry_impl(fun, 0, max_retries, base_delay, max_delay, backoff_multiplier)\n  end\n\n  defp with_retry_impl(fun, attempt, max_retries, _base_delay, _max_delay, _backoff_multiplier)\n       when attempt >= max_retries do\n    fun.()\n  end\n\n  defp with_retry_impl(fun, attempt, max_retries, base_delay, max_delay, backoff_multiplier) do\n    case fun.() do\n      {:ok, result} ->\n        {:ok, result}\n\n      {:error, _reason} when attempt < max_retries - 1 ->\n        delay = min(base_delay * :math.pow(backoff_multiplier, attempt), max_delay)\n        :timer.sleep(round(delay))\n        with_retry_impl(fun, attempt + 1, max_retries, base_delay, max_delay, backoff_multiplier)\n\n      result ->\n        result\n    end\n  end\nend\n",
      "line_count": 378,
      "word_count": 1040,
      "title": "Mcp.Ex",
      "summary": "defmodule ExUtcp.Transports.Mcp do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "close",
        "Model",
        "Closes",
        "timer",
        "error",
        "info",
        "index",
        "Utcp",
        "only",
        "rpc",
        "providers",
        "reply",
        "logger",
        "other",
        "AI",
        "sources",
        "keyword",
        "using",
        "Creates"
      ],
      "timestamp": "2025-12-24T18:56:01.440425"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\tcp_udp.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.TcpUdp do\n  @moduledoc \"\"\"\n  TCP/UDP Transport implementation for low-level network protocols.\n\n  This transport supports both TCP and UDP protocols for direct network communication.\n  It provides connection management, message serialization, and error handling.\n  \"\"\"\n\n  use GenServer\n  use ExUtcp.Transports.Behaviour\n\n  alias ExUtcp.Transports.TcpUdp.{Connection, Pool}\n\n  defstruct [\n    :connection_pool,\n    :retry_config,\n    :connection_timeout,\n    :providers\n  ]\n\n  def new(opts \\\\ []) do\n    retry_config =\n      Keyword.get(opts, :retry_config, %{max_retries: 3, retry_delay: 1000, backoff_multiplier: 2})\n\n    %__MODULE__{\n      connection_pool: nil,\n      retry_config: retry_config,\n      connection_timeout: Keyword.get(opts, :connection_timeout, 30_000),\n      providers: %{}\n    }\n  end\n\n  def start_link(opts \\\\ []) do\n    name = Keyword.get(opts, :name, __MODULE__)\n    GenServer.start_link(__MODULE__, opts, name: name)\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def transport_name, do: \"tcp_udp\"\n\n  @impl ExUtcp.Transports.Behaviour\n  def supports_streaming?, do: true\n\n  @impl ExUtcp.Transports.Behaviour\n  def register_tool_provider(provider) do\n    case provider.type do\n      :tcp -> register_tcp_provider(provider)\n      :udp -> register_udp_provider(provider)\n      _ -> {:error, \"TCP/UDP transport can only be used with TCP or UDP providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def deregister_tool_provider(provider) do\n    GenServer.call(__MODULE__, {:deregister_tool_provider, provider})\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def call_tool(tool_name, args, provider) do\n    GenServer.call(__MODULE__, {:call_tool, tool_name, args, provider})\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def call_tool_stream(tool_name, args, provider) do\n    GenServer.call(__MODULE__, {:call_tool_stream, tool_name, args, provider})\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def close do\n    GenServer.call(__MODULE__, :close)\n  end\n\n  # GenServer callbacks\n\n  @impl GenServer\n  def init(opts) do\n    connection_timeout = Keyword.get(opts, :connection_timeout, 30_000)\n    retry_config = %{max_retries: 3, retry_delay: 1000, backoff_multiplier: 2}\n\n    state = %__MODULE__{\n      connection_pool: nil,\n      retry_config: retry_config,\n      connection_timeout: connection_timeout,\n      providers: %{}\n    }\n\n    {:ok, state}\n  end\n\n  @impl GenServer\n  def handle_call({:register_tool_provider, provider}, _from, state) do\n    case provider.type do\n      :tcp ->\n        register_tcp_provider(provider, state)\n\n      :udp ->\n        register_udp_provider(provider, state)\n\n      _ ->\n        {:reply, {:error, \"TCP/UDP transport can only be used with TCP or UDP providers\"}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:deregister_tool_provider, provider}, _from, state) do\n    new_providers = Map.delete(state.providers, provider.name)\n    new_state = %{state | providers: new_providers}\n    {:reply, :ok, new_state}\n  end\n\n  @impl GenServer\n  def handle_call({:call_tool, tool_name, args, provider}, _from, state) do\n    result = execute_tool_call(tool_name, args, provider, state)\n    {:reply, result, state}\n  end\n\n  @impl GenServer\n  def handle_call({:call_tool_stream, tool_name, args, provider}, _from, state) do\n    result = execute_tool_stream(tool_name, args, provider, state)\n    {:reply, result, state}\n  end\n\n  @impl GenServer\n  def handle_call(:close, _from, state) do\n    if state.connection_pool do\n      Pool.close_all_connections(state.connection_pool)\n    end\n\n    {:reply, :ok, state}\n  end\n\n  # Private functions\n\n  defp register_tcp_provider(provider) do\n    GenServer.call(__MODULE__, {:register_tool_provider, provider})\n  end\n\n  defp register_udp_provider(provider) do\n    GenServer.call(__MODULE__, {:register_tool_provider, provider})\n  end\n\n  defp register_tcp_provider(provider, state) do\n    case validate_tcp_provider(provider) do\n      :ok ->\n        new_providers = Map.put(state.providers, provider.name, provider)\n        new_state = %{state | providers: new_providers}\n        {:reply, {:ok, []}, new_state}\n\n      {:error, reason} ->\n        {:reply, {:error, reason}, state}\n    end\n  end\n\n  defp register_udp_provider(provider, state) do\n    case validate_udp_provider(provider) do\n      :ok ->\n        new_providers = Map.put(state.providers, provider.name, provider)\n        new_state = %{state | providers: new_providers}\n        {:reply, {:ok, []}, new_state}\n\n      {:error, reason} ->\n        {:reply, {:error, reason}, state}\n    end\n  end\n\n  defp validate_tcp_provider(provider) do\n    required_fields = [:name, :host, :port, :protocol]\n\n    case Enum.find(required_fields, &(not Map.has_key?(provider, &1))) do\n      nil -> :ok\n      field -> {:error, \"TCP provider missing required field: :#{field}\"}\n    end\n  end\n\n  defp validate_udp_provider(provider) do\n    required_fields = [:name, :host, :port, :protocol]\n\n    case Enum.find(required_fields, &(not Map.has_key?(provider, &1))) do\n      nil -> :ok\n      field -> {:error, \"UDP provider missing required field: :#{field}\"}\n    end\n  end\n\n  defp execute_tool_call(tool_name, args, provider, state) do\n    with_retry(\n      fn ->\n        try do\n          case get_or_create_connection(provider, state) do\n            {:ok, conn} ->\n              case Connection.call_tool(conn, tool_name, args, state.connection_timeout) do\n                {:ok, result} -> {:ok, result}\n                {:error, reason} -> {:error, \"Failed to call tool: #{inspect(reason)}\"}\n              end\n\n            {:error, reason} ->\n              {:error, \"Failed to get connection: #{inspect(reason)}\"}\n          end\n        catch\n          :exit, reason -> {:error, \"Connection failed: #{inspect(reason)}\"}\n        end\n      end,\n      state.retry_config\n    )\n  end\n\n  defp execute_tool_stream(tool_name, args, provider, state) do\n    with_retry(\n      fn ->\n        try do\n          case get_or_create_connection(provider, state) do\n            {:ok, conn} ->\n              case Connection.call_tool_stream(conn, tool_name, args, state.connection_timeout) do\n                {:ok, stream} ->\n                  # Enhance the stream with proper TCP/UDP streaming metadata\n                  enhanced_stream = create_tcp_udp_stream(stream, tool_name, provider)\n\n                  {:ok,\n                   %{\n                     type: :stream,\n                     data: enhanced_stream,\n                     metadata: %{\n                       \"transport\" => \"tcp_udp\",\n                       \"tool\" => tool_name,\n                       \"protocol\" => provider.protocol\n                     }\n                   }}\n\n                {:error, reason} ->\n                  {:error, \"Failed to call tool stream: #{inspect(reason)}\"}\n              end\n\n            {:error, reason} ->\n              {:error, \"Failed to get connection: #{inspect(reason)}\"}\n          end\n        catch\n          :exit, reason -> {:error, \"Connection failed: #{inspect(reason)}\"}\n        end\n      end,\n      state.retry_config\n    )\n  end\n\n  defp create_tcp_udp_stream(stream, tool_name, provider) do\n    Stream.with_index(stream, 0)\n    |> Stream.map(fn {chunk, index} ->\n      case chunk do\n        %{type: :stream, data: data} ->\n          %{\n            data: data,\n            metadata: %{\n              \"sequence\" => index,\n              \"timestamp\" => System.monotonic_time(:millisecond),\n              \"tool\" => tool_name,\n              \"provider\" => provider.name,\n              \"protocol\" => provider.protocol\n            },\n            timestamp: System.monotonic_time(:millisecond),\n            sequence: index\n          }\n\n        %{type: :error, error: error} ->\n          %{type: :error, error: error, code: 500, metadata: %{\"sequence\" => index}}\n\n        %{type: :end} ->\n          %{type: :end, metadata: %{\"sequence\" => index}}\n\n        other ->\n          %{\n            data: other,\n            metadata: %{\n              \"sequence\" => index,\n              \"timestamp\" => System.monotonic_time(:millisecond),\n              \"tool\" => tool_name,\n              \"provider\" => provider.name,\n              \"protocol\" => provider.protocol\n            },\n            timestamp: System.monotonic_time(:millisecond),\n            sequence: index\n          }\n      end\n    end)\n  end\n\n  defp with_retry(fun, retry_config) do\n    max_retries = retry_config.max_retries\n    retry_delay = retry_config.retry_delay\n    backoff_multiplier = retry_config.backoff_multiplier\n\n    with_retry_impl(fun, 0, max_retries, retry_delay, backoff_multiplier)\n  end\n\n  defp with_retry_impl(_fun, current_retry, max_retries, _retry_delay, _backoff_multiplier)\n       when current_retry >= max_retries do\n    {:error, \"Max retries exceeded\"}\n  end\n\n  defp with_retry_impl(fun, current_retry, max_retries, retry_delay, backoff_multiplier) do\n    case fun.() do\n      {:ok, result} ->\n        {:ok, result}\n\n      {:error, _reason} when current_retry < max_retries ->\n        delay = (retry_delay * :math.pow(backoff_multiplier, current_retry)) |> round()\n        Process.sleep(delay)\n        with_retry_impl(fun, current_retry + 1, max_retries, retry_delay, backoff_multiplier)\n\n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\n\n  defp get_or_create_connection(provider, _state) do\n    # Use mocked connection in test mode, real connection otherwise\n    connection_module = Application.get_env(:ex_utcp, :tcp_udp_connection_behaviour, Connection)\n\n    case connection_module.start_link(provider) do\n      {:ok, conn_pid} -> {:ok, conn_pid}\n      {:error, reason} -> {:error, \"Failed to create connection: #{inspect(reason)}\"}\n    end\n  end\nend\n",
      "line_count": 322,
      "word_count": 844,
      "title": "Tcp Udp.Ex",
      "summary": "defmodule ExUtcp.Transports.TcpUdp do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "close",
        "error",
        "index",
        "mode",
        "Utcp",
        "only",
        "It",
        "providers",
        "reply",
        "other",
        "low",
        "if",
        "serialization",
        "otherwise",
        "Connection",
        "Pool",
        "exit",
        "streaming",
        "true"
      ],
      "timestamp": "2025-12-24T18:56:01.488166"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\webrtc.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.WebRTC do\n  @moduledoc \"\"\"\n  WebRTC transport for ExUtcp.\n\n  Provides peer-to-peer communication using WebRTC data channels.\n  Supports:\n  - Peer-to-peer tool calling without server intermediary\n  - Low-latency communication with NAT traversal\n  - Secure communication with DTLS encryption\n  - Multiple data channels for concurrent operations\n  - ICE candidate exchange and STUN/TURN server support\n  \"\"\"\n\n  use GenServer\n  use ExUtcp.Transports.Behaviour\n\n  alias ExUtcp.Transports.WebRTC.Connection\n\n  require Logger\n\n  @enforce_keys [:signaling_server, :ice_servers, :connection_timeout]\n  defstruct [\n    :signaling_server,\n    :ice_servers,\n    :connection_timeout,\n    :connections,\n    :providers\n  ]\n\n  @type t :: %__MODULE__{\n          signaling_server: String.t(),\n          ice_servers: [map()],\n          connection_timeout: integer(),\n          connections: %{String.t() => pid()},\n          providers: %{String.t() => map()}\n        }\n\n  @doc \"\"\"\n  Creates a new WebRTC transport.\n  \"\"\"\n  @spec new(keyword()) :: t()\n  def new(opts \\\\ []) do\n    %__MODULE__{\n      signaling_server: Keyword.get(opts, :signaling_server, \"wss://signaling.example.com\"),\n      ice_servers: Keyword.get(opts, :ice_servers, default_ice_servers()),\n      connection_timeout: Keyword.get(opts, :connection_timeout, 30_000),\n      connections: %{},\n      providers: %{}\n    }\n  end\n\n  @doc \"\"\"\n  Starts the WebRTC transport GenServer.\n  \"\"\"\n  @spec start_link(keyword()) :: {:ok, pid()} | {:error, term()}\n  def start_link(opts \\\\ []) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def transport_name, do: \"webrtc\"\n\n  @impl ExUtcp.Transports.Behaviour\n  def supports_streaming?, do: true\n\n  @impl ExUtcp.Transports.Behaviour\n  def register_tool_provider(provider) do\n    case provider.type do\n      :webrtc ->\n        GenServer.call(__MODULE__, {:register_tool_provider, provider})\n\n      _ ->\n        {:error, \"WebRTC transport can only be used with WebRTC providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def deregister_tool_provider(provider) do\n    case provider.type do\n      :webrtc ->\n        GenServer.call(__MODULE__, {:deregister_tool_provider, provider})\n\n      _ ->\n        {:error, \"WebRTC transport can only be used with WebRTC providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def call_tool(tool_name, args, provider) do\n    case provider.type do\n      :webrtc ->\n        GenServer.call(\n          __MODULE__,\n          {:call_tool, tool_name, args, provider},\n          provider.timeout || 30_000\n        )\n\n      _ ->\n        {:error, \"WebRTC transport can only be used with WebRTC providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def call_tool_stream(tool_name, args, provider) do\n    case provider.type do\n      :webrtc ->\n        GenServer.call(\n          __MODULE__,\n          {:call_tool_stream, tool_name, args, provider},\n          provider.timeout || 30_000\n        )\n\n      _ ->\n        {:error, \"WebRTC transport can only be used with WebRTC providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def close do\n    GenServer.call(__MODULE__, :close)\n  end\n\n  # GenServer callbacks\n\n  @impl GenServer\n  def init(opts) do\n    transport = new(opts)\n    {:ok, transport}\n  end\n\n  @impl GenServer\n  def handle_call({:register_tool_provider, provider}, _from, state) do\n    case discover_tools(provider) do\n      {:ok, tools} ->\n        new_state = %{state | providers: Map.put(state.providers, provider.name, provider)}\n        {:reply, {:ok, tools}, new_state}\n\n      {:error, reason} ->\n        {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:deregister_tool_provider, provider}, _from, state) do\n    # Close connection if exists\n    case Map.get(state.connections, provider.name) do\n      nil -> :ok\n      conn_pid -> Connection.close(conn_pid)\n    end\n\n    new_state = %{\n      state\n      | providers: Map.delete(state.providers, provider.name),\n        connections: Map.delete(state.connections, provider.name)\n    }\n\n    {:reply, :ok, new_state}\n  end\n\n  @impl GenServer\n  def handle_call({:call_tool, tool_name, args, provider}, _from, state) do\n    case get_or_create_connection(provider, state) do\n      {:ok, conn_pid, new_state} ->\n        case Connection.call_tool(conn_pid, tool_name, args, provider.timeout || 30_000) do\n          {:ok, result} ->\n            {:reply, {:ok, result}, new_state}\n\n          {:error, reason} ->\n            {:reply, {:error, \"Failed to call tool: #{inspect(reason)}\"}, new_state}\n        end\n\n      {:error, reason} ->\n        {:reply, {:error, \"Failed to get connection: #{inspect(reason)}\"}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:call_tool_stream, tool_name, args, provider}, _from, state) do\n    case get_or_create_connection(provider, state) do\n      {:ok, conn_pid, new_state} ->\n        case Connection.call_tool_stream(conn_pid, tool_name, args, provider.timeout || 30_000) do\n          {:ok, stream} ->\n            # Enhance the stream with WebRTC-specific metadata\n            enhanced_stream = create_webrtc_stream(stream, tool_name, provider)\n\n            {:reply,\n             {:ok,\n              %{\n                type: :stream,\n                data: enhanced_stream,\n                metadata: %{\"transport\" => \"webrtc\", \"tool\" => tool_name}\n              }}, new_state}\n\n          {:error, reason} ->\n            {:reply, {:error, \"Failed to call tool stream: #{inspect(reason)}\"}, new_state}\n        end\n\n      {:error, reason} ->\n        {:reply, {:error, \"Failed to get connection: #{inspect(reason)}\"}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call(:close, _from, state) do\n    # Close all connections\n    Enum.each(state.connections, fn {_name, conn_pid} ->\n      Connection.close(conn_pid)\n    end)\n\n    {:reply, :ok, %{state | connections: %{}}}\n  end\n\n  # Private functions\n\n  defp discover_tools(provider) do\n    # For WebRTC, tools would be discovered through the signaling server\n    # or provided in the provider configuration\n    case Map.get(provider, :tools) do\n      nil ->\n        {:ok, []}\n\n      tools when is_list(tools) ->\n        # Validate tools are properly formatted\n        if Enum.all?(tools, &is_map/1) do\n          {:ok, tools}\n        else\n          {:error, \"Invalid tool format: tools must be maps\"}\n        end\n\n      _ ->\n        {:error, \"Invalid tools configuration: must be a list\"}\n    end\n  end\n\n  defp get_or_create_connection(provider, state) do\n    case Map.get(state.connections, provider.name) do\n      nil ->\n        # Create new connection\n        case Connection.start_link(provider, state.signaling_server, state.ice_servers) do\n          {:ok, conn_pid} ->\n            new_connections = Map.put(state.connections, provider.name, conn_pid)\n            new_state = %{state | connections: new_connections}\n            {:ok, conn_pid, new_state}\n\n          {:error, reason} ->\n            {:error, reason}\n        end\n\n      conn_pid ->\n        # Reuse existing connection\n        if Process.alive?(conn_pid) do\n          {:ok, conn_pid, state}\n        else\n          # Connection died, create new one\n          case Connection.start_link(provider, state.signaling_server, state.ice_servers) do\n            {:ok, new_conn_pid} ->\n              new_connections = Map.put(state.connections, provider.name, new_conn_pid)\n              new_state = %{state | connections: new_connections}\n              {:ok, new_conn_pid, new_state}\n\n            {:error, reason} ->\n              {:error, reason}\n          end\n        end\n    end\n  end\n\n  defp create_webrtc_stream(stream, tool_name, provider) do\n    Stream.with_index(stream, 0)\n    |> Stream.map(fn {chunk, index} ->\n      case chunk do\n        %{type: :stream, data: data} ->\n          %{\n            type: :stream_chunk,\n            data: data,\n            metadata: %{\n              \"sequence\" => index,\n              \"tool\" => tool_name,\n              \"provider\" => provider.name,\n              \"transport\" => \"webrtc\",\n              \"timestamp\" => System.system_time(:millisecond)\n            }\n          }\n\n        %{type: :result, data: data} ->\n          %{\n            type: :stream_result,\n            data: data,\n            metadata: %{\n              \"tool\" => tool_name,\n              \"provider\" => provider.name,\n              \"transport\" => \"webrtc\",\n              \"timestamp\" => System.system_time(:millisecond)\n            }\n          }\n\n        %{type: :error, error: error} ->\n          %{\n            type: :stream_error,\n            error: error,\n            metadata: %{\n              \"tool\" => tool_name,\n              \"provider\" => provider.name,\n              \"transport\" => \"webrtc\",\n              \"timestamp\" => System.system_time(:millisecond)\n            }\n          }\n\n        _ ->\n          %{\n            type: :stream_chunk,\n            data: chunk,\n            metadata: %{\n              \"sequence\" => index,\n              \"tool\" => tool_name,\n              \"provider\" => provider.name,\n              \"transport\" => \"webrtc\",\n              \"timestamp\" => System.system_time(:millisecond)\n            }\n          }\n      end\n    end)\n  end\n\n  defp default_ice_servers do\n    [\n      %{\n        urls: [\"stun:stun.l.google.com:19302\"]\n      },\n      %{\n        urls: [\"stun:stun1.l.google.com:19302\"]\n      }\n    ]\n  end\nend\n",
      "line_count": 336,
      "word_count": 856,
      "title": "Webrtc.Ex",
      "summary": "defmodule ExUtcp.Transports.WebRTC do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "close",
        "DTLS",
        "each",
        "error",
        "through",
        "list",
        "index",
        "format",
        "Utcp",
        "only",
        "providers",
        "reply",
        "must",
        "keyword",
        "intermediary",
        "using",
        "Creates",
        "Provides",
        "if"
      ],
      "timestamp": "2025-12-24T18:56:01.521095"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\websocket.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.WebSocket do\n  @moduledoc \"\"\"\n  WebSocket transport implementation for UTCP.\n\n  This transport handles WebSocket-based tool providers, supporting real-time\n  bidirectional communication for tool discovery and execution.\n  \"\"\"\n\n  use ExUtcp.Transports.Behaviour\n  use GenServer\n\n  alias ExUtcp.Auth\n  alias ExUtcp.Transports.WebSocket.Connection\n\n  require Logger\n\n  defstruct [\n    :logger,\n    :connection_timeout,\n    :connection_pool,\n    :retry_config,\n    :max_retries,\n    :retry_delay\n  ]\n\n  @doc \"\"\"\n  Creates a new WebSocket transport.\n  \"\"\"\n  @spec new(keyword()) :: %__MODULE__{}\n  def new(opts \\\\ []) do\n    %__MODULE__{\n      logger: Keyword.get(opts, :logger, &Logger.info/1),\n      connection_timeout: Keyword.get(opts, :connection_timeout, 30_000),\n      connection_pool: %{},\n      retry_config: %{\n        max_retries: Keyword.get(opts, :max_retries, 3),\n        retry_delay: Keyword.get(opts, :retry_delay, 1000),\n        backoff_multiplier: Keyword.get(opts, :backoff_multiplier, 2)\n      },\n      max_retries: Keyword.get(opts, :max_retries, 3),\n      retry_delay: Keyword.get(opts, :retry_delay, 1000)\n    }\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def register_tool_provider(provider) do\n    case provider.type do\n      :websocket -> discover_tools(provider)\n      _ -> {:error, \"WebSocket transport can only be used with WebSocket providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def deregister_tool_provider(provider) do\n    case provider.type do\n      :websocket -> close_connection(provider)\n      _ -> {:error, \"WebSocket transport can only be used with WebSocket providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def call_tool(tool_name, args, provider) do\n    case provider.type do\n      :websocket -> execute_tool_call(tool_name, args, provider)\n      _ -> {:error, \"WebSocket transport can only be used with WebSocket providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def call_tool_stream(tool_name, args, provider) do\n    case provider.type do\n      :websocket -> execute_tool_stream(tool_name, args, provider)\n      _ -> {:error, \"WebSocket transport can only be used with WebSocket providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def close do\n    :ok\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def transport_name do\n    \"websocket\"\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def supports_streaming? do\n    true\n  end\n\n  # GenServer callbacks for connection management\n\n  def start_link(opts \\\\ []) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  @impl GenServer\n  def init(opts) do\n    state = new(opts)\n    {:ok, state}\n  end\n\n  @impl GenServer\n  def handle_call({:get_connection, provider}, _from, state) do\n    case get_or_create_connection(provider, state) do\n      {:ok, conn, new_state} -> {:reply, {:ok, conn}, new_state}\n      {:error, reason} -> {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:close_connection, provider}, _from, state) do\n    new_state = close_connection_for_provider(provider, state)\n    {:reply, :ok, new_state}\n  end\n\n  @impl GenServer\n  def handle_call(:close_all, _from, state) do\n    new_state = close_all_connections(state)\n    {:reply, :ok, new_state}\n  end\n\n  @impl GenServer\n  def handle_info({:websocket, _conn, {:text, data}}, state) do\n    # Handle incoming WebSocket messages\n    Logger.debug(\"Received WebSocket message: #{data}\")\n    {:noreply, state}\n  end\n\n  @impl GenServer\n  def handle_info({:websocket, conn, :close}, state) do\n    # Handle WebSocket connection close\n    Logger.info(\"WebSocket connection closed: #{inspect(conn)}\")\n    new_state = remove_connection_from_pool(conn, state)\n    {:noreply, new_state}\n  end\n\n  @impl GenServer\n  def handle_info({:websocket, _conn, {:error, reason}}, state) do\n    # Handle WebSocket errors\n    Logger.error(\"WebSocket error: #{inspect(reason)}\")\n    {:noreply, state}\n  end\n\n  # Private functions\n\n  defp discover_tools(provider) do\n    retry_config = %{max_retries: 3, retry_delay: 1000, backoff_multiplier: 2}\n\n    with_retry(\n      fn ->\n        with {:ok, conn} <- get_or_create_connection(provider),\n             {:ok, tools} <- request_manual(conn, provider) do\n          {:ok, tools}\n        else\n          {:error, reason} -> {:error, \"Failed to discover tools: #{inspect(reason)}\"}\n        end\n      end,\n      retry_config\n    )\n  end\n\n  defp execute_tool_call(tool_name, args, provider) do\n    retry_config = %{max_retries: 3, retry_delay: 1000, backoff_multiplier: 2}\n\n    with_retry(\n      fn ->\n        with {:ok, conn} <- get_or_create_connection(provider),\n             {:ok, result} <- send_tool_request(conn, tool_name, args, provider) do\n          {:ok, result}\n        else\n          {:error, reason} -> {:error, \"Failed to execute tool: #{inspect(reason)}\"}\n        end\n      end,\n      retry_config\n    )\n  end\n\n  defp execute_tool_stream(tool_name, args, provider) do\n    retry_config = %{max_retries: 3, retry_delay: 1000, backoff_multiplier: 2}\n\n    with_retry(\n      fn ->\n        with {:ok, conn} <- get_or_create_connection(provider),\n             {:ok, stream_result} <- send_tool_stream_request(conn, tool_name, args, provider) do\n          # Enhance the stream with proper WebSocket streaming metadata\n          enhanced_stream = create_websocket_stream(stream_result, tool_name, provider)\n\n          {:ok,\n           %{\n             type: :stream,\n             data: enhanced_stream,\n             metadata: %{\"transport\" => \"websocket\", \"tool\" => tool_name, \"protocol\" => \"ws\"}\n           }}\n        else\n          {:error, reason} -> {:error, \"Failed to execute tool stream: #{inspect(reason)}\"}\n        end\n      end,\n      retry_config\n    )\n  end\n\n  defp create_websocket_stream(stream, tool_name, provider) do\n    Stream.with_index(stream, 0)\n    |> Stream.map(fn {chunk, index} ->\n      case chunk do\n        %{\"type\" => \"stream_end\"} ->\n          %{type: :end, metadata: %{\"sequence\" => index, \"tool\" => tool_name}}\n\n        %{\"type\" => \"error\", \"message\" => error} ->\n          %{type: :error, error: error, code: 500, metadata: %{\"sequence\" => index}}\n\n        data ->\n          %{\n            data: data,\n            metadata: %{\n              \"sequence\" => index,\n              \"timestamp\" => System.monotonic_time(:millisecond),\n              \"tool\" => tool_name,\n              \"provider\" => provider.name,\n              \"protocol\" => \"ws\"\n            },\n            timestamp: System.monotonic_time(:millisecond),\n            sequence: index\n          }\n      end\n    end)\n  end\n\n  defp get_or_create_connection(provider) do\n    case GenServer.call(__MODULE__, {:get_connection, provider}) do\n      {:ok, conn} -> {:ok, conn}\n      {:error, reason} -> {:error, reason}\n    end\n  end\n\n  defp get_or_create_connection(provider, state) do\n    connection_key = build_connection_key(provider)\n\n    case Map.get(state.connection_pool, connection_key) do\n      nil ->\n        # Create new connection\n        case establish_connection(provider, state) do\n          {:ok, conn} ->\n            new_pool = Map.put(state.connection_pool, connection_key, conn)\n            new_state = %{state | connection_pool: new_pool}\n            {:ok, conn, new_state}\n\n          {:error, reason} ->\n            {:error, reason}\n        end\n\n      conn ->\n        # Use existing connection\n        {:ok, conn, state}\n    end\n  end\n\n  defp establish_connection(provider, state) do\n    headers = build_headers(provider)\n    headers = Auth.apply_to_headers(provider.auth, headers)\n\n    # Add WebSocket protocol if specified\n    headers =\n      if provider.protocol do\n        Map.put(headers, \"Sec-WebSocket-Protocol\", provider.protocol)\n      else\n        headers\n      end\n\n    # Convert headers to the format expected by websockex\n    # Use existing atoms only to prevent DOS attacks\n    ws_headers = Enum.map(headers, fn {k, v} -> {safe_string_to_atom(k), v} end)\n\n    opts = [\n      extra_headers: ws_headers,\n      timeout: state.connection_timeout,\n      transport_pid: self(),\n      ping_interval: 30_000\n    ]\n\n    case Connection.start_link(provider.url, provider, opts) do\n      {:ok, conn} -> {:ok, conn}\n      {:error, reason} -> {:error, \"Failed to connect to WebSocket: #{inspect(reason)}\"}\n    end\n  end\n\n  defp build_connection_key(provider) do\n    \"#{provider.url}:#{provider.name}\"\n  end\n\n  defp build_headers(provider) do\n    base_headers = %{\n      \"User-Agent\" => \"ExUtcp/0.2.0\",\n      \"Accept\" => \"application/json\"\n    }\n\n    Map.merge(base_headers, provider.headers)\n  end\n\n  defp request_manual(conn, provider) do\n    case Connection.send_message(conn, \"manual\") do\n      :ok ->\n        case Connection.get_next_message(conn, 5_000) do\n          {:ok, response} -> parse_manual_response(response, provider)\n          {:error, reason} -> {:error, reason}\n        end\n\n      {:error, reason} ->\n        {:error, \"Failed to send manual request: #{inspect(reason)}\"}\n    end\n  end\n\n  defp send_tool_request(conn, _tool_name, args, _provider) do\n    case Jason.encode(args) do\n      {:ok, json_data} ->\n        case Connection.send_message(conn, json_data) do\n          :ok ->\n            case Connection.get_next_message(conn, 30_000) do\n              {:ok, response} -> parse_tool_response(response)\n              {:error, reason} -> {:error, reason}\n            end\n\n          {:error, reason} ->\n            {:error, \"Failed to send tool request: #{inspect(reason)}\"}\n        end\n\n      {:error, reason} ->\n        {:error, \"Failed to encode arguments: #{inspect(reason)}\"}\n    end\n  end\n\n  defp send_tool_stream_request(conn, _tool_name, args, _provider) do\n    case Jason.encode(args) do\n      {:ok, json_data} ->\n        case Connection.send_message(conn, json_data) do\n          :ok ->\n            # For streaming, we collect all messages until connection closes\n            collect_stream_messages(conn, [])\n\n          {:error, reason} ->\n            {:error, \"Failed to send tool request: #{inspect(reason)}\"}\n        end\n\n      {:error, reason} ->\n        {:error, \"Failed to encode arguments: #{inspect(reason)}\"}\n    end\n  end\n\n  defp collect_stream_messages(conn, acc) do\n    # Get all available messages from the connection\n    messages = Connection.get_all_messages(conn)\n\n    case messages do\n      [] ->\n        # No messages available, wait a bit and try again\n        Process.sleep(100)\n        collect_stream_messages(conn, acc)\n\n      msgs ->\n        # Process all messages\n        decoded_messages =\n          Enum.map(msgs, fn msg ->\n            case Jason.decode(msg) do\n              {:ok, decoded} -> decoded\n              {:error, _} -> msg\n            end\n          end)\n\n        new_acc = Enum.reverse(decoded_messages, acc)\n\n        # Check if we should continue collecting or return\n        if length(msgs) < 10 do\n          # Few messages, might be done\n          {:ok, %{type: :stream, data: Enum.reverse(new_acc)}}\n        else\n          # More messages available, continue collecting\n          collect_stream_messages(conn, new_acc)\n        end\n    end\n  end\n\n  defp parse_manual_response(response, provider) do\n    case Jason.decode(response) do\n      {:ok, data} ->\n        case data do\n          %{\"tools\" => tools} when is_list(tools) ->\n            normalized_tools = Enum.map(tools, &normalize_tool(&1, provider))\n            {:ok, normalized_tools}\n\n          _ ->\n            {:ok, []}\n        end\n\n      {:error, reason} ->\n        {:error, \"Failed to parse manual response: #{inspect(reason)}\"}\n    end\n  end\n\n  defp parse_tool_response(response) do\n    case Jason.decode(response) do\n      {:ok, data} -> {:ok, data}\n      {:error, reason} -> {:error, \"Failed to parse tool response: #{inspect(reason)}\"}\n    end\n  end\n\n  defp normalize_tool(tool_data, provider) do\n    ExUtcp.Tools.new_tool(\n      name: Map.get(tool_data, \"name\", \"\"),\n      description: Map.get(tool_data, \"description\", \"\"),\n      inputs: parse_schema(Map.get(tool_data, \"inputs\", %{})),\n      outputs: parse_schema(Map.get(tool_data, \"outputs\", %{})),\n      tags: Map.get(tool_data, \"tags\", []),\n      average_response_size: Map.get(tool_data, \"average_response_size\"),\n      provider: provider\n    )\n  end\n\n  defp parse_schema(schema_data) do\n    ExUtcp.Tools.new_schema(\n      type: Map.get(schema_data, \"type\", \"object\"),\n      properties: Map.get(schema_data, \"properties\", %{}),\n      required: Map.get(schema_data, \"required\", []),\n      description: Map.get(schema_data, \"description\", \"\"),\n      title: Map.get(schema_data, \"title\", \"\"),\n      items: Map.get(schema_data, \"items\", %{}),\n      enum: Map.get(schema_data, \"enum\", []),\n      minimum: Map.get(schema_data, \"minimum\"),\n      maximum: Map.get(schema_data, \"maximum\"),\n      format: Map.get(schema_data, \"format\", \"\")\n    )\n  end\n\n  defp close_connection(provider) do\n    GenServer.call(__MODULE__, {:close_connection, provider})\n  end\n\n  defp close_connection_for_provider(provider, state) do\n    connection_key = build_connection_key(provider)\n\n    case Map.get(state.connection_pool, connection_key) do\n      nil ->\n        state\n\n      conn ->\n        Connection.close(conn)\n        new_pool = Map.delete(state.connection_pool, connection_key)\n        %{state | connection_pool: new_pool}\n    end\n  end\n\n  defp close_all_connections(state) do\n    Enum.each(state.connection_pool, fn {_key, conn} ->\n      Connection.close(conn)\n    end)\n\n    %{state | connection_pool: %{}}\n  end\n\n  defp remove_connection_from_pool(conn, state) do\n    # Find and remove the connection from the pool\n    new_pool =\n      Enum.reject(state.connection_pool, fn {_key, pool_conn} ->\n        pool_conn == conn\n      end)\n      |> Map.new()\n\n    %{state | connection_pool: new_pool}\n  end\n\n  # Retry logic with exponential backoff\n  defp with_retry(fun, retry_config) do\n    with_retry(fun, retry_config, 0)\n  end\n\n  defp with_retry(fun, retry_config, attempt) do\n    case fun.() do\n      {:ok, result} ->\n        {:ok, result}\n\n      {:error, _reason} when attempt < retry_config.max_retries ->\n        delay = retry_config.retry_delay * :math.pow(retry_config.backoff_multiplier, attempt)\n        :timer.sleep(round(delay))\n        with_retry(fun, retry_config, attempt + 1)\n\n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\n\n  # Safe conversion to atom - only converts if atom already exists\n  # Falls back to string if atom doesn't exist to prevent atom table exhaustion\n  defp safe_string_to_atom(string) do\n    String.to_existing_atom(string)\n  rescue\n    ArgumentError ->\n      # Try lowercase version\n      try do\n        String.to_existing_atom(String.downcase(string))\n      rescue\n        ArgumentError -> string\n      end\n  end\nend\n",
      "line_count": 506,
      "word_count": 1370,
      "title": "Websocket.Ex",
      "summary": "defmodule ExUtcp.Transports.WebSocket do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "close",
        "we",
        "timer",
        "bidirectional",
        "error",
        "headers",
        "exhaustion",
        "wait",
        "each",
        "based",
        "WebSocket",
        "merge",
        "index",
        "info",
        "format",
        "Utcp",
        "websocket",
        "available",
        "only"
      ],
      "timestamp": "2025-12-24T18:56:01.536004"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\graphql\\connection.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Graphql.Connection do\n  @moduledoc \"\"\"\n  Manages GraphQL connections with pooling and lifecycle management.\n  \"\"\"\n\n  @behaviour ExUtcp.Transports.Graphql.ConnectionBehaviour\n\n  use GenServer\n\n  require Logger\n\n  defstruct [\n    :provider,\n    :client,\n    :connection_state,\n    :last_used,\n    :retry_count,\n    :max_retries,\n    :subscription_handles\n  ]\n\n  @type t :: %__MODULE__{\n          provider: map(),\n          client: Req.Request.t(),\n          connection_state: :connecting | :connected | :disconnected | :error,\n          last_used: DateTime.t(),\n          retry_count: non_neg_integer(),\n          max_retries: non_neg_integer(),\n          subscription_handles: %{String.t() => pid()}\n        }\n\n  @doc \"\"\"\n  Starts a new GraphQL connection process.\n  \"\"\"\n  @spec start_link(map(), keyword()) :: {:ok, pid()} | {:error, term()}\n  @impl true\n  def start_link(provider, opts \\\\ []) do\n    GenServer.start_link(__MODULE__, {provider, opts})\n  end\n\n  @doc \"\"\"\n  Executes a GraphQL query.\n  \"\"\"\n  @spec query(pid(), String.t(), map(), keyword()) :: {:ok, map()} | {:error, term()}\n  @impl true\n  def query(pid, query_string, variables \\\\ %{}, opts \\\\ []) do\n    GenServer.call(pid, {:query, query_string, variables, opts})\n  end\n\n  @doc \"\"\"\n  Executes a GraphQL mutation.\n  \"\"\"\n  @spec mutation(pid(), String.t(), map(), keyword()) :: {:ok, map()} | {:error, term()}\n  @impl true\n  def mutation(pid, mutation_string, variables \\\\ %{}, opts \\\\ []) do\n    GenServer.call(pid, {:mutation, mutation_string, variables, opts})\n  end\n\n  @doc \"\"\"\n  Executes a GraphQL subscription.\n  \"\"\"\n  @spec subscription(pid(), String.t(), map(), keyword()) :: {:ok, [map()]} | {:error, term()}\n  @impl true\n  def subscription(pid, subscription_string, variables \\\\ %{}, opts \\\\ []) do\n    GenServer.call(pid, {:subscription, subscription_string, variables, opts})\n  end\n\n  @doc \"\"\"\n  Introspects the GraphQL schema.\n  \"\"\"\n  @spec introspect_schema(pid(), keyword()) :: {:ok, map()} | {:error, term()}\n  @impl true\n  def introspect_schema(pid, opts \\\\ []) do\n    GenServer.call(pid, {:introspect_schema, opts})\n  end\n\n  @doc \"\"\"\n  Closes the GraphQL connection.\n  \"\"\"\n  @spec close(pid()) :: :ok\n  @impl true\n  def close(pid) do\n    GenServer.stop(pid)\n  end\n\n  @doc \"\"\"\n  Checks if the connection is healthy.\n  \"\"\"\n  @spec healthy?(pid()) :: boolean()\n  def healthy?(pid) do\n    GenServer.call(pid, :healthy?)\n  end\n\n  @doc \"\"\"\n  Gets the last used timestamp.\n  \"\"\"\n  @spec get_last_used(pid()) :: integer()\n  @impl true\n  def get_last_used(pid) do\n    GenServer.call(pid, :get_last_used)\n  end\n\n  @doc \"\"\"\n  Updates the last used timestamp.\n  \"\"\"\n  @spec update_last_used(pid()) :: :ok\n  @impl true\n  def update_last_used(pid) do\n    GenServer.call(pid, :update_last_used)\n  end\n\n  # GenServer callbacks\n\n  @impl GenServer\n  def init({provider, opts}) do\n    max_retries = Keyword.get(opts, :max_retries, 3)\n\n    state = %__MODULE__{\n      provider: provider,\n      client: nil,\n      connection_state: :connecting,\n      last_used: DateTime.utc_now(),\n      retry_count: 0,\n      max_retries: max_retries,\n      subscription_handles: %{}\n    }\n\n    # Attempt initial connection\n    case establish_connection(state) do\n      {:ok, new_state} -> {:ok, new_state}\n      {:error, reason} -> {:stop, reason}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:query, query_string, variables, opts}, _from, state) do\n    case ensure_connected(state) do\n      {:ok, new_state} ->\n        case execute_graphql_operation(new_state, :query, query_string, variables, opts) do\n          {:ok, result} ->\n            {:reply, {:ok, result}, update_last_used(new_state)}\n\n          {:error, reason} ->\n            {:reply, {:error, reason}, state}\n        end\n\n      {:error, reason} ->\n        {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:mutation, mutation_string, variables, opts}, _from, state) do\n    case ensure_connected(state) do\n      {:ok, new_state} ->\n        case execute_graphql_operation(new_state, :mutation, mutation_string, variables, opts) do\n          {:ok, result} ->\n            {:reply, {:ok, result}, update_last_used(new_state)}\n\n          {:error, reason} ->\n            {:reply, {:error, reason}, state}\n        end\n\n      {:error, reason} ->\n        {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:subscription, subscription_string, variables, opts}, _from, state) do\n    case ensure_connected(state) do\n      {:ok, new_state} ->\n        case execute_graphql_subscription(new_state, subscription_string, variables, opts) do\n          {:ok, results} ->\n            {:reply, {:ok, results}, update_last_used(new_state)}\n\n          {:error, reason} ->\n            {:reply, {:error, reason}, state}\n        end\n\n      {:error, reason} ->\n        {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:introspect_schema, opts}, _from, state) do\n    case ensure_connected(state) do\n      {:ok, new_state} ->\n        case introspect_graphql_schema(new_state, opts) do\n          {:ok, schema} ->\n            {:reply, {:ok, schema}, update_last_used(new_state)}\n\n          {:error, reason} ->\n            {:reply, {:error, reason}, state}\n        end\n\n      {:error, reason} ->\n        {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call(:healthy?, _from, state) do\n    healthy = state.connection_state == :connected and state.client != nil\n    {:reply, healthy, state}\n  end\n\n  def handle_call(:get_last_used, _from, state) do\n    {:reply, state.last_used_at, state}\n  end\n\n  def handle_call(:update_last_used, _from, state) do\n    new_state = %{state | last_used_at: System.monotonic_time(:millisecond)}\n    {:reply, :ok, new_state}\n  end\n\n  @impl GenServer\n  def handle_info(:reconnect, state) do\n    case establish_connection(state) do\n      {:ok, new_state} -> {:noreply, new_state}\n      {:error, _reason} -> {:noreply, state}\n    end\n  end\n\n  @impl GenServer\n  def terminate(_reason, state) do\n    # Close any active subscriptions\n    Enum.each(state.subscription_handles, fn {_key, pid} ->\n      if Process.alive?(pid) do\n        Process.exit(pid, :normal)\n      end\n    end)\n  end\n\n  # Private functions\n\n  defp establish_connection(state) do\n    url = state.provider.url\n    headers = build_headers(state.provider)\n\n    client =\n      Req.new(\n        base_url: url,\n        headers: headers,\n        json: true,\n        retry: false\n      )\n\n    # Test the connection with a simple introspection query\n    test_query = \"\"\"\n    query IntrospectionQuery {\n      __schema {\n        queryType {\n          name\n        }\n      }\n    }\n    \"\"\"\n\n    case Req.post(client, json: %{query: test_query}) do\n      {:ok, %{status: 200, body: _body}} ->\n        new_state = %{state | client: client, connection_state: :connected, retry_count: 0}\n        Logger.info(\"GraphQL connection established to #{url}\")\n        {:ok, new_state}\n\n      {:ok, %{status: status, body: body}} ->\n        Logger.error(\"Failed to connect to GraphQL endpoint #{url}: HTTP #{status} - #{inspect(body)}\")\n\n        {:error, \"HTTP #{status}: #{inspect(body)}\"}\n\n      {:error, reason} ->\n        Logger.error(\"Failed to connect to GraphQL endpoint #{url}: #{inspect(reason)}\")\n        {:error, reason}\n    end\n  rescue\n    error ->\n      Logger.error(\"Exception during GraphQL connection: #{inspect(error)}\")\n      {:error, error}\n  end\n\n  defp ensure_connected(state) do\n    case state.connection_state do\n      :connected ->\n        {:ok, state}\n\n      _ ->\n        case establish_connection(state) do\n          {:ok, new_state} -> {:ok, new_state}\n          {:error, reason} -> {:error, reason}\n        end\n    end\n  end\n\n  defp execute_graphql_operation(state, operation_type, operation_string, variables, opts) do\n    timeout = Keyword.get(opts, :timeout, 30_000)\n\n    payload = %{\n      query: operation_string,\n      variables: variables,\n      operationName: nil\n    }\n\n    case Req.post(state.client, json: payload, receive_timeout: timeout) do\n      {:ok, %{status: 200, body: %{\"data\" => data, \"errors\" => nil}}} ->\n        {:ok, data}\n\n      {:ok, %{status: 200, body: %{\"data\" => data, \"errors\" => errors}}} ->\n        Logger.warning(\"GraphQL #{operation_type} returned errors: #{inspect(errors)}\")\n        {:ok, data}\n\n      {:ok, %{status: 200, body: %{\"errors\" => errors}}} ->\n        Logger.error(\"GraphQL #{operation_type} failed: #{inspect(errors)}\")\n        {:error, \"GraphQL errors: #{inspect(errors)}\"}\n\n      {:ok, %{status: status, body: body}} ->\n        Logger.error(\"GraphQL #{operation_type} failed with HTTP #{status}: #{inspect(body)}\")\n        {:error, \"HTTP #{status}: #{inspect(body)}\"}\n\n      {:error, reason} ->\n        Logger.error(\"GraphQL #{operation_type} request failed: #{inspect(reason)}\")\n        {:error, reason}\n    end\n  rescue\n    error ->\n      Logger.error(\"Exception during GraphQL #{operation_type}: #{inspect(error)}\")\n      {:error, error}\n  end\n\n  defp execute_graphql_subscription(state, subscription_string, variables, opts) do\n    # For now, simulate subscription with a single response\n    # In a real implementation, this would use WebSocket or Server-Sent Events\n    timeout = Keyword.get(opts, :timeout, 30_000)\n\n    payload = %{\n      query: subscription_string,\n      variables: variables,\n      operationName: nil\n    }\n\n    case Req.post(state.client, json: payload, receive_timeout: timeout) do\n      {:ok, %{status: 200, body: %{\"data\" => data, \"errors\" => nil}}} ->\n        # Simulate streaming by wrapping the data\n        results = [data]\n        {:ok, results}\n\n      {:ok, %{status: 200, body: %{\"data\" => data, \"errors\" => errors}}} ->\n        Logger.warning(\"GraphQL subscription returned errors: #{inspect(errors)}\")\n        results = [data]\n        {:ok, results}\n\n      {:ok, %{status: 200, body: %{\"errors\" => errors}}} ->\n        Logger.error(\"GraphQL subscription failed: #{inspect(errors)}\")\n        {:error, \"GraphQL errors: #{inspect(errors)}\"}\n\n      {:ok, %{status: status, body: body}} ->\n        Logger.error(\"GraphQL subscription failed with HTTP #{status}: #{inspect(body)}\")\n        {:error, \"HTTP #{status}: #{inspect(body)}\"}\n\n      {:error, reason} ->\n        Logger.error(\"GraphQL subscription request failed: #{inspect(reason)}\")\n        {:error, reason}\n    end\n  rescue\n    error ->\n      Logger.error(\"Exception during GraphQL subscription: #{inspect(error)}\")\n      {:error, error}\n  end\n\n  defp introspect_graphql_schema(state, opts) do\n    timeout = Keyword.get(opts, :timeout, 30_000)\n\n    introspection_query = \"\"\"\n    query IntrospectionQuery {\n      __schema {\n        queryType { name }\n        mutationType { name }\n        subscriptionType { name }\n        types {\n          ...FullType\n        }\n        directives {\n          name\n          description\n          locations\n          args {\n            ...InputValue\n          }\n        }\n      }\n    }\n\n    fragment FullType on __Type {\n      kind\n      name\n      description\n      fields(includeDeprecated: true) {\n        name\n        description\n        args {\n          ...InputValue\n        }\n        type {\n          ...TypeRef\n        }\n        isDeprecated\n        deprecationReason\n      }\n      inputFields {\n        ...InputValue\n      }\n      interfaces {\n        ...TypeRef\n      }\n      enumValues(includeDeprecated: true) {\n        name\n        description\n        isDeprecated\n        deprecationReason\n      }\n      possibleTypes {\n        ...TypeRef\n      }\n    }\n\n    fragment InputValue on __InputValue {\n      name\n      description\n      type { ...TypeRef }\n      defaultValue\n    }\n\n    fragment TypeRef on __Type {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                  ofType {\n                    kind\n                    name\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \"\"\"\n\n    payload = %{\n      query: introspection_query,\n      variables: %{},\n      operationName: \"IntrospectionQuery\"\n    }\n\n    case Req.post(state.client, json: payload, receive_timeout: timeout) do\n      {:ok, %{status: 200, body: %{\"data\" => data, \"errors\" => nil}}} ->\n        {:ok, data}\n\n      {:ok, %{status: 200, body: %{\"data\" => data, \"errors\" => errors}}} ->\n        Logger.warning(\"GraphQL introspection returned errors: #{inspect(errors)}\")\n        {:ok, data}\n\n      {:ok, %{status: 200, body: %{\"errors\" => errors}}} ->\n        Logger.error(\"GraphQL introspection failed: #{inspect(errors)}\")\n        {:error, \"GraphQL errors: #{inspect(errors)}\"}\n\n      {:ok, %{status: status, body: body}} ->\n        Logger.error(\"GraphQL introspection failed with HTTP #{status}: #{inspect(body)}\")\n        {:error, \"HTTP #{status}: #{inspect(body)}\"}\n\n      {:error, reason} ->\n        Logger.error(\"GraphQL introspection request failed: #{inspect(reason)}\")\n        {:error, reason}\n    end\n  rescue\n    error ->\n      Logger.error(\"Exception during GraphQL introspection: #{inspect(error)}\")\n      {:error, error}\n  end\n\n  defp build_headers(provider) do\n    base_headers = %{\n      \"Content-Type\" => \"application/json\",\n      \"Accept\" => \"application/json\",\n      \"User-Agent\" => \"ExUtcp/0.2.2\"\n    }\n\n    # Add custom headers\n    custom_headers = Map.get(provider, :headers, %{})\n    headers = Map.merge(base_headers, custom_headers)\n\n    # Add authentication if configured\n    case Map.get(provider, :auth) do\n      nil -> headers\n      auth -> add_auth_headers(headers, auth)\n    end\n  end\n\n  defp add_auth_headers(headers, auth) do\n    case auth.type do\n      :api_key ->\n        case auth.location do\n          \"header\" ->\n            Map.put(headers, \"Authorization\", \"Bearer #{auth.api_key}\")\n\n          \"query\" ->\n            # For query parameters, we'd need to modify the URL\n            headers\n        end\n\n      :basic ->\n        credentials = Base.encode64(\"#{auth.username}:#{auth.password}\")\n        Map.put(headers, \"Authorization\", \"Basic #{credentials}\")\n\n      :oauth2 ->\n        Map.put(headers, \"Authorization\", \"Bearer #{auth.access_token}\")\n\n      _ ->\n        headers\n    end\n  end\nend\n",
      "line_count": 541,
      "word_count": 1386,
      "title": "Connection.Ex",
      "summary": "defmodule ExUtcp.Transports.Graphql.Connection do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "close",
        "we",
        "fragment",
        "Closes",
        "each",
        "error",
        "headers",
        "Type",
        "WebSocket",
        "merge",
        "info",
        "Utcp",
        "during",
        "DateTime",
        "connect",
        "reply",
        "Test",
        "includeDeprecated",
        "application"
      ],
      "timestamp": "2025-12-24T18:56:01.567893"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\graphql\\connection_behaviour.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Graphql.ConnectionBehaviour do\n  @moduledoc \"\"\"\n  Behaviour for GraphQL connections to enable mocking in tests.\n  \"\"\"\n\n  @callback start_link(provider :: map()) :: {:ok, pid()} | {:error, term()}\n  @callback query(pid(), query :: String.t(), variables :: map(), opts :: keyword()) ::\n              {:ok, map()} | {:error, term()}\n  @callback mutation(pid(), mutation :: String.t(), variables :: map(), opts :: keyword()) ::\n              {:ok, map()} | {:error, term()}\n  @callback subscription(pid(), subscription :: String.t(), variables :: map(), opts :: keyword()) ::\n              {:ok, map()} | {:error, term()}\n  @callback introspect_schema(pid(), opts :: keyword()) ::\n              {:ok, map()} | {:error, term()}\n  @callback close(pid()) :: :ok | {:error, term()}\n  @callback get_last_used(pid()) :: integer()\n  @callback update_last_used(pid()) :: :ok\nend\n",
      "line_count": 19,
      "word_count": 103,
      "title": "Connection Behaviour.Ex",
      "summary": "defmodule ExUtcp.Transports.Graphql.ConnectionBehaviour do @moduledoc \"\"\"",
      "key_terms": [
        "ExUtcp",
        "close",
        "GraphQL",
        "variables",
        "error",
        "pid",
        "end",
        "Transports",
        "mocking",
        "Utcp",
        "map",
        "ok",
        "callback",
        "do",
        "for",
        "tests",
        "keyword",
        "integer",
        "String",
        "Graphql"
      ],
      "timestamp": "2025-12-24T18:56:01.599804"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\graphql\\mock_connection.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Graphql.MockConnection do\n  @moduledoc \"\"\"\n  Mock connection for testing GraphQL transport without real network calls.\n  \"\"\"\n\n  @doc \"\"\"\n  Executes a GraphQL query.\n  \"\"\"\n  @spec query(atom(), String.t(), map(), keyword()) :: {:ok, map()} | {:error, term()}\n  def query(_conn, _query_string, _variables \\\\ %{}, _opts \\\\ []) do\n    {:ok, %{\"result\" => \"Mock query result\"}}\n  end\n\n  @doc \"\"\"\n  Executes a GraphQL mutation.\n  \"\"\"\n  @spec mutation(atom(), String.t(), map(), keyword()) :: {:ok, map()} | {:error, term()}\n  def mutation(_conn, _mutation_string, _variables \\\\ %{}, _opts \\\\ []) do\n    {:ok, %{\"result\" => \"Mock mutation result\"}}\n  end\n\n  @doc \"\"\"\n  Executes a GraphQL subscription.\n  \"\"\"\n  @spec subscription(atom(), String.t(), map(), keyword()) :: {:ok, [map()]} | {:error, term()}\n  def subscription(_conn, _subscription_string, _variables \\\\ %{}, _opts \\\\ []) do\n    {:ok, [%{\"data\" => \"Mock subscription data\"}]}\n  end\n\n  @doc \"\"\"\n  Introspects the GraphQL schema.\n  \"\"\"\n  @spec introspect_schema(atom(), keyword()) :: {:ok, map()} | {:error, term()}\n  def introspect_schema(_conn, _opts \\\\ []) do\n    {:ok, %{\"__schema\" => %{\"queryType\" => %{\"name\" => \"Query\"}}}}\n  end\nend\n",
      "line_count": 38,
      "word_count": 153,
      "title": "Mock Connection.Ex",
      "summary": "defmodule ExUtcp.Transports.Graphql.MockConnection do @moduledoc \"\"\"",
      "key_terms": [
        "ExUtcp",
        "GraphQL",
        "schema",
        "MockConnection",
        "calls",
        "error",
        "def",
        "end",
        "Transports",
        "Utcp",
        "Introspects",
        "without",
        "map",
        "ok",
        "for",
        "do",
        "real",
        "spec",
        "keyword",
        "String"
      ],
      "timestamp": "2025-12-24T18:56:01.624138"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\graphql\\pool.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Graphql.Pool do\n  @moduledoc \"\"\"\n  Manages a pool of GraphQL connections with lifecycle management.\n  \"\"\"\n\n  use GenServer\n\n  alias ExUtcp.Transports.Graphql.Connection\n\n  require Logger\n\n  defstruct [\n    :connections,\n    :max_connections,\n    :connection_timeout,\n    :cleanup_interval,\n    :max_idle_time\n  ]\n\n  @type t :: %__MODULE__{\n          connections: %{String.t() => pid()},\n          max_connections: non_neg_integer(),\n          connection_timeout: timeout(),\n          cleanup_interval: timeout(),\n          max_idle_time: timeout()\n        }\n\n  @doc \"\"\"\n  Starts the connection pool.\n  \"\"\"\n  @spec start_link(keyword()) :: {:ok, pid()} | {:error, term()}\n  def start_link(opts \\\\ []) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  @doc \"\"\"\n  Gets or creates a connection for the given provider.\n  \"\"\"\n  @spec get_connection(map()) :: {:ok, pid()} | {:error, term()}\n  def get_connection(provider) do\n    GenServer.call(__MODULE__, {:get_connection, provider})\n  end\n\n  @doc \"\"\"\n  Returns a connection to the pool.\n  \"\"\"\n  @spec return_connection(pid()) :: :ok\n  def return_connection(pid) do\n    GenServer.cast(__MODULE__, {:return_connection, pid})\n  end\n\n  @doc \"\"\"\n  Closes a specific connection.\n  \"\"\"\n  @spec close_connection(pid()) :: :ok\n  def close_connection(pid) do\n    GenServer.cast(__MODULE__, {:close_connection, pid})\n  end\n\n  @doc \"\"\"\n  Closes all connections.\n  \"\"\"\n  @spec close_all_connections() :: :ok\n  def close_all_connections do\n    GenServer.cast(__MODULE__, :close_all_connections)\n  end\n\n  @doc \"\"\"\n  Gets pool statistics.\n  \"\"\"\n  @spec stats() :: map()\n  def stats do\n    GenServer.call(__MODULE__, :stats)\n  end\n\n  # GenServer callbacks\n\n  @impl GenServer\n  def init(opts) do\n    state = %__MODULE__{\n      connections: %{},\n      max_connections: Keyword.get(opts, :max_connections, 10),\n      connection_timeout: Keyword.get(opts, :connection_timeout, 30_000),\n      cleanup_interval: Keyword.get(opts, :cleanup_interval, 60_000),\n      # 5 minutes\n      max_idle_time: Keyword.get(opts, :max_idle_time, 300_000)\n    }\n\n    # Start cleanup timer\n    schedule_cleanup()\n\n    {:ok, state}\n  end\n\n  @impl GenServer\n  def handle_call({:get_connection, provider}, _from, state) do\n    connection_key = build_connection_key(provider)\n\n    case Map.get(state.connections, connection_key) do\n      nil ->\n        # Create new connection\n        case create_connection(provider, state) do\n          {:ok, pid} ->\n            new_connections = Map.put(state.connections, connection_key, pid)\n            new_state = %{state | connections: new_connections}\n            {:reply, {:ok, pid}, new_state}\n\n          {:error, reason} ->\n            {:reply, {:error, reason}, state}\n        end\n\n      pid ->\n        # Check if connection is still alive and healthy\n        if Process.alive?(pid) and Connection.healthy?(pid) do\n          {:reply, {:ok, pid}, state}\n        else\n          # Connection is dead, create a new one\n          new_connections = Map.delete(state.connections, connection_key)\n          new_state = %{state | connections: new_connections}\n\n          case create_connection(provider, new_state) do\n            {:ok, new_pid} ->\n              updated_connections = Map.put(new_connections, connection_key, new_pid)\n              {:reply, {:ok, new_pid}, %{new_state | connections: updated_connections}}\n\n            {:error, reason} ->\n              {:reply, {:error, reason}, new_state}\n          end\n        end\n    end\n  end\n\n  @impl GenServer\n  def handle_call(:stats, _from, state) do\n    stats = %{\n      total_connections: map_size(state.connections),\n      max_connections: state.max_connections,\n      connection_keys: Map.keys(state.connections)\n    }\n\n    {:reply, stats, state}\n  end\n\n  @impl GenServer\n  def handle_cast({:return_connection, _pid}, state) do\n    # Connection is returned to pool, no action needed\n    {:noreply, state}\n  end\n\n  @impl GenServer\n  def handle_cast({:close_connection, pid}, state) do\n    # Find and remove the connection\n    new_connections =\n      state.connections\n      |> Enum.reject(fn {_key, connection_pid} -> connection_pid == pid end)\n      |> Map.new()\n\n    # Close the connection\n    if Process.alive?(pid) do\n      Connection.close(pid)\n    end\n\n    {:noreply, %{state | connections: new_connections}}\n  end\n\n  @impl GenServer\n  def handle_cast(:close_all_connections, state) do\n    # Close all connections\n    Enum.each(state.connections, fn {_key, pid} ->\n      if Process.alive?(pid) do\n        Connection.close(pid)\n      end\n    end)\n\n    {:noreply, %{state | connections: %{}}}\n  end\n\n  @impl GenServer\n  def handle_info(:cleanup, state) do\n    # Clean up idle connections\n    now = DateTime.utc_now()\n    max_idle_time = state.max_idle_time\n\n    {active_connections, closed_count} =\n      state.connections\n      |> Enum.reduce({%{}, 0}, fn {key, pid}, {acc, closed} ->\n        if Process.alive?(pid) do\n          # Check if connection is idle\n          case get_connection_last_used(pid) do\n            {:ok, last_used} ->\n              idle_time = DateTime.diff(now, last_used, :millisecond)\n\n              if idle_time > max_idle_time do\n                Connection.close(pid)\n                {acc, closed + 1}\n              else\n                {Map.put(acc, key, pid), closed}\n              end\n\n            {:error, _} ->\n              # Connection is not responding, close it\n              Connection.close(pid)\n              {acc, closed + 1}\n          end\n        else\n          {acc, closed + 1}\n        end\n      end)\n\n    if closed_count > 0 do\n      Logger.info(\"Cleaned up #{closed_count} idle GraphQL connections\")\n    end\n\n    # Schedule next cleanup\n    schedule_cleanup()\n\n    {:noreply, %{state | connections: active_connections}}\n  end\n\n  # Private functions\n\n  defp create_connection(provider, state) do\n    if map_size(state.connections) >= state.max_connections do\n      {:error, \"Maximum number of connections reached\"}\n    else\n      opts = [\n        max_retries: 3,\n        connection_timeout: state.connection_timeout\n      ]\n\n      case Connection.start_link(provider, opts) do\n        {:ok, pid} -> {:ok, pid}\n        {:error, reason} -> {:error, reason}\n      end\n    end\n  end\n\n  defp build_connection_key(provider) do\n    url = Map.get(provider, :url, \"http://localhost:4000\")\n\n    auth_key =\n      case Map.get(provider, :auth) do\n        nil -> \"no_auth\"\n        auth -> \"#{auth.type}_#{auth.api_key || auth.username || auth.access_token}\"\n      end\n\n    \"#{url}:#{auth_key}\"\n  end\n\n  defp get_connection_last_used(pid) do\n    GenServer.call(pid, :last_used, 1000)\n  rescue\n    _ -> {:error, :timeout}\n  end\n\n  defp schedule_cleanup do\n    # 1 minute\n    Process.send_after(self(), :cleanup, 60_000)\n  end\nend\n",
      "line_count": 261,
      "word_count": 644,
      "title": "Pool.Ex",
      "summary": "defmodule ExUtcp.Transports.Graphql.Pool do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "dead",
        "close",
        "up",
        "Closes",
        "number",
        "timer",
        "error",
        "localhost",
        "cast",
        "each",
        "info",
        "cleanup",
        "Utcp",
        "DateTime",
        "reply",
        "reject",
        "minute",
        "keyword",
        "if"
      ],
      "timestamp": "2025-12-24T18:56:01.647413"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\graphql\\pool_behaviour.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Graphql.PoolBehaviour do\n  @moduledoc \"\"\"\n  Behaviour for GraphQL connection pools to enable mocking in tests.\n  \"\"\"\n\n  @callback get_connection(provider :: map()) :: {:ok, pid()} | {:error, term()}\n  @callback return_connection(pid()) :: :ok\n  @callback close_connection(pid()) :: :ok\n  @callback close_all_connections() :: :ok\n  @callback stats() :: map()\nend\n",
      "line_count": 12,
      "word_count": 43,
      "title": "Pool Behaviour.Ex",
      "summary": "defmodule ExUtcp.Transports.Graphql.PoolBehaviour do @moduledoc \"\"\"",
      "key_terms": [
        "ExUtcp",
        "GraphQL",
        "error",
        "pid",
        "end",
        "Transports",
        "PoolBehaviour",
        "mocking",
        "Utcp",
        "map",
        "ok",
        "callback",
        "do",
        "for",
        "tests",
        "pools",
        "Graphql",
        "moduledoc",
        "connection",
        "provider"
      ],
      "timestamp": "2025-12-24T18:56:01.662548"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\graphql\\schema.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Graphql.Schema do\n  @moduledoc \"\"\"\n  GraphQL schema introspection and tool extraction utilities.\n  \"\"\"\n\n  require Logger\n\n  @doc \"\"\"\n  Extracts tools from a GraphQL schema introspection result.\n  \"\"\"\n  @spec extract_tools(map()) :: [map()]\n  def extract_tools(schema) do\n    tools = []\n\n    # Extract query tools\n    query_tools = extract_operation_tools(schema, \"query\", \"Query\")\n    tools = tools ++ query_tools\n\n    # Extract mutation tools\n    mutation_tools = extract_operation_tools(schema, \"mutation\", \"Mutation\")\n    tools = tools ++ mutation_tools\n\n    # Extract subscription tools\n    subscription_tools = extract_operation_tools(schema, \"subscription\", \"Subscription\")\n    tools = tools ++ subscription_tools\n\n    tools\n  rescue\n    error ->\n      Logger.error(\"Failed to extract tools from GraphQL schema: #{inspect(error)}\")\n      []\n  end\n\n  @doc \"\"\"\n  Validates a GraphQL query string.\n  \"\"\"\n  @spec validate_query(String.t()) :: {:ok, String.t()} | {:error, term()}\n  def validate_query(query_string) do\n    # Basic validation - check for common GraphQL syntax\n    trimmed = String.trim(query_string)\n\n    cond do\n      String.length(trimmed) == 0 ->\n        {:error, \"Empty query\"}\n\n      not String.contains?(trimmed, [\"query\", \"mutation\", \"subscription\"]) ->\n        {:error, \"Query must contain query, mutation, or subscription\"}\n\n      not String.contains?(trimmed, \"{\") ->\n        {:error, \"Query must contain selection set\"}\n\n      true ->\n        {:ok, trimmed}\n    end\n  rescue\n    error ->\n      {:error, \"Query validation failed: #{inspect(error)}\"}\n  end\n\n  @doc \"\"\"\n  Builds a GraphQL query from tool name and arguments.\n  \"\"\"\n  @spec build_query(String.t(), map()) :: String.t()\n  def build_query(tool_name, args) do\n    operation_name = String.replace(tool_name, \".\", \"_\")\n    args_string = build_args_string(args)\n\n    \"\"\"\n    query #{operation_name}(#{args_string}) {\n      #{operation_name}(#{args_string}) {\n        result\n        success\n        error\n      }\n    }\n    \"\"\"\n  end\n\n  @doc \"\"\"\n  Builds a GraphQL mutation from tool name and arguments.\n  \"\"\"\n  @spec build_mutation(String.t(), map()) :: String.t()\n  def build_mutation(tool_name, args) do\n    operation_name = String.replace(tool_name, \".\", \"_\")\n    args_string = build_args_string(args)\n\n    \"\"\"\n    mutation #{operation_name}(#{args_string}) {\n      #{operation_name}(#{args_string}) {\n        result\n        success\n        error\n      }\n    }\n    \"\"\"\n  end\n\n  @doc \"\"\"\n  Builds a GraphQL subscription from tool name and arguments.\n  \"\"\"\n  @spec build_subscription(String.t(), map()) :: String.t()\n  def build_subscription(tool_name, args) do\n    operation_name = String.replace(tool_name, \".\", \"_\")\n    args_string = build_args_string(args)\n\n    \"\"\"\n    subscription #{operation_name}(#{args_string}) {\n      #{operation_name}(#{args_string}) {\n        data\n        timestamp\n      }\n    }\n    \"\"\"\n  end\n\n  @doc \"\"\"\n  Parses GraphQL response and extracts tool results.\n  \"\"\"\n  @spec parse_response(map()) :: {:ok, map()} | {:error, term()}\n  def parse_response(response) do\n    case response do\n      %{\"data\" => data, \"errors\" => nil} ->\n        {:ok, data}\n\n      %{\"data\" => data, \"errors\" => errors} ->\n        Logger.warning(\"GraphQL response contains errors: #{inspect(errors)}\")\n        {:ok, data}\n\n      %{\"errors\" => errors} ->\n        {:error, \"GraphQL errors: #{inspect(errors)}\"}\n\n      _ ->\n        {:error, \"Invalid GraphQL response format\"}\n    end\n  rescue\n    error ->\n      {:error, \"Failed to parse GraphQL response: #{inspect(error)}\"}\n  end\n\n  # Private functions\n\n  defp extract_operation_tools(schema, operation_type, type_name) do\n    case get_in(schema, [\"__schema\", \"#{operation_type}Type\"]) do\n      nil ->\n        []\n\n      %{\"name\" => ^type_name} ->\n        # Find the type definition\n        types = get_in(schema, [\"__schema\", \"types\"]) || []\n\n        type_def =\n          Enum.find(types, fn type ->\n            get_in(type, [\"name\"]) == type_name\n          end)\n\n        case type_def do\n          nil ->\n            []\n\n          type ->\n            fields = get_in(type, [\"fields\"]) || []\n\n            Enum.map(fields, fn field ->\n              build_tool_from_field(field, operation_type)\n            end)\n        end\n\n      _ ->\n        []\n    end\n  rescue\n    error ->\n      Logger.error(\"Failed to extract #{operation_type} tools: #{inspect(error)}\")\n      []\n  end\n\n  defp build_tool_from_field(field, operation_type) do\n    name = get_in(field, [\"name\"]) || \"unknown\"\n    description = get_in(field, [\"description\"]) || \"No description available\"\n\n    # Extract arguments\n    args = get_in(field, [\"args\"]) || []\n    input_schema = build_input_schema(args)\n\n    # Build outputs schema (simplified)\n    output_schema = %{\n      \"type\" => \"object\",\n      \"properties\" => %{\n        \"result\" => %{\"type\" => \"any\"},\n        \"success\" => %{\"type\" => \"boolean\"},\n        \"error\" => %{\"type\" => \"string\"}\n      }\n    }\n\n    %{\n      \"name\" => name,\n      \"description\" => description,\n      \"inputs\" => input_schema,\n      \"outputs\" => output_schema,\n      \"tags\" => [\"graphql\", operation_type],\n      \"operation_type\" => operation_type\n    }\n  end\n\n  defp build_input_schema(args) do\n    properties =\n      Enum.reduce(args, %{}, fn arg, acc ->\n        name = get_in(arg, [\"name\"]) || \"unknown\"\n        type_info = get_in(arg, [\"type\"]) || %{}\n        elixir_type = graphql_type_to_elixir(type_info)\n\n        Map.put(acc, name, %{\n          \"type\" => elixir_type,\n          \"description\" => get_in(arg, [\"description\"]) || \"No description\"\n        })\n      end)\n\n    %{\n      \"type\" => \"object\",\n      \"properties\" => properties,\n      \"required\" => []\n    }\n  end\n\n  defp graphql_type_to_elixir(type_info) do\n    case get_in(type_info, [\"kind\"]) do\n      \"SCALAR\" ->\n        case get_in(type_info, [\"name\"]) do\n          \"String\" -> \"string\"\n          \"Int\" -> \"integer\"\n          \"Float\" -> \"number\"\n          \"Boolean\" -> \"boolean\"\n          \"ID\" -> \"string\"\n          _ -> \"any\"\n        end\n\n      \"NON_NULL\" ->\n        # Non-null type, get the inner type\n        inner_type = get_in(type_info, [\"ofType\"])\n        graphql_type_to_elixir(inner_type || %{})\n\n      \"LIST\" ->\n        # List type\n        _inner_type = get_in(type_info, [\"ofType\"])\n        \"array\"\n\n      _ ->\n        \"any\"\n    end\n  end\n\n  defp build_args_string(args) when map_size(args) == 0 do\n    \"\"\n  end\n\n  defp build_args_string(args) do\n    args\n    |> Enum.map_join(\", \", fn {key, value} ->\n      \"$#{key}: #{value_to_graphql_type(value)}\"\n    end)\n  end\n\n  defp value_to_graphql_type(value) do\n    case value do\n      _ when is_binary(value) -> \"String\"\n      _ when is_integer(value) -> \"Int\"\n      _ when is_float(value) -> \"Float\"\n      _ when is_boolean(value) -> \"Boolean\"\n      _ when is_map(value) -> \"JSON\"\n      _ when is_list(value) -> \"[String]\"\n      _ -> \"String\"\n    end\n  end\nend\n",
      "line_count": 275,
      "word_count": 714,
      "title": "Schema.Ex",
      "summary": "defmodule ExUtcp.Transports.Graphql.Schema do @moduledoc \"\"\"",
      "key_terms": [
        "null",
        "contain",
        "extract",
        "number",
        "error",
        "Type",
        "check",
        "format",
        "Utcp",
        "available",
        "unknown",
        "trim",
        "Float",
        "must",
        "string",
        "Subscription",
        "inner",
        "ofType",
        "Empty",
        "LIST"
      ],
      "timestamp": "2025-12-24T18:56:01.678420"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\graphql\\testable.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Graphql.Testable do\n  @moduledoc \"\"\"\n  Testable version of the GraphQL transport that allows injecting mock modules.\n  \"\"\"\n\n  use GenServer\n  use ExUtcp.Transports.Behaviour\n\n  alias ExUtcp.Transports.Graphql.MockConnection\n  alias ExUtcp.Transports.Graphql.Schema\n\n  require Logger\n\n  defstruct [\n    :logger,\n    :connection_timeout,\n    :pool_opts,\n    :retry_config,\n    :max_retries,\n    :retry_delay,\n    # For testing GenServer calls\n    :genserver_module,\n    # For testing Connection calls\n    :connection_module\n  ]\n\n  @doc \"\"\"\n  Creates a new testable GraphQL transport.\n  \"\"\"\n  @spec new(keyword()) :: %__MODULE__{}\n  def new(opts \\\\ []) do\n    %__MODULE__{\n      logger: Keyword.get(opts, :logger, &Logger.info/1),\n      connection_timeout: Keyword.get(opts, :connection_timeout, 30_000),\n      pool_opts: Keyword.get(opts, :pool_opts, []),\n      retry_config: %{\n        max_retries: Keyword.get(opts, :max_retries, 3),\n        retry_delay: Keyword.get(opts, :retry_delay, 1000),\n        backoff_multiplier: Keyword.get(opts, :backoff_multiplier, 2)\n      },\n      max_retries: Keyword.get(opts, :max_retries, 3),\n      retry_delay: Keyword.get(opts, :retry_delay, 1000),\n      genserver_module: Keyword.get(opts, :genserver_module, GenServer),\n      connection_module: Keyword.get(opts, :connection_module, MockConnection)\n    }\n  end\n\n  @impl GenServer\n  def init(opts) do\n    {:ok, new(opts)}\n  end\n\n  @doc \"\"\"\n  Overloaded public functions that accept a transport struct as the first argument\n  to allow direct manipulation of the transport state in tests.\n  \"\"\"\n  @spec register_tool_provider(%__MODULE__{}, map()) :: {:ok, [map()]} | {:error, term()}\n  def register_tool_provider(transport, provider) do\n    case provider.type do\n      :graphql ->\n        case discover_tools(transport, provider) do\n          {:ok, tools} -> {:ok, tools}\n          {:error, reason} -> {:error, reason}\n        end\n\n      _ ->\n        {:error, \"GraphQL transport can only be used with GraphQL providers\"}\n    end\n  end\n\n  @spec deregister_tool_provider(%__MODULE__{}, map()) :: :ok | {:error, term()}\n  def deregister_tool_provider(_transport, provider) do\n    case provider.type do\n      :graphql ->\n        # For now, just return ok. In a real implementation, we might want to\n        # close the specific connection or clean up resources.\n        :ok\n\n      _ ->\n        {:error, \"GraphQL transport can only be used with GraphQL providers\"}\n    end\n  end\n\n  @spec call_tool(%__MODULE__{}, String.t(), map(), map()) :: {:ok, map()} | {:error, term()}\n  def call_tool(transport, tool_name, args, provider) do\n    case provider.type do\n      :graphql ->\n        case execute_tool_call(transport, tool_name, args, provider) do\n          {:ok, result} -> {:ok, result}\n          {:error, reason} -> {:error, reason}\n        end\n\n      _ ->\n        {:error, \"GraphQL transport can only be used with GraphQL providers\"}\n    end\n  end\n\n  @spec call_tool_stream(%__MODULE__{}, String.t(), map(), map()) ::\n          {:ok, map()} | {:error, term()}\n  def call_tool_stream(transport, tool_name, args, provider) do\n    case provider.type do\n      :graphql ->\n        case execute_tool_stream(transport, tool_name, args, provider) do\n          {:ok, result} -> {:ok, result}\n          {:error, reason} -> {:error, reason}\n        end\n\n      _ ->\n        {:error, \"GraphQL transport can only be used with GraphQL providers\"}\n    end\n  end\n\n  @spec query(%__MODULE__{}, map(), String.t(), map(), keyword()) ::\n          {:ok, map()} | {:error, term()}\n  def query(transport, provider, query_string, variables \\\\ %{}, opts \\\\ []) do\n    case get_connection_and_execute(transport, provider, fn conn ->\n           transport.connection_module.query(conn, query_string, variables, opts)\n         end) do\n      {:ok, result} -> {:ok, result}\n      {:error, reason} -> {:error, reason}\n    end\n  end\n\n  @spec mutation(%__MODULE__{}, map(), String.t(), map(), keyword()) ::\n          {:ok, map()} | {:error, term()}\n  def mutation(transport, provider, mutation_string, variables \\\\ %{}, opts \\\\ []) do\n    case get_connection_and_execute(transport, provider, fn conn ->\n           transport.connection_module.mutation(conn, mutation_string, variables, opts)\n         end) do\n      {:ok, result} -> {:ok, result}\n      {:error, reason} -> {:error, reason}\n    end\n  end\n\n  @spec subscription(%__MODULE__{}, map(), String.t(), map(), keyword()) ::\n          {:ok, [map()]} | {:error, term()}\n  def subscription(transport, provider, subscription_string, variables \\\\ %{}, opts \\\\ []) do\n    case get_connection_and_execute(transport, provider, fn conn ->\n           transport.connection_module.subscription(conn, subscription_string, variables, opts)\n         end) do\n      {:ok, result} -> {:ok, result}\n      {:error, reason} -> {:error, reason}\n    end\n  end\n\n  @spec introspect_schema(%__MODULE__{}, map(), keyword()) :: {:ok, map()} | {:error, term()}\n  def introspect_schema(transport, provider, opts \\\\ []) do\n    case get_connection_and_execute(transport, provider, fn conn ->\n           transport.connection_module.introspect_schema(conn, opts)\n         end) do\n      {:ok, result} -> {:ok, result}\n      {:error, reason} -> {:error, reason}\n    end\n  end\n\n  # Private functions\n\n  defp discover_tools(transport, provider) do\n    retry_config =\n      transport.retry_config || %{max_retries: 3, retry_delay: 1000, backoff_multiplier: 2.0}\n\n    with_retry(\n      fn ->\n        case get_connection(transport, provider) do\n          {:ok, conn} ->\n            case transport.connection_module.introspect_schema(conn,\n                   timeout: transport.connection_timeout\n                 ) do\n              {:ok, schema} ->\n                tools = Schema.extract_tools(schema)\n                {:ok, tools}\n\n              {:error, reason} ->\n                {:error, \"Failed to discover tools: #{inspect(reason)}\"}\n            end\n\n          {:error, reason} ->\n            {:error, \"Failed to get connection: #{inspect(reason)}\"}\n        end\n      end,\n      retry_config\n    )\n  end\n\n  defp execute_tool_call(transport, tool_name, args, provider) do\n    retry_config =\n      transport.retry_config || %{max_retries: 3, retry_delay: 1000, backoff_multiplier: 2.0}\n\n    with_retry(\n      fn ->\n        case get_connection(transport, provider) do\n          {:ok, conn} ->\n            # Convert tool call to GraphQL query\n            case build_graphql_operation(tool_name, args) do\n              {:query, query_string, variables} ->\n                case transport.connection_module.query(conn, query_string, variables,\n                       timeout: transport.connection_timeout\n                     ) do\n                  {:ok, result} -> {:ok, result}\n                  {:error, reason} -> {:error, \"Failed to execute query: #{inspect(reason)}\"}\n                end\n            end\n\n          {:error, reason} ->\n            {:error, \"Failed to get connection: #{inspect(reason)}\"}\n        end\n      end,\n      retry_config\n    )\n  end\n\n  defp execute_tool_stream(transport, tool_name, args, provider) do\n    retry_config =\n      transport.retry_config || %{max_retries: 3, retry_delay: 1000, backoff_multiplier: 2.0}\n\n    with_retry(\n      fn ->\n        case get_connection(transport, provider) do\n          {:ok, conn} ->\n            # Convert tool stream to GraphQL subscription\n            case build_graphql_subscription(tool_name, args) do\n              {:subscription, subscription_string, variables} ->\n                case transport.connection_module.subscription(\n                       conn,\n                       subscription_string,\n                       variables,\n                       timeout: transport.connection_timeout\n                     ) do\n                  {:ok, results} ->\n                    {:ok, %{type: :stream, data: results}}\n\n                  {:error, reason} ->\n                    {:error, \"Failed to execute subscription: #{inspect(reason)}\"}\n                end\n            end\n\n          {:error, reason} ->\n            {:error, \"Failed to get connection: #{inspect(reason)}\"}\n        end\n      end,\n      retry_config\n    )\n  end\n\n  defp get_connection_and_execute(transport, provider, fun) do\n    retry_config =\n      transport.retry_config || %{max_retries: 3, retry_delay: 1000, backoff_multiplier: 2.0}\n\n    with_retry(\n      fn ->\n        case get_connection(transport, provider) do\n          {:ok, conn} ->\n            fun.(conn)\n\n          {:error, reason} ->\n            {:error, \"Failed to get connection: #{inspect(reason)}\"}\n        end\n      end,\n      retry_config\n    )\n  end\n\n  defp get_connection(transport, _provider) do\n    # For testing, we'll simulate getting a connection using the injected mock\n    # In a real implementation, this would use the connection pool\n    case transport.connection_module do\n      nil -> {:error, \"No connection module configured\"}\n      MockConnection -> {:ok, :mock_connection}\n      _module -> {:ok, :mock_connection}\n    end\n  end\n\n  defp build_graphql_operation(tool_name, args) do\n    # Simple implementation - in a real system, this would be more sophisticated\n    # For now, we'll treat all tool calls as queries\n    query_string = \"\"\"\n    query #{String.replace(tool_name, \".\", \"_\")}($input: JSON!) {\n      #{String.replace(tool_name, \".\", \"_\")}(input: $input) {\n        result\n        success\n        error\n      }\n    }\n    \"\"\"\n\n    variables = %{\"input\" => args}\n    {:query, query_string, variables}\n  end\n\n  defp build_graphql_subscription(tool_name, args) do\n    # Simple implementation - in a real system, this would be more sophisticated\n    subscription_string = \"\"\"\n    subscription #{String.replace(tool_name, \".\", \"_\")}($input: JSON!) {\n      #{String.replace(tool_name, \".\", \"_\")}(input: $input) {\n        data\n        timestamp\n      }\n    }\n    \"\"\"\n\n    variables = %{\"input\" => args}\n    {:subscription, subscription_string, variables}\n  end\n\n  defp with_retry(fun, retry_config, attempt \\\\ 0) do\n    case fun.() do\n      {:ok, result} ->\n        {:ok, result}\n\n      {:error, _reason} when attempt < retry_config.max_retries ->\n        delay = retry_config.retry_delay * :math.pow(retry_config.backoff_multiplier, attempt)\n        :timer.sleep(round(delay))\n        with_retry(fun, retry_config, attempt + 1)\n\n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\n\n  # Implement ExUtcp.Transports.Behaviour callbacks\n  @impl ExUtcp.Transports.Behaviour\n  def transport_name, do: \"graphql\"\n\n  @impl ExUtcp.Transports.Behaviour\n  def supports_streaming?, do: true\n\n  @impl ExUtcp.Transports.Behaviour\n  def call_tool(tool_name, args, provider) do\n    execute_tool_call(tool_name, args, provider, [])\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def call_tool_stream(tool_name, args, provider) do\n    execute_tool_stream(tool_name, args, provider, [])\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def register_tool_provider(provider) do\n    case provider.type do\n      :graphql ->\n        # Create a default transport for testing\n        transport = new()\n\n        case discover_tools(transport, provider) do\n          {:ok, tools} -> {:ok, tools}\n          {:error, reason} -> {:error, reason}\n        end\n\n      _ ->\n        {:error, \"GraphQL transport can only be used with GraphQL providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def deregister_tool_provider(provider) do\n    case provider.type do\n      :graphql -> :ok\n      _ -> {:error, \"GraphQL transport can only be used with GraphQL providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def close, do: :ok\n\n  # Additional function for testing with transport parameter\n  def close(_transport), do: :ok\nend\n",
      "line_count": 368,
      "word_count": 1122,
      "title": "Testable.Ex",
      "summary": "defmodule ExUtcp.Transports.Graphql.Testable do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "close",
        "we",
        "up",
        "MockConnection",
        "getting",
        "error",
        "timer",
        "info",
        "Implement",
        "Utcp",
        "only",
        "providers",
        "logger",
        "treat",
        "keyword",
        "version",
        "using",
        "Creates",
        "that"
      ],
      "timestamp": "2025-12-24T18:56:01.712988"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\grpc\\connection.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Grpc.Connection do\n  @moduledoc \"\"\"\n  Manages gRPC connections with pooling and lifecycle management.\n  \"\"\"\n\n  use GenServer\n\n  alias ExUtcp.Grpcpb.Empty\n  alias ExUtcp.Grpcpb.ToolCallRequest\n  alias ExUtcp.Grpcpb.ToolCallResponse\n  alias ExUtcp.Grpcpb.UTCPService.Stub\n\n  require Logger\n\n  defstruct [\n    :provider,\n    :stub,\n    :channel,\n    :connection_state,\n    :last_used,\n    :retry_count,\n    :max_retries\n  ]\n\n  @type t :: %__MODULE__{\n          provider: map(),\n          stub: module(),\n          channel: GRPC.Channel.t(),\n          connection_state: :connecting | :connected | :disconnected | :error,\n          last_used: DateTime.t(),\n          retry_count: non_neg_integer(),\n          max_retries: non_neg_integer()\n        }\n\n  @doc \"\"\"\n  Starts a new gRPC connection process.\n  \"\"\"\n  @spec start_link(map(), keyword()) :: {:ok, pid()} | {:error, term()}\n  def start_link(provider, opts \\\\ []) do\n    GenServer.start_link(__MODULE__, {provider, opts})\n  end\n\n  @doc \"\"\"\n  Gets the manual (available tools) from the gRPC service.\n  \"\"\"\n  @spec get_manual(pid(), timeout()) :: {:ok, [map()]} | {:error, term()}\n  def get_manual(pid, timeout \\\\ 30_000) do\n    GenServer.call(pid, {:get_manual, timeout})\n  end\n\n  @doc \"\"\"\n  Calls a tool via gRPC.\n  \"\"\"\n  @spec call_tool(pid(), String.t(), map(), timeout()) :: {:ok, map()} | {:error, term()}\n  def call_tool(pid, tool_name, args, timeout \\\\ 30_000) do\n    GenServer.call(pid, {:call_tool, tool_name, args, timeout})\n  end\n\n  @doc \"\"\"\n  Calls a tool stream via gRPC.\n  \"\"\"\n  @spec call_tool_stream(pid(), String.t(), map(), timeout()) :: {:ok, [map()]} | {:error, term()}\n  def call_tool_stream(pid, tool_name, args, timeout \\\\ 30_000) do\n    GenServer.call(pid, {:call_tool_stream, tool_name, args, timeout})\n  end\n\n  @doc \"\"\"\n  Closes the gRPC connection.\n  \"\"\"\n  @spec close(pid()) :: :ok\n  def close(pid) do\n    GenServer.stop(pid)\n  end\n\n  @doc \"\"\"\n  Checks if the connection is healthy.\n  \"\"\"\n  @spec healthy?(pid()) :: boolean()\n  def healthy?(pid) do\n    GenServer.call(pid, :healthy?)\n  end\n\n  # GenServer callbacks\n\n  @impl GenServer\n  def init({provider, opts}) do\n    max_retries = Keyword.get(opts, :max_retries, 3)\n\n    state = %__MODULE__{\n      provider: provider,\n      stub: nil,\n      channel: nil,\n      connection_state: :connecting,\n      last_used: DateTime.utc_now(),\n      retry_count: 0,\n      max_retries: max_retries\n    }\n\n    # Attempt initial connection\n    case establish_connection(state) do\n      {:ok, new_state} -> {:ok, new_state}\n      {:error, reason} -> {:stop, reason}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:get_manual, timeout}, _from, state) do\n    case ensure_connected(state) do\n      {:ok, new_state} ->\n        case call_grpc_service(new_state, :get_manual, %Empty{}, timeout) do\n          {:ok, manual} ->\n            tools = Enum.map(manual.tools, &normalize_tool/1)\n            {:reply, {:ok, tools}, update_last_used(new_state)}\n\n          {:error, reason} ->\n            {:reply, {:error, reason}, state}\n        end\n\n      {:error, reason} ->\n        {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:call_tool, tool_name, args, timeout}, _from, state) do\n    case ensure_connected(state) do\n      {:ok, new_state} ->\n        request = %ToolCallRequest{\n          tool: tool_name,\n          args_json: Jason.encode!(args)\n        }\n\n        case call_grpc_service(new_state, :call_tool, request, timeout) do\n          {:ok, response} ->\n            result = Jason.decode!(response.result_json)\n            {:reply, {:ok, result}, update_last_used(new_state)}\n\n          {:error, reason} ->\n            {:reply, {:error, reason}, state}\n        end\n\n      {:error, reason} ->\n        {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:call_tool_stream, tool_name, args, timeout}, _from, state) do\n    case ensure_connected(state) do\n      {:ok, new_state} ->\n        request = %ToolCallRequest{\n          tool: tool_name,\n          args_json: Jason.encode!(args)\n        }\n\n        case call_grpc_service(new_state, :call_tool_stream, request, timeout) do\n          {:ok, responses} ->\n            results = Enum.map(responses, &Jason.decode!(&1.result_json))\n            {:reply, {:ok, results}, update_last_used(new_state)}\n\n          {:error, reason} ->\n            {:reply, {:error, reason}, state}\n        end\n\n      {:error, reason} ->\n        {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call(:healthy?, _from, state) do\n    healthy = state.connection_state == :connected and state.stub != nil\n    {:reply, healthy, state}\n  end\n\n  @impl GenServer\n  def handle_info(:reconnect, state) do\n    case establish_connection(state) do\n      {:ok, new_state} -> {:noreply, new_state}\n      {:error, _reason} -> {:noreply, state}\n    end\n  end\n\n  @impl GenServer\n  def terminate(_reason, state) do\n    if state.channel do\n      :ok\n    end\n  end\n\n  # Private functions\n\n  defp establish_connection(state) do\n    endpoint = build_endpoint(state.provider)\n    channel_opts = build_channel_opts(state.provider)\n\n    # For now, simulate a connection since the gRPC library API may vary\n    # In a real implementation, this would use the actual gRPC connection\n    try do\n      # Simulate connection attempt\n      channel = %{endpoint: endpoint, opts: channel_opts}\n      stub = Stub\n\n      new_state = %{\n        state\n        | channel: channel,\n          stub: stub,\n          connection_state: :connected,\n          retry_count: 0\n      }\n\n      Logger.info(\"gRPC connection established to #{endpoint}\")\n      {:ok, new_state}\n    rescue\n      error ->\n        Logger.error(\"Failed to connect to gRPC endpoint #{endpoint}: #{inspect(error)}\")\n        {:error, error}\n    end\n  rescue\n    error ->\n      Logger.error(\"Exception during gRPC connection: #{inspect(error)}\")\n      {:error, error}\n  end\n\n  defp ensure_connected(state) do\n    case state.connection_state do\n      :connected ->\n        {:ok, state}\n\n      _ ->\n        case establish_connection(state) do\n          {:ok, new_state} -> {:ok, new_state}\n          {:error, reason} -> {:error, reason}\n        end\n    end\n  end\n\n  defp call_grpc_service(_state, method, request, _timeout) do\n    # Simulate gRPC service calls since we don't have a real server\n    # In a real implementation, this would use the actual gRPC stub\n    case method do\n      :get_manual ->\n        # Simulate getting manual/tools\n        manual = %ExUtcp.Grpcpb.Manual{\n          version: \"1.0.0\",\n          tools: []\n        }\n\n        {:ok, manual}\n\n      :call_tool ->\n        # Simulate tool call response\n        response = %ToolCallResponse{\n          result_json: Jason.encode!(%{\"result\" => \"Mock gRPC response for #{request.tool}\"})\n        }\n\n        {:ok, response}\n\n      :call_tool_stream ->\n        # Simulate tool stream response\n        responses = [\n          %ToolCallResponse{\n            result_json: Jason.encode!(%{\"chunk\" => \"Mock gRPC stream chunk 1\"})\n          },\n          %ToolCallResponse{\n            result_json: Jason.encode!(%{\"chunk\" => \"Mock gRPC stream chunk 2\"})\n          }\n        ]\n\n        {:ok, responses}\n    end\n  rescue\n    error ->\n      Logger.error(\"gRPC call failed: #{inspect(error)}\")\n      {:error, error}\n  end\n\n  defp build_endpoint(provider) do\n    host = Map.get(provider, :host, \"localhost\")\n    port = Map.get(provider, :port, 50_051)\n    use_ssl = Map.get(provider, :use_ssl, false)\n\n    protocol = if use_ssl, do: \"https\", else: \"http\"\n    \"#{protocol}://#{host}:#{port}\"\n  end\n\n  defp build_channel_opts(provider) do\n    base_opts = [\n      interceptors: []\n    ]\n\n    # Add authentication if configured\n    case Map.get(provider, :auth) do\n      nil -> base_opts\n      auth -> add_auth_opts(base_opts, auth)\n    end\n  end\n\n  defp add_auth_opts(opts, auth) do\n    case auth.type do\n      :api_key ->\n        headers = [{\"authorization\", \"Bearer #{auth.api_key}\"}]\n        Keyword.put(opts, :headers, headers)\n\n      :basic ->\n        credentials = Base.encode64(\"#{auth.username}:#{auth.password}\")\n        headers = [{\"authorization\", \"Basic #{credentials}\"}]\n        Keyword.put(opts, :headers, headers)\n\n      :oauth2 ->\n        headers = [{\"authorization\", \"Bearer #{auth.access_token}\"}]\n        Keyword.put(opts, :headers, headers)\n\n      _ ->\n        opts\n    end\n  end\n\n  defp normalize_tool(tool) do\n    %{\n      \"name\" => tool.name,\n      \"description\" => tool.description,\n      \"inputs\" => Jason.decode!(tool.inputs),\n      \"outputs\" => Jason.decode!(tool.outputs),\n      \"tags\" => tool.tags\n    }\n  end\n\n  defp update_last_used(state) do\n    %{state | last_used: DateTime.utc_now()}\n  end\nend\n",
      "line_count": 333,
      "word_count": 859,
      "title": "Connection.Ex",
      "summary": "defmodule ExUtcp.Transports.Grpc.Connection do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "close",
        "we",
        "Closes",
        "getting",
        "error",
        "localhost",
        "headers",
        "info",
        "Utcp",
        "during",
        "available",
        "DateTime",
        "ToolCallRequest",
        "reply",
        "connect",
        "Jason",
        "since",
        "keyword",
        "version"
      ],
      "timestamp": "2025-12-24T18:56:01.749501"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\grpc\\connection_behaviour.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Grpc.ConnectionBehaviour do\n  @moduledoc \"\"\"\n  Behaviour for gRPC connections to enable mocking in tests.\n  \"\"\"\n\n  @callback start_link(provider :: map()) :: {:ok, pid()} | {:error, term()}\n  @callback call_tool(pid(), tool_name :: String.t(), args :: map(), opts :: keyword()) ::\n              {:ok, map()} | {:error, term()}\n  @callback call_tool_stream(pid(), tool_name :: String.t(), args :: map(), opts :: keyword()) ::\n              {:ok, Enumerable.t()} | {:error, term()}\n  @callback close(pid()) :: :ok | {:error, term()}\n  @callback get_last_used(pid()) :: integer()\n  @callback update_last_used(pid()) :: :ok\nend\n",
      "line_count": 15,
      "word_count": 75,
      "title": "Connection Behaviour.Ex",
      "summary": "defmodule ExUtcp.Transports.Grpc.ConnectionBehaviour do @moduledoc \"\"\"",
      "key_terms": [
        "ExUtcp",
        "close",
        "error",
        "pid",
        "end",
        "Transports",
        "mocking",
        "Utcp",
        "map",
        "ok",
        "callback",
        "do",
        "for",
        "gRPC",
        "tests",
        "keyword",
        "integer",
        "String",
        "Grpc",
        "moduledoc"
      ],
      "timestamp": "2025-12-24T18:56:01.773423"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\grpc\\gnmi.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Grpc.Gnmi do\n  @moduledoc \"\"\"\n  gNMI (gRPC Network Management Interface) specific functionality.\n\n  This module provides specialized functions for network management operations\n  using the gNMI protocol over gRPC.\n  \"\"\"\n\n  alias ExUtcp.Transports.Grpc.Connection\n\n  require Logger\n\n  @doc \"\"\"\n  Performs a gNMI Get operation to retrieve configuration or state data.\n  \"\"\"\n  @spec get(pid(), [String.t()], keyword()) :: {:ok, map()} | {:error, term()}\n  def get(connection_pid, paths, opts \\\\ []) do\n    request = build_get_request(paths, opts)\n    call_gnmi_operation(connection_pid, :get, request, opts)\n  end\n\n  @doc \"\"\"\n  Performs a gNMI Set operation to modify configuration.\n  \"\"\"\n  @spec set(pid(), [map()], keyword()) :: {:ok, map()} | {:error, term()}\n  def set(connection_pid, updates, opts \\\\ []) do\n    request = build_set_request(updates, opts)\n    call_gnmi_operation(connection_pid, :set, request, opts)\n  end\n\n  @doc \"\"\"\n  Performs a gNMI Subscribe operation for real-time data streaming.\n  \"\"\"\n  @spec subscribe(pid(), [String.t()], keyword()) :: {:ok, [map()]} | {:error, term()}\n  def subscribe(connection_pid, paths, opts \\\\ []) do\n    request = build_subscribe_request(paths, opts)\n    call_gnmi_operation(connection_pid, :subscribe, request, opts)\n  end\n\n  @doc \"\"\"\n  Performs a gNMI Capabilities operation to discover supported models.\n  \"\"\"\n  @spec capabilities(pid(), keyword()) :: {:ok, map()} | {:error, term()}\n  def capabilities(connection_pid, opts \\\\ []) do\n    request = build_capabilities_request()\n    call_gnmi_operation(connection_pid, :capabilities, request, opts)\n  end\n\n  @doc \"\"\"\n  Validates gNMI paths for correctness.\n  \"\"\"\n  @spec validate_paths([String.t()]) :: {:ok, [String.t()]} | {:error, term()}\n  def validate_paths(paths) when is_list(paths) do\n    validated_paths =\n      paths\n      |> Enum.map(&String.trim/1)\n      |> Enum.reject(&(&1 == \"\"))\n      |> Enum.map(&normalize_path/1)\n\n    if Enum.empty?(validated_paths) do\n      {:error, \"No valid paths provided\"}\n    else\n      {:ok, validated_paths}\n    end\n  end\n\n  @doc \"\"\"\n  Builds a gNMI path from components.\n  \"\"\"\n  @spec build_path(String.t(), [String.t()], String.t()) :: String.t()\n  def build_path(origin, elements, target \\\\ \"\") do\n    path_parts = [origin | elements]\n    path = Enum.join(path_parts, \"/\")\n\n    if target == \"\" do\n      path\n    else\n      \"#{path}[#{target}]\"\n    end\n  end\n\n  @doc \"\"\"\n  Parses a gNMI path into components.\n  \"\"\"\n  @spec parse_path(String.t()) :: {:ok, map()} | {:error, term()}\n  def parse_path(path) do\n    # Simple path parsing - in a real implementation, this would be more sophisticated\n    parts = String.split(path, \"/\", trim: true)\n\n    case parts do\n      [origin | elements] ->\n        {:ok,\n         %{\n           origin: origin,\n           elements: elements,\n           full_path: path\n         }}\n\n      [] ->\n        {:error, \"Empty path\"}\n    end\n  rescue\n    error ->\n      {:error, \"Failed to parse path: #{inspect(error)}\"}\n  end\n\n  # Private functions\n\n  defp build_get_request(paths, opts) do\n    %{\n      \"type\" => \"GetRequest\",\n      \"path\" => Enum.map(paths, &%{\"elem\" => String.split(&1, \"/\", trim: true)}),\n      \"encoding\" => Keyword.get(opts, :encoding, \"JSON\"),\n      \"use_models\" => Keyword.get(opts, :use_models, []),\n      \"extension\" => Keyword.get(opts, :extension, [])\n    }\n  end\n\n  defp build_set_request(updates, opts) do\n    %{\n      \"type\" => \"SetRequest\",\n      \"replace\" => Keyword.get(opts, :replace, []),\n      \"update\" => updates,\n      \"delete\" => Keyword.get(opts, :delete, []),\n      \"extension\" => Keyword.get(opts, :extension, [])\n    }\n  end\n\n  defp build_subscribe_request(paths, opts) do\n    subscription_list =\n      Enum.map(paths, fn path ->\n        %{\n          \"path\" => %{\"elem\" => String.split(path, \"/\", trim: true)},\n          \"mode\" => Keyword.get(opts, :mode, \"ON_CHANGE\"),\n          \"sample_interval\" => Keyword.get(opts, :sample_interval, 0),\n          \"suppress_redundant\" => Keyword.get(opts, :suppress_redundant, false),\n          \"heartbeat_interval\" => Keyword.get(opts, :heartbeat_interval, 0)\n        }\n      end)\n\n    %{\n      \"type\" => \"SubscribeRequest\",\n      \"subscribe\" => %{\n        \"subscription\" => subscription_list,\n        \"mode\" => Keyword.get(opts, :subscribe_mode, \"STREAM\"),\n        \"use_models\" => Keyword.get(opts, :use_models, []),\n        \"qos\" => Keyword.get(opts, :qos, %{}),\n        \"encoding\" => Keyword.get(opts, :encoding, \"JSON\"),\n        \"updates_only\" => Keyword.get(opts, :updates_only, false)\n      }\n    }\n  end\n\n  defp build_capabilities_request do\n    %{\n      \"type\" => \"CapabilityRequest\"\n    }\n  end\n\n  defp call_gnmi_operation(connection_pid, operation, request, opts) do\n    timeout = Keyword.get(opts, :timeout, 30_000)\n\n    # For now, we'll use the standard gRPC connection to call the gNMI operation\n    # In a real implementation, this would use a dedicated gNMI service\n    case operation do\n      :get ->\n        Connection.call_tool(connection_pid, \"gnmi.get\", request, timeout)\n\n      :set ->\n        Connection.call_tool(connection_pid, \"gnmi.set\", request, timeout)\n\n      :subscribe ->\n        Connection.call_tool_stream(\n          connection_pid,\n          \"gnmi.subscribe\",\n          request,\n          timeout\n        )\n\n      :capabilities ->\n        Connection.call_tool(\n          connection_pid,\n          \"gnmi.capabilities\",\n          request,\n          timeout\n        )\n    end\n  end\n\n  defp normalize_path(path) do\n    path\n    |> String.trim()\n    # Replace multiple slashes with single slash\n    |> String.replace(~r/\\/+/, \"/\")\n    # Remove leading slash\n    |> String.replace_leading(\"/\", \"\")\n  end\nend\n",
      "line_count": 199,
      "word_count": 588,
      "title": "Gnmi.Ex",
      "summary": "defmodule ExUtcp.Transports.Grpc.Gnmi do @moduledoc \"\"\"",
      "key_terms": [
        "leading",
        "we",
        "paths",
        "error",
        "extension",
        "qos",
        "mode",
        "Utcp",
        "trim",
        "reject",
        "subscribe",
        "multiple",
        "keyword",
        "using",
        "path",
        "if",
        "supported",
        "Empty",
        "Connection",
        "Subscribe"
      ],
      "timestamp": "2025-12-24T18:56:01.805156"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\grpc\\pool.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Grpc.Pool do\n  @moduledoc \"\"\"\n  Manages a pool of gRPC connections with lifecycle management.\n  \"\"\"\n\n  use GenServer\n\n  alias ExUtcp.Transports.Grpc.Connection\n\n  require Logger\n\n  defstruct [\n    :connections,\n    :max_connections,\n    :connection_timeout,\n    :cleanup_interval,\n    :max_idle_time\n  ]\n\n  @type t :: %__MODULE__{\n          connections: %{String.t() => pid()},\n          max_connections: non_neg_integer(),\n          connection_timeout: timeout(),\n          cleanup_interval: timeout(),\n          max_idle_time: timeout()\n        }\n\n  @doc \"\"\"\n  Starts the connection pool.\n  \"\"\"\n  @spec start_link(keyword()) :: {:ok, pid()} | {:error, term()}\n  def start_link(opts \\\\ []) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  @doc \"\"\"\n  Gets or creates a connection for the given provider.\n  \"\"\"\n  @spec get_connection(map()) :: {:ok, pid()} | {:error, term()}\n  def get_connection(provider) do\n    GenServer.call(__MODULE__, {:get_connection, provider})\n  end\n\n  @doc \"\"\"\n  Returns a connection to the pool.\n  \"\"\"\n  @spec return_connection(pid()) :: :ok\n  def return_connection(pid) do\n    GenServer.cast(__MODULE__, {:return_connection, pid})\n  end\n\n  @doc \"\"\"\n  Closes a specific connection.\n  \"\"\"\n  @spec close_connection(pid()) :: :ok\n  def close_connection(pid) do\n    GenServer.cast(__MODULE__, {:close_connection, pid})\n  end\n\n  @doc \"\"\"\n  Closes all connections.\n  \"\"\"\n  @spec close_all_connections() :: :ok\n  def close_all_connections do\n    GenServer.cast(__MODULE__, :close_all_connections)\n  end\n\n  @doc \"\"\"\n  Gets pool statistics.\n  \"\"\"\n  @spec stats() :: map()\n  def stats do\n    GenServer.call(__MODULE__, :stats)\n  end\n\n  # GenServer callbacks\n\n  @impl GenServer\n  def init(opts) do\n    state = %__MODULE__{\n      connections: %{},\n      max_connections: Keyword.get(opts, :max_connections, 10),\n      connection_timeout: Keyword.get(opts, :connection_timeout, 30_000),\n      cleanup_interval: Keyword.get(opts, :cleanup_interval, 60_000),\n      # 5 minutes\n      max_idle_time: Keyword.get(opts, :max_idle_time, 300_000)\n    }\n\n    # Start cleanup timer\n    schedule_cleanup()\n\n    {:ok, state}\n  end\n\n  @impl GenServer\n  def handle_call({:get_connection, provider}, _from, state) do\n    connection_key = build_connection_key(provider)\n\n    case Map.get(state.connections, connection_key) do\n      nil ->\n        # Create new connection\n        case create_connection(provider, state) do\n          {:ok, pid} ->\n            new_connections = Map.put(state.connections, connection_key, pid)\n            new_state = %{state | connections: new_connections}\n            {:reply, {:ok, pid}, new_state}\n\n          {:error, reason} ->\n            {:reply, {:error, reason}, state}\n        end\n\n      pid ->\n        # Check if connection is still alive and healthy\n        if Process.alive?(pid) and Connection.healthy?(pid) do\n          {:reply, {:ok, pid}, state}\n        else\n          # Connection is dead, create a new one\n          new_connections = Map.delete(state.connections, connection_key)\n          new_state = %{state | connections: new_connections}\n\n          case create_connection(provider, new_state) do\n            {:ok, new_pid} ->\n              updated_connections = Map.put(new_connections, connection_key, new_pid)\n              {:reply, {:ok, new_pid}, %{new_state | connections: updated_connections}}\n\n            {:error, reason} ->\n              {:reply, {:error, reason}, new_state}\n          end\n        end\n    end\n  end\n\n  @impl GenServer\n  def handle_call(:stats, _from, state) do\n    stats = %{\n      total_connections: map_size(state.connections),\n      max_connections: state.max_connections,\n      connection_keys: Map.keys(state.connections)\n    }\n\n    {:reply, stats, state}\n  end\n\n  @impl GenServer\n  def handle_cast({:return_connection, _pid}, state) do\n    # Connection is returned to pool, no action needed\n    {:noreply, state}\n  end\n\n  @impl GenServer\n  def handle_cast({:close_connection, pid}, state) do\n    # Find and remove the connection\n    new_connections =\n      state.connections\n      |> Enum.reject(fn {_key, connection_pid} -> connection_pid == pid end)\n      |> Map.new()\n\n    # Close the connection\n    if Process.alive?(pid) do\n      Connection.close(pid)\n    end\n\n    {:noreply, %{state | connections: new_connections}}\n  end\n\n  @impl GenServer\n  def handle_cast(:close_all_connections, state) do\n    # Close all connections\n    Enum.each(state.connections, fn {_key, pid} ->\n      if Process.alive?(pid) do\n        Connection.close(pid)\n      end\n    end)\n\n    {:noreply, %{state | connections: %{}}}\n  end\n\n  @impl GenServer\n  def handle_info(:cleanup, state) do\n    # Clean up idle connections\n    now = DateTime.utc_now()\n    max_idle_time = state.max_idle_time\n\n    {active_connections, closed_count} =\n      state.connections\n      |> Enum.reduce({%{}, 0}, fn {key, pid}, {acc, closed} ->\n        if Process.alive?(pid) do\n          # Check if connection is idle\n          case get_connection_last_used(pid) do\n            {:ok, last_used} ->\n              idle_time = DateTime.diff(now, last_used, :millisecond)\n\n              if idle_time > max_idle_time do\n                Connection.close(pid)\n                {acc, closed + 1}\n              else\n                {Map.put(acc, key, pid), closed}\n              end\n\n            {:error, _} ->\n              # Connection is not responding, close it\n              Connection.close(pid)\n              {acc, closed + 1}\n          end\n        else\n          {acc, closed + 1}\n        end\n      end)\n\n    if closed_count > 0 do\n      Logger.info(\"Cleaned up #{closed_count} idle gRPC connections\")\n    end\n\n    # Schedule next cleanup\n    schedule_cleanup()\n\n    {:noreply, %{state | connections: active_connections}}\n  end\n\n  # Private functions\n\n  defp create_connection(provider, state) do\n    if map_size(state.connections) >= state.max_connections do\n      {:error, \"Maximum number of connections reached\"}\n    else\n      opts = [\n        max_retries: 3,\n        connection_timeout: state.connection_timeout\n      ]\n\n      case Connection.start_link(provider, opts) do\n        {:ok, pid} -> {:ok, pid}\n        {:error, reason} -> {:error, reason}\n      end\n    end\n  end\n\n  defp build_connection_key(provider) do\n    host = Map.get(provider, :host, \"localhost\")\n    port = Map.get(provider, :port, 50_051)\n    use_ssl = Map.get(provider, :use_ssl, false)\n    service_name = Map.get(provider, :service_name, \"UTCPService\")\n\n    \"#{host}:#{port}:#{use_ssl}:#{service_name}\"\n  end\n\n  defp get_connection_last_used(pid) do\n    GenServer.call(pid, :last_used, 1000)\n  rescue\n    _ -> {:error, :timeout}\n  end\n\n  defp schedule_cleanup do\n    # 1 minute\n    Process.send_after(self(), :cleanup, 60_000)\n  end\nend\n",
      "line_count": 258,
      "word_count": 642,
      "title": "Pool.Ex",
      "summary": "defmodule ExUtcp.Transports.Grpc.Pool do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "dead",
        "close",
        "up",
        "Closes",
        "number",
        "timer",
        "error",
        "localhost",
        "cast",
        "each",
        "info",
        "cleanup",
        "Utcp",
        "DateTime",
        "reply",
        "reject",
        "minute",
        "keyword",
        "if"
      ],
      "timestamp": "2025-12-24T18:56:01.837262"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\grpc\\pool_behaviour.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Grpc.PoolBehaviour do\n  @moduledoc \"\"\"\n  Behaviour for gRPC connection pools to enable mocking in tests.\n  \"\"\"\n\n  @callback get_connection(provider :: map()) :: {:ok, pid()} | {:error, term()}\n  @callback return_connection(pid()) :: :ok\n  @callback close_connection(pid()) :: :ok\n  @callback close_all_connections() :: :ok\n  @callback stats() :: map()\nend\n",
      "line_count": 12,
      "word_count": 43,
      "title": "Pool Behaviour.Ex",
      "summary": "defmodule ExUtcp.Transports.Grpc.PoolBehaviour do @moduledoc \"\"\"",
      "key_terms": [
        "ExUtcp",
        "error",
        "pid",
        "end",
        "Transports",
        "PoolBehaviour",
        "mocking",
        "Utcp",
        "map",
        "ok",
        "callback",
        "do",
        "for",
        "gRPC",
        "tests",
        "pools",
        "Grpc",
        "moduledoc",
        "connection",
        "provider"
      ],
      "timestamp": "2025-12-24T18:56:01.853213"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\mcp\\connection.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Mcp.Connection do\n  @moduledoc \"\"\"\n  Manages MCP connections with JSON-RPC 2.0 communication.\n  \"\"\"\n\n  @behaviour ExUtcp.Transports.Mcp.ConnectionBehaviour\n\n  use GenServer\n\n  alias ExUtcp.Auth\n  alias ExUtcp.Transports.Mcp.Message\n\n  require Logger\n\n  defstruct [\n    :provider,\n    :client,\n    :connection_state,\n    :last_used_at,\n    :retry_count,\n    :max_retries,\n    :retry_delay,\n    :backoff_multiplier,\n    :request_id\n  ]\n\n  @doc \"\"\"\n  Starts a new MCP connection.\n  \"\"\"\n  @spec start_link(ExUtcp.Types.mcp_provider(), keyword()) :: GenServer.on_start()\n  @impl true\n  def start_link(provider, opts \\\\ []) do\n    GenServer.start_link(__MODULE__, {provider, opts})\n  end\n\n  @doc \"\"\"\n  Calls a tool using JSON-RPC.\n  \"\"\"\n  @spec call_tool(pid(), String.t(), map(), keyword()) :: ExUtcp.Types.call_result()\n  @impl true\n  def call_tool(pid, tool_name, args, opts \\\\ []) do\n    GenServer.call(pid, {:call_tool, tool_name, args, opts})\n  end\n\n  @doc \"\"\"\n  Calls a tool with streaming support.\n  \"\"\"\n  @spec call_tool_stream(pid(), String.t(), map(), keyword()) :: ExUtcp.Types.call_result()\n  @impl true\n  def call_tool_stream(pid, tool_name, args, opts \\\\ []) do\n    GenServer.call(pid, {:call_tool_stream, tool_name, args, opts})\n  end\n\n  @doc \"\"\"\n  Sends a JSON-RPC request.\n  \"\"\"\n  @spec send_request(pid(), String.t(), map(), keyword()) :: ExUtcp.Types.call_result()\n  @impl true\n  def send_request(pid, method, params, opts \\\\ []) do\n    GenServer.call(pid, {:send_request, method, params, opts})\n  end\n\n  @doc \"\"\"\n  Sends a JSON-RPC notification.\n  \"\"\"\n  @spec send_notification(pid(), String.t(), map(), keyword()) :: :ok | {:error, String.t()}\n  @impl true\n  def send_notification(pid, method, params, opts \\\\ []) do\n    GenServer.call(pid, {:send_notification, method, params, opts})\n  end\n\n  @doc \"\"\"\n  Closes the connection.\n  \"\"\"\n  @spec close(pid()) :: :ok\n  @impl true\n  def close(pid) do\n    GenServer.call(pid, :close)\n  end\n\n  @doc \"\"\"\n  Gets the last used timestamp.\n  \"\"\"\n  @spec get_last_used(pid()) :: integer()\n  @impl true\n  def get_last_used(pid) do\n    GenServer.call(pid, :get_last_used)\n  end\n\n  @doc \"\"\"\n  Updates the last used timestamp.\n  \"\"\"\n  @spec update_last_used(pid()) :: :ok\n  @impl true\n  def update_last_used(pid) do\n    GenServer.call(pid, :update_last_used)\n  end\n\n  # GenServer callbacks\n\n  @impl GenServer\n  def init({provider, opts}) do\n    state = %__MODULE__{\n      provider: provider,\n      client: nil,\n      connection_state: :disconnected,\n      last_used_at: System.monotonic_time(:millisecond),\n      retry_count: 0,\n      max_retries: Keyword.get(opts, :max_retries, 3),\n      retry_delay: Keyword.get(opts, :retry_delay, 1000),\n      backoff_multiplier: Keyword.get(opts, :backoff_multiplier, 2),\n      request_id: 1\n    }\n\n    case establish_connection(state) do\n      {:ok, new_state} -> {:ok, new_state}\n      {:error, reason} -> {:stop, reason}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:call_tool, tool_name, args, opts}, _from, state) do\n    case ensure_connection(state) do\n      {:ok, new_state} ->\n        result = execute_tool_call(tool_name, args, new_state, opts)\n        {:reply, result, update_last_used_impl(new_state)}\n\n      {:error, reason} ->\n        {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:call_tool_stream, tool_name, args, opts}, _from, state) do\n    case ensure_connection(state) do\n      {:ok, new_state} ->\n        result = execute_tool_stream(tool_name, args, new_state, opts)\n        {:reply, result, update_last_used_impl(new_state)}\n\n      {:error, reason} ->\n        {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:send_request, method, params, opts}, _from, state) do\n    case ensure_connection(state) do\n      {:ok, new_state} ->\n        result = execute_request(method, params, new_state, opts)\n        {:reply, result, update_last_used_impl(new_state)}\n\n      {:error, reason} ->\n        {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:send_notification, method, params, opts}, _from, state) do\n    case ensure_connection(state) do\n      {:ok, new_state} ->\n        result = execute_notification(method, params, new_state, opts)\n        {:reply, result, update_last_used_impl(new_state)}\n\n      {:error, reason} ->\n        {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call(:close, _from, state) do\n    {:reply, :ok, %{state | connection_state: :closed}}\n  end\n\n  @impl GenServer\n  def handle_call(:get_last_used, _from, state) do\n    {:reply, state.last_used_at, state}\n  end\n\n  @impl GenServer\n  def handle_call(:update_last_used, _from, state) do\n    new_state = update_last_used(state)\n    {:reply, :ok, new_state}\n  end\n\n  # Private functions\n\n  defp establish_connection(state) do\n    client = build_http_client(state.provider)\n\n    # Test connection with a ping request\n    ping_request = Message.build_request(\"ping\", %{})\n\n    case send_http_request(client, ping_request) do\n      {:ok, %{status: 200, body: _body}} ->\n        new_state = %{state | client: client, connection_state: :connected, retry_count: 0}\n        Logger.info(\"MCP connection established to #{state.provider.url}\")\n        {:ok, new_state}\n\n      {:error, reason} ->\n        Logger.error(\"Failed to connect to MCP endpoint #{state.provider.url}: #{inspect(reason)}\")\n\n        {:error, reason}\n\n      {:ok, %{status: status, body: body}} ->\n        Logger.error(\"Failed to connect to MCP endpoint #{state.provider.url} with HTTP #{status}: #{inspect(body)}\")\n\n        {:error, \"HTTP #{status}: #{inspect(body)}\"}\n    end\n  rescue\n    error ->\n      Logger.error(\"Exception during MCP connection: #{inspect(error)}\")\n      {:error, error}\n  end\n\n  defp ensure_connection(state) do\n    case state.connection_state do\n      :connected -> {:ok, state}\n      _ -> establish_connection(state)\n    end\n  end\n\n  defp execute_tool_call(tool_name, args, state, _opts) do\n    request =\n      Message.build_request(\"tools/call\", %{\n        name: tool_name,\n        arguments: args\n      })\n\n    case send_http_request(state.client, request) do\n      {:ok, %{status: 200, body: body}} ->\n        case Message.parse_response(body) do\n          {:ok, result} -> {:ok, result}\n          {:error, reason} -> {:error, \"Failed to parse response: #{inspect(reason)}\"}\n        end\n\n      {:error, reason} ->\n        {:error, \"HTTP request failed: #{inspect(reason)}\"}\n\n      {:ok, %{status: status, body: body}} ->\n        {:error, \"HTTP #{status}: #{inspect(body)}\"}\n    end\n  end\n\n  defp execute_tool_stream(tool_name, args, state, opts) do\n    # For streaming, we'll use Server-Sent Events if available\n    # For now, we'll simulate streaming by returning a stream of chunks\n    case execute_tool_call(tool_name, args, state, opts) do\n      {:ok, result} ->\n        # Simulate streaming by chunking the result\n        stream =\n          Stream.map([result], fn data ->\n            case data do\n              %{\"content\" => content} when is_list(content) ->\n                Enum.map(content, &%{\"chunk\" => &1})\n\n              _ ->\n                [%{\"chunk\" => data}]\n            end\n          end)\n\n        {:ok, stream}\n\n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\n\n  defp execute_request(method, params, state, _opts) do\n    request = Message.build_request(method, params)\n\n    case send_http_request(state.client, request) do\n      {:ok, %{status: 200, body: body}} ->\n        case Message.parse_response(body) do\n          {:ok, result} -> {:ok, result}\n          {:error, reason} -> {:error, \"Failed to parse response: #{inspect(reason)}\"}\n        end\n\n      {:error, reason} ->\n        {:error, \"HTTP request failed: #{inspect(reason)}\"}\n\n      {:ok, %{status: status, body: body}} ->\n        {:error, \"HTTP #{status}: #{inspect(body)}\"}\n    end\n  end\n\n  defp execute_notification(method, params, state, _opts) do\n    notification = Message.build_notification(method, params)\n\n    case send_http_request(state.client, notification) do\n      {:ok, %{status: 200}} -> :ok\n      {:error, reason} -> {:error, \"HTTP request failed: #{inspect(reason)}\"}\n      {:ok, %{status: status, body: body}} -> {:error, \"HTTP #{status}: #{inspect(body)}\"}\n    end\n  end\n\n  defp send_http_request(client, message) do\n    Req.post(client, json: message)\n  end\n\n  defp build_http_client(provider) do\n    base_url = provider.url\n    headers = build_headers(provider)\n\n    Req.new(\n      base_url: base_url,\n      headers: headers,\n      receive_timeout: 30_000,\n      retry: false\n    )\n  end\n\n  defp build_headers(provider) do\n    headers = %{\n      \"Content-Type\" => \"application/json\",\n      \"Accept\" => \"application/json\"\n    }\n\n    case provider.auth do\n      nil -> headers\n      auth -> add_auth_headers(headers, auth)\n    end\n  end\n\n  defp add_auth_headers(headers, auth) do\n    Auth.apply_to_headers(auth, headers)\n  end\n\n  defp update_last_used_impl(state) do\n    %{state | last_used_at: System.monotonic_time(:millisecond)}\n  end\nend\n",
      "line_count": 332,
      "word_count": 886,
      "title": "Connection.Ex",
      "summary": "defmodule ExUtcp.Transports.Mcp.Connection do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "close",
        "we",
        "Closes",
        "error",
        "headers",
        "Type",
        "info",
        "Utcp",
        "during",
        "available",
        "connect",
        "reply",
        "Test",
        "application",
        "keyword",
        "Req",
        "using",
        "if",
        "established"
      ],
      "timestamp": "2025-12-24T18:56:01.875099"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\mcp\\connection_behaviour.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Mcp.ConnectionBehaviour do\n  @moduledoc \"\"\"\n  Behaviour for MCP connections to enable mocking in tests.\n  \"\"\"\n\n  @callback start_link(provider :: map(), opts :: keyword()) :: {:ok, pid()} | {:error, term()}\n  @callback call_tool(pid(), tool_name :: String.t(), args :: map(), opts :: keyword()) ::\n              {:ok, map()} | {:error, term()}\n  @callback call_tool_stream(pid(), tool_name :: String.t(), args :: map(), opts :: keyword()) ::\n              {:ok, Enumerable.t()} | {:error, term()}\n  @callback send_request(pid(), method :: String.t(), params :: map(), opts :: keyword()) ::\n              {:ok, map()} | {:error, term()}\n  @callback send_notification(pid(), method :: String.t(), params :: map(), opts :: keyword()) ::\n              :ok | {:error, term()}\n  @callback close(pid()) :: :ok | {:error, term()}\n  @callback get_last_used(pid()) :: integer()\n  @callback update_last_used(pid()) :: :ok\nend\n",
      "line_count": 19,
      "word_count": 111,
      "title": "Connection Behaviour.Ex",
      "summary": "defmodule ExUtcp.Transports.Mcp.ConnectionBehaviour do @moduledoc \"\"\"",
      "key_terms": [
        "ExUtcp",
        "close",
        "params",
        "error",
        "pid",
        "end",
        "Transports",
        "mocking",
        "method",
        "Utcp",
        "map",
        "ok",
        "callback",
        "do",
        "for",
        "tests",
        "keyword",
        "integer",
        "String",
        "moduledoc"
      ],
      "timestamp": "2025-12-24T18:56:01.885162"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\mcp\\message.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Mcp.Message do\n  @moduledoc \"\"\"\n  Handles JSON-RPC 2.0 message formatting and parsing for MCP protocol.\n  \"\"\"\n\n  require Logger\n\n  @doc \"\"\"\n  Builds a JSON-RPC 2.0 request message.\n  \"\"\"\n  @spec build_request(String.t(), map(), integer() | nil) :: map()\n  def build_request(method, params, id \\\\ nil) do\n    %{\n      \"jsonrpc\" => \"2.0\",\n      \"method\" => method,\n      \"params\" => params,\n      \"id\" => id || generate_request_id()\n    }\n  end\n\n  @doc \"\"\"\n  Builds a JSON-RPC 2.0 notification message.\n  \"\"\"\n  @spec build_notification(String.t(), map()) :: map()\n  def build_notification(method, params) do\n    %{\n      \"jsonrpc\" => \"2.0\",\n      \"method\" => method,\n      \"params\" => params\n    }\n  end\n\n  @doc \"\"\"\n  Builds a JSON-RPC 2.0 response message.\n  \"\"\"\n  @spec build_response(any(), integer() | nil) :: map()\n  def build_response(result, id) do\n    %{\n      \"jsonrpc\" => \"2.0\",\n      \"result\" => result,\n      \"id\" => id\n    }\n  end\n\n  @doc \"\"\"\n  Builds a JSON-RPC 2.0 error response message.\n  \"\"\"\n  @spec build_error_response(integer(), String.t(), any(), integer() | nil) :: map()\n  def build_error_response(code, message, data \\\\ nil, id \\\\ nil) do\n    error = %{\n      \"code\" => code,\n      \"message\" => message\n    }\n\n    error = if data, do: Map.put(error, \"data\", data), else: error\n\n    %{\n      \"jsonrpc\" => \"2.0\",\n      \"error\" => error,\n      \"id\" => id\n    }\n  end\n\n  @doc \"\"\"\n  Parses a JSON-RPC 2.0 response.\n  \"\"\"\n  @spec parse_response(String.t()) :: {:ok, any()} | {:error, String.t()}\n  def parse_response(json_string) do\n    case Jason.decode(json_string) do\n      {:ok, %{\"jsonrpc\" => \"2.0\"} = message} ->\n        parse_jsonrpc_message(message)\n\n      {:ok, message} ->\n        {:ok, message}\n\n      {:error, reason} ->\n        {:error, \"Failed to parse JSON: #{inspect(reason)}\"}\n    end\n  end\n\n  @doc \"\"\"\n  Validates a JSON-RPC 2.0 message.\n  \"\"\"\n  @spec validate_message(map()) :: :ok | {:error, String.t()}\n  def validate_message(message) do\n    cond do\n      not Map.has_key?(message, \"jsonrpc\") ->\n        {:error, \"Missing jsonrpc field\"}\n\n      message[\"jsonrpc\"] != \"2.0\" ->\n        {:error, \"Invalid jsonrpc version: #{message[\"jsonrpc\"]}\"}\n\n      not Map.has_key?(message, \"method\") and not Map.has_key?(message, \"result\") and\n          not Map.has_key?(message, \"error\") ->\n        {:error, \"Message must have method, result, or error field\"}\n\n      true ->\n        :ok\n    end\n  end\n\n  @doc \"\"\"\n  Extracts the method name from a request message.\n  \"\"\"\n  @spec extract_method(map()) :: String.t() | nil\n  def extract_method(%{\"method\" => method}), do: method\n  def extract_method(_), do: nil\n\n  @doc \"\"\"\n  Extracts the request ID from a message.\n  \"\"\"\n  @spec extract_id(map()) :: integer() | nil\n  def extract_id(%{\"id\" => id}), do: id\n  def extract_id(_), do: nil\n\n  @doc \"\"\"\n  Checks if a message is a notification.\n  \"\"\"\n  @spec notification?(map()) :: boolean()\n  def notification?(%{\"method\" => _method, \"id\" => nil}), do: true\n  def notification?(%{\"method\" => _method}), do: false\n  def notification?(_), do: false\n\n  @doc \"\"\"\n  Checks if a message is a request.\n  \"\"\"\n  @spec request?(map()) :: boolean()\n  def request?(%{\"method\" => _method, \"id\" => id}) when not is_nil(id), do: true\n  def request?(_), do: false\n\n  @doc \"\"\"\n  Checks if a message is a response.\n  \"\"\"\n  @spec response?(map()) :: boolean()\n  def response?(%{\"result\" => _result}), do: true\n  def response?(%{\"error\" => _error}), do: true\n  def response?(_), do: false\n\n  @doc \"\"\"\n  Checks if a message is an error response.\n  \"\"\"\n  @spec error?(map()) :: boolean()\n  def error?(%{\"error\" => _error}), do: true\n  def error?(_), do: false\n\n  @doc \"\"\"\n  Extracts error information from an error response.\n  \"\"\"\n  @spec extract_error(map()) :: {integer(), String.t(), any()}\n  def extract_error(%{\"error\" => error}) do\n    code = Map.get(error, \"code\", -1)\n    message = Map.get(error, \"message\", \"Unknown error\")\n    data = Map.get(error, \"data\")\n    {code, message, data}\n  end\n\n  @doc \"\"\"\n  Extracts result from a successful response.\n  \"\"\"\n  @spec extract_result(map()) :: any()\n  def extract_result(%{\"result\" => result}), do: result\n  def extract_result(_), do: nil\n\n  # Private functions\n\n  defp parse_jsonrpc_message(%{\"result\" => result} = message) do\n    case validate_message(message) do\n      :ok -> {:ok, result}\n      {:error, reason} -> {:error, reason}\n    end\n  end\n\n  defp parse_jsonrpc_message(%{\"error\" => _error} = message) do\n    case validate_message(message) do\n      :ok ->\n        {code, message_text, data} = extract_error(message)\n\n        {:error, \"JSON-RPC Error #{code}: #{message_text}#{if data, do: \" (#{inspect(data)})\", else: \"\"}\"}\n\n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\n\n  defp parse_jsonrpc_message(%{\"method\" => _method} = message) do\n    case validate_message(message) do\n      :ok -> {:ok, message}\n      {:error, reason} -> {:error, reason}\n    end\n  end\n\n  defp parse_jsonrpc_message(message) do\n    case validate_message(message) do\n      :ok -> {:ok, message}\n      {:error, reason} -> {:error, reason}\n    end\n  end\n\n  defp generate_request_id do\n    :rand.uniform(1_000_000)\n  end\nend\n",
      "line_count": 203,
      "word_count": 628,
      "title": "Message.Ex",
      "summary": "defmodule ExUtcp.Transports.Mcp.Message do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "rand",
        "error",
        "id",
        "Utcp",
        "Jason",
        "must",
        "Error",
        "version",
        "if",
        "Parses",
        "Invalid",
        "true",
        "Message",
        "function",
        "request",
        "defp",
        "Handles",
        "Unknown",
        "any"
      ],
      "timestamp": "2025-12-24T18:56:01.902326"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\mcp\\pool.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Mcp.Pool do\n  @moduledoc \"\"\"\n  Manages a pool of MCP connections for efficient resource usage.\n  \"\"\"\n\n  use GenServer\n\n  alias ExUtcp.Transports.Mcp.Connection\n\n  require Logger\n\n  defstruct [\n    :connections,\n    :max_connections,\n    :connection_timeout,\n    :cleanup_interval\n  ]\n\n  @doc \"\"\"\n  Starts the MCP connection pool.\n  \"\"\"\n  @spec start_link(keyword()) :: GenServer.on_start()\n  def start_link(opts \\\\ []) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  @doc \"\"\"\n  Gets a connection for the given provider.\n  \"\"\"\n  @spec get_connection(ExUtcp.Types.mcp_provider()) :: {:ok, pid()} | {:error, String.t()}\n  def get_connection(provider) do\n    GenServer.call(__MODULE__, {:get_connection, provider})\n  end\n\n  @doc \"\"\"\n  Closes a specific connection.\n  \"\"\"\n  @spec close_connection(pid()) :: :ok\n  def close_connection(pid) do\n    GenServer.call(__MODULE__, {:close_connection, pid})\n  end\n\n  @doc \"\"\"\n  Closes all connections.\n  \"\"\"\n  @spec close_all_connections() :: :ok\n  def close_all_connections do\n    GenServer.call(__MODULE__, :close_all_connections)\n  end\n\n  @doc \"\"\"\n  Gets pool statistics.\n  \"\"\"\n  @spec stats() :: map()\n  def stats do\n    GenServer.call(__MODULE__, :stats)\n  end\n\n  # GenServer callbacks\n\n  @impl GenServer\n  def init(opts) do\n    state = %__MODULE__{\n      connections: %{},\n      max_connections: Keyword.get(opts, :max_connections, 10),\n      connection_timeout: Keyword.get(opts, :connection_timeout, 30_000),\n      cleanup_interval: Keyword.get(opts, :cleanup_interval, 60_000)\n    }\n\n    # Start cleanup timer\n    cleanup_timer = Process.send_after(self(), :cleanup, state.cleanup_interval)\n\n    {:ok, Map.put(state, :cleanup_timer, cleanup_timer)}\n  end\n\n  @impl GenServer\n  def handle_call({:get_connection, provider}, _from, state) do\n    provider_key = build_provider_key(provider)\n\n    case Map.get(state.connections, provider_key) do\n      nil ->\n        case create_connection(provider, state) do\n          {:ok, pid} ->\n            new_connections = Map.put(state.connections, provider_key, pid)\n            new_state = %{state | connections: new_connections}\n            {:reply, {:ok, pid}, new_state}\n\n          {:error, reason} ->\n            {:reply, {:error, reason}, state}\n        end\n\n      pid ->\n        # Check if connection is still alive\n        if Process.alive?(pid) do\n          {:reply, {:ok, pid}, state}\n        else\n          # Connection is dead, create a new one\n          case create_connection(provider, state) do\n            {:ok, new_pid} ->\n              new_connections = Map.put(state.connections, provider_key, new_pid)\n              new_state = %{state | connections: new_connections}\n              {:reply, {:ok, new_pid}, new_state}\n\n            {:error, reason} ->\n              {:reply, {:error, reason}, state}\n          end\n        end\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:close_connection, pid}, _from, state) do\n    # Find and remove the connection\n    new_connections =\n      Enum.reject(state.connections, fn {_key, connection_pid} ->\n        connection_pid == pid\n      end)\n      |> Map.new()\n\n    # Close the connection if it's still alive\n    if Process.alive?(pid) do\n      Connection.close(pid)\n    end\n\n    new_state = %{state | connections: new_connections}\n    {:reply, :ok, new_state}\n  end\n\n  @impl GenServer\n  def handle_call(:close_all_connections, _from, state) do\n    # Close all connections\n    Enum.each(state.connections, fn {_key, pid} ->\n      if Process.alive?(pid) do\n        Connection.close(pid)\n      end\n    end)\n\n    new_state = %{state | connections: %{}}\n    {:reply, :ok, new_state}\n  end\n\n  @impl GenServer\n  def handle_call(:stats, _from, state) do\n    stats = %{\n      total_connections: map_size(state.connections),\n      max_connections: state.max_connections,\n      connections: Map.keys(state.connections)\n    }\n\n    {:reply, stats, state}\n  end\n\n  @impl GenServer\n  def handle_info(:cleanup, state) do\n    # Clean up dead connections\n    alive_connections =\n      Enum.filter(state.connections, fn {_key, pid} ->\n        Process.alive?(pid)\n      end)\n      |> Map.new()\n\n    new_state = %{state | connections: alive_connections}\n\n    # Schedule next cleanup\n    cleanup_timer = Process.send_after(self(), :cleanup, state.cleanup_interval)\n    new_state = Map.put(new_state, :cleanup_timer, cleanup_timer)\n\n    {:noreply, new_state}\n  end\n\n  @impl GenServer\n  def handle_info({:DOWN, _ref, :process, pid, _reason}, state) do\n    # Remove dead connection from pool\n    new_connections =\n      Enum.reject(state.connections, fn {_key, connection_pid} ->\n        connection_pid == pid\n      end)\n      |> Map.new()\n\n    new_state = %{state | connections: new_connections}\n    {:noreply, new_state}\n  end\n\n  # Private functions\n\n  defp create_connection(provider, state) do\n    if map_size(state.connections) >= state.max_connections do\n      {:error, \"Maximum number of connections reached\"}\n    else\n      case Connection.start_link(provider) do\n        {:ok, pid} ->\n          # Monitor the connection\n          Process.monitor(pid)\n          {:ok, pid}\n\n        {:error, reason} ->\n          {:error, \"Failed to create connection: #{inspect(reason)}\"}\n      end\n    end\n  end\n\n  defp build_provider_key(provider) do\n    \"#{provider.name}:#{provider.url}\"\n  end\nend\n",
      "line_count": 206,
      "word_count": 507,
      "title": "Pool.Ex",
      "summary": "defmodule ExUtcp.Transports.Mcp.Pool do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "Monitor",
        "dead",
        "close",
        "up",
        "Closes",
        "number",
        "timer",
        "error",
        "each",
        "monitor",
        "cleanup",
        "Utcp",
        "reply",
        "reject",
        "usage",
        "keyword",
        "if",
        "reached",
        "Connection"
      ],
      "timestamp": "2025-12-24T18:56:01.925925"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\mcp\\pool_behaviour.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.Mcp.PoolBehaviour do\n  @moduledoc \"\"\"\n  Behaviour for MCP connection pools to enable mocking in tests.\n  \"\"\"\n\n  @callback get_connection(provider :: map()) :: {:ok, pid()} | {:error, term()}\n  @callback close_connection(pid()) :: :ok\n  @callback close_all_connections() :: :ok\n  @callback stats() :: map()\nend\n",
      "line_count": 11,
      "word_count": 39,
      "title": "Pool Behaviour.Ex",
      "summary": "defmodule ExUtcp.Transports.Mcp.PoolBehaviour do @moduledoc \"\"\"",
      "key_terms": [
        "ExUtcp",
        "error",
        "pid",
        "end",
        "Transports",
        "PoolBehaviour",
        "mocking",
        "Utcp",
        "map",
        "ok",
        "callback",
        "do",
        "for",
        "tests",
        "pools",
        "moduledoc",
        "Mcp",
        "connection",
        "provider",
        "stats"
      ],
      "timestamp": "2025-12-24T18:56:01.933037"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\tcp_udp\\connection.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.TcpUdp.Connection do\n  @moduledoc \"\"\"\n  Manages individual TCP/UDP connections.\n\n  This module handles the low-level network communication for both TCP and UDP protocols.\n  It provides message serialization, connection management, and error handling.\n  \"\"\"\n\n  use GenServer\n  use ExUtcp.Transports.TcpUdp.ConnectionBehaviour\n\n  alias ExUtcp.Transports.TcpUdp.ConnectionBehaviour\n\n  defstruct [\n    :socket,\n    :provider,\n    :last_used,\n    :protocol,\n    :host,\n    :port,\n    :buffer\n  ]\n\n  @impl ConnectionBehaviour\n  def start_link(provider) do\n    GenServer.start_link(__MODULE__, provider)\n  end\n\n  @impl ConnectionBehaviour\n  def call_tool(conn, tool_name, args, timeout) do\n    GenServer.call(conn, {:call_tool, tool_name, args, timeout})\n  end\n\n  @impl ConnectionBehaviour\n  def call_tool_stream(conn, tool_name, args, timeout) do\n    GenServer.call(conn, {:call_tool_stream, tool_name, args, timeout})\n  end\n\n  @impl ConnectionBehaviour\n  def close(conn) do\n    GenServer.call(conn, :close)\n  end\n\n  @impl ConnectionBehaviour\n  def get_last_used(conn) do\n    GenServer.call(conn, :get_last_used)\n  end\n\n  @impl ConnectionBehaviour\n  def update_last_used(conn) do\n    GenServer.cast(conn, :update_last_used)\n  end\n\n  # GenServer callbacks\n\n  @impl GenServer\n  def init(provider) do\n    case establish_connection(provider) do\n      {:ok, socket} ->\n        state = %__MODULE__{\n          socket: socket,\n          provider: provider,\n          last_used: System.monotonic_time(:millisecond),\n          protocol: provider.protocol,\n          host: provider.host,\n          port: provider.port,\n          buffer: \"\"\n        }\n\n        {:ok, state}\n\n      {:error, reason} ->\n        {:stop, {:error, reason}}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:call_tool, tool_name, args, timeout}, _from, state) do\n    case execute_tool_call(tool_name, args, state, timeout) do\n      {:ok, result} ->\n        new_state = %{state | last_used: System.monotonic_time(:millisecond)}\n        {:reply, {:ok, result}, new_state}\n\n      {:error, reason} ->\n        {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:call_tool_stream, tool_name, args, timeout}, _from, state) do\n    case execute_tool_stream(tool_name, args, state, timeout) do\n      {:ok, stream} ->\n        new_state = %{state | last_used: System.monotonic_time(:millisecond)}\n        {:reply, {:ok, stream}, new_state}\n\n      {:error, reason} ->\n        {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call(:close, _from, state) do\n    if state.socket do\n      :gen_tcp.close(state.socket)\n    end\n\n    {:reply, :ok, state}\n  end\n\n  @impl GenServer\n  def handle_call(:get_last_used, _from, state) do\n    {:reply, state.last_used, state}\n  end\n\n  @impl GenServer\n  def handle_cast(:update_last_used, state) do\n    new_state = %{state | last_used: System.monotonic_time(:millisecond)}\n    {:noreply, new_state}\n  end\n\n  @impl GenServer\n  def handle_info({:tcp, _socket, data}, state) do\n    new_buffer = state.buffer <> data\n    new_state = %{state | buffer: new_buffer}\n    {:noreply, new_state}\n  end\n\n  @impl GenServer\n  def handle_info({:tcp_closed, _socket}, state) do\n    {:stop, :normal, state}\n  end\n\n  @impl GenServer\n  def handle_info({:udp, _socket, _ip, _port, data}, state) do\n    new_buffer = state.buffer <> data\n    new_state = %{state | buffer: new_buffer}\n    {:noreply, new_state}\n  end\n\n  @impl GenServer\n  def handle_info({:udp_error, _socket, reason}, state) do\n    {:stop, reason, state}\n  end\n\n  # Private functions\n\n  defp establish_connection(provider) do\n    case provider.protocol do\n      :tcp -> establish_tcp_connection(provider)\n      :udp -> establish_udp_connection(provider)\n      _ -> {:error, \"Unsupported protocol: #{provider.protocol}\"}\n    end\n  end\n\n  defp establish_tcp_connection(provider) do\n    host = String.to_charlist(provider.host)\n    port = provider.port\n    timeout = Map.get(provider, :timeout, 5000)\n\n    case :gen_tcp.connect(host, port, [:binary, active: true], timeout) do\n      {:ok, socket} -> {:ok, socket}\n      {:error, reason} -> {:error, \"TCP connection failed: #{inspect(reason)}\"}\n    end\n  end\n\n  defp establish_udp_connection(provider) do\n    case :gen_udp.open(0) do\n      {:ok, socket} ->\n        # Try to send a test packet to verify connectivity\n        case :gen_udp.send(socket, to_charlist(provider.host), provider.port, \"test\") do\n          :ok ->\n            {:ok, socket}\n\n          {:error, reason} ->\n            :gen_udp.close(socket)\n            {:error, \"UDP connection failed: #{inspect(reason)}\"}\n        end\n\n      {:error, reason} ->\n        {:error, \"UDP socket creation failed: #{inspect(reason)}\"}\n    end\n  end\n\n  defp execute_tool_call(tool_name, args, state, timeout) do\n    message = build_message(tool_name, args, state.provider)\n\n    case send_message(message, state) do\n      {:ok, _} ->\n        case receive_response(timeout) do\n          {:ok, response} ->\n            case parse_response(response) do\n              {:ok, result} -> {:ok, result}\n              {:error, reason} -> {:error, \"Failed to parse response: #{inspect(reason)}\"}\n            end\n\n          {:error, reason} ->\n            {:error, \"Failed to receive response: #{inspect(reason)}\"}\n        end\n\n      {:error, reason} ->\n        {:error, \"Failed to send message: #{inspect(reason)}\"}\n    end\n  end\n\n  defp execute_tool_stream(tool_name, args, state, timeout) do\n    message = build_message(tool_name, args, state.provider)\n\n    case send_message(message, state) do\n      {:ok, _} ->\n        # For streaming, we'll simulate by returning a stream of chunks\n        stream = create_stream_from_response(state, timeout)\n        {:ok, stream}\n\n      {:error, reason} ->\n        {:error, \"Failed to send message: #{inspect(reason)}\"}\n    end\n  end\n\n  defp build_message(tool_name, args, provider) do\n    %{\n      tool: tool_name,\n      args: args,\n      timestamp: System.monotonic_time(:millisecond),\n      protocol: provider.protocol\n    }\n  end\n\n  defp send_message(message, state) do\n    encoded_message = Jason.encode!(message)\n\n    case state.protocol do\n      :tcp -> send_tcp_message(encoded_message, state)\n      :udp -> send_udp_message(encoded_message, state)\n    end\n  end\n\n  defp send_tcp_message(message, state) do\n    case :gen_tcp.send(state.socket, message) do\n      :ok -> {:ok, :sent}\n      {:error, reason} -> {:error, \"TCP send failed: #{inspect(reason)}\"}\n    end\n  end\n\n  defp send_udp_message(message, state) do\n    host = String.to_charlist(state.host)\n    port = state.port\n\n    case :gen_udp.send(state.socket, host, port, message) do\n      :ok -> {:ok, :sent}\n      {:error, reason} -> {:error, \"UDP send failed: #{inspect(reason)}\"}\n    end\n  end\n\n  defp receive_response(timeout) do\n    receive do\n      {:tcp, _socket, data} -> {:ok, data}\n      {:udp, _socket, _ip, _port, data} -> {:ok, data}\n    after\n      timeout -> {:error, :timeout}\n    end\n  end\n\n  defp parse_response(response) do\n    case Jason.decode(response) do\n      {:ok, data} -> {:ok, data}\n      {:error, reason} -> {:error, \"JSON decode failed: #{inspect(reason)}\"}\n    end\n  end\n\n  defp create_stream_from_response(state, timeout) do\n    Stream.resource(\n      fn -> {state, timeout} end,\n      fn {state, remaining_timeout} ->\n        case receive_response(remaining_timeout) do\n          {:ok, data} ->\n            case parse_response(data) do\n              {:ok, result} ->\n                {[%{type: :stream, data: result}], {state, remaining_timeout}}\n\n              {:error, _} ->\n                {[%{type: :error, error: \"Parse error\"}], {state, remaining_timeout}}\n            end\n\n          {:error, :timeout} ->\n            {[%{type: :end}], {state, 0}}\n\n          {:error, reason} ->\n            {[%{type: :error, error: reason}], {state, 0}}\n        end\n      end,\n      fn _state -> :ok end\n    )\n  end\nend\n",
      "line_count": 295,
      "word_count": 760,
      "title": "Connection.Ex",
      "summary": "defmodule ExUtcp.Transports.TcpUdp.Connection do @moduledoc \"\"\"",
      "key_terms": [
        "open",
        "reason",
        "close",
        "we",
        "cast",
        "error",
        "receive",
        "Utcp",
        "Unsupported",
        "packet",
        "It",
        "connect",
        "reply",
        "Jason",
        "low",
        "if",
        "serialization",
        "Connection",
        "streaming",
        "returning"
      ],
      "timestamp": "2025-12-24T18:56:01.981144"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\tcp_udp\\connection_behaviour.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.TcpUdp.ConnectionBehaviour do\n  @moduledoc \"\"\"\n  Behaviour for TCP/UDP connections to enable mocking in tests.\n  \"\"\"\n\n  @callback start_link(provider :: map()) :: {:ok, pid()} | {:error, term()}\n  @callback call_tool(conn :: pid(), tool_name :: String.t(), args :: map(), timeout :: integer()) ::\n              {:ok, any()} | {:error, term()}\n  @callback call_tool_stream(\n              conn :: pid(),\n              tool_name :: String.t(),\n              args :: map(),\n              timeout :: integer()\n            ) :: {:ok, Enumerable.t()} | {:error, term()}\n  @callback close(conn :: pid()) :: :ok | {:error, term()}\n  @callback get_last_used(conn :: pid()) :: integer()\n  @callback update_last_used(conn :: pid()) :: :ok\n\n  defmacro __using__(_opts) do\n    quote do\n      @behaviour ExUtcp.Transports.TcpUdp.ConnectionBehaviour\n    end\n  end\nend\n",
      "line_count": 25,
      "word_count": 96,
      "title": "Connection Behaviour.Ex",
      "summary": "defmodule ExUtcp.Transports.TcpUdp.ConnectionBehaviour do @moduledoc \"\"\"",
      "key_terms": [
        "ExUtcp",
        "close",
        "any",
        "error",
        "pid",
        "end",
        "Transports",
        "behaviour",
        "mocking",
        "Utcp",
        "TCP",
        "map",
        "ok",
        "callback",
        "do",
        "for",
        "tests",
        "integer",
        "timeout",
        "String"
      ],
      "timestamp": "2025-12-24T18:56:02.003328"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\tcp_udp\\pool.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.TcpUdp.Pool do\n  @moduledoc \"\"\"\n  Manages a pool of TCP/UDP connections.\n\n  This module provides connection pooling for TCP/UDP connections to improve\n  performance and resource management.\n  \"\"\"\n\n  use GenServer\n  use ExUtcp.Transports.TcpUdp.PoolBehaviour\n\n  alias ExUtcp.Transports.TcpUdp.Connection\n  alias ExUtcp.Transports.TcpUdp.PoolBehaviour\n\n  defstruct [\n    :connections,\n    :max_connections,\n    :connection_timeout\n  ]\n\n  @impl PoolBehaviour\n  def start_link(opts \\\\ []) do\n    GenServer.start_link(__MODULE__, opts)\n  end\n\n  @impl PoolBehaviour\n  def get_connection(pool_pid, provider) do\n    GenServer.call(pool_pid, {:get_connection, provider})\n  end\n\n  @impl PoolBehaviour\n  def close_connection(pool_pid, conn_pid) do\n    GenServer.call(pool_pid, {:close_connection, conn_pid})\n  end\n\n  @impl PoolBehaviour\n  def close_all_connections(pool_pid) do\n    GenServer.call(pool_pid, :close_all_connections)\n  end\n\n  @impl PoolBehaviour\n  def stats(pool_pid) do\n    GenServer.call(pool_pid, :stats)\n  end\n\n  # GenServer callbacks\n\n  @impl GenServer\n  def init(opts) do\n    max_connections = Keyword.get(opts, :max_connections, 10)\n    connection_timeout = Keyword.get(opts, :connection_timeout, 30_000)\n\n    state = %__MODULE__{\n      connections: %{},\n      max_connections: max_connections,\n      connection_timeout: connection_timeout\n    }\n\n    {:ok, state}\n  end\n\n  @impl GenServer\n  def handle_call({:get_connection, provider}, _from, state) do\n    case get_or_create_connection(provider, state) do\n      {:ok, conn_pid, new_state} ->\n        {:reply, {:ok, conn_pid}, new_state}\n\n      {:error, reason} ->\n        {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:close_connection, conn_pid}, _from, state) do\n    case Map.get(state.connections, conn_pid) do\n      nil ->\n        {:reply, {:error, :not_found}, state}\n\n      _provider ->\n        Connection.close(conn_pid)\n        new_connections = Map.delete(state.connections, conn_pid)\n        new_state = %{state | connections: new_connections}\n        {:reply, :ok, new_state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call(:close_all_connections, _from, state) do\n    Enum.each(state.connections, fn {conn_pid, _provider} ->\n      Connection.close(conn_pid)\n    end)\n\n    new_state = %{state | connections: %{}}\n    {:reply, :ok, new_state}\n  end\n\n  @impl GenServer\n  def handle_call(:stats, _from, state) do\n    stats = %{\n      total_connections: map_size(state.connections),\n      max_connections: state.max_connections,\n      connection_timeout: state.connection_timeout\n    }\n\n    {:reply, stats, state}\n  end\n\n  # Private functions\n\n  defp get_or_create_connection(provider, state) do\n    # Check if we already have a connection for this provider\n    case find_existing_connection(provider, state) do\n      {:ok, conn_pid} ->\n        {:ok, conn_pid, state}\n\n      :not_found ->\n        create_new_connection(provider, state)\n    end\n  end\n\n  defp find_existing_connection(provider, state) do\n    case Enum.find(state.connections, fn {_pid, conn_provider} ->\n           conn_provider.name == provider.name and conn_provider.protocol == provider.protocol\n         end) do\n      {conn_pid, _provider} -> {:ok, conn_pid}\n      nil -> :not_found\n    end\n  end\n\n  defp create_new_connection(provider, state) do\n    if map_size(state.connections) >= state.max_connections do\n      {:error, \"Maximum connections reached\"}\n    else\n      case Connection.start_link(provider) do\n        {:ok, conn_pid} ->\n          new_connections = Map.put(state.connections, conn_pid, provider)\n          new_state = %{state | connections: new_connections}\n          {:ok, conn_pid, new_state}\n\n        {:error, reason} ->\n          {:error, \"Failed to create connection: #{inspect(reason)}\"}\n      end\n    end\n  end\nend\n",
      "line_count": 146,
      "word_count": 337,
      "title": "Pool.Ex",
      "summary": "defmodule ExUtcp.Transports.TcpUdp.Pool do @moduledoc \"\"\"",
      "key_terms": [
        "ExUtcp",
        "reason",
        "close",
        "we",
        "each",
        "error",
        "state",
        "delete",
        "Maximum",
        "Transports",
        "module",
        "PoolBehaviour",
        "performance",
        "def",
        "end",
        "Map",
        "find",
        "pool",
        "create",
        "Utcp"
      ],
      "timestamp": "2025-12-24T18:56:02.028677"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\tcp_udp\\pool_behaviour.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.TcpUdp.PoolBehaviour do\n  @moduledoc \"\"\"\n  Behaviour for TCP/UDP connection pools to enable mocking in tests.\n  \"\"\"\n\n  @callback start_link(opts :: keyword()) :: {:ok, pid()} | {:error, term()}\n  @callback get_connection(pool_pid :: pid(), provider :: map()) ::\n              {:ok, pid()} | {:error, term()}\n  @callback close_connection(pool_pid :: pid(), conn_pid :: pid()) :: :ok | {:error, term()}\n  @callback close_all_connections(pool_pid :: pid()) :: :ok | {:error, term()}\n  @callback stats(pool_pid :: pid()) :: map()\n\n  defmacro __using__(_opts) do\n    quote do\n      @behaviour ExUtcp.Transports.TcpUdp.PoolBehaviour\n    end\n  end\nend\n",
      "line_count": 19,
      "word_count": 76,
      "title": "Pool Behaviour.Ex",
      "summary": "defmodule ExUtcp.Transports.TcpUdp.PoolBehaviour do @moduledoc \"\"\"",
      "key_terms": [
        "ExUtcp",
        "error",
        "pid",
        "end",
        "Transports",
        "behaviour",
        "PoolBehaviour",
        "mocking",
        "Utcp",
        "TCP",
        "ok",
        "map",
        "callback",
        "do",
        "for",
        "tests",
        "keyword",
        "pools",
        "moduledoc",
        "quote"
      ],
      "timestamp": "2025-12-24T18:56:02.044520"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\tcp_udp\\testable.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.TcpUdp.Testable do\n  @moduledoc \"\"\"\n  Testable module for TCP/UDP transport to enable mocking in tests.\n\n  This module provides a way to inject mocks for the TCP/UDP transport components\n  during testing, allowing for isolated unit tests.\n  \"\"\"\n\n  alias ExUtcp.Transports.TcpUdp.{Connection, Pool}\n\n  @doc \"\"\"\n  Sets the mock modules for testing.\n  \"\"\"\n  def set_mocks(connection_behaviour, pool_behaviour) do\n    # Store the behaviours in application env for the transport to use\n    Application.put_env(:ex_utcp, :tcp_udp_connection_behaviour, connection_behaviour)\n    Application.put_env(:ex_utcp, :tcp_udp_pool_behaviour, pool_behaviour)\n    :ok\n  end\n\n  @doc \"\"\"\n  Gets the mock module for connections.\n  \"\"\"\n  def get_connection_mock do\n    Application.get_env(:ex_utcp, :tcp_udp_connection_mock, Connection)\n  end\n\n  @doc \"\"\"\n  Gets the mock module for pools.\n  \"\"\"\n  def get_pool_mock do\n    Application.get_env(:ex_utcp, :tcp_udp_pool_mock, Pool)\n  end\n\n  @doc \"\"\"\n  Clears all mocks.\n  \"\"\"\n  def clear_mocks do\n    # Mox doesn't have a clear function, so we just return :ok\n    :ok\n  end\n\n  @doc \"\"\"\n  Creates a mock connection for testing.\n  \"\"\"\n  def create_mock_connection(provider) do\n    connection_mock = get_connection_mock()\n    connection_mock.start_link(provider)\n  end\n\n  @doc \"\"\"\n  Creates a mock pool for testing.\n  \"\"\"\n  def create_mock_pool(opts \\\\ []) do\n    pool_mock = get_pool_mock()\n    pool_mock.start_link(opts)\n  end\n\n  @doc \"\"\"\n  Mocks a tool call response.\n  \"\"\"\n  def mock_tool_call_response(tool_name, args, response) do\n    # This would be used by the mock modules to return predefined responses\n    %{\n      tool: tool_name,\n      args: args,\n      response: response,\n      timestamp: System.monotonic_time(:millisecond)\n    }\n  end\n\n  @doc \"\"\"\n  Mocks a tool stream response.\n  \"\"\"\n  def mock_tool_stream_response(tool_name, args, stream_data) do\n    # This would be used by the mock modules to return predefined stream responses\n    stream =\n      Stream.map(stream_data, fn data ->\n        %{\n          type: :stream,\n          data: data,\n          tool: tool_name,\n          timestamp: System.monotonic_time(:millisecond)\n        }\n      end)\n\n    %{\n      tool: tool_name,\n      args: args,\n      stream: stream,\n      timestamp: System.monotonic_time(:millisecond)\n    }\n  end\n\n  @doc \"\"\"\n  Mocks a connection error.\n  \"\"\"\n  def mock_connection_error(reason) do\n    {:error, reason}\n  end\n\n  @doc \"\"\"\n  Mocks a pool error.\n  \"\"\"\n  def mock_pool_error(reason) do\n    {:error, reason}\n  end\n\n  @doc \"\"\"\n  Validates a TCP provider configuration.\n  \"\"\"\n  def validate_tcp_provider(provider) do\n    required_fields = [:name, :host, :port, :protocol]\n\n    case Enum.find(required_fields, &(not Map.has_key?(provider, &1))) do\n      nil -> :ok\n      field -> {:error, \"TCP provider missing required field: #{field}\"}\n    end\n  end\n\n  @doc \"\"\"\n  Validates a UDP provider configuration.\n  \"\"\"\n  def validate_udp_provider(provider) do\n    required_fields = [:name, :host, :port, :protocol]\n\n    case Enum.find(required_fields, &(not Map.has_key?(provider, &1))) do\n      nil -> :ok\n      field -> {:error, \"UDP provider missing required field: #{field}\"}\n    end\n  end\n\n  @doc \"\"\"\n  Creates a test TCP provider.\n  \"\"\"\n  def create_test_tcp_provider(opts \\\\ []) do\n    %{\n      name: Keyword.get(opts, :name, \"test_tcp\"),\n      type: :tcp,\n      protocol: :tcp,\n      host: Keyword.get(opts, :host, \"localhost\"),\n      port: Keyword.get(opts, :port, 8080),\n      timeout: Keyword.get(opts, :timeout, 5000),\n      auth: Keyword.get(opts, :auth, nil)\n    }\n  end\n\n  @doc \"\"\"\n  Creates a test UDP provider.\n  \"\"\"\n  def create_test_udp_provider(opts \\\\ []) do\n    %{\n      name: Keyword.get(opts, :name, \"test_udp\"),\n      type: :udp,\n      protocol: :udp,\n      host: Keyword.get(opts, :host, \"localhost\"),\n      port: Keyword.get(opts, :port, 8080),\n      timeout: Keyword.get(opts, :timeout, 5000),\n      auth: Keyword.get(opts, :auth, nil)\n    }\n  end\n\n  @doc \"\"\"\n  Creates a test tool.\n  \"\"\"\n  def create_test_tool(opts \\\\ []) do\n    %{\n      name: Keyword.get(opts, :name, \"test_tool\"),\n      description: Keyword.get(opts, :description, \"A test tool\"),\n      inputs: %{\n        type: \"object\",\n        properties: %{\n          \"message\" => %{\n            type: \"string\",\n            description: \"The message to send\"\n          }\n        },\n        required: [\"message\"]\n      },\n      outputs: %{\n        type: \"object\",\n        properties: %{\n          \"response\" => %{\n            type: \"string\",\n            description: \"The response from the tool\"\n          }\n        },\n        required: [\"response\"]\n      },\n      tags: Keyword.get(opts, :tags, [\"test\"]),\n      average_response_size: Keyword.get(opts, :average_response_size, 100),\n      provider: Keyword.get(opts, :provider, create_test_tcp_provider())\n    }\n  end\nend\n",
      "line_count": 196,
      "word_count": 516,
      "title": "Testable.Ex",
      "summary": "defmodule ExUtcp.Transports.TcpUdp.Testable do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "Mocks",
        "we",
        "clear",
        "localhost",
        "error",
        "Utcp",
        "during",
        "string",
        "behaviours",
        "application",
        "Sets",
        "Creates",
        "Connection",
        "Pool",
        "UDP",
        "object",
        "function",
        "description",
        "modules"
      ],
      "timestamp": "2025-12-24T18:56:02.076112"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\webrtc\\connection.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.WebRTC.Connection do\n  @moduledoc \"\"\"\n  WebRTC peer connection management for UTCP.\n\n  Handles:\n  - Peer connection establishment with signaling\n  - ICE candidate exchange and NAT traversal\n  - Data channel creation and management\n  - Tool call communication over data channels\n  \"\"\"\n\n  use GenServer\n\n  alias ExUtcp.Transports.WebRTC.Signaling\n  alias ExWebRTC.PeerConnection\n\n  require Logger\n\n  @enforce_keys [:provider, :signaling_server, :ice_servers]\n  defstruct [\n    :provider,\n    :signaling_server,\n    :ice_servers,\n    :peer_connection,\n    :data_channel,\n    :signaling_pid,\n    :connection_state,\n    :ice_connection_state,\n    :pending_calls,\n    :call_id_counter\n  ]\n\n  @type t :: %__MODULE__{\n          provider: map(),\n          signaling_server: String.t(),\n          ice_servers: [map()],\n          peer_connection: pid() | nil,\n          data_channel: pid() | nil,\n          signaling_pid: pid() | nil,\n          connection_state: atom(),\n          ice_connection_state: atom(),\n          pending_calls: %{String.t() => pid()},\n          call_id_counter: integer()\n        }\n\n  @doc \"\"\"\n  Starts a new WebRTC connection.\n  \"\"\"\n  @spec start_link(map(), String.t(), [map()]) :: {:ok, pid()} | {:error, term()}\n  def start_link(provider, signaling_server, ice_servers) do\n    GenServer.start_link(__MODULE__, {provider, signaling_server, ice_servers})\n  end\n\n  @doc \"\"\"\n  Calls a tool over the WebRTC data channel.\n  \"\"\"\n  @spec call_tool(pid(), String.t(), map(), integer()) :: {:ok, map()} | {:error, term()}\n  def call_tool(pid, tool_name, args, timeout \\\\ 30_000) do\n    GenServer.call(pid, {:call_tool, tool_name, args}, timeout)\n  end\n\n  @doc \"\"\"\n  Calls a tool stream over the WebRTC data channel.\n  \"\"\"\n  @spec call_tool_stream(pid(), String.t(), map(), integer()) ::\n          {:ok, Stream.t()} | {:error, term()}\n  def call_tool_stream(pid, tool_name, args, timeout \\\\ 30_000) do\n    GenServer.call(pid, {:call_tool_stream, tool_name, args}, timeout)\n  end\n\n  @doc \"\"\"\n  Closes the WebRTC connection.\n  \"\"\"\n  @spec close(pid()) :: :ok\n  def close(pid) do\n    GenServer.stop(pid)\n  end\n\n  @doc \"\"\"\n  Gets the connection state.\n  \"\"\"\n  @spec get_connection_state(pid()) :: atom()\n  def get_connection_state(pid) do\n    GenServer.call(pid, :get_connection_state)\n  end\n\n  @doc \"\"\"\n  Gets the ICE connection state.\n  \"\"\"\n  @spec get_ice_connection_state(pid()) :: atom()\n  def get_ice_connection_state(pid) do\n    GenServer.call(pid, :get_ice_connection_state)\n  end\n\n  # GenServer callbacks\n\n  @impl GenServer\n  def init({provider, signaling_server, ice_servers}) do\n    state = %__MODULE__{\n      provider: provider,\n      signaling_server: signaling_server,\n      ice_servers: ice_servers,\n      peer_connection: nil,\n      data_channel: nil,\n      signaling_pid: nil,\n      connection_state: :new,\n      ice_connection_state: :new,\n      pending_calls: %{},\n      call_id_counter: 0\n    }\n\n    # Start connection establishment asynchronously\n    send(self(), :establish_connection)\n\n    {:ok, state}\n  end\n\n  @impl GenServer\n  def handle_call({:call_tool, tool_name, args}, from, state) do\n    if state.connection_state == :connected and state.data_channel != nil do\n      # Generate unique call ID\n      call_id = \"call_#{state.call_id_counter}\"\n\n      # Create tool call message\n      message = %{\n        id: call_id,\n        type: \"tool_call\",\n        tool: tool_name,\n        args: args\n      }\n\n      # Send message over data channel\n      case send_data_channel_message(state.peer_connection, state.data_channel, message) do\n        :ok ->\n          # Store pending call\n          new_pending_calls = Map.put(state.pending_calls, call_id, from)\n\n          new_state = %{\n            state\n            | pending_calls: new_pending_calls,\n              call_id_counter: state.call_id_counter + 1\n          }\n\n          {:noreply, new_state}\n\n        {:error, reason} ->\n          {:reply, {:error, \"Failed to send message: #{inspect(reason)}\"}, state}\n      end\n    else\n      {:reply, {:error, \"Connection not ready. State: #{state.connection_state}\"}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:call_tool_stream, tool_name, args}, _from, state) do\n    if state.connection_state == :connected and state.data_channel != nil do\n      # For streaming, we'll create a stream that polls for chunks\n      stream = create_polling_stream(state.peer_connection, state.data_channel, tool_name, args)\n      {:reply, {:ok, stream}, state}\n    else\n      {:reply, {:error, \"Connection not ready. State: #{state.connection_state}\"}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call(:get_connection_state, _from, state) do\n    {:reply, state.connection_state, state}\n  end\n\n  @impl GenServer\n  def handle_call(:get_ice_connection_state, _from, state) do\n    {:reply, state.ice_connection_state, state}\n  end\n\n  @impl GenServer\n  def handle_info(:establish_connection, state) do\n    Logger.info(\"Establishing WebRTC connection for provider: #{state.provider.name}\")\n\n    try do\n      # Create peer connection\n      {:ok, pc} =\n        PeerConnection.start_link(\n          ice_servers: state.ice_servers,\n          ice_transport_policy: :all\n        )\n\n      # Create data channel\n      {:ok, dc} =\n        PeerConnection.create_data_channel(pc, \"utcp_channel\", %{\n          ordered: true,\n          max_retransmits: 3\n        })\n\n      # Connect to signaling server\n      {:ok, signaling_pid} = Signaling.start_link(state.signaling_server, self())\n\n      # Create and send offer\n      {:ok, offer} = PeerConnection.create_offer(pc)\n      :ok = PeerConnection.set_local_description(pc, offer)\n\n      # Send offer through signaling\n      :ok = Signaling.send_offer(signaling_pid, offer, state.provider.peer_id)\n\n      new_state = %{\n        state\n        | peer_connection: pc,\n          data_channel: dc,\n          signaling_pid: signaling_pid,\n          connection_state: :connecting\n      }\n\n      {:noreply, new_state}\n    rescue\n      error ->\n        Logger.error(\"Failed to establish WebRTC connection: #{inspect(error)}\")\n        {:noreply, %{state | connection_state: :failed}}\n    end\n  end\n\n  @impl GenServer\n  def handle_info({:signaling, :answer, answer}, state) do\n    # Received answer from remote peer\n    case PeerConnection.set_remote_description(state.peer_connection, answer) do\n      :ok ->\n        Logger.info(\"Remote description set successfully\")\n        {:noreply, state}\n\n      {:error, reason} ->\n        Logger.error(\"Failed to set remote description: #{inspect(reason)}\")\n        {:noreply, %{state | connection_state: :failed}}\n    end\n  end\n\n  @impl GenServer\n  def handle_info({:signaling, :ice_candidate, candidate}, state) do\n    # Received ICE candidate from remote peer\n    case PeerConnection.add_ice_candidate(state.peer_connection, candidate) do\n      :ok ->\n        Logger.debug(\"ICE candidate added successfully\")\n        {:noreply, state}\n\n      {:error, reason} ->\n        Logger.warning(\"Failed to add ICE candidate: #{inspect(reason)}\")\n        {:noreply, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_info({:ex_webrtc, _pc, {:ice_candidate, candidate}}, state) do\n    # Local ICE candidate generated, send to remote peer\n    case Signaling.send_ice_candidate(state.signaling_pid, candidate, state.provider.peer_id) do\n      :ok ->\n        :ok\n\n      {:error, reason} ->\n        Logger.warning(\"Failed to send ICE candidate: #{inspect(reason)}\")\n    end\n\n    {:noreply, state}\n  end\n\n  @impl GenServer\n  def handle_info({:ex_webrtc, _pc, {:connection_state_change, new_state}}, state) do\n    Logger.info(\"WebRTC connection state changed: #{new_state}\")\n    {:noreply, %{state | connection_state: new_state}}\n  end\n\n  @impl GenServer\n  def handle_info({:ex_webrtc, _pc, {:ice_connection_state_change, new_state}}, state) do\n    Logger.info(\"ICE connection state changed: #{new_state}\")\n    {:noreply, %{state | ice_connection_state: new_state}}\n  end\n\n  @impl GenServer\n  def handle_info({:ex_webrtc, _dc, {:data, data}}, state) do\n    # Received data from data channel\n    case Jason.decode(data) do\n      {:ok, message} ->\n        handle_data_channel_message(message, state)\n\n      {:error, reason} ->\n        Logger.error(\"Failed to decode data channel message: #{inspect(reason)}\")\n        {:noreply, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_info({:ex_webrtc, _dc, :open}, state) do\n    Logger.info(\"Data channel opened\")\n    {:noreply, %{state | connection_state: :connected}}\n  end\n\n  @impl GenServer\n  def handle_info({:ex_webrtc, _dc, :closed}, state) do\n    Logger.info(\"Data channel closed\")\n    {:noreply, %{state | connection_state: :closed}}\n  end\n\n  @impl GenServer\n  def handle_info(msg, state) do\n    Logger.debug(\"Unhandled WebRTC message: #{inspect(msg)}\")\n    {:noreply, state}\n  end\n\n  # Private helper functions\n\n  defp handle_data_channel_message(%{\"id\" => call_id, \"type\" => \"response\", \"result\" => result}, state) do\n    # Handle tool call response\n    case Map.get(state.pending_calls, call_id) do\n      nil ->\n        Logger.warning(\"Received response for unknown call ID: #{call_id}\")\n        {:noreply, state}\n\n      from ->\n        GenServer.reply(from, {:ok, result})\n        new_pending_calls = Map.delete(state.pending_calls, call_id)\n        {:noreply, %{state | pending_calls: new_pending_calls}}\n    end\n  end\n\n  defp handle_data_channel_message(%{\"id\" => call_id, \"type\" => \"error\", \"error\" => error}, state) do\n    # Handle tool call error\n    case Map.get(state.pending_calls, call_id) do\n      nil ->\n        Logger.warning(\"Received error for unknown call ID: #{call_id}\")\n        {:noreply, state}\n\n      from ->\n        GenServer.reply(from, {:error, error})\n        new_pending_calls = Map.delete(state.pending_calls, call_id)\n        {:noreply, %{state | pending_calls: new_pending_calls}}\n    end\n  end\n\n  defp handle_data_channel_message(message, state) do\n    Logger.debug(\"Received unhandled data channel message: #{inspect(message)}\")\n    {:noreply, state}\n  end\n\n  defp send_data_channel_message(peer_connection, data_channel, message) do\n    case Jason.encode(message) do\n      {:ok, json} ->\n        # Use PeerConnection.send_data/4 with the data channel reference\n        PeerConnection.send_data(peer_connection, data_channel, json, :string)\n\n      {:error, reason} ->\n        {:error, \"Failed to encode message: #{inspect(reason)}\"}\n    end\n  end\n\n  defp create_polling_stream(peer_connection, data_channel, tool_name, args) do\n    # Create a stream that polls for streaming chunks\n    # This is a simplified implementation\n    Stream.resource(\n      fn ->\n        # Initialize: send streaming request\n        message = %{\n          id: \"stream_#{:rand.uniform(1_000_000)}\",\n          type: \"tool_call_stream\",\n          tool: tool_name,\n          args: args\n        }\n\n        send_data_channel_message(peer_connection, data_channel, message)\n        {peer_connection, data_channel, []}\n      end,\n      fn {pc, dc, buffer} ->\n        # Poll for chunks (simplified - in real implementation would use message handlers)\n        Process.sleep(10)\n\n        # Check if we have buffered chunks\n        if Enum.empty?(buffer) do\n          {:halt, {pc, dc, buffer}}\n        else\n          {[hd(buffer)], {pc, dc, tl(buffer)}}\n        end\n      end,\n      fn {_pc, _dc, _buffer} ->\n        # Cleanup\n        :ok\n      end\n    )\n  end\nend\n",
      "line_count": 385,
      "word_count": 1066,
      "title": "Connection.Ex",
      "summary": "defmodule ExUtcp.Transports.WebRTC.Connection do @moduledoc \"\"\"",
      "key_terms": [
        "open",
        "reason",
        "close",
        "we",
        "rand",
        "Closes",
        "error",
        "through",
        "id",
        "info",
        "Utcp",
        "helper",
        "unknown",
        "Remote",
        "reply",
        "Jason",
        "string",
        "if",
        "that",
        "Poll"
      ],
      "timestamp": "2025-12-24T18:56:02.123811"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\webrtc\\signaling.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.WebRTC.Signaling do\n  @moduledoc \"\"\"\n  WebRTC signaling server client for exchanging SDP and ICE candidates.\n\n  Handles communication with the signaling server for:\n  - SDP offer/answer exchange\n  - ICE candidate exchange\n  - Peer discovery and connection establishment\n  \"\"\"\n\n  use GenServer\n\n  require Logger\n\n  @enforce_keys [:server_url, :parent_pid]\n  defstruct [\n    :server_url,\n    :parent_pid,\n    :websocket_pid,\n    :peer_id,\n    :connection_state\n  ]\n\n  @type t :: %__MODULE__{\n          server_url: String.t(),\n          parent_pid: pid(),\n          websocket_pid: pid() | nil,\n          peer_id: String.t() | nil,\n          connection_state: atom()\n        }\n\n  @doc \"\"\"\n  Starts the signaling client.\n  \"\"\"\n  @spec start_link(String.t(), pid()) :: {:ok, pid()} | {:error, term()}\n  def start_link(server_url, parent_pid) do\n    GenServer.start_link(__MODULE__, {server_url, parent_pid})\n  end\n\n  @doc \"\"\"\n  Sends an SDP offer to the remote peer.\n  \"\"\"\n  @spec send_offer(pid(), map(), String.t()) :: :ok | {:error, term()}\n  def send_offer(pid, offer, peer_id) do\n    GenServer.call(pid, {:send_offer, offer, peer_id})\n  end\n\n  @doc \"\"\"\n  Sends an SDP answer to the remote peer.\n  \"\"\"\n  @spec send_answer(pid(), map(), String.t()) :: :ok | {:error, term()}\n  def send_answer(pid, answer, peer_id) do\n    GenServer.call(pid, {:send_answer, answer, peer_id})\n  end\n\n  @doc \"\"\"\n  Sends an ICE candidate to the remote peer.\n  \"\"\"\n  @spec send_ice_candidate(pid(), map(), String.t()) :: :ok | {:error, term()}\n  def send_ice_candidate(pid, candidate, peer_id) do\n    GenServer.call(pid, {:send_ice_candidate, candidate, peer_id})\n  end\n\n  @doc \"\"\"\n  Closes the signaling connection.\n  \"\"\"\n  @spec close(pid()) :: :ok\n  def close(pid) do\n    GenServer.stop(pid)\n  end\n\n  # GenServer callbacks\n\n  @impl GenServer\n  def init({server_url, parent_pid}) do\n    state = %__MODULE__{\n      server_url: server_url,\n      parent_pid: parent_pid,\n      websocket_pid: nil,\n      peer_id: nil,\n      connection_state: :disconnected\n    }\n\n    # Connect to signaling server asynchronously\n    send(self(), :connect_to_signaling_server)\n\n    {:ok, state}\n  end\n\n  @impl GenServer\n  def handle_call({:send_offer, offer, peer_id}, _from, state) do\n    message = %{\n      type: \"offer\",\n      sdp: offer.sdp,\n      to: peer_id,\n      from: state.peer_id\n    }\n\n    case send_signaling_message(state.websocket_pid, message) do\n      :ok -> {:reply, :ok, state}\n      {:error, reason} -> {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:send_answer, answer, peer_id}, _from, state) do\n    message = %{\n      type: \"answer\",\n      sdp: answer.sdp,\n      to: peer_id,\n      from: state.peer_id\n    }\n\n    case send_signaling_message(state.websocket_pid, message) do\n      :ok -> {:reply, :ok, state}\n      {:error, reason} -> {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:send_ice_candidate, candidate, peer_id}, _from, state) do\n    message = %{\n      type: \"ice_candidate\",\n      candidate: %{\n        candidate: candidate.candidate,\n        sdp_mid: candidate.sdp_mid,\n        sdp_m_line_index: candidate.sdp_m_line_index\n      },\n      to: peer_id,\n      from: state.peer_id\n    }\n\n    case send_signaling_message(state.websocket_pid, message) do\n      :ok -> {:reply, :ok, state}\n      {:error, reason} -> {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_info(:connect_to_signaling_server, state) do\n    Logger.info(\"Connecting to signaling server: #{state.server_url}\")\n\n    try do\n      # In a real implementation, this would establish a WebSocket connection\n      # For now, we'll simulate it\n      peer_id = generate_peer_id()\n\n      new_state = %{state | peer_id: peer_id, connection_state: :connected}\n\n      Logger.info(\"Connected to signaling server with peer ID: #{peer_id}\")\n      {:noreply, new_state}\n    rescue\n      error ->\n        Logger.error(\"Failed to connect to signaling server: #{inspect(error)}\")\n\n        # Retry after delay\n        Process.send_after(self(), :connect_to_signaling_server, 5000)\n        {:noreply, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_info({:websocket, :message, data}, state) do\n    # Handle incoming signaling messages\n    case Jason.decode(data) do\n      {:ok, message} ->\n        handle_signaling_message(message, state)\n\n      {:error, reason} ->\n        Logger.error(\"Failed to decode signaling message: #{inspect(reason)}\")\n        {:noreply, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_info(msg, state) do\n    Logger.debug(\"Unhandled signaling message: #{inspect(msg)}\")\n    {:noreply, state}\n  end\n\n  # Private functions\n\n  defp handle_signaling_message(%{\"type\" => \"answer\", \"sdp\" => sdp}, state) do\n    # Forward answer to parent (WebRTC connection)\n    answer = %{type: :answer, sdp: sdp}\n    send(state.parent_pid, {:signaling, :answer, answer})\n    {:noreply, state}\n  end\n\n  defp handle_signaling_message(%{\"type\" => \"ice_candidate\", \"candidate\" => candidate_data}, state) do\n    # Forward ICE candidate to parent\n    candidate = %{\n      candidate: candidate_data[\"candidate\"],\n      sdp_mid: candidate_data[\"sdp_mid\"],\n      sdp_m_line_index: candidate_data[\"sdp_m_line_index\"]\n    }\n\n    send(state.parent_pid, {:signaling, :ice_candidate, candidate})\n    {:noreply, state}\n  end\n\n  defp handle_signaling_message(message, state) do\n    Logger.debug(\"Unhandled signaling message type: #{inspect(message)}\")\n    {:noreply, state}\n  end\n\n  defp send_signaling_message(websocket_pid, message) do\n    if websocket_pid == nil do\n      {:error, \"Signaling connection not established\"}\n      # In a real implementation, send via WebSocket\n      # For now, we'll simulate success\n    else\n      case Jason.encode(message) do\n        {:ok, _json} ->\n          :ok\n\n        {:error, reason} ->\n          {:error, \"Failed to encode message: #{inspect(reason)}\"}\n      end\n    end\n  end\n\n  defp generate_peer_id do\n    # Generate a unique peer ID\n    \"peer_#{:crypto.strong_rand_bytes(8) |> Base.encode16(case: :lower)}\"\n  end\nend\n",
      "line_count": 228,
      "word_count": 617,
      "title": "Signaling.Ex",
      "summary": "defmodule ExUtcp.Transports.WebRTC.Signaling do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "lower",
        "close",
        "we",
        "Closes",
        "error",
        "Forward",
        "WebSocket",
        "info",
        "Utcp",
        "websocket",
        "connect",
        "reply",
        "Jason",
        "if",
        "established",
        "establishment",
        "term",
        "establish",
        "In"
      ],
      "timestamp": "2025-12-24T18:56:02.144983"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\websocket\\connection.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.WebSocket.Connection do\n  @moduledoc \"\"\"\n  WebSocket connection handler for UTCP transport.\n\n  This module handles individual WebSocket connections and implements\n  the WebSockex behavior for managing WebSocket state and messages.\n  \"\"\"\n\n  @behaviour ExUtcp.Transports.WebSocket.ConnectionBehaviour\n\n  use WebSockex\n\n  alias ExUtcp.Transports.WebSocket.ConnectionBehaviour\n\n  require Logger\n\n  defstruct [\n    :provider,\n    :transport_pid,\n    :message_queue,\n    :connection_state,\n    :last_ping,\n    :ping_interval\n  ]\n\n  @doc \"\"\"\n  Starts a new WebSocket connection.\n  \"\"\"\n  @impl ConnectionBehaviour\n  @spec start_link(map()) :: {:ok, pid()} | {:error, term()}\n  def start_link(provider) do\n    start_link(provider.url, provider, [])\n  end\n\n  @spec start_link(String.t(), map(), keyword()) :: {:ok, pid()} | {:error, term()}\n  def start_link(url, provider, opts \\\\ []) do\n    state = %__MODULE__{\n      provider: provider,\n      transport_pid: Keyword.get(opts, :transport_pid),\n      message_queue: :queue.new(),\n      connection_state: :connecting,\n      last_ping: nil,\n      ping_interval: Keyword.get(opts, :ping_interval, 30_000)\n    }\n\n    WebSockex.start_link(url, __MODULE__, state, opts)\n  end\n\n  @doc \"\"\"\n  Sends a message through the WebSocket connection.\n  \"\"\"\n  @spec send_message(pid(), String.t()) :: :ok | {:error, term()}\n  def send_message(pid, message) do\n    WebSockex.send_frame(pid, {:text, message})\n  end\n\n  @doc \"\"\"\n  Closes the WebSocket connection.\n  \"\"\"\n  @impl ConnectionBehaviour\n  @spec close(pid()) :: :ok\n  def close(pid) do\n    GenServer.stop(pid)\n  end\n\n  # WebSockex callbacks\n\n  @impl WebSockex\n  def handle_connect(conn, state) do\n    Logger.info(\"WebSocket connected to #{inspect(conn)}\")\n\n    # Start ping timer\n    if state.ping_interval > 0 do\n      Process.send_after(self(), :ping, state.ping_interval)\n    end\n\n    new_state = %{state | connection_state: :connected}\n    {:ok, new_state}\n  end\n\n  @impl WebSockex\n  def handle_disconnect(disconnect_map, state) do\n    Logger.info(\"WebSocket disconnected: #{inspect(disconnect_map)}\")\n\n    # Notify transport about disconnection\n    if state.transport_pid do\n      send(state.transport_pid, {:websocket, self(), :close})\n    end\n\n    new_state = %{state | connection_state: :disconnected}\n    {:ok, new_state}\n  end\n\n  @impl WebSockex\n  def handle_frame({:text, message}, state) do\n    Logger.debug(\"Received WebSocket message: #{message}\")\n\n    # Notify transport about incoming message\n    if state.transport_pid do\n      send(state.transport_pid, {:websocket, self(), {:text, message}})\n    end\n\n    # Add message to queue for synchronous operations\n    new_queue = :queue.in(message, state.message_queue)\n    new_state = %{state | message_queue: new_queue}\n    {:ok, new_state}\n  end\n\n  @impl WebSockex\n  def handle_frame({:binary, data}, state) do\n    Logger.debug(\"Received WebSocket binary data: #{inspect(data)}\")\n\n    # Notify transport about incoming binary data\n    if state.transport_pid do\n      send(state.transport_pid, {:websocket, self(), {:binary, data}})\n    end\n\n    {:ok, state}\n  end\n\n  @impl WebSockex\n  def handle_frame({:ping, payload}, state) do\n    Logger.debug(\"Received WebSocket ping: #{inspect(payload)}\")\n    {:reply, {:pong, payload}, state}\n  end\n\n  @impl WebSockex\n  def handle_frame({:pong, payload}, state) do\n    Logger.debug(\"Received WebSocket pong: #{inspect(payload)}\")\n    new_state = %{state | last_ping: :os.system_time(:millisecond)}\n    {:ok, new_state}\n  end\n\n  @impl WebSockex\n  def handle_info(:ping, state) do\n    case state.connection_state do\n      :connected ->\n        # Send ping frame\n        {:reply, {:ping, \"ping\"}, state}\n\n      _ ->\n        {:ok, state}\n    end\n  end\n\n  @impl WebSockex\n  def handle_info({:send_message, message}, state) do\n    {:reply, {:text, message}, state}\n  end\n\n  @impl WebSockex\n  def handle_info(:close, state) do\n    {:close, state}\n  end\n\n  @impl WebSockex\n  def handle_info(msg, state) do\n    Logger.warning(\"Unhandled WebSocket info: #{inspect(msg)}\")\n    {:ok, state}\n  end\n\n  @impl WebSockex\n  def terminate(reason, state) do\n    Logger.info(\"WebSocket connection terminated: #{inspect(reason)}\")\n\n    # Notify transport about termination\n    if state.transport_pid do\n      send(state.transport_pid, {:websocket, self(), {:error, reason}})\n    end\n\n    :ok\n  end\n\n  # Helper functions\n\n  @doc \"\"\"\n  Gets the next message from the message queue.\n  \"\"\"\n  @spec get_next_message(pid(), timeout()) :: {:ok, String.t()} | {:error, :timeout}\n  def get_next_message(pid, timeout \\\\ 5_000) do\n    case GenServer.call(pid, :get_next_message, timeout) do\n      {:ok, message} -> {:ok, message}\n      {:error, :empty} -> {:error, :timeout}\n      {:error, reason} -> {:error, reason}\n    end\n  end\n\n  @doc \"\"\"\n  Gets all messages from the message queue.\n  \"\"\"\n  @spec get_all_messages(pid()) :: [String.t()]\n  def get_all_messages(pid) do\n    GenServer.call(pid, :get_all_messages)\n  end\n\n  @doc \"\"\"\n  Clears the message queue.\n  \"\"\"\n  @spec clear_messages(pid()) :: :ok\n  def clear_messages(pid) do\n    GenServer.call(pid, :clear_messages)\n  end\n\n  @doc \"\"\"\n  Calls a tool through the WebSocket connection.\n  \"\"\"\n  @impl ConnectionBehaviour\n  @spec call_tool(pid(), String.t(), map(), keyword()) :: {:ok, map()} | {:error, term()}\n  def call_tool(pid, tool_name, args, opts \\\\ []) do\n    message = %{\n      type: \"tool_call\",\n      tool: tool_name,\n      args: args\n    }\n\n    case send_message(pid, Jason.encode!(message)) do\n      :ok ->\n        case get_next_message(pid, Keyword.get(opts, :timeout, 30_000)) do\n          {:ok, response} -> {:ok, response}\n          {:error, reason} -> {:error, reason}\n        end\n\n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\n\n  @doc \"\"\"\n  Calls a tool stream through the WebSocket connection.\n  \"\"\"\n  @impl ConnectionBehaviour\n  @spec call_tool_stream(pid(), String.t(), map(), keyword()) ::\n          {:ok, Enumerable.t()} | {:error, term()}\n  def call_tool_stream(pid, tool_name, args, opts \\\\ []) do\n    message = %{\n      type: \"tool_stream\",\n      tool: tool_name,\n      args: args\n    }\n\n    case send_message(pid, Jason.encode!(message)) do\n      :ok ->\n        stream =\n          Stream.unfold(nil, fn _ ->\n            case get_next_message(pid, Keyword.get(opts, :timeout, 5_000)) do\n              {:ok, %{\"type\" => \"stream_end\"}} -> nil\n              {:ok, data} -> {data, nil}\n              {:error, _} -> nil\n            end\n          end)\n\n        {:ok, stream}\n\n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\n\n  @doc \"\"\"\n  Gets the last used timestamp.\n  \"\"\"\n  @impl ConnectionBehaviour\n  @spec get_last_used(pid()) :: integer()\n  def get_last_used(pid) do\n    GenServer.call(pid, :get_last_used)\n  end\n\n  @doc \"\"\"\n  Updates the last used timestamp.\n  \"\"\"\n  @impl ConnectionBehaviour\n  @spec update_last_used(pid()) :: :ok\n  def update_last_used(pid) do\n    GenServer.cast(pid, :update_last_used)\n  end\n\n  # GenServer callbacks for message queue management\n\n  def handle_call(:get_next_message, _from, state) do\n    case :queue.out(state.message_queue) do\n      {{:value, message}, new_queue} ->\n        new_state = %{state | message_queue: new_queue}\n        {:reply, {:ok, message}, new_state}\n\n      {:empty, _} ->\n        {:reply, {:error, :empty}, state}\n    end\n  end\n\n  def handle_call(:get_all_messages, _from, state) do\n    messages = :queue.to_list(state.message_queue)\n    new_state = %{state | message_queue: :queue.new()}\n    {:reply, messages, new_state}\n  end\n\n  def handle_call(:clear_messages, _from, state) do\n    new_state = %{state | message_queue: :queue.new()}\n    {:reply, :ok, new_state}\n  end\n\n  def handle_call(:get_last_used, _from, state) do\n    {:reply, state.last_ping || System.monotonic_time(:millisecond), state}\n  end\n\n  def handle_call(msg, _from, state) do\n    Logger.warning(\"Unhandled WebSocket call: #{inspect(msg)}\")\n    {:reply, {:error, :not_implemented}, state}\n  end\n\n  @impl true\n  def handle_cast(:update_last_used, state) do\n    new_state = %{state | last_ping: System.monotonic_time(:millisecond)}\n    {:noreply, new_state}\n  end\n\n  def handle_cast(msg, state) do\n    Logger.warning(\"Unhandled WebSocket cast: #{inspect(msg)}\")\n    {:noreply, state}\n  end\nend\n",
      "line_count": 321,
      "word_count": 829,
      "title": "Connection.Ex",
      "summary": "defmodule ExUtcp.Transports.WebSocket.Connection do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "close",
        "Closes",
        "timer",
        "error",
        "cast",
        "through",
        "WebSocket",
        "info",
        "Utcp",
        "websocket",
        "reply",
        "Jason",
        "WebSockex",
        "keyword",
        "if",
        "synchronous",
        "behavior",
        "handler",
        "Connection"
      ],
      "timestamp": "2025-12-24T18:56:02.171166"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\websocket\\connection_behaviour.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.WebSocket.ConnectionBehaviour do\n  @moduledoc \"\"\"\n  Behaviour for WebSocket connections to enable mocking in tests.\n  \"\"\"\n\n  @callback start_link(provider :: map()) :: {:ok, pid()} | {:error, term()}\n  @callback call_tool(pid(), tool_name :: String.t(), args :: map(), opts :: keyword()) ::\n              {:ok, map()} | {:error, term()}\n  @callback call_tool_stream(pid(), tool_name :: String.t(), args :: map(), opts :: keyword()) ::\n              {:ok, Enumerable.t()} | {:error, term()}\n  @callback close(pid()) :: :ok | {:error, term()}\n  @callback get_last_used(pid()) :: integer()\n  @callback update_last_used(pid()) :: :ok\nend\n",
      "line_count": 15,
      "word_count": 75,
      "title": "Connection Behaviour.Ex",
      "summary": "defmodule ExUtcp.Transports.WebSocket.ConnectionBehaviour do @moduledoc \"\"\"",
      "key_terms": [
        "ExUtcp",
        "close",
        "error",
        "pid",
        "end",
        "Transports",
        "mocking",
        "WebSocket",
        "Utcp",
        "map",
        "ok",
        "callback",
        "do",
        "for",
        "tests",
        "keyword",
        "integer",
        "String",
        "moduledoc",
        "provider"
      ],
      "timestamp": "2025-12-24T18:56:02.171166"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\websocket\\connection_mock.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.WebSocket.ConnectionMock do\n  @moduledoc \"\"\"\n  Mock implementation for WebSocket connections in tests.\n  \"\"\"\n\n  @behaviour ExUtcp.Transports.WebSocket.ConnectionBehaviour\n\n  def start_link(_provider) do\n    {:ok, :mock_connection}\n  end\n\n  def call_tool(_pid, _tool_name, _args, _opts \\\\ []) do\n    {:ok, %{\"result\" => \"mock_result\"}}\n  end\n\n  def call_tool_stream(_pid, _tool_name, _args, _opts \\\\ []) do\n    {:ok, Stream.map([%{\"chunk\" => \"mock_data\"}], & &1)}\n  end\n\n  def close(_pid) do\n    :ok\n  end\n\n  def get_last_used(_pid) do\n    System.monotonic_time(:millisecond)\n  end\n\n  def update_last_used(_pid) do\n    :ok\n  end\nend\n",
      "line_count": 32,
      "word_count": 65,
      "title": "Connection Mock.Ex",
      "summary": "defmodule ExUtcp.Transports.WebSocket.ConnectionMock do @moduledoc \"\"\"",
      "key_terms": [
        "ExUtcp",
        "close",
        "chunk",
        "def",
        "end",
        "Transports",
        "behaviour",
        "WebSocket",
        "Utcp",
        "ok",
        "map",
        "for",
        "do",
        "tests",
        "moduledoc",
        "ConnectionMock",
        "Stream",
        "ConnectionBehaviour",
        "implementation",
        "millisecond"
      ],
      "timestamp": "2025-12-24T18:56:02.186980"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\lib\\ex_utcp\\transports\\websocket\\testable.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Transports.WebSocket.Testable do\n  @moduledoc \"\"\"\n  Testable version of WebSocket transport that can use mocks.\n  \"\"\"\n\n  use ExUtcp.Transports.Behaviour\n  use GenServer\n\n  alias ExUtcp.Auth\n  alias ExUtcp.Transports.WebSocket.Connection\n\n  require Logger\n\n  defstruct [\n    :logger,\n    :connection_timeout,\n    :connection_pool,\n    :retry_config,\n    :max_retries,\n    :retry_delay,\n    :genserver_module,\n    :connection_module\n  ]\n\n  @doc \"\"\"\n  Creates a new testable WebSocket transport.\n  \"\"\"\n  @spec new(keyword()) :: %__MODULE__{}\n  def new(opts \\\\ []) do\n    %__MODULE__{\n      logger: Keyword.get(opts, :logger, &Logger.info/1),\n      connection_timeout: Keyword.get(opts, :connection_timeout, 30_000),\n      connection_pool: %{},\n      retry_config: %{\n        max_retries: Keyword.get(opts, :max_retries, 3),\n        retry_delay: Keyword.get(opts, :retry_delay, 1000),\n        backoff_multiplier: Keyword.get(opts, :backoff_multiplier, 2)\n      },\n      max_retries: Keyword.get(opts, :max_retries, 3),\n      retry_delay: Keyword.get(opts, :retry_delay, 1000),\n      genserver_module: Keyword.get(opts, :genserver_module, __MODULE__),\n      connection_module: Keyword.get(opts, :connection_module, Connection)\n    }\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def register_tool_provider(provider) do\n    case provider.type do\n      :websocket -> discover_tools(provider)\n      _ -> {:error, \"WebSocket transport can only be used with WebSocket providers\"}\n    end\n  end\n\n  def register_tool_provider(transport, provider) do\n    case provider.type do\n      :websocket -> discover_tools(transport, provider)\n      _ -> {:error, \"WebSocket transport can only be used with WebSocket providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def deregister_tool_provider(provider) do\n    case provider.type do\n      :websocket -> close_connection(provider)\n      _ -> {:error, \"WebSocket transport can only be used with WebSocket providers\"}\n    end\n  end\n\n  def deregister_tool_provider(transport, provider) do\n    case provider.type do\n      :websocket -> close_connection(transport, provider)\n      _ -> {:error, \"WebSocket transport can only be used with WebSocket providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def call_tool(tool_name, args, provider) do\n    case provider.type do\n      :websocket -> execute_tool_call(tool_name, args, provider)\n      _ -> {:error, \"WebSocket transport can only be used with WebSocket providers\"}\n    end\n  end\n\n  def call_tool(transport, tool_name, args, provider) do\n    case provider.type do\n      :websocket -> execute_tool_call(transport, tool_name, args, provider)\n      _ -> {:error, \"WebSocket transport can only be used with WebSocket providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def call_tool_stream(tool_name, args, provider) do\n    case provider.type do\n      :websocket -> execute_tool_stream(tool_name, args, provider)\n      _ -> {:error, \"WebSocket transport can only be used with WebSocket providers\"}\n    end\n  end\n\n  def call_tool_stream(transport, tool_name, args, provider) do\n    case provider.type do\n      :websocket -> execute_tool_stream(transport, tool_name, args, provider)\n      _ -> {:error, \"WebSocket transport can only be used with WebSocket providers\"}\n    end\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def close do\n    :ok\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def transport_name do\n    \"websocket\"\n  end\n\n  @impl ExUtcp.Transports.Behaviour\n  def supports_streaming? do\n    true\n  end\n\n  # GenServer callbacks for connection management\n\n  def start_link(opts \\\\ []) do\n    genserver_module = Keyword.get(opts, :genserver_module, __MODULE__)\n    GenServer.start_link(genserver_module, opts, name: __MODULE__)\n  end\n\n  @impl GenServer\n  def init(opts) do\n    state = new(opts)\n    {:ok, state}\n  end\n\n  @impl GenServer\n  def handle_call({:get_connection, provider}, _from, state) do\n    case get_or_create_connection(provider, state) do\n      {:ok, conn, new_state} -> {:reply, {:ok, conn}, new_state}\n      {:error, reason} -> {:reply, {:error, reason}, state}\n    end\n  end\n\n  @impl GenServer\n  def handle_call({:close_connection, provider}, _from, state) do\n    new_state = close_connection_for_provider(provider, state)\n    {:reply, :ok, new_state}\n  end\n\n  @impl GenServer\n  def handle_call(:close_all, _from, state) do\n    new_state = close_all_connections(state)\n    {:reply, :ok, new_state}\n  end\n\n  @impl GenServer\n  def handle_info({:websocket, _conn, {:text, data}}, state) do\n    # Handle incoming WebSocket messages\n    Logger.debug(\"Received WebSocket message: #{data}\")\n    {:noreply, state}\n  end\n\n  @impl GenServer\n  def handle_info({:websocket, conn, :close}, state) do\n    # Handle WebSocket connection close\n    Logger.info(\"WebSocket connection closed: #{inspect(conn)}\")\n    new_state = remove_connection_from_pool(conn, state)\n    {:noreply, new_state}\n  end\n\n  @impl GenServer\n  def handle_info({:websocket, _conn, {:error, reason}}, state) do\n    # Handle WebSocket errors\n    Logger.error(\"WebSocket error: #{inspect(reason)}\")\n    {:noreply, state}\n  end\n\n  # Private functions\n\n  defp discover_tools(provider) do\n    retry_config = %{max_retries: 3, retry_delay: 1000, backoff_multiplier: 2}\n\n    with_retry(\n      fn ->\n        with {:ok, conn} <- get_or_create_connection(provider),\n             {:ok, tools} <- request_manual(conn, provider) do\n          {:ok, tools}\n        else\n          {:error, reason} -> {:error, \"Failed to discover tools: #{inspect(reason)}\"}\n        end\n      end,\n      retry_config\n    )\n  end\n\n  defp discover_tools(transport, provider) do\n    retry_config = %{max_retries: 3, retry_delay: 1000, backoff_multiplier: 2}\n\n    with_retry(\n      fn ->\n        case get_or_create_connection(transport, provider) do\n          {:ok, conn, _new_transport} ->\n            case request_manual(conn, provider) do\n              {:ok, tools} -> {:ok, tools}\n              {:error, reason} -> {:error, \"Failed to discover tools: #{inspect(reason)}\"}\n            end\n\n          {:error, reason} ->\n            {:error, \"Failed to discover tools: #{inspect(reason)}\"}\n        end\n      end,\n      retry_config\n    )\n  end\n\n  defp execute_tool_call(tool_name, args, provider) do\n    # Create a default transport for this call\n    transport = new()\n    execute_tool_call(transport, tool_name, args, provider)\n  end\n\n  defp execute_tool_call(transport, tool_name, args, provider) do\n    retry_config = %{max_retries: 3, retry_delay: 1000, backoff_multiplier: 2}\n\n    with_retry(\n      fn ->\n        case get_or_create_connection(transport, provider) do\n          {:ok, conn, _new_transport} ->\n            case send_tool_request(transport, conn, tool_name, args, provider) do\n              {:ok, result} -> {:ok, result}\n              {:error, reason} -> {:error, \"Failed to execute tool: #{inspect(reason)}\"}\n            end\n\n          {:error, reason} ->\n            {:error, \"Failed to execute tool: #{inspect(reason)}\"}\n        end\n      end,\n      retry_config\n    )\n  end\n\n  defp execute_tool_stream(tool_name, args, provider) do\n    # Create a default transport for this call\n    transport = new()\n    execute_tool_stream(transport, tool_name, args, provider)\n  end\n\n  defp execute_tool_stream(transport, tool_name, args, provider) do\n    retry_config = %{max_retries: 3, retry_delay: 1000, backoff_multiplier: 2}\n\n    with_retry(\n      fn ->\n        case get_or_create_connection(transport, provider) do\n          {:ok, conn, _new_transport} ->\n            case send_tool_stream_request(transport, conn, tool_name, args, provider) do\n              {:ok, stream_result} -> {:ok, stream_result}\n              {:error, reason} -> {:error, \"Failed to execute tool stream: #{inspect(reason)}\"}\n            end\n\n          {:error, reason} ->\n            {:error, \"Failed to execute tool stream: #{inspect(reason)}\"}\n        end\n      end,\n      retry_config\n    )\n  end\n\n  defp get_or_create_connection(provider) do\n    case GenServer.call(__MODULE__, {:get_connection, provider}) do\n      {:ok, conn} -> {:ok, conn}\n      {:error, reason} -> {:error, reason}\n    end\n  end\n\n  defp get_or_create_connection(transport, provider) do\n    connection_key = build_connection_key(provider)\n\n    case Map.get(transport.connection_pool, connection_key) do\n      nil ->\n        # For testing, simulate getting a connection using the injected mock\n        case transport.connection_module do\n          Connection ->\n            # Real connection - use the actual implementation\n            case establish_connection_for_transport(transport, provider) do\n              {:ok, conn} ->\n                new_pool = Map.put(transport.connection_pool, connection_key, conn)\n                new_transport = %{transport | connection_pool: new_pool}\n                {:ok, conn, new_transport}\n\n              {:error, reason} ->\n                {:error, reason}\n            end\n\n          _ ->\n            # Mock connection - return mock\n            {:ok, :mock_connection, transport}\n        end\n\n      conn ->\n        # Use existing connection\n        {:ok, conn, transport}\n    end\n  end\n\n  defp establish_connection_for_transport(transport, provider) do\n    headers = build_headers(provider)\n    headers = Auth.apply_to_headers(Map.get(provider, :auth), headers)\n\n    # Add WebSocket protocol if specified\n    headers =\n      if Map.get(provider, :protocol) do\n        Map.put(headers, \"Sec-WebSocket-Protocol\", Map.get(provider, :protocol))\n      else\n        headers\n      end\n\n    # Convert headers to the format expected by websockex\n    # Use existing atoms only to prevent DOS attacks\n    ws_headers = Enum.map(headers, fn {k, v} -> {safe_string_to_atom(k), v} end)\n\n    _opts = [\n      extra_headers: ws_headers,\n      timeout: transport.connection_timeout,\n      transport_pid: self(),\n      ping_interval: 30_000\n    ]\n\n    connection_module = transport.connection_module || Connection\n\n    case connection_module.start_link(provider) do\n      {:ok, conn} -> {:ok, conn}\n      {:error, reason} -> {:error, \"Failed to connect to WebSocket: #{inspect(reason)}\"}\n    end\n  end\n\n  defp build_connection_key(provider) do\n    \"#{provider.url}:#{provider.name}\"\n  end\n\n  defp build_headers(provider) do\n    base_headers = %{\n      \"User-Agent\" => \"ExUtcp/0.2.0\",\n      \"Accept\" => \"application/json\"\n    }\n\n    Map.merge(base_headers, Map.get(provider, :headers, %{}))\n  end\n\n  defp request_manual(conn, provider) do\n    # For testing, we'll simulate the manual request\n    # In a real implementation, this would use the connection module\n    case conn do\n      :mock_connection ->\n        # Mock response for testing\n        {:ok, [%{\"name\" => \"test_tool\", \"description\" => \"A test tool\"}]}\n\n      _ ->\n        # Real connection - use the actual implementation\n        connection_module = Connection\n\n        case connection_module.send_message(conn, \"manual\") do\n          :ok ->\n            case connection_module.get_next_message(conn, 5_000) do\n              {:ok, response} -> parse_manual_response(response, provider)\n              {:error, reason} -> {:error, reason}\n            end\n\n          {:error, reason} ->\n            {:error, \"Failed to send manual request: #{inspect(reason)}\"}\n        end\n    end\n  end\n\n  defp send_tool_request(transport, conn, tool_name, args, _provider) do\n    case conn do\n      :mock_connection ->\n        # Use the injected mock module\n        connection_module = transport.connection_module || Connection\n\n        case connection_module.call_tool(conn, tool_name, args, []) do\n          {:ok, result} -> {:ok, result}\n          {:error, reason} -> {:error, reason}\n        end\n\n      _ ->\n        # Real connection - use the actual implementation\n        connection_module = Connection\n\n        case Jason.encode(args) do\n          {:ok, json_data} ->\n            case connection_module.send_message(conn, json_data) do\n              :ok ->\n                case connection_module.get_next_message(conn, 30_000) do\n                  {:ok, response} -> parse_tool_response(response)\n                  {:error, reason} -> {:error, reason}\n                end\n\n              {:error, reason} ->\n                {:error, \"Failed to send tool request: #{inspect(reason)}\"}\n            end\n\n          {:error, reason} ->\n            {:error, \"Failed to encode arguments: #{inspect(reason)}\"}\n        end\n    end\n  end\n\n  defp send_tool_stream_request(transport, conn, _tool_name, args, _provider) do\n    case conn do\n      :mock_connection ->\n        # Use the injected mock module\n        connection_module = transport.connection_module || Connection\n\n        case connection_module.call_tool_stream(conn, \"stream_tool\", args, []) do\n          {:ok, stream} -> {:ok, stream}\n          {:error, reason} -> {:error, reason}\n        end\n\n      _ ->\n        # Real connection - use the actual implementation\n        connection_module = Connection\n\n        case Jason.encode(args) do\n          {:ok, json_data} ->\n            case connection_module.send_message(conn, json_data) do\n              :ok ->\n                # For streaming, we collect all messages until connection closes\n                collect_stream_messages(conn, [])\n\n              {:error, reason} ->\n                {:error, \"Failed to send tool request: #{inspect(reason)}\"}\n            end\n\n          {:error, reason} ->\n            {:error, \"Failed to encode arguments: #{inspect(reason)}\"}\n        end\n    end\n  end\n\n  defp collect_stream_messages(conn, acc) do\n    # Get all available messages from the connection\n    connection_module = Connection\n    messages = connection_module.get_all_messages(conn)\n\n    case messages do\n      [] ->\n        # No messages available, wait a bit and try again\n        Process.sleep(100)\n        collect_stream_messages(conn, acc)\n\n      msgs ->\n        # Process all messages\n        decoded_messages =\n          Enum.map(msgs, fn msg ->\n            case Jason.decode(msg) do\n              {:ok, decoded} -> decoded\n              {:error, _} -> msg\n            end\n          end)\n\n        new_acc = Enum.reverse(decoded_messages, acc)\n\n        # Check if we should continue collecting or return\n        if length(msgs) < 10 do\n          # Few messages, might be done\n          {:ok, %{type: :stream, data: Enum.reverse(new_acc)}}\n        else\n          # More messages available, continue collecting\n          collect_stream_messages(conn, new_acc)\n        end\n    end\n  end\n\n  defp parse_manual_response(response, provider) do\n    case Jason.decode(response) do\n      {:ok, data} ->\n        case data do\n          %{\"tools\" => tools} when is_list(tools) ->\n            normalized_tools = Enum.map(tools, &normalize_tool(&1, provider))\n            {:ok, normalized_tools}\n\n          _ ->\n            {:ok, []}\n        end\n\n      {:error, reason} ->\n        {:error, \"Failed to parse manual response: #{inspect(reason)}\"}\n    end\n  end\n\n  defp parse_tool_response(response) do\n    case Jason.decode(response) do\n      {:ok, data} -> {:ok, data}\n      {:error, reason} -> {:error, \"Failed to parse tool response: #{inspect(reason)}\"}\n    end\n  end\n\n  defp normalize_tool(tool_data, provider) do\n    ExUtcp.Tools.new_tool(\n      name: Map.get(tool_data, \"name\", \"\"),\n      description: Map.get(tool_data, \"description\", \"\"),\n      inputs: parse_schema(Map.get(tool_data, \"inputs\", %{})),\n      outputs: parse_schema(Map.get(tool_data, \"outputs\", %{})),\n      tags: Map.get(tool_data, \"tags\", []),\n      average_response_size: Map.get(tool_data, \"average_response_size\"),\n      provider: provider\n    )\n  end\n\n  defp parse_schema(schema_data) do\n    ExUtcp.Tools.new_schema(\n      type: Map.get(schema_data, \"type\", \"object\"),\n      properties: Map.get(schema_data, \"properties\", %{}),\n      required: Map.get(schema_data, \"required\", []),\n      description: Map.get(schema_data, \"description\", \"\"),\n      title: Map.get(schema_data, \"title\", \"\"),\n      items: Map.get(schema_data, \"items\", %{}),\n      enum: Map.get(schema_data, \"enum\", []),\n      minimum: Map.get(schema_data, \"minimum\"),\n      maximum: Map.get(schema_data, \"maximum\"),\n      format: Map.get(schema_data, \"format\", \"\")\n    )\n  end\n\n  defp close_connection(provider) do\n    GenServer.call(__MODULE__, {:close_connection, provider})\n  end\n\n  defp close_connection(transport, provider) do\n    connection_key = build_connection_key(provider)\n    connection_module = Application.get_env(:ex_utcp, :connection_module, Connection)\n\n    case Map.get(transport.connection_pool, connection_key) do\n      nil ->\n        :ok\n\n      conn ->\n        connection_module.close(conn)\n        :ok\n    end\n  end\n\n  defp close_connection_for_provider(provider, state) do\n    connection_key = build_connection_key(provider)\n    connection_module = Application.get_env(:ex_utcp, :connection_module, Connection)\n\n    case Map.get(state.connection_pool, connection_key) do\n      nil ->\n        state\n\n      conn ->\n        connection_module.close(conn)\n        new_pool = Map.delete(state.connection_pool, connection_key)\n        %{state | connection_pool: new_pool}\n    end\n  end\n\n  defp close_all_connections(state) do\n    connection_module = Application.get_env(:ex_utcp, :connection_module, Connection)\n\n    Enum.each(state.connection_pool, fn {_key, conn} ->\n      connection_module.close(conn)\n    end)\n\n    %{state | connection_pool: %{}}\n  end\n\n  defp remove_connection_from_pool(conn, state) do\n    # Find and remove the connection from the pool\n    new_pool =\n      Enum.reject(state.connection_pool, fn {_key, pool_conn} ->\n        pool_conn == conn\n      end)\n      |> Map.new()\n\n    %{state | connection_pool: new_pool}\n  end\n\n  # Retry logic with exponential backoff\n  defp with_retry(fun, retry_config) do\n    with_retry(fun, retry_config, 0)\n  end\n\n  defp with_retry(fun, retry_config, attempt) do\n    case fun.() do\n      {:ok, result} ->\n        {:ok, result}\n\n      {:error, _reason} when attempt < retry_config.max_retries ->\n        delay = retry_config.retry_delay * :math.pow(retry_config.backoff_multiplier, attempt)\n        :timer.sleep(round(delay))\n        with_retry(fun, retry_config, attempt + 1)\n\n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\n\n  # Additional functions for testing\n  def send_message(transport, message, provider) do\n    case get_or_create_connection(transport, provider) do\n      {:ok, conn, _new_transport} ->\n        connection_module = transport.connection_module || Connection\n        connection_module.send_message(conn, message)\n\n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\n\n  def get_next_message(transport, provider) do\n    case get_or_create_connection(transport, provider) do\n      {:ok, conn, _new_transport} ->\n        connection_module = transport.connection_module || Connection\n        connection_module.get_next_message(conn, 5000)\n\n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\n\n  def close(_transport) do\n    :ok\n  end\n\n  # Safe conversion to atom - only converts if atom already exists\n  # Falls back to string if atom doesn't exist to prevent atom table exhaustion\n  defp safe_string_to_atom(string) do\n    String.to_existing_atom(string)\n  rescue\n    ArgumentError ->\n      # Try lowercase version\n      try do\n        String.to_existing_atom(String.downcase(string))\n      rescue\n        ArgumentError -> string\n      end\n  end\nend\n",
      "line_count": 638,
      "word_count": 1796,
      "title": "Testable.Ex",
      "summary": "defmodule ExUtcp.Transports.WebSocket.Testable do @moduledoc \"\"\"",
      "key_terms": [
        "reason",
        "close",
        "we",
        "getting",
        "error",
        "headers",
        "timer",
        "exhaustion",
        "wait",
        "each",
        "WebSocket",
        "merge",
        "info",
        "format",
        "Utcp",
        "websocket",
        "available",
        "only",
        "specified",
        "providers"
      ],
      "timestamp": "2025-12-24T18:56:02.218330"
    },
    {
      "file_path": "UPSTREAM\\elixir-utcp\\test\\support\\mocks.ex",
      "content_type": "code",
      "content": "defmodule ExUtcp.Mocks do\n  @moduledoc \"\"\"\n  Mocks for testing ExUtcp modules.\n  \"\"\"\n\n  # WebSocket Transport Mock\n  defmock(ExUtcp.Transports.WebSocketMock, for: ExUtcp.Transports.Behaviour)\n\n  # WebSocket Connection Mock\n  defmock(ExUtcp.Transports.WebSocket.ConnectionMock, for: ExUtcp.Transports.WebSocket.Connection)\n\n  # GenServer Mock for WebSocket Transport\n  defmock(ExUtcp.Transports.WebSocket.GenServerMock, for: GenServer)\nend\n",
      "line_count": 15,
      "word_count": 35,
      "title": "Mocks.Ex",
      "summary": "defmodule ExUtcp.Mocks do @moduledoc \"\"\"",
      "key_terms": [
        "ExUtcp",
        "Mocks",
        "GenServerMock",
        "end",
        "Transports",
        "WebSocket",
        "Utcp",
        "for",
        "do",
        "defmock",
        "moduledoc",
        "ConnectionMock",
        "Connection",
        "WebSocketMock",
        "testing",
        "Transport",
        "Behaviour",
        "defmodule",
        "modules",
        "GenServer"
      ],
      "timestamp": "2025-12-24T18:56:02.234497"
    }
  ],
  "timestamp": "2025-12-24T18:56:02.234497"
}