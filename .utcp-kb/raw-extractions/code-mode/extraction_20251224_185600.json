{
  "repository": "code-mode",
  "commit_hash": "1d2c5ab46875b751d3207e4fe008f8a8a7e190b9",
  "commit_timestamp": "1765801934",
  "file_count": 19,
  "extractions": [
    {
      "file_path": "UPSTREAM\\code-mode\\README.md",
      "content_type": "documentation",
      "content": "<div align=\"center\">\n<!-- <img alt=\"utcp code mode banner\" src=\"https://github.com/user-attachments/assets/77723130-ecbc-4d1d-9e9b-20f978882699\" width=\"80%\" style=\"margin: 20px auto;\"> -->\n\n<h1 align=\"center\">ðŸ¤– Code-Mode Library: First library for tool calls via code execution</h1>\n<p align=\"center\">\n    <a href=\"https://github.com/universal-tool-calling-protocol\">\n        <img src=\"https://img.shields.io/github/followers/universal-tool-calling-protocol?label=Follow%20Org&logo=github\" /></a>\n    <a href=\"https://img.shields.io/npm/dt/@utcp/code-mode\" title=\"PyPI Version\">\n        <img src=\"https://img.shields.io/npm/dt/@utcp/code-mode\"/></a>\n    <a href=\"https://github.com/universal-tool-calling-protocol/code-mode/blob/main/LICENSE\" alt=\"License\">\n        <img src=\"https://img.shields.io/github/license/universal-tool-calling-protocol/code-mode\" /></a>\n \n  [![npm](https://img.shields.io/npm/v/@utcp/code-mode)](https://www.npmjs.com/package/@utcp/code-mode)\n</p>\n</div>\n\n> Transform your AI agents from clunky tool callers into efficient code executors â€” in just 3 lines.\n\n## Why This Changes Everything\n\nLLMs excel at writing code but struggle with tool calls. Instead of exposing hundreds of tools directly, give them ONE tool that executes TypeScript code with access to your entire toolkit.\n\n[Apple](https://machinelearning.apple.com/research/codeact), [Cloudflare](https://blog.cloudflare.com/code-mode/), and [Anthropic](https://www.anthropic.com/engineering/code-execution-with-mcp) say that Code-Mode is a more efficient way to approach tool calling compared to the traditional dump function information and then extract a JSON for function calling.\n\n## Benchmarks\n\nIndependent [Python benchmark study](https://github.com/imran31415/codemode_python_benchmark) validates the performance claims with **$9,536/year cost savings** at 1,000 scenarios/day:\n\n| Scenario Complexity | Traditional | Code Mode | **Improvement** |\n|---------------------|-------------|-----------|----------------|\n| **Simple (2-3 tools)** | 3 iterations | 1 execution | **67% faster** |\n| **Medium (4-7 tools)** | 8 iterations | 1 execution | **75% faster** |\n| **Complex (8+ tools)** | 16 iterations | 1 execution | **88% faster** |\n\n### **Why Code Mode Dominates:**\n\n   **Batching Advantage** - Single code block replaces multiple API calls  \n   **Cognitive Efficiency** - LLMs excel at code generation vs. tool orchestration  \n   **Computational Efficiency** - No context re-processing between operations\n\n# Getting Started\n\n[<img width=\"2606\" height=\"1445\" alt=\"Frame 4 (4)\" src=\"https://github.com/user-attachments/assets/58ba26ab-6e77-459b-a59a-eeb60d711746\" />\n](https://www.youtube.com/watch?v=zsMjkPzmqhA)\n\n## Get Started in 3 Lines\n\n```typescript\nimport { CodeModeUtcpClient } from '@utcp/code-mode';\n\nconst client = await CodeModeUtcpClient.create();                    // 1. Initialize\nawait client.registerManual({ name: 'github', /* MCP config */ });  // 2. Add tools  \nconst { result } = await client.callToolChain(`/* TypeScript */`);   // 3. Execute code\n```\n\nThat's it. Your AI agent can now execute complex workflows in a single request instead of dozens.\n\n## What You Get\n\n### **Progressive Tool Discovery**\n```typescript\n// Agent discovers tools dynamically, loads only what it needs\nconst tools = await client.searchTools('github pull request');\n// Instead of 500 tool definitions â†’ 3 relevant tools\n```\n\n### **Natural Code Execution**  \n```typescript\nconst { result, logs } = await client.callToolChain(`\n  // Chain multiple operations in one request\n  const pr = await github.get_pull_request({ owner: 'microsoft', repo: 'vscode', pull_number: 1234 });\n  const comments = await github.get_pull_request_comments({ owner: 'microsoft', repo: 'vscode', pull_number: 1234 });\n  const reviews = await github.get_pull_request_reviews({ owner: 'microsoft', repo: 'vscode', pull_number: 1234 });\n  \n  // Process data efficiently in-sandbox\n  return {\n    title: pr.title,\n    commentCount: comments.length,\n    approvals: reviews.filter(r => r.state === 'APPROVED').length\n  };\n`);\n// Single API call replaces 15+ traditional tool calls\n```\n\n### **Auto-Generated TypeScript Interfaces**\n```typescript\nnamespace github {\n  interface get_pull_requestInput {\n    /** Repository owner */\n    owner: string;\n    /** Repository name */ \n    repo: string;\n    /** Pull request number */\n    pull_number: number;\n  }\n}\n```\n\n## Enterprise-Ready\n\n- **Secure VM Sandboxing** â€“ Node.js isolates prevent unauthorized access\n- **Timeout Protection** â€“ Configurable execution limits prevent runaway code  \n- **Complete Observability** â€“ Full console output capture and error handling\n- **Zero External Dependencies** â€“ Tools only accessible through registered UTCP/MCP servers\n- **Runtime Introspection** â€“ Dynamic interface discovery for adaptive workflows\n\nIf you're working at an enterprise, and need support, book a consultation [here](https://bevel.neetocal.com/meeting-with-ali).\n## Universal Protocol Support\n\nWorks with **any tool ecosystem:**\n\n| Protocol | Description | Usage |\n|----------|-------------|-------|\n| **MCP** | Model Context Protocol servers | `call_template_type: 'mcp'` |\n| **HTTP** | REST APIs with auto-discovery | `call_template_type: 'http'` |  \n| **File** | Local JSON/YAML configurations | `call_template_type: 'file'` |\n| **CLI** | Command-line tool execution | `call_template_type: 'cli'` |\n\n## Installation\n\n```bash\nnpm install @utcp/code-mode\n```\n\n## Even Easier: Ready-to-Use MCP Server\n\n**Want Code Mode without any setup?** Use our plug-and-play MCP server with Claude Desktop or any MCP client:\n\n```json\n{\n  \"mcpServers\": {\n    \"code-mode\": {\n      \"command\": \"npx\",\n      \"args\": [\"@utcp/code-mode-mcp\"],\n      \"env\": {\n        \"UTCP_CONFIG_FILE\": \"/path/to/your/.utcp_config.json\"\n      }\n    }\n  }\n}\n```\n\n**That's it!** No installation, no Node.js knowledge required. The [Code Mode MCP Server](https://github.com/universal-tool-calling-protocol/code-mode/tree/main/code-mode-mcp) automatically:\n- Downloads and runs the latest version via `npx`\n- Loads your tool configurations from JSON\n- Provides code execution capabilities to Claude Desktop\n- Gives you `call_tool_chain` as an MCP tool for TypeScript execution\n\n**Perfect for non-developers** who want Code Mode power in Claude Desktop!\n\n## Direct TypeScript Usage\n\n### 1. **MCP Server Integration**\nConnect to any Model Context Protocol server:\n\n```typescript\nimport { CodeModeUtcpClient } from '@utcp/code-mode';\n\nconst client = await CodeModeUtcpClient.create();\n\n// Connect to GitHub MCP server\nawait client.registerManual({\n  name: 'github',\n  call_template_type: 'mcp',\n  config: {\n    mcpServers: {\n      github: {\n        command: 'docker',\n        args: ['run', '-i', '--rm', '-e', 'GITHUB_PERSONAL_ACCESS_TOKEN', 'mcp/github'],\n        env: { GITHUB_PERSONAL_ACCESS_TOKEN: process.env.GITHUB_TOKEN }\n      }\n    }\n  }\n});\n```\n\n### 2. **Execute Multi-Step Workflows**\nReplace 15+ tool calls with a single code execution:\n\n```typescript\nconst { result, logs } = await client.callToolChain(`\n  // Traditional: 4 separate API round trips â†’ Code Mode: 1 execution\n  const pr = await github.get_pull_request({ owner: 'microsoft', repo: 'vscode', pull_number: 1234 });\n  const comments = await github.get_pull_request_comments({ owner: 'microsoft', repo: 'vscode', pull_number: 1234 });\n  const reviews = await github.get_pull_request_reviews({ owner: 'microsoft', repo: 'vscode', pull_number: 1234 });\n  const files = await github.get_pull_request_files({ owner: 'microsoft', repo: 'vscode', pull_number: 1234 });\n  \n  // Process data in-sandbox (no token overhead)\n  const summary = {\n    title: pr.title,\n    state: pr.state,\n    author: pr.user.login,\n    stats: {\n      comments: comments.length,\n      reviews: reviews.length, \n      filesChanged: files.length,\n      approvals: reviews.filter(r => r.state === 'APPROVED').length\n    },\n    topDiscussion: comments.slice(0, 3).map(c => ({\n      author: c.user.login,\n      preview: c.body.substring(0, 100) + '...'\n    }))\n  };\n  \n  console.log(\\`PR \"\\${pr.title}\" analysis complete\\`);\n  return summary;\n`);\n\nconsole.log('Analysis Result:', result);\n// console output: 'PR \"Fix memory leak in hooks\" analysis complete'\n```\n\n---\n\n## Advanced Features\n\n### **Multi-Protocol Tool Chains**\nMix and match different tool ecosystems in a single execution:\n\n```typescript\n// Register multiple tool sources\nawait client.registerManual({ name: 'github', call_template_type: 'mcp', /* config */ });\nawait client.registerManual({ name: 'slack', call_template_type: 'http', /* config */ });\nawait client.registerManual({ name: 'db', call_template_type: 'file', file_path: './db-tools.json' }); // This loads a UTCP manual from a json file\n\nconst result = await client.callToolChain(`\n  // Fetch PR data from GitHub (MCP)\n  const pr = await github.get_pull_request({ owner: 'company', repo: 'api', pull_number: 42 });\n  \n  // Query deployment status from database (File)\n  const deployment = await db.get_deployment_status({ pr_id: pr.id });\n  \n  // Send notification to Slack (HTTP)\n  await slack.post_message({\n    channel: '#releases',\n    text: \\`PR #42 \"\\${pr.title}\" deployed to \\${deployment.environment}\\`\n  });\n  \n  return { pr: pr.title, environment: deployment.environment };\n`);\n```\n\n### **Runtime Interface Introspection**\nTools can dynamically discover and adapt to available interfaces:\n\n```typescript\nconst result = await client.callToolChain(`\n  // Discover available tools at runtime\n  console.log('Available interfaces:', __interfaces);\n  \n  // Get specific tool interface for validation\n  const prInterface = __getToolInterface('github.get_pull_request');\n  console.log('PR tool expects:', prInterface);\n  \n  // Use interface info for dynamic workflows\n  const hasSlackTools = __interfaces.includes('namespace slack');\n  if (hasSlackTools) {\n    await slack.post_message({ channel: '#dev', text: 'Analysis complete' });\n  }\n  \n  return { toolsAvailable: hasSlackTools };\n`);\n```\n\n### **Context-Efficient Data Processing**\nProcess large datasets without bloating the model's context:\n\n```typescript\nconst result = await client.callToolChain(`\n  // Fetch large dataset\n  const allIssues = await github.list_repository_issues({ owner: 'facebook', repo: 'react' });\n  console.log('Fetched', allIssues.length, 'total issues');\n  \n  // Process efficiently in-sandbox\n  const criticalBugs = allIssues\n    .filter(issue => issue.labels.some(l => l.name === 'bug'))\n    .filter(issue => issue.labels.some(l => l.name === 'high priority'))\n    .map(issue => ({\n      number: issue.number,\n      title: issue.title,\n      author: issue.user.login,\n      daysOld: Math.floor((Date.now() - new Date(issue.created_at)) / (1000 * 60 * 60 * 24))\n    }))\n    .sort((a, b) => b.daysOld - a.daysOld);\n  \n  // Only return processed summary (not 10,000 raw issues)\n  return {\n    totalIssues: allIssues.length,\n    criticalBugs: criticalBugs.slice(0, 10), // Top 10 oldest critical bugs\n    summary: \\`Found \\${criticalBugs.length} critical bugs, oldest is \\${criticalBugs[0]?.daysOld} days old\\`\n  };\n`);\n```\n\n### **Error Handling & Observability**\nBuilt-in error handling with complete execution transparency:\n\n```typescript\nconst { result, logs } = await client.callToolChain(`\n  try {\n    console.log('Starting multi-step workflow...');\n    \n    const data = await external_api.fetch_data({ id: 'user-123' });\n    console.log('Data fetched successfully');\n    \n    const processed = await data_processor.transform(data);\n    console.warn('Processing completed with', processed.warnings.length, 'warnings');\n    \n    return processed;\n  } catch (error) {\n    console.error('Workflow failed:', error.message);\n    throw error; // Propagates to outer error handling\n  }\n`, 30000); // 30-second timeout\n\n// Complete observability\nconsole.log('Result:', result);\nconsole.log('Execution logs:', logs);\n// ['Starting multi-step workflow...', 'Data fetched successfully', '[WARN] Processing completed with 2 warnings']\n```\n\n### **Custom Timeouts**\nConfigure execution limits for different workload types:\n\n```typescript\n// Quick operations (5 seconds)\nconst quickResult = await client.callToolChain(`return await ping.check();`, 5000);\n\n// Heavy data processing (2 minutes) \nconst heavyResult = await client.callToolChain(`\n  const bigData = await database.export_full_dataset();\n  return await analytics.process_dataset(bigData);\n`, 120000);\n```\n\n---\n\n## AI Agent Integration\n\nPlug-and-play with any AI framework. The built-in prompt template handles all the complexity:\n\n```typescript\nimport { CodeModeUtcpClient } from '@utcp/code-mode';\n\nconst systemPrompt = `\nYou are an AI assistant with access to tools via UTCP CodeMode.\n${CodeModeUtcpClient.AGENT_PROMPT_TEMPLATE}\nAdditional instructions...\n`;\n\n// Works with any AI library\nconst response = await openai.chat.completions.create({\n  model: 'gpt-4',\n  messages: [\n    { role: 'system', content: systemPrompt },\n    { role: 'user', content: 'Analyze the latest PR in microsoft/vscode' }\n  ]\n});\n```\n\n**The template provides comprehensive guidance on:**\n- Tool discovery workflow (`searchTools` â†’ `__interfaces` â†’ `callToolChain`)\n- Hierarchical access patterns (`manual.tool()` syntax)  \n- Interface introspection (`__getToolInterface()`)\n- Error handling and best practices\n\n---\n\n## API Reference\n\n### **Core Methods**\n\n#### `callToolChain(code: string, timeout?: number)`\nExecute TypeScript code with full tool access and observability.\n- **Returns**: `{result: any, logs: string[]}` with execution result and captured console output\n- **Default timeout**: 30 seconds\n\n#### `getAllToolsTypeScriptInterfaces()`\nGenerate complete TypeScript interfaces for IDE integration.\n- **Returns**: String containing all interface definitions with namespaces\n\n#### `searchTools(query: string)` *(from UtcpClient)*\nDiscover tools using natural language queries.\n- **Returns**: Array of relevant tools with descriptions and interfaces\n\n### **Static Methods**\n\n#### `CodeModeUtcpClient.create(root_dir?, config?)`\nCreate a new client instance with optional configuration.\n\n#### `CodeModeUtcpClient.AGENT_PROMPT_TEMPLATE`\nProduction-ready prompt template for AI agents.\n\n---\n\n## Security & Performance\n\n### **Secure by Design**\n- **Node.js VM sandboxing** â€“ Isolated execution context\n- **No filesystem access** â€“ Tools only through registered servers  \n- **Timeout protection** â€“ Configurable execution limits\n- **Zero network access** â€“ No external dependencies or API keys exposed\n\n### **Performance Optimized**\n- **Minimal memory footprint** â€“ VM contexts are lightweight\n- **Efficient tool caching** â€“ TypeScript interfaces cached automatically\n- **Streaming console output** â€“ Real-time log capture without buffering\n- **Identifier sanitization** â€“ Handles invalid TypeScript identifiers gracefully\n\n---\n\n## Development Experience\n\n### **IDE Integration**\nGenerate TypeScript definitions for full IntelliSense support:\n\n```bash\n# Generate tool interfaces  \nconst interfaces = await client.getAllToolsTypeScriptInterfaces();\nawait fs.writeFile('generated-tools.d.ts', interfaces);\n\n# Add to tsconfig.json\n{\n  \"compilerOptions\": {\n    \"typeRoots\": [\"./generated-tools.d.ts\"]\n  }\n}\n```\n\n### **Debug & Monitor**\nBuilt-in observability for production deployments:\n\n```typescript\nconst { result, logs } = await client.callToolChain(userCode);\n\n// Ship logs to your monitoring system\nlogs.forEach(log => {\n  if (log.startsWith('[ERROR]')) monitoring.error(log);\n  if (log.startsWith('[WARN]')) monitoring.warn(log);\n});\n```\n\n---\n\n\n### **Benchmark Methodology**\nThe [comprehensive Python study](https://github.com/imran31415/codemode_python_benchmark) tested **16 realistic scenarios** across:\n- **Financial workflows** (invoicing, expense tracking)  \n- **DevOps operations** (deployments, monitoring)\n- **Data processing** (analysis, reporting)\n- **Business automation** (CRM, notifications)\n\n**Models tested:** Claude Haiku, Gemini Flash  \n**Pricing basis:** $0.25/1M input, $1.25/1M output tokens  \n**Scale:** 1,000 scenarios/day = $9,536/year savings with Code Mode\n\n## Learn More\n\n- **[Cloudflare Research](https://blog.cloudflare.com/code-mode/)** â€“ Original code mode whitepaper\n- **[Anthropic Study](https://www.anthropic.com/engineering/code-execution-with-mcp)** â€“ MCP code execution benefits\n- **[Python Benchmark Study](https://github.com/imran31415/codemode_python_benchmark)** â€“ Comprehensive performance analysis\n- **[UTCP Specification](https://utcp.io)** â€“ Official TypeScript implementation  \n- **[Report Issues](https://github.com/universal-tool-calling-protocol/code-mode/issues)** â€“ Bug reports and feature requests\n\n## License\n\n**MPL-2.0** â€“ Open source with commercial-friendly terms.\n",
      "line_count": 468,
      "word_count": 1867,
      "title": "Readme.Md",
      "summary": "<div align=\"center\"> <!-- <img alt=\"utcp code mode banner\" src=\"https://github.com/user-attachments/assets/77723130-ecbc-4d1d-9e9b-20f978882699\" width=\"80%\" style=\"margin: 20px auto;\"> -->",
      "key_terms": [
        "Batching",
        "comprehensive",
        "const",
        "chat",
        "Model",
        "img",
        "Optimized",
        "Code",
        "gracefully",
        "filesystem",
        "mode",
        "Found",
        "Efficient",
        "Dominates",
        "multiple",
        "CodeModeUtcpClient",
        "dynamically",
        "APPROVED",
        "orchestration",
        "heavyResult"
      ],
      "timestamp": "2025-12-24T18:55:59.587052"
    },
    {
      "file_path": "UPSTREAM\\code-mode\\code-mode-mcp\\.utcp_config.json",
      "content_type": "configuration",
      "content": "{\n    \"load_variables_from\": [\n      {\n        \"variable_loader_type\": \"dotenv\",\n        \"env_file_path\": \".env\"\n      }\n    ],\n    \"tool_repository\": {\n      \"tool_repository_type\": \"in_memory\"\n    },\n    \"tool_search_strategy\": {\n      \"tool_search_strategy_type\": \"tag_and_description_word_match\"\n    },\n    \"manual_call_templates\": [\n      {\n          \"name\": \"openlibrary\",\n          \"call_template_type\": \"http\",\n          \"http_method\": \"GET\",\n          \"url\": \"https://openlibrary.org/static/openapi.json\",\n          \"content_type\": \"application/json\"\n      }\n    ],\n    \"post_processing\": [\n    ]\n  }",
      "line_count": 25,
      "word_count": 39,
      "title": ".Utcp Config.Json",
      "summary": "\"load_variables_from\": [ \"variable_loader_type\": \"dotenv\",",
      "key_terms": [
        "url",
        "https",
        "GET",
        "org",
        "env",
        "api",
        "dotenv",
        "json",
        "static",
        "openlibrary",
        "openapi",
        "application",
        "method",
        "http",
        "name"
      ],
      "timestamp": "2025-12-24T18:55:59.603088"
    },
    {
      "file_path": "UPSTREAM\\code-mode\\code-mode-mcp\\index.ts",
      "content_type": "code",
      "content": "#!/usr/bin/env node\n\n// UTCP-MCP Bridge Entry Point\n// This is the main entry point for the npx @utcp/mcp-bridge command\n\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\nimport path from \"path\";\nimport { promises as fs } from \"fs\";\nimport { parse as parseDotEnv } from 'dotenv';\nimport { fileURLToPath } from 'url';\nimport { dirname } from 'path';\n\nimport \"@utcp/http\";\nimport \"@utcp/text\";\nimport \"@utcp/mcp\";\nimport \"@utcp/cli\";\nimport \"@utcp/dotenv-loader\"\nimport \"@utcp/file\"\n\nimport {\n    UtcpClient,\n    CallTemplateSchema,\n    InMemConcurrentToolRepository,\n    TagSearchStrategy,\n    DefaultVariableSubstitutor,\n    ensureCorePluginsInitialized,\n    UtcpClientConfigSerializer\n} from \"@utcp/sdk\";\nimport type { UtcpClientConfig } from \"@utcp/sdk\";\nimport { CodeModeUtcpClient } from \"@utcp/code-mode\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\nensureCorePluginsInitialized();\n\nlet utcpClient: CodeModeUtcpClient | null = null;\n\nasync function main() {\n    setupMcpTools();\n    utcpClient = await initializeUtcpClient();\n    const transport = new StdioServerTransport();\n    await mcp.connect(transport);\n}\n\nconst mcp = new McpServer({\n    name: \"CodeMode-MCP\",\n    version: \"1.0.0\",\n});\n\n/**\n * Sanitizes an identifier to be a valid TypeScript identifier.\n */\nfunction sanitizeIdentifier(name: string): string {\n    return name\n        .replace(/[^a-zA-Z0-9_]/g, '_')\n        .replace(/^[0-9]/, '_$&');\n}\n\n/**\n * Converts a UTCP tool name to its TypeScript interface name.\n */\nfunction utcpNameToTsInterfaceName(utcpName: string): string {\n    if (utcpName.includes('.')) {\n        const parts = utcpName.split('.');\n        const manualName = parts[0]!;\n        const toolParts = parts.slice(1);\n        const sanitizedManualName = sanitizeIdentifier(manualName);\n        const toolName = toolParts.map(part => sanitizeIdentifier(part)).join('_');\n        return `${sanitizedManualName}.${toolName}`;\n    } else {\n        return sanitizeIdentifier(utcpName);\n    }\n}\n\n/**\n * Finds a tool by either UTCP name or TypeScript interface name.\n */\nasync function findToolByName(client: CodeModeUtcpClient, name: string): Promise<{ tool: any, utcpName: string } | null> {\n    // First, try direct lookup by UTCP name\n    const directTool = await client.config.tool_repository.getTool(name);\n    if (directTool) {\n        return { tool: directTool, utcpName: name };\n    }\n    \n    // If not found, search through all tools to find one whose TS interface name matches\n    const allTools = await client.config.tool_repository.getTools();\n    for (const tool of allTools) {\n        if (utcpNameToTsInterfaceName(tool.name) === name) {\n            return { tool, utcpName: tool.name };\n        }\n    }\n    \n    return null;\n}\n\nfunction setupMcpTools() {\n    // Register MCP prompt for using the code mode server\n    mcp.registerPrompt(\"utcp_codemode_usage\", {\n        title: \"UTCP Code Mode Usage Guide\",\n        description: \"Comprehensive guide on how to use the UTCP Code Mode MCP server for executing TypeScript code with tool access.\"\n    }, async () => {\n        const codeInstructions = `# UTCP Code Mode MCP Server Usage Guide\n\nYou have access to a powerful UTCP Code Mode MCP server that allows you to execute TypeScript code with direct access to registered tools.\n\n## Workflow: Always Follow This Pattern\n\n### 1. ðŸ” DISCOVER TOOLS FIRST\n**Always start by searching for relevant tools before writing code:**\n- Use \\`search_tools\\` with a description of your task to find relevant tools\n- This returns tools with their TypeScript interfaces - study these carefully\n- Use \\`tool_info\\` to get detailed interface information for specific tools if needed\n\n${CodeModeUtcpClient.AGENT_PROMPT_TEMPLATE}\n\n- in the call_tool_chain code, return the result that you want to see, your code will be wrapped in an async function and executed\n\nRemember: The power of this system comes from combining multiple tools in sophisticated TypeScript code execution workflows.`;\n\n        return {\n            messages: [{\n                role: \"user\",\n                content: {\n                    type: \"text\",\n                    text: codeInstructions\n                }\n            }]\n        };\n    });\n\n    mcp.registerTool(\"register_manual\", {\n        title: \"Register a UTCP Manual\",\n        description: \"Registers a new tool provider by providing its call template.\",\n        inputSchema: { manual_call_template: CallTemplateSchema.describe(\"The call template for the UTCP Manual endpoint.\") },\n    }, async (input) => {\n        const client = await initializeUtcpClient();\n        try {\n            const result = await client.registerManual(input.manual_call_template as any);\n            return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n\n    mcp.registerTool(\"deregister_manual\", {\n        title: \"Deregister a UTCP Manual\",\n        description: \"Deregisters a tool provider from the UTCP client.\",\n        inputSchema: { manual_name: z.string().describe(\"The name of the manual to deregister.\") },\n    }, async (input) => {\n        const client = await initializeUtcpClient();\n        try {\n            const success = await client.deregisterManual(input.manual_name);\n            const message = success ? `Manual '${input.manual_name}' deregistered.` : `Manual '${input.manual_name}' not found.`;\n            return { content: [{ type: \"text\", text: JSON.stringify({ success, message }) }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n\n    mcp.registerTool(\"search_tools\", {\n        title: \"Search for UTCP Tools\",\n        description: \"Searches for relevant tools based on a task description.\",\n        inputSchema: {\n            task_description: z.string().describe(\"A natural language description of the task.\"),\n            limit: z.number().optional().default(10),\n        },\n    }, async (input) => {\n        const client = await initializeUtcpClient();\n        try {\n            const tools = await client.searchTools(input.task_description, input.limit);\n            const toolsWithInterfaces = tools.map(t => ({\n                name: utcpNameToTsInterfaceName(t.name),\n                description: t.description,\n                typescript_interface: client.toolToTypeScriptInterface(t)\n            }));\n            return { content: [{ type: \"text\", text: JSON.stringify({ tools: toolsWithInterfaces }) }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n\n    mcp.registerTool(\"list_tools\", {\n        title: \"List All Registered UTCP Tools\",\n        description: \"Returns a list of all tool names currently registered.\",\n        inputSchema: {},\n    }, async () => {\n        const client = await initializeUtcpClient();\n        try {\n            const tools = await client.config.tool_repository.getTools();\n            const toolNames = tools.map(t => utcpNameToTsInterfaceName(t.name));\n            return { content: [{ type: \"text\", text: JSON.stringify({ tools: toolNames }) }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n\n    mcp.registerTool(\"get_required_keys_for_tool\", {\n        title: \"Get Required Variables for Tool\",\n        description: \"Get required environment variables for a registered tool.\",\n        inputSchema: {\n            tool_name: z.string().describe(\"Name of the tool to get required variables for.\"),\n        },\n    }, async (input) => {\n        const client = await initializeUtcpClient();\n        try {\n            const found = await findToolByName(client, input.tool_name);\n            if (!found) {\n                return { content: [{ type: \"text\", text: JSON.stringify({ success: false, tool_name: input.tool_name, error: `Tool '${input.tool_name}' not found` }) }] };\n            }\n            const variables = await client.getRequiredVariablesForRegisteredTool(found.utcpName);\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: true, tool_name: input.tool_name, required_variables: variables }) }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, tool_name: input.tool_name, error: e.message }) }] };\n        }\n    });\n\n    mcp.registerTool(\"tool_info\", {\n        title: \"Get Tool Information with TypeScript Interface\",\n        description: \"Get complete information about a specific tool including TypeScript interface definition.\",\n        inputSchema: {\n            tool_name: z.string().describe(\"Name of the tool to get complete information for.\"),\n        },\n    }, async (input) => {\n        const client = await initializeUtcpClient();\n        try {\n            const found = await findToolByName(client, input.tool_name);\n            if (!found) {\n                return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: `Tool '${input.tool_name}' not found` }) }] };\n            }\n            const typescript_interface = client.toolToTypeScriptInterface(found.tool);\n            return { content: [{ type: \"text\", text: typescript_interface }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n\n    // Code Mode specific tools\n    mcp.registerTool(\"call_tool_chain\", {\n        title: \"Execute TypeScript Code with Tool Access\",\n        description: \"Execute TypeScript code with direct access to all registered tools as hierarchical functions (e.g., manual.tool()).\",\n        inputSchema: {\n            code: z.string().describe(\"TypeScript code to execute with access to all registered tools.\"),\n            timeout: z.number().optional().default(30000).describe(\"Optional timeout in milliseconds (default: 30000).\"),\n            max_output_size: z.number().optional().default(200000).describe(\"Optional maximum output size in characters (default: 200000).\"),\n        },\n    }, async (input) => {\n        const client = await initializeUtcpClient();\n        try {\n            const { result, logs } = await client.callToolChain(input.code, input.timeout);\n            const content = JSON.stringify({ success: true, result, logs })\n            if (content.length > input.max_output_size) {\n                return { content: [{ type: \"text\", text: content.slice(0, input.max_output_size) + \"...\\nmax_output_size exceeded\" }] };\n            }\n            return { content: [{ type: \"text\", text: content }] };\n        } catch (e: any) {\n            return { content: [{ type: \"text\", text: JSON.stringify({ success: false, error: e.message }) }] };\n        }\n    });\n\n}\n\nasync function initializeUtcpClient(): Promise<CodeModeUtcpClient> {\n    if (utcpClient) {\n        return utcpClient;\n    }\n\n    // Look for config file: 1) Environment variable, 2) Current working directory, 3) Package directory\n    const cwd = process.cwd();\n    const packageDir = __dirname;\n    \n    let configPath: string;\n    let scriptDir: string;\n    \n    // Check if UTCP_CONFIG_FILE environment variable is set\n    if (process.env.UTCP_CONFIG_FILE) {\n        configPath = path.resolve(process.env.UTCP_CONFIG_FILE);\n        scriptDir = path.dirname(configPath);\n        \n        try {\n            await fs.access(configPath);\n        } catch {\n            console.warn(`UTCP config file specified in UTCP_CONFIG_FILE not found: ${configPath}`);\n        }\n    } else {\n        // Fall back to current working directory first, then package directory\n        configPath = path.resolve(cwd, '.utcp_config.json');\n        scriptDir = cwd;\n        \n        try {\n            await fs.access(configPath);\n        } catch {\n            configPath = path.resolve(packageDir, '.utcp_config.json');\n            scriptDir = packageDir;\n        }\n    }\n\n    let rawConfig: any = {};\n    try {\n        const configFileContent = await fs.readFile(configPath, 'utf-8');\n        rawConfig = JSON.parse(configFileContent);\n    } catch (e: any) {\n        if (e.code !== 'ENOENT') {\n            console.warn(`Could not read or parse .utcp_config.json. Error: ${e.message}`);\n        }\n    }\n\n    const clientConfig = new UtcpClientConfigSerializer().validateDict(rawConfig);\n\n    const newClient = await CodeModeUtcpClient.create(scriptDir, clientConfig);\n\n    utcpClient = newClient;\n    return utcpClient;\n}\n\nmain().catch(err => {\n    console.error(\"Failed to start UTCP-MCP Bridge:\", err);\n    process.exit(1);\n});\n",
      "line_count": 322,
      "word_count": 1413,
      "title": "Index.Ts",
      "summary": "// UTCP-MCP Bridge Entry Point // This is the main entry point for the npx @utcp/mcp-bridge command",
      "key_terms": [
        "directTool",
        "const",
        "Code",
        "either",
        "list",
        "mode",
        "toolName",
        "multiple",
        "CodeModeUtcpClient",
        "if",
        "that",
        "interface",
        "these",
        "how",
        "title",
        "await",
        "Returns",
        "call",
        "fileURLToPath",
        "scriptDir"
      ],
      "timestamp": "2025-12-24T18:55:59.650987"
    },
    {
      "file_path": "UPSTREAM\\code-mode\\code-mode-mcp\\package-lock.json",
      "content_type": "configuration",
      "content": "{\n  \"name\": \"@utcp/code-mode-mcp\",\n  \"version\": \"1.1.0\",\n  \"lockfileVersion\": 3,\n  \"requires\": true,\n  \"packages\": {\n    \"\": {\n      \"name\": \"@utcp/code-mode-mcp\",\n      \"version\": \"1.1.0\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@modelcontextprotocol/sdk\": \"^1.20.2\",\n        \"@utcp/cli\": \"^1.1.0\",\n        \"@utcp/code-mode\": \"^1.1.0\",\n        \"@utcp/dotenv-loader\": \"^1.1.0\",\n        \"@utcp/file\": \"^1.1.0\",\n        \"@utcp/http\": \"^1.1.0\",\n        \"@utcp/mcp\": \"^1.1.1\",\n        \"@utcp/sdk\": \"^1.1.0\",\n        \"@utcp/text\": \"^1.1.0\",\n        \"dotenv\": \"^16.0.0\",\n        \"zod\": \"^3.22.0\"\n      },\n      \"bin\": {\n        \"mcp-bridge\": \"dist/index.js\"\n      },\n      \"devDependencies\": {\n        \"@types/node\": \"^20.0.0\",\n        \"typescript\": \"^5.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=18.0.0\"\n      }\n    },\n    \"node_modules/@apidevtools/json-schema-ref-parser\": {\n      \"version\": \"15.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/@apidevtools/json-schema-ref-parser/-/json-schema-ref-parser-15.1.2.tgz\",\n      \"integrity\": \"sha512-54vnqDyGsDAVM0LOIdGMnfVyCN1NlqoGnHEGpMfaDBLMvClfT4j2XbJgvfuF0Ca0kxT6Gb7xUgS5W1I14QqjiQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"js-yaml\": \"^4.1.1\"\n      },\n      \"engines\": {\n        \"node\": \">=20\"\n      },\n      \"peerDependencies\": {\n        \"@types/json-schema\": \"^7.0.15\"\n      }\n    },\n    \"node_modules/@modelcontextprotocol/sdk\": {\n      \"version\": \"1.21.1\",\n      \"resolved\": \"https://registry.npmjs.org/@modelcontextprotocol/sdk/-/sdk-1.21.1.tgz\",\n      \"integrity\": \"sha512-UyLFcJLDvUuZbGnaQqXFT32CpPpGj7VS19roLut6gkQVhb439xUzYWbsUvdI3ZPL+2hnFosuugtYWE0Mcs1rmQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ajv\": \"^8.17.1\",\n        \"ajv-formats\": \"^3.0.1\",\n        \"content-type\": \"^1.0.5\",\n        \"cors\": \"^2.8.5\",\n        \"cross-spawn\": \"^7.0.5\",\n        \"eventsource\": \"^3.0.2\",\n        \"eventsource-parser\": \"^3.0.0\",\n        \"express\": \"^5.0.1\",\n        \"express-rate-limit\": \"^7.5.0\",\n        \"pkce-challenge\": \"^5.0.0\",\n        \"raw-body\": \"^3.0.0\",\n        \"zod\": \"^3.23.8\",\n        \"zod-to-json-schema\": \"^3.24.1\"\n      },\n      \"engines\": {\n        \"node\": \">=18\"\n      },\n      \"peerDependencies\": {\n        \"@cfworker/json-schema\": \"^4.1.1\"\n      },\n      \"peerDependenciesMeta\": {\n        \"@cfworker/json-schema\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/@types/json-schema\": {\n      \"version\": \"7.0.15\",\n      \"resolved\": \"https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.15.tgz\",\n      \"integrity\": \"sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==\",\n      \"license\": \"MIT\",\n      \"peer\": true\n    },\n    \"node_modules/@types/node\": {\n      \"version\": \"20.19.24\",\n      \"resolved\": \"https://registry.npmjs.org/@types/node/-/node-20.19.24.tgz\",\n      \"integrity\": \"sha512-FE5u0ezmi6y9OZEzlJfg37mqqf6ZDSF2V/NLjUyGrR9uTZ7Sb9F7bLNZ03S4XVUNRWGA7Ck4c1kK+YnuWjl+DA==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"undici-types\": \"~6.21.0\"\n      }\n    },\n    \"node_modules/@utcp/cli\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/@utcp/cli/-/cli-1.1.0.tgz\",\n      \"integrity\": \"sha512-G/vNqERtFxNLdiXY2g1KDjgQJ4MIH+YI/Hmb2hzXA2QtZh1J9hQMlId4ndn2qGDja3wUZREiLMvFxbAQHxdbHg==\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"@utcp/sdk\": \"^1.1.0\"\n      }\n    },\n    \"node_modules/@utcp/code-mode\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/@utcp/code-mode/-/code-mode-1.1.0.tgz\",\n      \"integrity\": \"sha512-BADtH1rzB+TlPnPof/+9RldO+FsY7g566tV3kOCZPxwUFDOE7NpNzSjBzcecKbkeRgkWdIbz03EkJlThNMnzDA==\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"@utcp/sdk\": \"^1.1.0\"\n      }\n    },\n    \"node_modules/@utcp/dotenv-loader\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/@utcp/dotenv-loader/-/dotenv-loader-1.1.0.tgz\",\n      \"integrity\": \"sha512-kgziyumoeWVnCBtcQ59VJEDJXE/M/Or62TPamBVGVpyvNWyz4xH0CjLsN+k95I8NElZma45s4jgWoQrUMB6ARw==\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"dotenv\": \"^17.2.1\",\n        \"zod\": \"^3.23.8\"\n      },\n      \"peerDependencies\": {\n        \"@utcp/sdk\": \"^1.1.0\"\n      }\n    },\n    \"node_modules/@utcp/dotenv-loader/node_modules/dotenv\": {\n      \"version\": \"17.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/dotenv/-/dotenv-17.2.3.tgz\",\n      \"integrity\": \"sha512-JVUnt+DUIzu87TABbhPmNfVdBDt18BLOWjMUFJMSi/Qqg7NTYtabbvSNJGOJ7afbRuv9D/lngizHtP7QyLQ+9w==\",\n      \"license\": \"BSD-2-Clause\",\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://dotenvx.com\"\n      }\n    },\n    \"node_modules/@utcp/file\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/@utcp/file/-/file-1.1.0.tgz\",\n      \"integrity\": \"sha512-7bx1KoYEWEaXZvwbzOfePByL1NKTGAvO2cuXOYItKB8XCHRUDzcPEZkEPgKJqavBgYNJXVEiNQJlf7WRWJGIeQ==\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"@utcp/http\": \"^1.1.0\",\n        \"@utcp/sdk\": \"^1.1.0\",\n        \"js-yaml\": \"^4.1.0\"\n      }\n    },\n    \"node_modules/@utcp/http\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/@utcp/http/-/http-1.1.0.tgz\",\n      \"integrity\": \"sha512-+B1OOxstnC39e3nx8jgaFGoO1KZIwFLjYPfKz1t+OX/tfpE01tsLoErZ5yI3dc4JHdTV3AwK+LTmFnFpspFZBA==\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"@utcp/sdk\": \"^1.1.0\",\n        \"axios\": \"^1.11.0\",\n        \"js-yaml\": \"^4.1.0\"\n      }\n    },\n    \"node_modules/@utcp/mcp\": {\n      \"version\": \"1.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/@utcp/mcp/-/mcp-1.1.1.tgz\",\n      \"integrity\": \"sha512-9EQ+bQH1sg4lIF0YUNGRIgKcUh35s3Eg2G9gmpIIvHKJq9/W514s12Cr/3aG60W8Tc9aW1S3rX/qqe7jCv1TOA==\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"@apidevtools/json-schema-ref-parser\": \"^15.1.2\",\n        \"@modelcontextprotocol/sdk\": \"^1.17.4\",\n        \"@utcp/sdk\": \"^1.1.0\",\n        \"axios\": \"^1.11.0\"\n      }\n    },\n    \"node_modules/@utcp/sdk\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/@utcp/sdk/-/sdk-1.1.0.tgz\",\n      \"integrity\": \"sha512-JyNG+TdtoaZ19K2v+FSmRzi3YR3Ri0XVI7ntiz8pKDA9ZbNqa5+op2EAmmGIHD9sp0IyTI7pMHeUR+mYqd97PA==\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"dotenv\": \"^17.2.1\",\n        \"zod\": \"^3.23.8\"\n      }\n    },\n    \"node_modules/@utcp/sdk/node_modules/dotenv\": {\n      \"version\": \"17.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/dotenv/-/dotenv-17.2.3.tgz\",\n      \"integrity\": \"sha512-JVUnt+DUIzu87TABbhPmNfVdBDt18BLOWjMUFJMSi/Qqg7NTYtabbvSNJGOJ7afbRuv9D/lngizHtP7QyLQ+9w==\",\n      \"license\": \"BSD-2-Clause\",\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://dotenvx.com\"\n      }\n    },\n    \"node_modules/@utcp/text\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/@utcp/text/-/text-1.1.0.tgz\",\n      \"integrity\": \"sha512-hAcnvfxW8HjapWEP1es2XvkuYriV2uJWXd7fQl8UNg/4hEeJbJwBWwbNkst/i9ZmTBkHcCr7vSMAtj1CeTlcjg==\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"@utcp/http\": \"^1.1.0\",\n        \"@utcp/sdk\": \"^1.1.0\",\n        \"js-yaml\": \"^4.1.0\"\n      }\n    },\n    \"node_modules/accepts\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/accepts/-/accepts-2.0.0.tgz\",\n      \"integrity\": \"sha512-5cvg6CtKwfgdmVqY1WIiXKc3Q1bkRqGLi+2W/6ao+6Y7gu/RCwRuAhGEzh5B4KlszSuTLgZYuqFqo5bImjNKng==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"mime-types\": \"^3.0.0\",\n        \"negotiator\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/ajv\": {\n      \"version\": \"8.17.1\",\n      \"resolved\": \"https://registry.npmjs.org/ajv/-/ajv-8.17.1.tgz\",\n      \"integrity\": \"sha512-B/gBuNg5SiMTrPkC+A2+cW0RszwxYmn6VYxB/inlBStS5nx6xHIt/ehKRhIMhqusl7a8LjQoZnjCs5vhwxOQ1g==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"fast-deep-equal\": \"^3.1.3\",\n        \"fast-uri\": \"^3.0.1\",\n        \"json-schema-traverse\": \"^1.0.0\",\n        \"require-from-string\": \"^2.0.2\"\n      },\n      \"funding\": {\n        \"type\": \"github\",\n        \"url\": \"https://github.com/sponsors/epoberezkin\"\n      }\n    },\n    \"node_modules/ajv-formats\": {\n      \"version\": \"3.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/ajv-formats/-/ajv-formats-3.0.1.tgz\",\n      \"integrity\": \"sha512-8iUql50EUR+uUcdRQ3HDqa6EVyo3docL8g5WJ3FNcWmu62IbkGUue/pEyLBW8VGKKucTPgqeks4fIU1DA4yowQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ajv\": \"^8.0.0\"\n      },\n      \"peerDependencies\": {\n        \"ajv\": \"^8.0.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"ajv\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/argparse\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz\",\n      \"integrity\": \"sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==\",\n      \"license\": \"Python-2.0\"\n    },\n    \"node_modules/asynckit\": {\n      \"version\": \"0.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz\",\n      \"integrity\": \"sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/axios\": {\n      \"version\": \"1.13.2\",\n      \"resolved\": \"https://registry.npmjs.org/axios/-/axios-1.13.2.tgz\",\n      \"integrity\": \"sha512-VPk9ebNqPcy5lRGuSlKx752IlDatOjT9paPlm8A7yOuW2Fbvp4X3JznJtT4f0GzGLLiWE9W8onz51SqLYwzGaA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"follow-redirects\": \"^1.15.6\",\n        \"form-data\": \"^4.0.4\",\n        \"proxy-from-env\": \"^1.1.0\"\n      }\n    },\n    \"node_modules/body-parser\": {\n      \"version\": \"2.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/body-parser/-/body-parser-2.2.0.tgz\",\n      \"integrity\": \"sha512-02qvAaxv8tp7fBa/mw1ga98OGm+eCbqzJOKoRt70sLmfEEi+jyBYVTDGfCL/k06/4EMk/z01gCe7HoCH/f2LTg==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"bytes\": \"^3.1.2\",\n        \"content-type\": \"^1.0.5\",\n        \"debug\": \"^4.4.0\",\n        \"http-errors\": \"^2.0.0\",\n        \"iconv-lite\": \"^0.6.3\",\n        \"on-finished\": \"^2.4.1\",\n        \"qs\": \"^6.14.0\",\n        \"raw-body\": \"^3.0.0\",\n        \"type-is\": \"^2.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/bytes\": {\n      \"version\": \"3.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz\",\n      \"integrity\": \"sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/call-bind-apply-helpers\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz\",\n      \"integrity\": \"sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"es-errors\": \"^1.3.0\",\n        \"function-bind\": \"^1.1.2\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/call-bound\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/call-bound/-/call-bound-1.0.4.tgz\",\n      \"integrity\": \"sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"call-bind-apply-helpers\": \"^1.0.2\",\n        \"get-intrinsic\": \"^1.3.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/combined-stream\": {\n      \"version\": \"1.0.8\",\n      \"resolved\": \"https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz\",\n      \"integrity\": \"sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"delayed-stream\": \"~1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/content-disposition\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/content-disposition/-/content-disposition-1.0.0.tgz\",\n      \"integrity\": \"sha512-Au9nRL8VNUut/XSzbQA38+M78dzP4D+eqg3gfJHMIHHYa3bg067xj1KxMUWj+VULbiZMowKngFFbKczUrNJ1mg==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"safe-buffer\": \"5.2.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/content-type\": {\n      \"version\": \"1.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz\",\n      \"integrity\": \"sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/cookie\": {\n      \"version\": \"0.7.2\",\n      \"resolved\": \"https://registry.npmjs.org/cookie/-/cookie-0.7.2.tgz\",\n      \"integrity\": \"sha512-yki5XnKuf750l50uGTllt6kKILY4nQ1eNIQatoXEByZ5dWgnKqbnqmTrBE5B4N7lrMJKQ2ytWMiTO2o0v6Ew/w==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/cookie-signature\": {\n      \"version\": \"1.2.2\",\n      \"resolved\": \"https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.2.2.tgz\",\n      \"integrity\": \"sha512-D76uU73ulSXrD1UXF4KE2TMxVVwhsnCgfAyTg9k8P6KGZjlXKrOLe4dJQKI3Bxi5wjesZoFXJWElNWBjPZMbhg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=6.6.0\"\n      }\n    },\n    \"node_modules/cors\": {\n      \"version\": \"2.8.5\",\n      \"resolved\": \"https://registry.npmjs.org/cors/-/cors-2.8.5.tgz\",\n      \"integrity\": \"sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"object-assign\": \"^4\",\n        \"vary\": \"^1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.10\"\n      }\n    },\n    \"node_modules/cross-spawn\": {\n      \"version\": \"7.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz\",\n      \"integrity\": \"sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"path-key\": \"^3.1.0\",\n        \"shebang-command\": \"^2.0.0\",\n        \"which\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 8\"\n      }\n    },\n    \"node_modules/debug\": {\n      \"version\": \"4.4.3\",\n      \"resolved\": \"https://registry.npmjs.org/debug/-/debug-4.4.3.tgz\",\n      \"integrity\": \"sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ms\": \"^2.1.3\"\n      },\n      \"engines\": {\n        \"node\": \">=6.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"supports-color\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/delayed-stream\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz\",\n      \"integrity\": \"sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=0.4.0\"\n      }\n    },\n    \"node_modules/depd\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/depd/-/depd-2.0.0.tgz\",\n      \"integrity\": \"sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/dotenv\": {\n      \"version\": \"16.6.1\",\n      \"resolved\": \"https://registry.npmjs.org/dotenv/-/dotenv-16.6.1.tgz\",\n      \"integrity\": \"sha512-uBq4egWHTcTt33a72vpSG0z3HnPuIl6NqYcTrKEg2azoEyl2hpW0zqlxysq2pK9HlDIHyHyakeYaYnSAwd8bow==\",\n      \"license\": \"BSD-2-Clause\",\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://dotenvx.com\"\n      }\n    },\n    \"node_modules/dunder-proto\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz\",\n      \"integrity\": \"sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"call-bind-apply-helpers\": \"^1.0.1\",\n        \"es-errors\": \"^1.3.0\",\n        \"gopd\": \"^1.2.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/ee-first\": {\n      \"version\": \"1.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz\",\n      \"integrity\": \"sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/encodeurl\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz\",\n      \"integrity\": \"sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/es-define-property\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz\",\n      \"integrity\": \"sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/es-errors\": {\n      \"version\": \"1.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz\",\n      \"integrity\": \"sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/es-object-atoms\": {\n      \"version\": \"1.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz\",\n      \"integrity\": \"sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"es-errors\": \"^1.3.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/es-set-tostringtag\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.1.0.tgz\",\n      \"integrity\": \"sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"es-errors\": \"^1.3.0\",\n        \"get-intrinsic\": \"^1.2.6\",\n        \"has-tostringtag\": \"^1.0.2\",\n        \"hasown\": \"^2.0.2\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/escape-html\": {\n      \"version\": \"1.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz\",\n      \"integrity\": \"sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/etag\": {\n      \"version\": \"1.8.1\",\n      \"resolved\": \"https://registry.npmjs.org/etag/-/etag-1.8.1.tgz\",\n      \"integrity\": \"sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/eventsource\": {\n      \"version\": \"3.0.7\",\n      \"resolved\": \"https://registry.npmjs.org/eventsource/-/eventsource-3.0.7.tgz\",\n      \"integrity\": \"sha512-CRT1WTyuQoD771GW56XEZFQ/ZoSfWid1alKGDYMmkt2yl8UXrVR4pspqWNEcqKvVIzg6PAltWjxcSSPrboA4iA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"eventsource-parser\": \"^3.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=18.0.0\"\n      }\n    },\n    \"node_modules/eventsource-parser\": {\n      \"version\": \"3.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/eventsource-parser/-/eventsource-parser-3.0.6.tgz\",\n      \"integrity\": \"sha512-Vo1ab+QXPzZ4tCa8SwIHJFaSzy4R6SHf7BY79rFBDf0idraZWAkYrDjDj8uWaSm3S2TK+hJ7/t1CEmZ7jXw+pg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=18.0.0\"\n      }\n    },\n    \"node_modules/express\": {\n      \"version\": \"5.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/express/-/express-5.1.0.tgz\",\n      \"integrity\": \"sha512-DT9ck5YIRU+8GYzzU5kT3eHGA5iL+1Zd0EutOmTE9Dtk+Tvuzd23VBU+ec7HPNSTxXYO55gPV/hq4pSBJDjFpA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"accepts\": \"^2.0.0\",\n        \"body-parser\": \"^2.2.0\",\n        \"content-disposition\": \"^1.0.0\",\n        \"content-type\": \"^1.0.5\",\n        \"cookie\": \"^0.7.1\",\n        \"cookie-signature\": \"^1.2.1\",\n        \"debug\": \"^4.4.0\",\n        \"encodeurl\": \"^2.0.0\",\n        \"escape-html\": \"^1.0.3\",\n        \"etag\": \"^1.8.1\",\n        \"finalhandler\": \"^2.1.0\",\n        \"fresh\": \"^2.0.0\",\n        \"http-errors\": \"^2.0.0\",\n        \"merge-descriptors\": \"^2.0.0\",\n        \"mime-types\": \"^3.0.0\",\n        \"on-finished\": \"^2.4.1\",\n        \"once\": \"^1.4.0\",\n        \"parseurl\": \"^1.3.3\",\n        \"proxy-addr\": \"^2.0.7\",\n        \"qs\": \"^6.14.0\",\n        \"range-parser\": \"^1.2.1\",\n        \"router\": \"^2.2.0\",\n        \"send\": \"^1.1.0\",\n        \"serve-static\": \"^2.2.0\",\n        \"statuses\": \"^2.0.1\",\n        \"type-is\": \"^2.0.1\",\n        \"vary\": \"^1.1.2\"\n      },\n      \"engines\": {\n        \"node\": \">= 18\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/express\"\n      }\n    },\n    \"node_modules/express-rate-limit\": {\n      \"version\": \"7.5.1\",\n      \"resolved\": \"https://registry.npmjs.org/express-rate-limit/-/express-rate-limit-7.5.1.tgz\",\n      \"integrity\": \"sha512-7iN8iPMDzOMHPUYllBEsQdWVB6fPDMPqwjBaFrgr4Jgr/+okjvzAy+UHlYYL/Vs0OsOrMkwS6PJDkFlJwoxUnw==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 16\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/express-rate-limit\"\n      },\n      \"peerDependencies\": {\n        \"express\": \">= 4.11\"\n      }\n    },\n    \"node_modules/fast-deep-equal\": {\n      \"version\": \"3.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz\",\n      \"integrity\": \"sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/fast-uri\": {\n      \"version\": \"3.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/fast-uri/-/fast-uri-3.1.0.tgz\",\n      \"integrity\": \"sha512-iPeeDKJSWf4IEOasVVrknXpaBV0IApz/gp7S2bb7Z4Lljbl2MGJRqInZiUrQwV16cpzw/D3S5j5Julj/gT52AA==\",\n      \"funding\": [\n        {\n          \"type\": \"github\",\n          \"url\": \"https://github.com/sponsors/fastify\"\n        },\n        {\n          \"type\": \"opencollective\",\n          \"url\": \"https://opencollective.com/fastify\"\n        }\n      ],\n      \"license\": \"BSD-3-Clause\"\n    },\n    \"node_modules/finalhandler\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/finalhandler/-/finalhandler-2.1.0.tgz\",\n      \"integrity\": \"sha512-/t88Ty3d5JWQbWYgaOGCCYfXRwV1+be02WqYYlL6h0lEiUAMPM8o8qKGO01YIkOHzka2up08wvgYD0mDiI+q3Q==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"debug\": \"^4.4.0\",\n        \"encodeurl\": \"^2.0.0\",\n        \"escape-html\": \"^1.0.3\",\n        \"on-finished\": \"^2.4.1\",\n        \"parseurl\": \"^1.3.3\",\n        \"statuses\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/follow-redirects\": {\n      \"version\": \"1.15.11\",\n      \"resolved\": \"https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.15.11.tgz\",\n      \"integrity\": \"sha512-deG2P0JfjrTxl50XGCDyfI97ZGVCxIpfKYmfyrQ54n5FO/0gfIES8C/Psl6kWVDolizcaaxZJnTS0QSMxvnsBQ==\",\n      \"funding\": [\n        {\n          \"type\": \"individual\",\n          \"url\": \"https://github.com/sponsors/RubenVerborgh\"\n        }\n      ],\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=4.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"debug\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/form-data\": {\n      \"version\": \"4.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/form-data/-/form-data-4.0.4.tgz\",\n      \"integrity\": \"sha512-KrGhL9Q4zjj0kiUt5OO4Mr/A/jlI2jDYs5eHBpYHPcBEVSiipAvn2Ko2HnPe20rmcuuvMHNdZFp+4IlGTMF0Ow==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"asynckit\": \"^0.4.0\",\n        \"combined-stream\": \"^1.0.8\",\n        \"es-set-tostringtag\": \"^2.1.0\",\n        \"hasown\": \"^2.0.2\",\n        \"mime-types\": \"^2.1.12\"\n      },\n      \"engines\": {\n        \"node\": \">= 6\"\n      }\n    },\n    \"node_modules/form-data/node_modules/mime-db\": {\n      \"version\": \"1.52.0\",\n      \"resolved\": \"https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz\",\n      \"integrity\": \"sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/form-data/node_modules/mime-types\": {\n      \"version\": \"2.1.35\",\n      \"resolved\": \"https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz\",\n      \"integrity\": \"sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"mime-db\": \"1.52.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/forwarded\": {\n      \"version\": \"0.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz\",\n      \"integrity\": \"sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/fresh\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/fresh/-/fresh-2.0.0.tgz\",\n      \"integrity\": \"sha512-Rx/WycZ60HOaqLKAi6cHRKKI7zxWbJ31MhntmtwMoaTeF7XFH9hhBp8vITaMidfljRQ6eYWCKkaTK+ykVJHP2A==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/function-bind\": {\n      \"version\": \"1.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz\",\n      \"integrity\": \"sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==\",\n      \"license\": \"MIT\",\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/get-intrinsic\": {\n      \"version\": \"1.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz\",\n      \"integrity\": \"sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"call-bind-apply-helpers\": \"^1.0.2\",\n        \"es-define-property\": \"^1.0.1\",\n        \"es-errors\": \"^1.3.0\",\n        \"es-object-atoms\": \"^1.1.1\",\n        \"function-bind\": \"^1.1.2\",\n        \"get-proto\": \"^1.0.1\",\n        \"gopd\": \"^1.2.0\",\n        \"has-symbols\": \"^1.1.0\",\n        \"hasown\": \"^2.0.2\",\n        \"math-intrinsics\": \"^1.1.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/get-proto\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz\",\n      \"integrity\": \"sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"dunder-proto\": \"^1.0.1\",\n        \"es-object-atoms\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/gopd\": {\n      \"version\": \"1.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz\",\n      \"integrity\": \"sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/has-symbols\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz\",\n      \"integrity\": \"sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/has-tostringtag\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.2.tgz\",\n      \"integrity\": \"sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"has-symbols\": \"^1.0.3\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/hasown\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz\",\n      \"integrity\": \"sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"function-bind\": \"^1.1.2\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/http-errors\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/http-errors/-/http-errors-2.0.0.tgz\",\n      \"integrity\": \"sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"depd\": \"2.0.0\",\n        \"inherits\": \"2.0.4\",\n        \"setprototypeof\": \"1.2.0\",\n        \"statuses\": \"2.0.1\",\n        \"toidentifier\": \"1.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/http-errors/node_modules/statuses\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/statuses/-/statuses-2.0.1.tgz\",\n      \"integrity\": \"sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/iconv-lite\": {\n      \"version\": \"0.6.3\",\n      \"resolved\": \"https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.6.3.tgz\",\n      \"integrity\": \"sha512-4fCk79wshMdzMp2rH06qWrJE4iolqLhCUH+OiuIgU++RB0+94NlDL81atO7GX55uUKueo0txHNtvEyI6D7WdMw==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"safer-buffer\": \">= 2.1.2 < 3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      }\n    },\n    \"node_modules/inherits\": {\n      \"version\": \"2.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz\",\n      \"integrity\": \"sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==\",\n      \"license\": \"ISC\"\n    },\n    \"node_modules/ipaddr.js\": {\n      \"version\": \"1.9.1\",\n      \"resolved\": \"https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz\",\n      \"integrity\": \"sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.10\"\n      }\n    },\n    \"node_modules/is-promise\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/is-promise/-/is-promise-4.0.0.tgz\",\n      \"integrity\": \"sha512-hvpoI6korhJMnej285dSg6nu1+e6uxs7zG3BYAm5byqDsgJNWwxzM6z6iZiAgQR4TJ30JmBTOwqZUw3WlyH3AQ==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/isexe\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz\",\n      \"integrity\": \"sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==\",\n      \"license\": \"ISC\"\n    },\n    \"node_modules/js-yaml\": {\n      \"version\": \"4.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz\",\n      \"integrity\": \"sha512-qQKT4zQxXl8lLwBtHMWwaTcGfFOZviOJet3Oy/xmGk2gZH677CJM9EvtfdSkgWcATZhj/55JZ0rmy3myCT5lsA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"argparse\": \"^2.0.1\"\n      },\n      \"bin\": {\n        \"js-yaml\": \"bin/js-yaml.js\"\n      }\n    },\n    \"node_modules/json-schema-traverse\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-1.0.0.tgz\",\n      \"integrity\": \"sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/math-intrinsics\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz\",\n      \"integrity\": \"sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/media-typer\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/media-typer/-/media-typer-1.1.0.tgz\",\n      \"integrity\": \"sha512-aisnrDP4GNe06UcKFnV5bfMNPBUw4jsLGaWwWfnH3v02GnBuXX2MCVn5RbrWo0j3pczUilYblq7fQ7Nw2t5XKw==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/merge-descriptors\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-2.0.0.tgz\",\n      \"integrity\": \"sha512-Snk314V5ayFLhp3fkUREub6WtjBfPdCPY1Ln8/8munuLuiYhsABgBVWsozAG+MWMbVEvcdcpbi9R7ww22l9Q3g==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=18\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/mime-db\": {\n      \"version\": \"1.54.0\",\n      \"resolved\": \"https://registry.npmjs.org/mime-db/-/mime-db-1.54.0.tgz\",\n      \"integrity\": \"sha512-aU5EJuIN2WDemCcAp2vFBfp/m4EAhWJnUNSSw0ixs7/kXbd6Pg64EmwJkNdFhB8aWt1sH2CTXrLxo/iAGV3oPQ==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/mime-types\": {\n      \"version\": \"3.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/mime-types/-/mime-types-3.0.1.tgz\",\n      \"integrity\": \"sha512-xRc4oEhT6eaBpU1XF7AjpOFD+xQmXNB5OVKwp4tqCuBpHLS/ZbBDrc07mYTDqVMg6PfxUjjNp85O6Cd2Z/5HWA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"mime-db\": \"^1.54.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/ms\": {\n      \"version\": \"2.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/ms/-/ms-2.1.3.tgz\",\n      \"integrity\": \"sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/negotiator\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/negotiator/-/negotiator-1.0.0.tgz\",\n      \"integrity\": \"sha512-8Ofs/AUQh8MaEcrlq5xOX0CQ9ypTF5dl78mjlMNfOK08fzpgTHQRQPBxcPlEtIw0yRpws+Zo/3r+5WRby7u3Gg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/object-assign\": {\n      \"version\": \"4.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz\",\n      \"integrity\": \"sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      }\n    },\n    \"node_modules/object-inspect\": {\n      \"version\": \"1.13.4\",\n      \"resolved\": \"https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz\",\n      \"integrity\": \"sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/on-finished\": {\n      \"version\": \"2.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz\",\n      \"integrity\": \"sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ee-first\": \"1.1.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/once\": {\n      \"version\": \"1.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/once/-/once-1.4.0.tgz\",\n      \"integrity\": \"sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==\",\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"wrappy\": \"1\"\n      }\n    },\n    \"node_modules/parseurl\": {\n      \"version\": \"1.3.3\",\n      \"resolved\": \"https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz\",\n      \"integrity\": \"sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/path-key\": {\n      \"version\": \"3.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz\",\n      \"integrity\": \"sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/path-to-regexp\": {\n      \"version\": \"8.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-8.3.0.tgz\",\n      \"integrity\": \"sha512-7jdwVIRtsP8MYpdXSwOS0YdD0Du+qOoF/AEPIt88PcCFrZCzx41oxku1jD88hZBwbNUIEfpqvuhjFaMAqMTWnA==\",\n      \"license\": \"MIT\",\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/express\"\n      }\n    },\n    \"node_modules/pkce-challenge\": {\n      \"version\": \"5.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/pkce-challenge/-/pkce-challenge-5.0.0.tgz\",\n      \"integrity\": \"sha512-ueGLflrrnvwB3xuo/uGob5pd5FN7l0MsLf0Z87o/UQmRtwjvfylfc9MurIxRAWywCYTgrvpXBcqjV4OfCYGCIQ==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=16.20.0\"\n      }\n    },\n    \"node_modules/proxy-addr\": {\n      \"version\": \"2.0.7\",\n      \"resolved\": \"https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz\",\n      \"integrity\": \"sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"forwarded\": \"0.2.0\",\n        \"ipaddr.js\": \"1.9.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.10\"\n      }\n    },\n    \"node_modules/proxy-from-env\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/proxy-from-env/-/proxy-from-env-1.1.0.tgz\",\n      \"integrity\": \"sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/qs\": {\n      \"version\": \"6.14.0\",\n      \"resolved\": \"https://registry.npmjs.org/qs/-/qs-6.14.0.tgz\",\n      \"integrity\": \"sha512-YWWTjgABSKcvs/nWBi9PycY/JiPJqOD4JA6o9Sej2AtvSGarXxKC3OQSk4pAarbdQlKAh5D4FCQkJNkW+GAn3w==\",\n      \"license\": \"BSD-3-Clause\",\n      \"dependencies\": {\n        \"side-channel\": \"^1.1.0\"\n      },\n      \"engines\": {\n        \"node\": \">=0.6\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/range-parser\": {\n      \"version\": \"1.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz\",\n      \"integrity\": \"sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/raw-body\": {\n      \"version\": \"3.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/raw-body/-/raw-body-3.0.1.tgz\",\n      \"integrity\": \"sha512-9G8cA+tuMS75+6G/TzW8OtLzmBDMo8p1JRxN5AZ+LAp8uxGA8V8GZm4GQ4/N5QNQEnLmg6SS7wyuSmbKepiKqA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"bytes\": \"3.1.2\",\n        \"http-errors\": \"2.0.0\",\n        \"iconv-lite\": \"0.7.0\",\n        \"unpipe\": \"1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.10\"\n      }\n    },\n    \"node_modules/raw-body/node_modules/iconv-lite\": {\n      \"version\": \"0.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.7.0.tgz\",\n      \"integrity\": \"sha512-cf6L2Ds3h57VVmkZe+Pn+5APsT7FpqJtEhhieDCvrE2MK5Qk9MyffgQyuxQTm6BChfeZNtcOLHp9IcWRVcIcBQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"safer-buffer\": \">= 2.1.2 < 3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/express\"\n      }\n    },\n    \"node_modules/require-from-string\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/require-from-string/-/require-from-string-2.0.2.tgz\",\n      \"integrity\": \"sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      }\n    },\n    \"node_modules/router\": {\n      \"version\": \"2.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/router/-/router-2.2.0.tgz\",\n      \"integrity\": \"sha512-nLTrUKm2UyiL7rlhapu/Zl45FwNgkZGaCpZbIHajDYgwlJCOzLSk+cIPAnsEqV955GjILJnKbdQC1nVPz+gAYQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"debug\": \"^4.4.0\",\n        \"depd\": \"^2.0.0\",\n        \"is-promise\": \"^4.0.0\",\n        \"parseurl\": \"^1.3.3\",\n        \"path-to-regexp\": \"^8.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 18\"\n      }\n    },\n    \"node_modules/safe-buffer\": {\n      \"version\": \"5.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz\",\n      \"integrity\": \"sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==\",\n      \"funding\": [\n        {\n          \"type\": \"github\",\n          \"url\": \"https://github.com/sponsors/feross\"\n        },\n        {\n          \"type\": \"patreon\",\n          \"url\": \"https://www.patreon.com/feross\"\n        },\n        {\n          \"type\": \"consulting\",\n          \"url\": \"https://feross.org/support\"\n        }\n      ],\n      \"license\": \"MIT\"\n    },\n    \"node_modules/safer-buffer\": {\n      \"version\": \"2.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz\",\n      \"integrity\": \"sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/send\": {\n      \"version\": \"1.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/send/-/send-1.2.0.tgz\",\n      \"integrity\": \"sha512-uaW0WwXKpL9blXE2o0bRhoL2EGXIrZxQ2ZQ4mgcfoBxdFmQold+qWsD2jLrfZ0trjKL6vOw0j//eAwcALFjKSw==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"debug\": \"^4.3.5\",\n        \"encodeurl\": \"^2.0.0\",\n        \"escape-html\": \"^1.0.3\",\n        \"etag\": \"^1.8.1\",\n        \"fresh\": \"^2.0.0\",\n        \"http-errors\": \"^2.0.0\",\n        \"mime-types\": \"^3.0.1\",\n        \"ms\": \"^2.1.3\",\n        \"on-finished\": \"^2.4.1\",\n        \"range-parser\": \"^1.2.1\",\n        \"statuses\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 18\"\n      }\n    },\n    \"node_modules/serve-static\": {\n      \"version\": \"2.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/serve-static/-/serve-static-2.2.0.tgz\",\n      \"integrity\": \"sha512-61g9pCh0Vnh7IutZjtLGGpTA355+OPn2TyDv/6ivP2h/AdAVX9azsoxmg2/M6nZeQZNYBEwIcsne1mJd9oQItQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"encodeurl\": \"^2.0.0\",\n        \"escape-html\": \"^1.0.3\",\n        \"parseurl\": \"^1.3.3\",\n        \"send\": \"^1.2.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 18\"\n      }\n    },\n    \"node_modules/setprototypeof\": {\n      \"version\": \"1.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz\",\n      \"integrity\": \"sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==\",\n      \"license\": \"ISC\"\n    },\n    \"node_modules/shebang-command\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz\",\n      \"integrity\": \"sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"shebang-regex\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/shebang-regex\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz\",\n      \"integrity\": \"sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/side-channel\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz\",\n      \"integrity\": \"sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"es-errors\": \"^1.3.0\",\n        \"object-inspect\": \"^1.13.3\",\n        \"side-channel-list\": \"^1.0.0\",\n        \"side-channel-map\": \"^1.0.1\",\n        \"side-channel-weakmap\": \"^1.0.2\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/side-channel-list\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz\",\n      \"integrity\": \"sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"es-errors\": \"^1.3.0\",\n        \"object-inspect\": \"^1.13.3\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/side-channel-map\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz\",\n      \"integrity\": \"sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"call-bound\": \"^1.0.2\",\n        \"es-errors\": \"^1.3.0\",\n        \"get-intrinsic\": \"^1.2.5\",\n        \"object-inspect\": \"^1.13.3\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/side-channel-weakmap\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz\",\n      \"integrity\": \"sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"call-bound\": \"^1.0.2\",\n        \"es-errors\": \"^1.3.0\",\n        \"get-intrinsic\": \"^1.2.5\",\n        \"object-inspect\": \"^1.13.3\",\n        \"side-channel-map\": \"^1.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/statuses\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/statuses/-/statuses-2.0.2.tgz\",\n      \"integrity\": \"sha512-DvEy55V3DB7uknRo+4iOGT5fP1slR8wQohVdknigZPMpMstaKJQWhwiYBACJE3Ul2pTnATihhBYnRhZQHGBiRw==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/toidentifier\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz\",\n      \"integrity\": \"sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=0.6\"\n      }\n    },\n    \"node_modules/type-is\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/type-is/-/type-is-2.0.1.tgz\",\n      \"integrity\": \"sha512-OZs6gsjF4vMp32qrCbiVSkrFmXtG/AZhY3t0iAMrMBiAZyV9oALtXO8hsrHbMXF9x6L3grlFuwW2oAz7cav+Gw==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"content-type\": \"^1.0.5\",\n        \"media-typer\": \"^1.1.0\",\n        \"mime-types\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/typescript\": {\n      \"version\": \"5.9.3\",\n      \"resolved\": \"https://registry.npmjs.org/typescript/-/typescript-5.9.3.tgz\",\n      \"integrity\": \"sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==\",\n      \"dev\": true,\n      \"license\": \"Apache-2.0\",\n      \"bin\": {\n        \"tsc\": \"bin/tsc\",\n        \"tsserver\": \"bin/tsserver\"\n      },\n      \"engines\": {\n        \"node\": \">=14.17\"\n      }\n    },\n    \"node_modules/undici-types\": {\n      \"version\": \"6.21.0\",\n      \"resolved\": \"https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz\",\n      \"integrity\": \"sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/unpipe\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz\",\n      \"integrity\": \"sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/vary\": {\n      \"version\": \"1.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/vary/-/vary-1.1.2.tgz\",\n      \"integrity\": \"sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/which\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/which/-/which-2.0.2.tgz\",\n      \"integrity\": \"sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==\",\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"isexe\": \"^2.0.0\"\n      },\n      \"bin\": {\n        \"node-which\": \"bin/node-which\"\n      },\n      \"engines\": {\n        \"node\": \">= 8\"\n      }\n    },\n    \"node_modules/wrappy\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz\",\n      \"integrity\": \"sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==\",\n      \"license\": \"ISC\"\n    },\n    \"node_modules/zod\": {\n      \"version\": \"3.25.76\",\n      \"resolved\": \"https://registry.npmjs.org/zod/-/zod-3.25.76.tgz\",\n      \"integrity\": \"sha512-gzUt/qt81nXsFGKIFcC3YnfEAx5NkunCfnDlvuBSSFS02bcXu4Lmea0AFIUwbLWxWPx3d9p8S5QoaujKcNQxcQ==\",\n      \"license\": \"MIT\",\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/colinhacks\"\n      }\n    },\n    \"node_modules/zod-to-json-schema\": {\n      \"version\": \"3.24.6\",\n      \"resolved\": \"https://registry.npmjs.org/zod-to-json-schema/-/zod-to-json-schema-3.24.6.tgz\",\n      \"integrity\": \"sha512-h/z3PKvcTcTetyjl1fkj79MHNEjm+HpD6NXheWjzOekY7kV+lwDYnHw+ivHkijnCSMz1yJaWBD9vu/Fcmk+vEg==\",\n      \"license\": \"ISC\",\n      \"peerDependencies\": {\n        \"zod\": \"^3.24.1\"\n      }\n    }\n  }\n}\n",
      "line_count": 1439,
      "word_count": 2624,
      "title": "Package Lock.Json",
      "summary": "\"name\": \"@utcp/code-mode-mcp\", \"version\": \"1.1.0\",",
      "key_terms": [
        "form-data",
        "packages",
        "sha512-Rx",
        "lite",
        "list",
        "mode",
        "dotenvx",
        "cookie",
        "shebang",
        "http-errors",
        "es-errors",
        "jyBYVTDGfCL",
        "es-object",
        "devDependencies",
        "disposition",
        "side",
        "safe",
        "fresh",
        "Gw",
        "call"
      ],
      "timestamp": "2025-12-24T18:55:59.714863"
    },
    {
      "file_path": "UPSTREAM\\code-mode\\code-mode-mcp\\package.json",
      "content_type": "configuration",
      "content": "{\n  \"name\": \"@utcp/code-mode-mcp\",\n  \"version\": \"1.1.0\",\n  \"description\": \"Model Context Protocol (MCP) server for UTCP Code Mode - Execute TypeScript code with direct tool access\",\n  \"type\": \"module\",\n  \"main\": \"dist/index.js\",\n  \"bin\": {\n    \"mcp-bridge\": \"./dist/index.js\"\n  },\n  \"files\": [\n    \"dist/**/*\",\n    \"README.md\"\n  ],\n  \"scripts\": {\n    \"build\": \"node --max-old-space-size=8192 ./node_modules/typescript/bin/tsc\",\n    \"prepublishOnly\": \"npm run build\",\n    \"start\": \"node dist/index.js\"\n  },\n  \"keywords\": [\n    \"utcp\",\n    \"mcp\",\n    \"code-mode\",\n    \"typescript\",\n    \"model-context-protocol\",\n    \"universal-tool-calling-protocol\",\n    \"bridge\",\n    \"tools\",\n    \"ai\",\n    \"code-execution\"\n  ],\n  \"author\": \"UTCP Team\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/universal-tool-calling-protocol/utcp-mcp.git\"\n  },\n  \"homepage\": \"https://github.com/universal-tool-calling-protocol/utcp-mcp#readme\",\n  \"bugs\": {\n    \"url\": \"https://github.com/universal-tool-calling-protocol/utcp-mcp/issues\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  },\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"typescript\": \"^5.0.0\"\n  },\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^1.20.2\",\n    \"@utcp/cli\": \"^1.1.0\",\n    \"@utcp/code-mode\": \"^1.1.0\",\n    \"@utcp/dotenv-loader\": \"^1.1.0\",\n    \"@utcp/file\": \"^1.1.0\",\n    \"@utcp/http\": \"^1.1.0\",\n    \"@utcp/mcp\": \"^1.1.1\",\n    \"@utcp/sdk\": \"^1.1.0\",\n    \"@utcp/text\": \"^1.1.0\",\n    \"dotenv\": \"^16.0.0\",\n    \"zod\": \"^3.22.0\"\n  }\n}\n",
      "line_count": 65,
      "word_count": 126,
      "title": "Package.Json",
      "summary": "\"name\": \"@utcp/code-mode-mcp\", \"version\": \"1.1.0\",",
      "key_terms": [
        "build",
        "Model",
        "Code",
        "md",
        "index",
        "mode",
        "dependencies",
        "version",
        "devDependencies",
        "Execute",
        "model",
        "https",
        "code-mode",
        "utcp-mcp",
        "universal-tool",
        "readme",
        "git",
        "files",
        "ai",
        "description"
      ],
      "timestamp": "2025-12-24T18:55:59.744508"
    },
    {
      "file_path": "UPSTREAM\\code-mode\\code-mode-mcp\\README.md",
      "content_type": "documentation",
      "content": "# UTCP Code Mode MCP Bridge\n\n**Execute TypeScript code with direct tool access through MCP.**\n\nAn advanced MCP server that brings UTCP Code Mode to the MCP ecosystem, allowing you to execute TypeScript code with all registered tools available as native TypeScript functions.\n\n## ðŸš€ Quick Start\n\nAdd this configuration to your MCP client (Claude Desktop, etc.):\n\n```json\n{\n  \"mcpServers\": {\n    \"utcp-codemode\": {\n      \"command\": \"npx\",\n      \"args\": [\"@utcp/code-mode-mcp\"],\n      \"env\": {\n        \"UTCP_CONFIG_FILE\": \"/path/to/your/.utcp_config.json\"\n      }\n    }\n  }\n}\n```\n\n**That's it!** No installation required. The bridge will automatically:\n- Download and run the latest version via npx\n- Load your UTCP configuration from the specified path\n- Register all your UTCP manuals as tools available in TypeScript code\n- Enable TypeScript code execution with hierarchical tool access (e.g., `manual.tool()`)\n\n## ðŸ”§ Configuration\n\nCreate a `.utcp_config.json` file to configure your tools and services:\n\n```json\n{\n    \"load_variables_from\": [\n      {\n        \"variable_loader_type\": \"dotenv\",\n        \"env_file_path\": \".env\"\n      }\n    ],\n    \"manual_call_templates\": [\n      {\n          \"name\": \"openlibrary\",\n          \"call_template_type\": \"http\",\n          \"http_method\": \"GET\", \n          \"url\": \"https://openlibrary.org/static/openapi.json\",\n          \"content_type\": \"application/json\"\n      }\n    ],\n    \"post_processing\": [\n      {\n          \"tool_post_processor_type\": \"filter_dict\",\n          \"only_include_keys\": [\"name\", \"description\"],\n          \"only_include_tools\": [\"openlibrary.*\"]\n      }\n    ],\n    \"tool_repository\": {\n      \"tool_repository_type\": \"in_memory\"\n    },\n    \"tool_search_strategy\": {\n      \"tool_search_strategy_type\": \"tag_and_description_word_match\"\n    }\n}\n```\n\n### Enabling CLI Support\n\n**Important:** CLI protocol support is **disabled by default** for security reasons. To enable CLI tool execution, you need to explicitly register the CLI plugin in 'index.ts'.\n\n```typescript\nimport { register as registerCli } from \"@utcp/cli\";\n\n// Enable CLI support\nregisterCli();\n```\n\n**Security Note:** Only enable CLI if you trust the code that will be executed, as CLI tools can execute arbitrary commands on your system.\n\n## ðŸ› ï¸ Available MCP Tools\n\nThe bridge exposes these MCP tools for managing your UTCP Code Mode ecosystem:\n\n- **`register_manual`** - Register new UTCP manuals/APIs\n- **`deregister_manual`** - Remove registered manuals\n- **`search_tools`** - Find tools by description with TypeScript interfaces\n- **`list_tools`** - List all registered tool names\n- **`get_required_keys_for_tool`** - Get required environment variables\n- **`tool_info`** - Get complete tool information with TypeScript interface\n- **`call_tool_chain`** - Execute TypeScript code with direct tool access\n\n## ðŸ“ What is UTCP?\n\nThe Universal Tool Calling Protocol (UTCP) allows you to:\n- **Connect to any API** via HTTP, OpenAPI specs, or custom formats\n- **Use command-line tools** with automatic argument parsing (requires explicit CLI plugin registration)\n- **Process text and files** with built-in utilities\n- **Chain and combine** multiple tools seamlessly\n\nWith this MCP bridge, all your UTCP tools become available in Claude Desktop and other MCP clients.\n \n**Optional Protocols:** CLI requires explicit registration for security (see \"Enabling CLI Support\" above).\n\n## ðŸ’» Code Mode Example\n\nThe main feature of this bridge is the ability to execute TypeScript code with direct access to all registered tools:\n\n```typescript\n// Example using call_tool_chain\nconst result = await call_tool_chain(`\n  // Get user data from an API\n  const user = await user_service.getUserProfile({ userId: \"123\" });\n  console.log('User data:', user);\n  \n  // Process the data with another tool\n  const processed = await data_processor.analyzeUserBehavior({\n    userData: user,\n    timeframe: \"30days\"\n  });\n  \n  // Generate a report\n  const report = await reporting.generateInsights({\n    analysis: processed,\n    format: \"summary\"\n  });\n  \n  return {\n    userId: user.id,\n    totalActions: processed.actionCount,\n    topInsight: report.insights[0]\n  };\n`);\n```\n\n**Key Benefits:**\n- **Hierarchical Access**: Use `manual.tool()` syntax to avoid naming conflicts\n- **Type Safety**: Get TypeScript interfaces for all tools via `search_tools` or `tool_info`\n- **Code Execution**: Chain multiple tool calls in a single code block\n- **Error Handling**: Proper error handling with timeout support\n\n## ðŸŒŸ Features\n\n- âœ… **Zero installation** - Works via npx\n- âœ… **Universal compatibility** - Works with any MCP client\n- âœ… **Dynamic configuration** - Update tools without restarting\n- âœ… **Environment isolation** - Each project can have its own config\n- âœ… **Comprehensive tool management** - Register, search, call, and inspect tools\n\n---\n\n<img width=\"2263\" height=\"976\" alt=\"UTCP MCP Bridge Interface\" src=\"https://github.com/user-attachments/assets/a6759512-1c0d-4265-9518-64916fbe1428\" />\n",
      "line_count": 153,
      "word_count": 623,
      "title": "UTCP Code Mode MCP Bridge",
      "summary": "**Execute TypeScript code with direct tool access through MCP.** An advanced MCP server that brings UTCP Code Mode to the MCP ecosystem, allowing you to execute TypeScript code with all registered too...",
      "key_terms": [
        "Important",
        "const",
        "project",
        "isolation",
        "search",
        "etc",
        "error",
        "img",
        "Type",
        "Code",
        "through",
        "Comprehensive",
        "Available",
        "id",
        "index",
        "Hierarchical",
        "format",
        "mode",
        "available",
        "specified"
      ],
      "timestamp": "2025-12-24T18:55:59.778221"
    },
    {
      "file_path": "UPSTREAM\\code-mode\\code-mode-mcp\\tsconfig.json",
      "content_type": "configuration",
      "content": "{\n  \"compilerOptions\": {\n    // Environment setup & latest features\n    \"lib\": [\"ESNext\", \"ES2022\"],\n    \"target\": \"ES2022\",\n    \"module\": \"ESNext\",\n    \"moduleDetection\": \"force\",\n    \"allowJs\": true,\n\n    // Node.js mode\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"resolveJsonModule\": true,\n\n    // Output configuration\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./\",\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true,\n\n    // Best practices\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"noUncheckedIndexedAccess\": true,\n    \"noImplicitOverride\": true,\n\n    // Some stricter flags (disabled by default)\n    \"noUnusedLocals\": false,\n    \"noUnusedParameters\": false,\n    \"noPropertyAccessFromIndexSignature\": false\n  },\n  \"include\": [\n    \"index.ts\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"examples\",\n    \"web_ui_utcp_mcp_bridge\",\n    \"python_mcp_bridge\"\n  ]\n}\n",
      "line_count": 46,
      "word_count": 84,
      "title": "Tsconfig.Json",
      "summary": "\"compilerOptions\": { // Environment setup & latest features",
      "key_terms": [
        "node",
        "disabled",
        "exclude",
        "Some",
        "lib",
        "module",
        "skipLibCheck",
        "flags",
        "force",
        "target",
        "allowSyntheticDefaultImports",
        "outDir",
        "index",
        "mode",
        "utcp",
        "examples",
        "configuration",
        "rootDir",
        "default",
        "ts"
      ],
      "timestamp": "2025-12-24T18:55:59.797912"
    },
    {
      "file_path": "UPSTREAM\\code-mode\\python-library\\pyproject.toml",
      "content_type": "other",
      "content": "[build-system]\nrequires = [\"setuptools>=61.0\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"code-mode\"\nversion = \"0.0.3\"\nauthors = [\n  { name = \"UTCP Contributors\" },\n]\ndescription = \"Code execution mode for UTCP - enables executing Python code chains with tool access.\"\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\ndependencies = [\n    \"pydantic>=2.0\",\n    \"utcp>=1.0\",\n    \"typing-extensions>=4.0\",\n    \"RestrictedPython>=6.0\"\n]\nclassifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Developers\",\n    \"Programming Language :: Python :: 3\",\n    \"Operating System :: OS Independent\",\n]\nlicense = \"MPL-2.0\"\n\n[project.optional-dependencies]\ndev = [\n    \"build\",\n    \"pytest\",\n    \"pytest-asyncio\",\n    \"pytest-cov\",\n    \"coverage\",\n    \"twine\",\n]\n\n[project.urls]\nHomepage = \"https://utcp.io\"\nSource = \"https://github.com/universal-tool-calling-protocol/python-utcp\"\nIssues = \"https://github.com/universal-tool-calling-protocol/python-utcp/issues\"\n",
      "line_count": 42,
      "word_count": 103,
      "title": "Pyproject.Toml",
      "summary": "[build-system] requires = [\"setuptools>=61.0\"]",
      "key_terms": [
        "executing",
        "build",
        "project",
        "Python",
        "setuptools",
        "optional-dependencies",
        "Code",
        "md",
        "coverage",
        "twine",
        "mode",
        "extensions",
        "dependencies",
        "version",
        "pytest-asyncio",
        "RestrictedPython",
        "https",
        "code-mode",
        "system",
        "Language"
      ],
      "timestamp": "2025-12-24T18:55:59.825645"
    },
    {
      "file_path": "UPSTREAM\\code-mode\\python-library\\README.md",
      "content_type": "documentation",
      "content": "<div align=\"center\">\n\n<h1 align=\"center\">ðŸ Python Code-Mode Library: Tool calling via code execution</h1>\n<p align=\"center\">\n    <a href=\"https://github.com/universal-tool-calling-protocol\">\n        <img src=\"https://img.shields.io/github/followers/universal-tool-calling-protocol?label=Follow%20Org&logo=github\" /></a>\n    <a href=\"https://pypi.org/project/code-mode/\" title=\"PyPI Version\">\n        <img src=\"https://img.shields.io/pypi/v/code-mode\"/></a>\n    <a href=\"https://github.com/universal-tool-calling-protocol/code-mode/blob/main/LICENSE\" alt=\"License\">\n        <img src=\"https://img.shields.io/github/license/universal-tool-calling-protocol/code-mode\" /></a>\n</p>\n</div>\n\n> Transform your AI agents from clunky tool callers into efficient code executors â€” in Python.\n\n## Why This Changes Everything\n\nLLMs excel at writing code but struggle with tool calls. Instead of exposing hundreds of tools directly, give them ONE tool that executes Python code with access to your entire toolkit.\n\n[Apple](https://machinelearning.apple.com/research/codeact), [Cloudflare](https://blog.cloudflare.com/code-mode/), and [Anthropic](https://www.anthropic.com/engineering/code-execution-with-mcp) say that Code-Mode is a more efficient way to approach tool calling compared to the traditional dump function information and then extract a JSON for function calling.\n\n## Benchmarks\n\nIndependent [Python benchmark study](https://github.com/imran31415/codemode_python_benchmark) validates the performance claims with **$9,536/year cost savings** at 1,000 scenarios/day:\n\n| Scenario Complexity | Traditional | Code Mode | **Improvement** |\n|---------------------|-------------|-----------|----------------|\n| **Simple (2-3 tools)** | 3 iterations | 1 execution | **67% faster** |\n| **Medium (4-7 tools)** | 8 iterations | 1 execution | **75% faster** |\n| **Complex (8+ tools)** | 16 iterations | 1 execution | **88% faster** |\n\n### **Why Code Mode Dominates:**\n\n   **Batching Advantage** - Single code block replaces multiple API calls  \n   **Cognitive Efficiency** - LLMs excel at code generation vs. tool orchestration  \n   **Computational Efficiency** - No context re-processing between operations\n\n# Getting Started\n\n## Get Started in 3 Lines\n\n```python\nfrom utcp_code_mode import CodeModeUtcpClient\nfrom utcp.data.call_template import CallTemplateSerializer\n\nclient = await CodeModeUtcpClient.create()                              # 1. Initialize\n\n# Serialize the call template dict to CallTemplate object\ncall_template = CallTemplateSerializer().validate_dict({\n    'name': 'github',\n    'call_template_type': 'mcp',\n    'config': {...}\n})\nawait client.register_manual(call_template)                             # 2. Add tools  \nresult = await client.call_tool_chain(\"# Python code here\")             # 3. Execute code\n```\n\nThat's it. Your AI agent can now execute complex workflows in a single request instead of dozens.\n\n## What You Get\n\n### **Progressive Tool Discovery**\n```python\n# Agent discovers tools dynamically, loads only what it needs\ntools = await client.search_tools('github pull request')\n# Instead of 500 tool definitions â†’ 3 relevant tools\n```\n\n### **Natural Code Execution**  \n```python\nresult = await client.call_tool_chain('''\n# Chain multiple operations in one request\npr = await github.get_pull_request(owner='microsoft', repo='vscode', pull_number=1234)\ncomments = await github.get_pull_request_comments(owner='microsoft', repo='vscode', pull_number=1234)\nreviews = await github.get_pull_request_reviews(owner='microsoft', repo='vscode', pull_number=1234)\n\n# Process data efficiently in-sandbox\nreturn {\n    \"title\": pr[\"title\"],\n    \"commentCount\": len(comments),\n    \"approvals\": len([r for r in reviews if r[\"state\"] == \"APPROVED\"])\n}\n''')\n# Single API call replaces 15+ traditional tool calls\n```\n\n### **Auto-Generated Python TypedDict Interfaces**\n```python\nclass GithubGetPullRequestInput(TypedDict):\n    \"\"\"Repository owner\"\"\"\n    owner: str\n    \"\"\"Repository name\"\"\"\n    repo: str\n    \"\"\"Pull request number\"\"\"\n    pull_number: int\n```\n\n## Enterprise-Ready\n\n- **Secure Process Sandboxing** â€“ Subprocess isolation prevents unauthorized access\n- **Timeout Protection** â€“ Configurable execution limits prevent runaway code  \n- **Complete Observability** â€“ Full console output capture and error handling\n- **Zero External Dependencies** â€“ Tools only accessible through registered UTCP/MCP servers\n- **Runtime Introspection** â€“ Dynamic interface discovery for adaptive workflows\n\n## Universal Protocol Support\n\nWorks with **any tool ecosystem:**\n\n| Protocol | Description | Usage | Plugin Required |\n|----------|-------------|-------|----------------|\n| **MCP** | Model Context Protocol servers | `call_template_type: 'mcp'` | `pip install utcp-mcp` |\n| **HTTP** | REST APIs with auto-discovery | `call_template_type: 'http'` | Built-in |  \n| **Text** | Local JSON/YAML/UTCP files | `call_template_type: 'text'` | Built-in |\n| **CLI** | Command-line tool execution | `call_template_type: 'cli'` | `pip install utcp-cli` |\n\n> **Note:** Each protocol requires its corresponding plugin to be installed. Installing a plugin automatically registers it with the UTCP client.\n\n## Installation\n\n```bash\npip install code-mode\n```\n\n## Direct Python Usage\n\n### 1. **MCP Server Integration**\nConnect to any Model Context Protocol server:\n\n> **Prerequisites:** `pip install utcp-mcp` (installing the plugin auto-registers it)\n\n```python\nfrom utcp_code_mode import CodeModeUtcpClient\nfrom utcp.data.call_template import CallTemplateSerializer\nimport os\n\nclient = await CodeModeUtcpClient.create()\n\n# Connect to GitHub MCP server\n# Serialize the dict to CallTemplate object\ncall_template = CallTemplateSerializer().validate_dict({\n    'name': 'github',\n    'call_template_type': 'mcp',\n    'config': {\n        'mcpServers': {\n            'github': {\n                'command': 'docker',\n                'args': ['run', '-i', '--rm', '-e', 'GITHUB_PERSONAL_ACCESS_TOKEN', 'mcp/github'],\n                'env': {'GITHUB_PERSONAL_ACCESS_TOKEN': os.environ.get('GITHUB_TOKEN')}\n            }\n        }\n    }\n})\nawait client.register_manual(call_template)\n```\n\n### 2. **Execute Multi-Step Workflows**\nReplace 15+ tool calls with a single code execution:\n\n```python\nresult = await client.call_tool_chain('''\n# Traditional: 4 separate API round trips â†’ Code Mode: 1 execution\npr = await github.get_pull_request(owner='microsoft', repo='vscode', pull_number=1234)\ncomments = await github.get_pull_request_comments(owner='microsoft', repo='vscode', pull_number=1234)\nreviews = await github.get_pull_request_reviews(owner='microsoft', repo='vscode', pull_number=1234)\nfiles = await github.get_pull_request_files(owner='microsoft', repo='vscode', pull_number=1234)\n\n# Process data in-sandbox (no token overhead)\nsummary = {\n    \"title\": pr[\"title\"],\n    \"state\": pr[\"state\"],\n    \"author\": pr[\"user\"][\"login\"],\n    \"stats\": {\n        \"comments\": len(comments),\n        \"reviews\": len(reviews),\n        \"filesChanged\": len(files),\n        \"approvals\": len([r for r in reviews if r[\"state\"] == \"APPROVED\"])\n    },\n    \"topDiscussion\": [\n        {\n            \"author\": c[\"user\"][\"login\"],\n            \"preview\": c[\"body\"][:100] + \"...\"\n        } for c in comments[:3]\n    ]\n}\n\nprint(f'PR \"{pr[\"title\"]}\" analysis complete')\nreturn summary\n''')\n\nprint('Analysis Result:', result['result'])\n# console output: 'PR \"Fix memory leak in hooks\" analysis complete'\n```\n\n---\n\n## Advanced Features\n\n### **Multi-Protocol Tool Chains**\nMix and match different tool ecosystems in a single execution:\n\n```python\nfrom utcp.data.call_template import CallTemplateSerializer\n\nserializer = CallTemplateSerializer()\n\n# Register multiple tool sources\nawait client.register_manual(serializer.validate_dict({\n    'name': 'github',\n    'call_template_type': 'mcp',\n    'config': {...}\n}))\nawait client.register_manual(serializer.validate_dict({\n    'name': 'slack',\n    'call_template_type': 'http',\n    'http_method': 'POST',\n    'url': 'https://api.slack.com/utcp'\n}))\nawait client.register_manual(serializer.validate_dict({\n    'name': 'db',\n    'call_template_type': 'text',\n    'file_path': './db-tools.json'\n}))\n\nresult = await client.call_tool_chain('''\n# Fetch PR data from GitHub (MCP)\npr = await github.get_pull_request(owner='company', repo='api', pull_number=42)\n\n# Query deployment status from database (File)\ndeployment = await db.get_deployment_status(pr_id=pr[\"id\"])\n\n# Send notification to Slack (HTTP)\nawait slack.post_message(\n    channel='#releases',\n    text=f'PR #42 \"{pr[\"title\"]}\" deployed to {deployment[\"environment\"]}'\n)\n\nreturn {\"pr\": pr[\"title\"], \"environment\": deployment[\"environment\"]}\n''')\n```\n\n### **Runtime Interface Introspection**\nTools can dynamically discover and adapt to available interfaces:\n\n```python\nresult = await client.call_tool_chain('''\n# Discover available tools at runtime\nprint('Available interfaces:', __interfaces)\n\n# Get specific tool interface for validation\npr_interface = __get_tool_interface('github.get_pull_request')\nprint('PR tool expects:', pr_interface)\n\n# Use interface info for dynamic workflows\nhas_slack_tools = 'namespace slack' in __interfaces\nif has_slack_tools:\n    await slack.post_message(channel='#dev', text='Analysis complete')\n\nreturn {\"toolsAvailable\": has_slack_tools}\n''')\n```\n\n### **Context-Efficient Data Processing**\nProcess large datasets without bloating the model's context:\n\n```python\nresult = await client.call_tool_chain('''\n# Fetch large dataset\nall_issues = await github.list_repository_issues(owner='facebook', repo='react')\nprint(f'Fetched {len(all_issues)} total issues')\n\n# Process efficiently in-sandbox\ncritical_bugs = [\n    {\n        \"number\": issue[\"number\"],\n        \"title\": issue[\"title\"],\n        \"author\": issue[\"user\"][\"login\"],\n        \"daysOld\": (datetime.now() - datetime.fromisoformat(issue[\"created_at\"].replace('Z', '+00:00'))).days\n    }\n    for issue in all_issues\n    if any(l[\"name\"] == \"bug\" for l in issue[\"labels\"])\n    and any(l[\"name\"] == \"high priority\" for l in issue[\"labels\"])\n]\n\ncritical_bugs.sort(key=lambda x: x[\"daysOld\"], reverse=True)\n\n# Only return processed summary (not 10,000 raw issues)\nreturn {\n    \"totalIssues\": len(all_issues),\n    \"criticalBugs\": critical_bugs[:10],  # Top 10 oldest critical bugs\n    \"summary\": f'Found {len(critical_bugs)} critical bugs, oldest is {critical_bugs[0][\"daysOld\"]} days old'\n}\n''')\n```\n\n### **Error Handling & Observability**\nBuilt-in error handling with complete execution transparency:\n\n```python\nresult = await client.call_tool_chain('''\ntry:\n    print('Starting multi-step workflow...')\n    \n    data = await external_api.fetch_data(id='user-123')\n    print('Data fetched successfully')\n    \n    processed = await data_processor.transform(data)\n    print(f'Processing completed with {len(processed.get(\"warnings\", []))} warnings')\n    \n    return processed\nexcept Exception as error:\n    print(f'Workflow failed: {str(error)}')\n    raise error  # Propagates to outer error handling\n''', timeout=30)  # 30-second timeout\n\n# Complete observability\nprint('Result:', result['result'])\nprint('Execution logs:', result['logs'])\n# ['Starting multi-step workflow...', 'Data fetched successfully', 'Processing completed with 2 warnings']\n```\n\n### **Custom Timeouts**\nConfigure execution limits for different workload types:\n\n```python\n# Quick operations (5 seconds)\nquick_result = await client.call_tool_chain('return await ping.check()', timeout=5)\n\n# Heavy data processing (2 minutes)\nheavy_result = await client.call_tool_chain('''\nbig_data = await database.export_full_dataset()\nreturn await analytics.process_dataset(big_data)\n''', timeout=120)\n```\n\n---\n\n## AI Agent Integration\n\nPlug-and-play with any AI framework. The built-in prompt template handles all the complexity:\n\n```python\nfrom utcp_code_mode import CodeModeUtcpClient\nfrom openai import OpenAI\n\nsystem_prompt = f\"\"\"\nYou are an AI assistant with access to tools via UTCP CodeMode.\n{CodeModeUtcpClient.AGENT_PROMPT_TEMPLATE}\nAdditional instructions...\n\"\"\"\n\n# Works with any AI library\nclient = OpenAI()\nresponse = client.chat.completions.create(\n    model='gpt-4',\n    messages=[\n        {'role': 'system', 'content': system_prompt},\n        {'role': 'user', 'content': 'Analyze the latest PR in microsoft/vscode'}\n    ]\n)\n```\n\n**The template provides comprehensive guidance on:**\n- Tool discovery workflow (`search_tools` â†’ `__interfaces` â†’ `call_tool_chain`)\n- Hierarchical access patterns (`manual.tool()` syntax)  \n- Interface introspection (`__get_tool_interface()`)\n- Error handling and best practices\n\n---\n\n## API Reference\n\n### **Core Methods**\n\n#### `call_tool_chain(code: str, timeout: int = 30) -> Dict[str, Any]`\nExecute Python code with full tool access and observability.\n- **Returns**: `{\"result\": any, \"logs\": List[str]}` with execution result and captured console output\n- **Default timeout**: 30 seconds\n\n#### `get_all_tools_python_interfaces() -> str`\nGenerate complete Python TypedDict interfaces for IDE integration.\n- **Returns**: String containing all interface definitions with proper typing\n\n#### `search_tools(query: str, limit: int = 10)` *(from UtcpClient)*\nDiscover tools using natural language queries.\n- **Returns**: List of relevant tools with descriptions and interfaces\n\n### **Static Methods**\n\n#### `CodeModeUtcpClient.create(root_dir=None, config=None) -> CodeModeUtcpClient`\nCreate a new client instance with optional configuration.\n\n#### `CodeModeUtcpClient.AGENT_PROMPT_TEMPLATE`\nProduction-ready prompt template for AI agents.\n\n---\n\n## Security & Performance\n\n### **Secure by Design**\n- **Process sandboxing** â€“ Isolated execution in separate processes with real termination\n- **No filesystem access** â€“ Tools only through registered servers  \n- **Timeout protection** â€“ Configurable execution limits with forcible termination\n- **Zero network access** â€“ No external dependencies or API keys exposed\n- **Restricted imports** â€“ Only safe modules allowed (json, math, asyncio, datetime, time, re, typing, collections, itertools, functools, operator, uuid)\n- **Safe builtins** â€“ Dangerous functions like `exec`, `eval`, `open` are blocked\n- **No system access** â€“ Modules like `os`, `sys`, `subprocess` not available\n\n### **Performance Optimized**\n- **Minimal memory footprint** â€“ Process isolation is efficient with copy-on-write\n- **Efficient tool caching** â€“ TypedDict interfaces cached automatically\n- **Streaming console output** â€“ Real-time log capture without buffering\n- **Identifier sanitization** â€“ Handles invalid Python identifiers gracefully\n\n### **Cooperative Sandbox Model**\nThis security model is designed for **cooperative LLM-generated code** (not adversarial scenarios). It's perfect for:\n- **AI agents** with tool-based workflows\n- **Development environments** with controlled tool access\n- **Educational settings** for safe code experimentation\n- **Internal automation** with defined interfaces\n\n**Not suitable for**: Production multi-tenant environments or untrusted user code.\n\n---\n\n## Development Experience\n\n### **IDE Integration**\nGenerate Python definitions for full IntelliSense support:\n\n```python\n# Generate tool interfaces  \ninterfaces = await client.get_all_tools_python_interfaces()\nwith open('generated_tools.py', 'w') as f:\n    f.write(interfaces)\n\n# Import in your code for type hints\nfrom generated_tools import *\n```\n\n### **Debug & Monitor**\nBuilt-in observability for production deployments:\n\n```python\nresult = await client.call_tool_chain(user_code)\n\n# Ship logs to your monitoring system\nfor log in result['logs']:\n    if '[ERROR]' in log:\n        monitoring.error(log)\n    if '[WARN]' in log:\n        monitoring.warn(log)\n```\n\n---\n\n### **Benchmark Methodology**\nThe [comprehensive Python study](https://github.com/imran31415/codemode_python_benchmark) tested **16 realistic scenarios** across:\n- **Financial workflows** (invoicing, expense tracking)  \n- **DevOps operations** (deployments, monitoring)\n- **Data processing** (analysis, reporting)\n- **Business automation** (CRM, notifications)\n\n**Models tested:** Claude Haiku, Gemini Flash  \n**Pricing basis:** $0.25/1M input, $1.25/1M output tokens  \n**Scale:** 1,000 scenarios/day = $9,536/year savings with Code Mode\n\n## Learn More\n\n- **[Cloudflare Research](https://blog.cloudflare.com/code-mode/)** â€“ Original code mode whitepaper\n- **[Anthropic Study](https://www.anthropic.com/engineering/code-execution-with-mcp)** â€“ MCP code execution benefits\n- **[Python Benchmark Study](https://github.com/imran31415/codemode_python_benchmark)** â€“ Comprehensive performance analysis\n- **[UTCP Specification](https://utcp.io)** â€“ Universal Tool Calling Protocol  \n- **[Report Issues](https://github.com/universal-tool-calling-protocol/code-mode/issues)** â€“ Bug reports and feature requests\n\n## License\n\n**MPL-2.0** â€“ Open source with commercial-friendly terms.\n",
      "line_count": 479,
      "word_count": 1809,
      "title": "Readme.Md",
      "summary": "<div align=\"center\"> <h1 align=\"center\">ðŸ Python Code-Mode Library: Tool calling via code execution</h1>",
      "key_terms": [
        "open",
        "Batching",
        "comprehensive",
        "chat",
        "Model",
        "img",
        "Optimized",
        "Code",
        "gracefully",
        "filesystem",
        "mode",
        "corresponding",
        "Found",
        "Efficient",
        "Dominates",
        "multiple",
        "CodeModeUtcpClient",
        "dynamically",
        "APPROVED",
        "orchestration"
      ],
      "timestamp": "2025-12-24T18:55:59.874495"
    },
    {
      "file_path": "UPSTREAM\\code-mode\\python-library\\src\\utcp_code_mode\\code_mode_utcp_client.py",
      "content_type": "code",
      "content": "\"\"\"Code mode UTCP client extension that adds Python code execution capabilities.\n\nThis module extends the base UtcpClient to provide Python code execution\nfunctionality, allowing execution of Python code that can directly call\nregistered tools as functions.\n\nKey Features:\n    - Python code execution with tool access\n    - Automatic Python type hint generation from JSON schemas\n    - Console output capture\n    - Tool introspection capabilities\n    - Safe execution environment with timeout support\n    - Code sandboxing using RestrictedPython\n    - Import restrictions (safe modules only)\n    - Limited builtins for security\n    - Comprehensive security logging\n    - Tool call integration within same process\n\"\"\"\nfrom typing import Dict, Any, List, Optional, Union, TYPE_CHECKING\nimport logging\nimport asyncio\nfrom RestrictedPython import compile_restricted\nfrom RestrictedPython.Guards import safe_globals\nfrom RestrictedPython.PrintCollector import PrintCollector\n\nfrom utcp.utcp_client import UtcpClient\nfrom utcp.data.utcp_client_config import UtcpClientConfig\nfrom utcp.data.tool import Tool, JsonSchema\n\nif TYPE_CHECKING:\n    from utcp.implementations.utcp_client_implementation import UtcpClientImplementation\n\nlogger = logging.getLogger(__name__)\n\n\nclass CodeModeUtcpClient(UtcpClient):\n    \"\"\"REQUIRED\n    Code mode UTCP client that extends UtcpClient with Python code execution capabilities.\n    \n    This client allows executing Python code that can directly call registered tools\n    as functions. It provides automatic type hint generation from JSON schemas and\n    a secure execution environment with comprehensive safety measures.\n    \n    Security Features:\n        - Code sandboxing via RestrictedPython compilation\n        - Restricted imports (safe modules only)\n        - Limited builtins (no exec/eval/open/file operations)\n        - Safe globals from RestrictedPython\n        - Print output collection and capture\n        - Comprehensive security logging\n        - Timeout enforcement with asyncio\n        - Tool calls execute in same process with full access\n    \n    This implementation uses RestrictedPython for secure code execution\n    while maintaining tool call functionality in LLM environments.\n    \"\"\"\n\n    AGENT_PROMPT_TEMPLATE = \"\"\"\n## UTCP CodeMode Tool Usage Guide\n\nYou have access to a CodeModeUtcpClient that allows you to execute Python code with access to registered tools. Follow this workflow:\n\n### 1. Tool Discovery Phase\n**Always start by discovering available tools:**\n- Tools are organized by manual namespace (e.g., `manual_name.tool_name`)\n- Use hierarchical access patterns: `manual.tool(param=value)`\n- Multiple manuals can contain tools with the same name - namespaces prevent conflicts\n\n### 2. Interface Introspection\n**Understand tool contracts before using them:**\n- Access `__interfaces` to see all available Python type definitions\n- Use `__get_tool_interface('manual.tool')` to get specific tool interfaces\n- Interfaces show required inputs, expected outputs, and descriptions\n- Look for \"Access as: manual.tool(args)\" comments for usage patterns\n\n### 3. Code Execution Guidelines\n**When writing code for `call_tool_chain`:**\n- Use `manual.tool(param=value)` syntax for all tool calls (synchronous - no await needed!)\n- Tools are regular functions that block until completion\n- You have access to standard Python globals: `print`, `json`, `math`, `datetime`, etc.\n- All print output is automatically captured and returned\n- Build properly structured input objects based on interface definitions\n- Handle errors appropriately with try/except blocks\n- Chain tool calls by using results from previous calls\n- Use `return value` to return a result from code execution\n\n### 4. Best Practices\n- **Discover first, code second**: Always explore available tools before writing execution code\n- **Respect namespaces**: Use full `manual.tool` names to avoid conflicts\n- **Parse interfaces**: Use interface information to construct proper input objects\n- **Error handling**: Wrap tool calls in try/except for robustness\n- **Data flow**: Chain tools by passing outputs as inputs to subsequent tools\n- **Return values**: Use `return your_value` to return a value from code execution\n\n### 5. Available Runtime Context\n- `__interfaces`: String containing all Python type definitions\n- `__get_tool_interface(tool_name)`: Function to get specific tool interface\n- All registered tools as `manual.tool` synchronous functions\n- Standard Python built-ins for data processing\n\nRemember: Always discover and understand available tools before attempting to use them in code execution.\n\"\"\".strip()\n\n    def __init__(self, base_client: 'UtcpClient'):\n        \"\"\"Initialize the CodeModeUtcpClient.\n        \n        Args:\n            base_client: The base UtcpClient to wrap\n        \"\"\"\n        self._base_client = base_client\n        self._tool_function_cache: Dict[str, str] = {}\n        \n    @classmethod\n    async def create(\n        cls,\n        root_dir: Optional[str] = None,\n        config: Optional[Union[str, Dict[str, Any], UtcpClientConfig]] = None,\n    ) -> 'CodeModeUtcpClient':\n        \"\"\"Create a new CodeModeUtcpClient instance.\n        \n        This creates a regular UtcpClient first and then wraps it with\n        CodeModeUtcpClient functionality.\n        \n        Args:\n            root_dir: The root directory for the client to resolve relative paths from\n            config: The configuration for the client\n            \n        Returns:\n            A new CodeModeUtcpClient instance\n        \"\"\"\n        # Import here to avoid circular import\n        from utcp.implementations.utcp_client_implementation import UtcpClientImplementation  # noqa: F811\n        \n        # Create the base client\n        base_client = await UtcpClientImplementation.create(root_dir, config)\n        return cls(base_client)\n\n    def _sanitize_identifier(self, name: str) -> str:\n        \"\"\"Sanitize an identifier to be a valid Python identifier.\n        \n        Replaces any non-alphanumeric character (except underscore) with underscore\n        and ensures the first character is not a number.\n        \n        Args:\n            name: The name to sanitize\n            \n        Returns:\n            Sanitized identifier\n        \"\"\"\n        import re\n        sanitized = re.sub(r'[^a-zA-Z0-9_]', '_', name)\n        if sanitized and sanitized[0].isdigit():\n            sanitized = '_' + sanitized\n        return sanitized\n\n    def tool_to_python_interface(self, tool: Tool) -> str:\n        \"\"\"REQUIRED\n        Convert a Tool object into a Python type hint interface string.\n        \n        This generates the function signature and type hints that can be used\n        in Python code.\n        \n        Args:\n            tool: The Tool object to convert\n            \n        Returns:\n            Python type hint interface as a string\n        \"\"\"\n        if tool.name in self._tool_function_cache:\n            return self._tool_function_cache[tool.name]\n\n        # Generate hierarchical interface structure\n        interface_content: str\n        access_pattern: str\n        \n        if '.' in tool.name:\n            manual_name, *tool_parts = tool.name.split('.')\n            sanitized_manual_name = self._sanitize_identifier(manual_name)\n            tool_name = '_'.join(self._sanitize_identifier(part) for part in tool_parts)\n            access_pattern = f\"{sanitized_manual_name}.{tool_name}\"\n            \n            # Generate TypedDict classes within namespace\n            input_class_content = self._json_schema_to_typed_dict_content(tool.inputs)\n            output_class_content = self._json_schema_to_typed_dict_content(tool.outputs)\n            \n            interface_content = f\"\"\"\n# Namespace: {sanitized_manual_name}\nclass {tool_name}Input(TypedDict):\n{input_class_content}\n\nclass {tool_name}Output(TypedDict):\n{output_class_content}\"\"\"\n        else:\n            # No manual namespace, generate flat interfaces\n            sanitized_tool_name = self._sanitize_identifier(tool.name)\n            access_pattern = f\"{sanitized_tool_name}\"\n            input_type = self._json_schema_to_python_type(tool.inputs, f\"{sanitized_tool_name}Input\")\n            output_type = self._json_schema_to_python_type(tool.outputs, f\"{sanitized_tool_name}Output\")\n            interface_content = f\"{input_type}\\n\\n{output_type}\"\n            \n        interface_string = f\"\"\"{interface_content}\n\n# {tool.description}\n# Tags: {', '.join(tool.tags)}\n# Access as: {access_pattern}(args)\n\"\"\"\n\n        self._tool_function_cache[tool.name] = interface_string\n        return interface_string\n\n    async def get_all_tools_python_interfaces(self) -> str:\n        \"\"\"REQUIRED\n        Convert all registered tools to Python type hint definitions.\n        \n        This provides the complete type definitions for all available tools.\n        \n        Returns:\n            A complete Python type hint definition string\n        \"\"\"\n        tools = await self.get_tools()\n        interfaces = [self.tool_to_python_interface(tool) for tool in tools]\n        \n        return f\"\"\"# Auto-generated Python interfaces for UTCP tools\nfrom typing import TypedDict, Any, List, Dict, Optional, Union\nimport asyncio\n\n{chr(10).join(interfaces)}\"\"\"\n\n    async def call_tool_chain(self, code: str, timeout: int = 30) -> Dict[str, Any]:\n        \"\"\"REQUIRED\n        Execute Python code with access to registered tools and capture console output.\n        \n        The code can call tools directly as async functions and has access to\n        standard Python globals.\n        \n        Args:\n            code: Python code to execute\n            timeout: Optional timeout in seconds (default: 30)\n            \n        Returns:\n            Dict containing both the execution result and captured console logs\n        \"\"\"\n        # Security logging\n        code_hash = hash(code) & 0x7fffffff  # Positive hash for logging\n        logger.info(f\"Code execution requested (hash: {code_hash}, timeout: {timeout}s)\")\n        \n        tools = await self.get_tools()\n        tool_names = [tool.name for tool in tools]\n        logger.info(f\"Available tools for execution: {tool_names}\")\n        \n        # Create logs list for output capture\n        logs: List[str] = []\n        \n        try:\n            # Execute with timeout using RestrictedPython\n            result = await self._run_with_restricted_python(code, tools, logs, timeout)\n            return {\"result\": result, \"logs\": logs}\n        except Exception as error:\n            error_msg = f\"Code execution failed: {error}\"\n            logs.append(f\"[ERROR] {error_msg}\")\n            logger.warning(f\"Code execution failed: {error}\")\n            return {\"result\": None, \"logs\": logs}\n\n    async def _run_with_restricted_python(self, code: str, tools: List[Tool], logs: List[str], timeout: int) -> Any:\n        \"\"\"Run code with timeout support using RestrictedPython for secure execution.\n        \n        Args:\n            code: Python code to execute\n            tools: Available tools for the execution context\n            logs: List to capture print output\n            timeout: Timeout in seconds\n            \n        Returns:\n            Execution result\n        \"\"\"\n        # Wrap user code in a function so return statements work\n        # Indent the user code to be inside the function\n        indented_code = '\\n'.join('    ' + line if line.strip() else '' for line in code.split('\\n'))\n        wrapped_code = f\"\"\"def user_code_function():\n{indented_code}\n\"\"\"\n        \n        # Compile code with RestrictedPython for security\n        compile_result = compile_restricted(wrapped_code, '<string>', 'exec')\n        \n        # Check for compilation errors\n        if hasattr(compile_result, 'errors') and compile_result.errors:\n            error_msg = f\"RestrictedPython compilation errors: {compile_result.errors}\"\n            logger.warning(error_msg)\n            raise RuntimeError(error_msg)\n        \n        # Get the compiled code object\n        if hasattr(compile_result, 'code'):\n            compiled_code = compile_result.code\n        else:\n            # Fallback: compile_result might be the code object itself\n            compiled_code = compile_result\n        \n        # Create execution context with tools and security restrictions\n        context = await self._create_execution_context(tools, logs)\n        \n        # Execute with timeout\n        try:\n            result = await asyncio.wait_for(\n                self._execute_restricted_code(compiled_code, context, logs),\n                timeout=timeout\n            )\n            logger.info(\"Code execution completed successfully\")\n            return result\n        except asyncio.TimeoutError:\n            error_msg = f\"Code execution timed out after {timeout} seconds\"\n            logger.warning(error_msg)\n            raise TimeoutError(error_msg)\n        except Exception as e:\n            logger.warning(f\"Code execution failed: {e}\")\n            raise RuntimeError(f\"Code execution failed: {e}\")\n    \n    async def _execute_restricted_code(self, compiled_code, context: Dict[str, Any], logs: Optional[List[str]] = None) -> Any:\n        \"\"\"Execute the compiled restricted code in the given context.\n        \n        The code is wrapped in a function, so return statements work naturally.\n        \n        Args:\n            compiled_code: Compiled RestrictedPython code object\n            context: Execution context dictionary\n            logs: Optional list to capture print output\n            \n        Returns:\n            Execution result from the function's return statement or None\n        \"\"\"\n        # Execute the compiled code (defines the user_code_function)\n        exec(compiled_code, context)\n        \n        # Call the user function in a thread executor so we can interrupt it with timeout\n        # This is necessary because synchronous code can't be interrupted by asyncio.wait_for()\n        user_function = context.get('user_code_function')\n        if user_function and callable(user_function):\n            import concurrent.futures\n            loop = asyncio.get_event_loop()\n            \n            # Run the user function in a thread pool executor\n            # This allows us to interrupt long-running synchronous code\n            with concurrent.futures.ThreadPoolExecutor(max_workers=1) as executor:\n                future = loop.run_in_executor(executor, user_function)\n                result = await future\n        elif 'result' in context:\n            # Fallback: check if user set 'result' variable (for backwards compatibility)\n            result = context['result']\n        else:\n            result = None\n        \n        # Extract print output from the shared PrintCollector\n        if logs is not None:\n            print_collector = context.get('__shared_print_collector__')\n            if print_collector:\n                # Call the PrintCollector to get accumulated output\n                output = print_collector()\n                if output:\n                    logs.append(output.strip())\n        \n        return result\n\n    def _create_restricted_import(self):\n        \"\"\"Create a restricted import function that only allows safe modules.\n        \n        Note: 'time' module is included for timing functionality, though time.sleep()\n        can bypass async timeouts since it's a blocking call.\n        \"\"\"\n        SAFE_MODULES = {\n            'json', 'math', 'asyncio', 'datetime', 'time', 're', 'typing',\n            'collections', 'itertools', 'functools', 'operator', 'uuid'\n        }\n        \n        def restricted_import(name, *args, **kwargs):\n            if name in SAFE_MODULES:\n                return __import__(name, *args, **kwargs)\n            raise ImportError(f\"Import of '{name}' is not allowed in code execution context\")\n        \n        return restricted_import\n\n    async def _create_execution_context(self, tools: List[Tool], logs: Optional[List[str]] = None) -> Dict[str, Any]:\n        \"\"\"Create a secure execution context for running Python code.\n        \n        This context includes tool functions and safe Python globals with\n        RestrictedPython security restrictions.\n        \n        Args:\n            tools: Array of tools to make available\n            logs: Optional array to capture print output\n            \n        Returns:\n            Secure execution context dictionary\n        \"\"\"\n        # Start with RestrictedPython's safe globals\n        context: Dict[str, Any] = safe_globals.copy()\n        \n        # Create restricted import before updating builtins\n        restricted_import = self._create_restricted_import()\n        \n        # Ensure common builtins are available in __builtins__\n        # RestrictedPython's safe_globals might be missing some common functions\n        if '__builtins__' in context and isinstance(context['__builtins__'], dict):\n            context['__builtins__'].update({\n                'max': max,\n                'min': min,\n                'sum': sum,\n                'abs': abs,\n                'round': round,\n                'sorted': sorted,\n                'reversed': reversed,\n                'enumerate': enumerate,\n                'zip': zip,\n                'filter': filter,\n                'map': map,\n                '__import__': restricted_import,  # Add restricted import to builtins\n            })\n        \n        # Add safe modules\n        context.update({\n            'json': __import__('json'),\n            'asyncio': __import__('asyncio'),\n            'math': __import__('math'),\n            'datetime': __import__('datetime'),\n            'time': __import__('time'),\n            're': __import__('re'),\n            \n            # Add Python interface definitions for reference\n            '__interfaces': await self.get_all_tools_python_interfaces(),\n            '__get_tool_interface': lambda tool_name: (\n                self.tool_to_python_interface(tool)\n                if (tool := next((t for t in tools if t.name == tool_name), None))\n                else None\n            ),\n            \n            # Also add __import__ to context root for compatibility\n            '__import__': restricted_import,\n        })\n        \n        # Set up print collector for output capture\n        # RestrictedPython transforms print statements to use _print_() factory\n        # We create a shared instance that we can access after execution\n        shared_print_collector = PrintCollector()\n        \n        def print_factory(_getattr=None):\n            \"\"\"Factory that returns our shared PrintCollector instance.\n            \n            Args:\n                _getattr: Optional getattr function (RestrictedPython passes this)\n            \"\"\"\n            return shared_print_collector\n        \n        context['_print_'] = print_factory\n        context['_print'] = shared_print_collector  # Also set without trailing underscore\n        context['_getattr_'] = getattr\n        \n        # Store reference to access logs after execution\n        context['__shared_print_collector__'] = shared_print_collector\n\n        # Add tool functions to context organized by manual name (fix closure bug)\n        def make_tool_function(tool_name_ref: str):\n            \"\"\"Create a tool function with proper closure to avoid late binding issues.\n            \n            The function is synchronous but internally blocks on async tool calls,\n            making it easier for LLM-generated code to use without async/await.\n            \"\"\"\n            def tool_function(args: Dict[str, Any] = None, **kwargs):\n                if args is None:\n                    args = kwargs\n                try:\n                    # Security logging for tool calls\n                    logger.info(f\"Tool call: {tool_name_ref} with args: {list(args.keys()) if args else 'none'}\")\n                    \n                    # Block on the async call - this makes the tool function synchronous\n                    # We need to get the current event loop or create one\n                    try:\n                        loop = asyncio.get_event_loop()\n                        if loop.is_running():\n                            # If we're already in an async context, we need to use run_coroutine_threadsafe\n                            # or create a new event loop in a thread. For simplicity, we'll use asyncio.run\n                            # which creates a new event loop\n                            import concurrent.futures\n                            with concurrent.futures.ThreadPoolExecutor() as executor:\n                                future = executor.submit(asyncio.run, self.call_tool(tool_name_ref, args))\n                                result = future.result()\n                        else:\n                            result = loop.run_until_complete(self.call_tool(tool_name_ref, args))\n                    except RuntimeError:\n                        # No event loop, create one\n                        result = asyncio.run(self.call_tool(tool_name_ref, args))\n                    \n                    logger.info(f\"Tool call {tool_name_ref} completed successfully\")\n                    return result\n                except Exception as error:\n                    logger.warning(f\"Tool call {tool_name_ref} failed: {error}\")\n                    raise RuntimeError(f\"Error calling tool '{tool_name_ref}': {error}\")\n            return tool_function\n        \n        for tool in tools:\n            if '.' in tool.name:\n                manual_name, *tool_parts = tool.name.split('.')\n                sanitized_manual_name = self._sanitize_identifier(manual_name)\n                tool_name = '_'.join(self._sanitize_identifier(part) for part in tool_parts)\n                \n                # Create manual namespace object if it doesn't exist\n                if sanitized_manual_name not in context:\n                    context[sanitized_manual_name] = type('Manual', (), {})()\n                \n                # Add the tool function to the manual namespace\n                setattr(\n                    context[sanitized_manual_name],\n                    tool_name,\n                    make_tool_function(tool.name)\n                )\n            else:\n                # If no dot, add directly to root context (no manual name)\n                sanitized_tool_name = self._sanitize_identifier(tool.name)\n                context[sanitized_tool_name] = make_tool_function(tool.name)\n\n        return context\n\n    def _json_schema_to_typed_dict_content(self, schema: JsonSchema) -> str:\n        \"\"\"Convert a JSON Schema to Python TypedDict content (properties only).\n        \n        This generates the content inside a TypedDict class definition.\n        \n        Args:\n            schema: JSON Schema to convert\n            \n        Returns:\n            Python TypedDict properties as string\n        \"\"\"\n        if not schema or not hasattr(schema, 'type') or schema.type != 'object':\n            return '    pass  # Any type allowed'\n\n        properties = getattr(schema, 'properties', {}) or {}\n        required = getattr(schema, 'required', []) or []\n        lines: List[str] = []\n\n        if not properties:\n            return '    pass  # No specific properties defined'\n\n        for prop_name, prop_schema in properties.items():\n            is_required = prop_name in required\n            description = getattr(prop_schema, 'description', '') if prop_schema else ''\n            py_type = self._json_schema_to_python_type_string(prop_schema)\n\n            if description:\n                lines.append(f'    # {description}')\n            \n            if is_required:\n                lines.append(f'    {prop_name}: {py_type}')\n            else:\n                lines.append(f'    {prop_name}: Optional[{py_type}]')\n\n        return '\\n'.join(lines) if lines else '    pass  # No properties'\n\n    def _json_schema_to_python_type(self, schema: JsonSchema, type_name: str) -> str:\n        \"\"\"Convert a JSON Schema to Python TypedDict class definition.\n        \n        This handles the most common JSON Schema patterns used in UTCP tools.\n        \n        Args:\n            schema: JSON Schema to convert\n            type_name: Name for the generated Python class\n            \n        Returns:\n            Python class definition as string\n        \"\"\"\n        if not schema:\n            return f\"class {type_name}(TypedDict):\\n    pass  # Any type\"\n\n        # Handle different schema types\n        schema_type = getattr(schema, 'type', None)\n        if schema_type == 'object':\n            return self._object_schema_to_python_class(schema, type_name)\n        elif schema_type == 'array':\n            return self._array_schema_to_python_type(schema, type_name)\n        elif schema_type in ['string', 'number', 'integer', 'boolean', 'null']:\n            return self._primitive_schema_to_python_type(schema, type_name)\n        else:\n            # Handle union types or fallback to Any\n            if hasattr(schema, 'type') and isinstance(schema.type, list):\n                types = [self._map_json_type_to_python(t) for t in schema.type]\n                union_type = ' | '.join(types)\n                return f\"{type_name} = {union_type}\"\n            return f\"{type_name} = Any\"\n\n    def _object_schema_to_python_class(self, schema: JsonSchema, type_name: str) -> str:\n        \"\"\"Convert an object JSON Schema to Python TypedDict class.\"\"\"\n        properties = getattr(schema, 'properties', {})\n        if not properties:\n            return f\"\"\"class {type_name}(TypedDict):\n    pass  # No specific properties defined\"\"\"\n\n        required = getattr(schema, 'required', []) or []\n        prop_lines = []\n        \n        for key, prop_schema in properties.items():\n            is_required = key in required\n            prop_type = self._json_schema_to_python_type_string(prop_schema)\n            description = getattr(prop_schema, 'description', '') if prop_schema else ''\n            \n            if description:\n                prop_lines.append(f'    # {description}')\n            \n            if is_required:\n                prop_lines.append(f'    {key}: {prop_type}')\n            else:\n                prop_lines.append(f'    {key}: Optional[{prop_type}]')\n\n        properties_content = '\\n'.join(prop_lines)\n        return f\"\"\"class {type_name}(TypedDict):\n{properties_content}\"\"\"\n\n    def _array_schema_to_python_type(self, schema: JsonSchema, type_name: str) -> str:\n        \"\"\"Convert an array JSON Schema to Python type alias.\"\"\"\n        items = getattr(schema, 'items', None)\n        if not items:\n            return f\"{type_name} = List[Any]\"\n\n        if isinstance(items, list):\n            item_types = [self._json_schema_to_python_type_string(item) for item in items]\n            union_type = ' | '.join(item_types)\n            return f\"{type_name} = List[{union_type}]\"\n        else:\n            item_type = self._json_schema_to_python_type_string(items)\n            return f\"{type_name} = List[{item_type}]\"\n\n    def _primitive_schema_to_python_type(self, schema: JsonSchema, type_name: str) -> str:\n        \"\"\"Convert a primitive JSON Schema to Python type with enum support.\"\"\"\n        enum_values = getattr(schema, 'enum', None)\n        if enum_values:\n            enum_literals = []\n            for val in enum_values:\n                if isinstance(val, str):\n                    enum_literals.append(f'\"{val}\"')\n                else:\n                    enum_literals.append(str(val))\n            return f\"{type_name} = Literal[{', '.join(enum_literals)}]\"\n\n        schema_type = getattr(schema, 'type', 'any')\n        base_type = self._map_json_type_to_python(schema_type)\n        return f\"{type_name} = {base_type}\"\n\n    def _json_schema_to_python_type_string(self, schema: JsonSchema) -> str:\n        \"\"\"Convert a JSON Schema to a Python type string (not a full type definition).\"\"\"\n        if not schema:\n            return 'Any'\n\n        enum_values = getattr(schema, 'enum', None)\n        if enum_values:\n            enum_literals = []\n            for val in enum_values:\n                if isinstance(val, str):\n                    enum_literals.append(f'\"{val}\"')\n                else:\n                    enum_literals.append(str(val))\n            return f\"Literal[{', '.join(enum_literals)}]\"\n\n        schema_type = getattr(schema, 'type', None)\n        if schema_type == 'object':\n            properties = getattr(schema, 'properties', {})\n            if not properties:\n                return 'Dict[str, Any]'\n            \n            required = getattr(schema, 'required', []) or []\n            prop_types = []\n            for key, prop_schema in properties.items():\n                is_required = key in required\n                prop_type = self._json_schema_to_python_type_string(prop_schema)\n                if is_required:\n                    prop_types.append(f'\"{key}\": {prop_type}')\n                else:\n                    prop_types.append(f'\"{key}\": Optional[{prop_type}]')\n            return f\"TypedDict('{{{', '.join(prop_types)}}}')\"\n        \n        elif schema_type == 'array':\n            items = getattr(schema, 'items', None)\n            if not items:\n                return 'List[Any]'\n            if isinstance(items, list):\n                item_types = [self._json_schema_to_python_type_string(item) for item in items]\n                return f\"List[{' | '.join(item_types)}]\"\n            else:\n                item_type = self._json_schema_to_python_type_string(items)\n                return f\"List[{item_type}]\"\n        \n        elif schema_type in ['string', 'number', 'integer', 'boolean', 'null']:\n            return self._map_json_type_to_python(schema_type)\n        \n        elif isinstance(schema_type, list):\n            types = [self._map_json_type_to_python(t) for t in schema_type]\n            return ' | '.join(types)\n        \n        return 'Any'\n\n    def _map_json_type_to_python(self, json_type: str) -> str:\n        \"\"\"Map basic JSON Schema types to Python types.\"\"\"\n        mapping = {\n            'string': 'str',\n            'number': 'float',\n            'integer': 'int',\n            'boolean': 'bool',\n            'null': 'None',\n            'object': 'Dict[str, Any]',\n            'array': 'List[Any]'\n        }\n        return mapping.get(json_type, 'Any')\n\n    # Delegate all abstract methods to the base client\n    async def register_manual(self, manual_call_template):\n        return await self._base_client.register_manual(manual_call_template)\n\n    async def register_manuals(self, manual_call_templates):\n        return await self._base_client.register_manuals(manual_call_templates)\n        \n    async def deregister_manual(self, manual_call_template_name: str):\n        return await self._base_client.deregister_manual(manual_call_template_name)\n    \n    async def call_tool(self, tool_name: str, tool_args: Dict[str, Any]):\n        return await self._base_client.call_tool(tool_name, tool_args)\n\n    async def call_tool_streaming(self, tool_name: str, tool_args: Dict[str, Any]):\n        async for item in self._base_client.call_tool_streaming(tool_name, tool_args):\n            yield item\n\n    async def search_tools(self, query: str, limit: int = 10, any_of_tags_required: Optional[List[str]] = None):\n        return await self._base_client.search_tools(query, limit, any_of_tags_required)\n\n    async def get_required_variables_for_manual_and_tools(self, manual_call_template):\n        return await self._base_client.get_required_variables_for_manual_and_tools(manual_call_template)\n\n    async def get_required_variables_for_registered_tool(self, tool_name: str):\n        return await self._base_client.get_required_variables_for_registered_tool(tool_name)\n        \n    async def get_tools(self) -> List[Tool]:\n        \"\"\"Get all registered tools from the base client.\"\"\"\n        return await self._base_client.config.tool_repository.get_tools()\n",
      "line_count": 739,
      "word_count": 2927,
      "title": "Code Mode Utcp Client.Py",
      "summary": "\"\"\"Code mode UTCP client extension that adds Python code execution capabilities. This module extends the base UtcpClient to provide Python code execution",
      "key_terms": [
        "open",
        "comprehensive",
        "reversed",
        "contain",
        "sanitized",
        "etc",
        "convert",
        "extension",
        "Code",
        "list",
        "long-running",
        "mode",
        "interrupted",
        "logger",
        "since",
        "yield",
        "CodeModeUtcpClient",
        "Tags",
        "chr",
        "if"
      ],
      "timestamp": "2025-12-24T18:55:59.921309"
    },
    {
      "file_path": "UPSTREAM\\code-mode\\python-library\\src\\utcp_code_mode\\__init__.py",
      "content_type": "code",
      "content": "\"\"\"UTCP Code Mode Client Extension.\n\nThis package provides a CodeModeUtcpClient that extends the base UtcpClient\nwith Python code execution capabilities. It allows executing Python code\nthat can directly call registered tools as functions.\n\nKey Features:\n    - Python code execution with tool access\n    - Automatic Python type hint generation from JSON schemas\n    - Console output capture\n    - Tool introspection capabilities\n    - Safe execution environment with timeout support\n\nUsage:\n    ```python\n    from utcp_code_mode import CodeModeUtcpClient\n    \n    # Create a code mode client\n    client = await CodeModeUtcpClient.create()\n    \n    # Execute Python code with tool access\n    result = await client.call_tool_chain('''\n    # Your Python code here\n    tools = await search_tools(\"weather\")\n    result = await weather.get_current_weather(city=\"London\")\n    print(f\"Weather in London: {result}\")\n    ''')\n    \n    print(\"Result:\", result[\"result\"])\n    print(\"Logs:\", result[\"logs\"])\n    ```\n\"\"\"\n\nfrom utcp_code_mode.code_mode_utcp_client import CodeModeUtcpClient\n\n# Since this is a client extension rather than a communication protocol,\n# we don't need to register with the plugin system in the same way.\n# The CodeModeUtcpClient can be used directly by importing it.\n\n__all__ = [\n    \"CodeModeUtcpClient\",\n]\n\n__version__ = \"1.0.0\"\n",
      "line_count": 45,
      "word_count": 165,
      "title": "  Init  .Py",
      "summary": "\"\"\"UTCP Code Mode Client Extension. This package provides a CodeModeUtcpClient that extends the base UtcpClient",
      "key_terms": [
        "London",
        "executing",
        "output",
        "we",
        "Python",
        "Result",
        "extension",
        "Code",
        "importing",
        "mode",
        "Utcp",
        "same",
        "It",
        "CodeModeUtcpClient",
        "Execute",
        "that",
        "Features",
        "system",
        "function",
        "Usage"
      ],
      "timestamp": "2025-12-24T18:55:59.953068"
    },
    {
      "file_path": "UPSTREAM\\code-mode\\python-library\\tests\\test_code_mode_utcp_client.py",
      "content_type": "code",
      "content": "\"\"\"Tests for the CodeModeUtcpClient.\"\"\"\n\nimport pytest\nimport pytest_asyncio\nimport asyncio\nimport json\nfrom typing import Dict, Any\nfrom unittest.mock import Mock, AsyncMock, patch\n\nfrom utcp_code_mode import CodeModeUtcpClient\nfrom utcp.data.tool import Tool, JsonSchema\nfrom utcp.data.call_template import CallTemplate\n\n\nclass MockCallTemplate(CallTemplate):\n    \"\"\"Mock call template for testing.\"\"\"\n    def __init__(self, name=\"test\", call_template_type=\"http\"):\n        super().__init__(name=name, call_template_type=call_template_type)\n\n\n@pytest.fixture\ndef mock_base_client():\n    \"\"\"Create a mock base client for testing.\"\"\"\n    mock_client = Mock()\n    mock_client.config = Mock()\n    mock_client.root_dir = \"/test/root\"\n    \n    # Mock tool repository\n    mock_repo = Mock()\n    mock_repo.get_tools = AsyncMock(return_value=[])\n    mock_client.config.tool_repository = mock_repo\n    \n    # Mock the base client methods\n    mock_client.register_manual = AsyncMock()\n    mock_client.register_manuals = AsyncMock()\n    mock_client.deregister_manual = AsyncMock()\n    mock_client.call_tool = AsyncMock()\n    mock_client.call_tool_streaming = AsyncMock()\n    mock_client.search_tools = AsyncMock()\n    mock_client.get_required_variables_for_manual_and_tools = AsyncMock()\n    mock_client.get_required_variables_for_registered_tool = AsyncMock()\n    \n    return mock_client\n\n\n@pytest.fixture\ndef code_mode_client(mock_base_client):\n    \"\"\"Create a CodeModeUtcpClient instance for testing.\"\"\"\n    return CodeModeUtcpClient(mock_base_client)\n\n\n@pytest.fixture\ndef sample_tool():\n    \"\"\"Create a sample tool for testing.\"\"\"\n    input_schema = JsonSchema(\n        type=\"object\",\n        properties={\n            \"city\": JsonSchema(type=\"string\", description=\"City name\"),\n            \"country\": JsonSchema(type=\"string\", description=\"Country code\")\n        },\n        required=[\"city\"]\n    )\n    \n    output_schema = JsonSchema(\n        type=\"object\",\n        properties={\n            \"temperature\": JsonSchema(type=\"number\", description=\"Temperature in Celsius\"),\n            \"description\": JsonSchema(type=\"string\", description=\"Weather description\")\n        }\n    )\n    \n    return Tool(\n        name=\"weather.get_current_weather\",\n        description=\"Get current weather for a city\",\n        inputs=input_schema,\n        outputs=output_schema,\n        tags=[\"weather\", \"api\"],\n        tool_call_template=MockCallTemplate()\n    )\n\n\nclass TestCodeModeUtcpClient:\n    \"\"\"Test cases for CodeModeUtcpClient.\"\"\"\n\n    def test_sanitize_identifier(self, code_mode_client):\n        \"\"\"Test identifier sanitization.\"\"\"\n        client = code_mode_client\n        \n        # Test normal identifier\n        assert client._sanitize_identifier(\"normal_name\") == \"normal_name\"\n        \n        # Test identifier with special characters\n        assert client._sanitize_identifier(\"test-name.with@special\") == \"test_name_with_special\"\n        \n        # Test identifier starting with number\n        assert client._sanitize_identifier(\"123test\") == \"_123test\"\n        \n        # Test empty string\n        assert client._sanitize_identifier(\"\") == \"\"\n\n    def test_tool_to_python_interface(self, code_mode_client, sample_tool):\n        \"\"\"Test converting tool to Python interface.\"\"\"\n        client = code_mode_client\n        \n        interface = client.tool_to_python_interface(sample_tool)\n        \n        # Check that it contains expected elements\n        assert \"weather\" in interface  # namespace\n        assert \"get_current_weather\" in interface  # tool name\n        assert \"TypedDict\" in interface\n        assert \"Get current weather for a city\" in interface  # description\n        assert \"weather, api\" in interface  # tags\n        assert \"weather.get_current_weather\" in interface  # access pattern (no await)\n        \n        # Check caching\n        interface2 = client.tool_to_python_interface(sample_tool)\n        assert interface == interface2\n\n    @pytest.mark.asyncio\n    async def test_get_all_tools_python_interfaces(self, code_mode_client, sample_tool, mock_base_client):\n        \"\"\"Test getting all tool interfaces.\"\"\"\n        client = code_mode_client\n        base_client = mock_base_client\n        \n        # Mock the get_tools method\n        base_client.config.tool_repository.get_tools.return_value = [sample_tool]\n        \n        interfaces = await client.get_all_tools_python_interfaces()\n        \n        # Check that it contains expected imports and content\n        assert \"from typing import TypedDict, Any, List, Dict, Optional, Union\" in interfaces\n        assert \"import asyncio\" in interfaces\n        assert \"weather\" in interfaces\n        assert \"get_current_weather\" in interfaces\n\n    @pytest.mark.asyncio\n    async def test_call_tool_chain_simple_execution(self, code_mode_client, mock_base_client):\n        \"\"\"Test simple code execution without tools.\"\"\"\n        client = code_mode_client\n        base_client = mock_base_client\n        \n        base_client.config.tool_repository.get_tools.return_value = []\n        \n        code = \"\"\"\nvalue = 2 + 2\nprint(f\"The answer is {value}\")\nreturn value\n\"\"\"\n        \n        result = await client.call_tool_chain(code)\n        \n        assert result[\"result\"] == 4\n        # Logs should now capture print output with RestrictedPython\n        assert isinstance(result[\"logs\"], list)\n        assert len(result[\"logs\"]) > 0\n        assert \"The answer is 4\" in result[\"logs\"][0]\n\n    @pytest.mark.asyncio\n    async def test_call_tool_chain_with_tool_calls(self, code_mode_client, mock_base_client, sample_tool):\n        \"\"\"Test code execution with tool calls.\"\"\"\n        client = code_mode_client\n        base_client = mock_base_client\n        \n        # Setup mocks\n        base_client.config.tool_repository.get_tools.return_value = [sample_tool]\n        base_client.call_tool.return_value = {\"temperature\": 20, \"description\": \"Sunny\"}\n        \n        code = \"\"\"\n# Call the weather tool - now synchronous!\nweather_data = weather.get_current_weather(city=\"London\")\nprint(f\"Weather result: {weather_data}\")\nreturn weather_data\n\"\"\"\n        \n        # Tool calls should now work with RestrictedPython in same process\n        result = await client.call_tool_chain(code)\n        \n        # Tool calls should work now\n        assert result[\"result\"] == {\"temperature\": 20, \"description\": \"Sunny\"}\n        # Verify the tool was called with correct arguments\n        base_client.call_tool.assert_called_once_with(\"weather.get_current_weather\", {\"city\": \"London\"})\n        # Verify logs are captured\n        assert len(result[\"logs\"]) > 0\n        assert \"Weather result:\" in result[\"logs\"][0]\n\n    @pytest.mark.asyncio\n    async def test_call_tool_chain_error_handling(self, code_mode_client, mock_base_client):\n        \"\"\"Test error handling in code execution.\"\"\"\n        client = code_mode_client\n        base_client = mock_base_client\n        \n        base_client.config.tool_repository.get_tools.return_value = []\n        \n        code = \"\"\"\n# This will cause an error\nreturn 1 / 0\n\"\"\"\n        \n        result = await client.call_tool_chain(code)\n        \n        assert result[\"result\"] is None\n        # Error should now be captured in logs\n        assert isinstance(result[\"logs\"], list)\n        assert len(result[\"logs\"]) > 0\n        assert \"ERROR\" in result[\"logs\"][0] or \"division by zero\" in str(result).lower()\n\n    @pytest.mark.asyncio\n    async def test_call_tool_chain_timeout(self, code_mode_client, mock_base_client):\n        \"\"\"Test timeout handling.\n        \n        Note: Python can't forcibly kill threads running synchronous code,\n        so infinite loops can't be interrupted. This test verifies that\n        the timeout mechanism works for operations that yield control.\n        \"\"\"\n        client = code_mode_client\n        base_client = mock_base_client\n        \n        base_client.config.tool_repository.get_tools.return_value = []\n        \n        # Test with code that takes too long but can be interrupted\n        # Use a computation that checks for cancellation\n        code = \"\"\"\n# Test timeout with a long-running but interruptible operation\nimport asyncio\nresult = []\nfor i in range(1000000):\n    result.append(i * i)\nreturn len(result)\n\"\"\"\n        \n        # Test with a very short timeout\n        result = await client.call_tool_chain(code, timeout=1)\n        \n        # The operation should time out\n        assert result[\"result\"] is None\n        # Timeout error should be captured in logs\n        assert isinstance(result[\"logs\"], list)\n        assert len(result[\"logs\"]) > 0\n        assert \"timed out\" in result[\"logs\"][0].lower() or \"ERROR\" in result[\"logs\"][0]\n\n    @pytest.mark.asyncio\n    async def test_create_execution_context(self, code_mode_client, sample_tool):\n        \"\"\"Test execution context creation.\"\"\"\n        client = code_mode_client\n        logs = []\n        context = await client._create_execution_context([sample_tool], logs)\n        \n        # Check basic utilities are present\n        assert \"json\" in context\n        assert \"asyncio\" in context\n        assert \"math\" in context\n        \n        # Check that RestrictedPython safe globals are present\n        assert \"_getattr_\" in context\n        assert \"_print\" in context\n        \n        # Check that dangerous modules are not present in context root\n        assert \"os\" not in context\n        assert \"sys\" not in context\n        \n        # Check that restricted imports are in place\n        assert \"__import__\" in context\n        \n        # Check tool-related items\n        assert \"__interfaces\" in context\n        assert \"__get_tool_interface\" in context\n        assert \"weather\" in context\n        \n        # Test the tool interface function\n        interface = context[\"__get_tool_interface\"](\"weather.get_current_weather\")\n        assert interface is not None\n        assert \"get_current_weather\" in interface\n\n    def test_json_schema_to_python_type_string(self, code_mode_client):\n        \"\"\"Test JSON schema to Python type conversion.\"\"\"\n        client = code_mode_client\n        \n        # Test string type\n        string_schema = JsonSchema(type=\"string\")\n        assert client._json_schema_to_python_type_string(string_schema) == \"str\"\n        \n        # Test number type\n        number_schema = JsonSchema(type=\"number\")\n        assert client._json_schema_to_python_type_string(number_schema) == \"float\"\n        \n        # Test object type\n        object_schema = JsonSchema(\n            type=\"object\",\n            properties={\"name\": JsonSchema(type=\"string\")},\n            required=[\"name\"]\n        )\n        result = client._json_schema_to_python_type_string(object_schema)\n        assert \"TypedDict\" in result\n        assert \"name\" in result\n        \n        # Test array type\n        array_schema = JsonSchema(\n            type=\"array\",\n            items=JsonSchema(type=\"string\")\n        )\n        assert client._json_schema_to_python_type_string(array_schema) == \"List[str]\"\n        \n        # Test enum\n        enum_schema = JsonSchema(\n            type=\"string\",\n            enum=[\"red\", \"green\", \"blue\"]\n        )\n        result = client._json_schema_to_python_type_string(enum_schema)\n        assert \"Literal\" in result\n        assert '\"red\"' in result\n\n    def test_map_json_type_to_python(self, code_mode_client):\n        \"\"\"Test basic type mapping.\"\"\"\n        client = code_mode_client\n        \n        assert client._map_json_type_to_python(\"string\") == \"str\"\n        assert client._map_json_type_to_python(\"number\") == \"float\"\n        assert client._map_json_type_to_python(\"integer\") == \"int\"\n        assert client._map_json_type_to_python(\"boolean\") == \"bool\"\n        assert client._map_json_type_to_python(\"null\") == \"None\"\n        assert client._map_json_type_to_python(\"unknown\") == \"Any\"\n\n    @pytest.mark.asyncio\n    async def test_delegation_methods(self, code_mode_client, mock_base_client):\n        \"\"\"Test that all abstract methods are properly delegated.\"\"\"\n        client = code_mode_client\n        base_client = mock_base_client\n        \n        call_template = MockCallTemplate()\n        \n        # Test all delegated methods\n        await client.register_manual(call_template)\n        base_client.register_manual.assert_called_once_with(call_template)\n        \n        await client.register_manuals([call_template])\n        base_client.register_manuals.assert_called_once_with([call_template])\n        \n        await client.deregister_manual(\"test\")\n        base_client.deregister_manual.assert_called_once_with(\"test\")\n        \n        await client.call_tool(\"tool\", {\"arg\": \"value\"})\n        base_client.call_tool.assert_called_once_with(\"tool\", {\"arg\": \"value\"})\n        \n        await client.search_tools(\"query\")\n        base_client.search_tools.assert_called_once_with(\"query\", 10, None)\n        \n        await client.get_required_variables_for_manual_and_tools(call_template)\n        base_client.get_required_variables_for_manual_and_tools.assert_called_once_with(call_template)\n        \n        await client.get_required_variables_for_registered_tool(\"tool\")\n        base_client.get_required_variables_for_registered_tool.assert_called_once_with(\"tool\")\n\n    @pytest.mark.asyncio\n    async def test_restricted_imports(self, code_mode_client, mock_base_client):\n        \"\"\"Test that dangerous imports are blocked.\"\"\"\n        client = code_mode_client\n        base_client = mock_base_client\n        \n        base_client.config.tool_repository.get_tools.return_value = []\n        \n        # Test that dangerous imports are blocked\n        dangerous_code = \"\"\"\ntry:\n    import os\n    return \"Should not reach here - os import succeeded\"\nexcept ImportError as e:\n    return f\"Import blocked: {e}\"\n\"\"\"\n        \n        result = await client.call_tool_chain(dangerous_code)\n        assert \"Import blocked\" in str(result[\"result\"])\n        \n        # Test that safe imports work\n        safe_code = \"\"\"\ntry:\n    import json\n    import math\n    return \"Safe imports work\"\nexcept ImportError as e:\n    return f\"Unexpected error: {e}\"\n\"\"\"\n        \n        result = await client.call_tool_chain(safe_code)\n        assert result[\"result\"] == \"Safe imports work\"\n\n    @pytest.mark.asyncio\n    async def test_restricted_builtins(self, code_mode_client, mock_base_client):\n        \"\"\"Test that builtins are properly restricted.\"\"\"\n        client = code_mode_client\n        base_client = mock_base_client\n        \n        base_client.config.tool_repository.get_tools.return_value = []\n        \n        # Test that safe builtins work\n        safe_builtins_code = \"\"\"\nresults = []\nresults.append(len(\"test\"))  # len should work\nresults.append(str(42))      # str should work\nresults.append(max([1,2,3])) # max should work\nreturn results\n\"\"\"\n        \n        result = await client.call_tool_chain(safe_builtins_code)\n        assert result[\"result\"] == [4, \"42\", 3]\n\n    @pytest.mark.asyncio\n    async def test_create_class_method(self, mock_base_client):\n        \"\"\"Test the create class method.\"\"\"\n        base_client = mock_base_client\n        \n        with patch('utcp.implementations.utcp_client_implementation.UtcpClientImplementation') as mock_impl:\n            # Make the create method an AsyncMock to properly handle await\n            mock_impl.create = AsyncMock(return_value=base_client)\n            \n            client = await CodeModeUtcpClient.create(\"/test/root\", {\"test\": \"config\"})\n            \n            assert isinstance(client, CodeModeUtcpClient)\n            assert client._base_client == base_client\n            mock_impl.create.assert_called_once_with(\"/test/root\", {\"test\": \"config\"})\n\n    def test_create_restricted_import(self, code_mode_client):\n        \"\"\"Test RestrictedPython integration and safe globals.\"\"\"\n        client = code_mode_client\n        \n        # Test that restricted import function works\n        restricted_import = client._create_restricted_import()\n        \n        # Test safe imports work\n        json_module = restricted_import('json')\n        assert json_module is not None\n        \n        # Test dangerous imports are blocked\n        with pytest.raises(ImportError, match=\"Import of 'os' is not allowed\"):\n            restricted_import('os')\n\n    def test_agent_prompt_template(self):\n        \"\"\"Test that the agent prompt template is properly defined.\"\"\"\n        template = CodeModeUtcpClient.AGENT_PROMPT_TEMPLATE\n        \n        assert isinstance(template, str)\n        assert len(template) > 100  # Should be substantial\n        assert \"CodeModeUtcpClient\" in template\n        assert \"Tool Discovery\" in template\n        assert \"call_tool_chain\" in template\n        assert \"manual.tool\" in template\n        assert \"synchronous\" in template  # Should mention tools are synchronous\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__])\n",
      "line_count": 451,
      "word_count": 1370,
      "title": "Test Code Mode Utcp Client.Py",
      "summary": "\"\"\"Tests for the CodeModeUtcpClient.\"\"\" import pytest",
      "key_terms": [
        "Timeout",
        "London",
        "lower",
        "output",
        "implementations",
        "integration",
        "AsyncMock",
        "Python",
        "loops",
        "null",
        "async",
        "number",
        "getting",
        "Sunny",
        "error",
        "pattern",
        "Setup",
        "list",
        "mention",
        "long-running"
      ],
      "timestamp": "2025-12-24T18:55:59.984978"
    },
    {
      "file_path": "UPSTREAM\\code-mode\\typescript-library\\package.json",
      "content_type": "configuration",
      "content": "// OUTDATED, you can find the new version at https://github.com/universal-tool-calling-protocol/typescript-utcp/tree/main/packages/code-mode\n{\n  \"name\": \"@utcp/code-mode\",\n  \"version\": \"1.0.4\",\n  \"description\": \"Code execution mode for UTCP - enables executing TypeScript code chains with tool access\",\n  \"main\": \"dist/index.cjs\",\n  \"module\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"type\": \"module\",\n  \"license\": \"MPL-2.0\",\n  \"author\": \"UTCP Contributors\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/universal-tool-calling-protocol/typescript-utcp.git\",\n    \"directory\": \"packages/code-mode\"\n  },\n  \"keywords\": [\n    \"utcp\",\n    \"code\",\n    \"typescript\",\n    \"execution\",\n    \"tool calling\",\n    \"chain\"\n  ],\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"test\": \"bun test\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\",\n      \"require\": \"./dist/index.cjs\",\n      \"default\": \"./dist/index.js\"\n    }\n  },\n  \"dependencies\": {\n    \"@utcp/sdk\": \"^1.0.17\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"@utcp/direct-call\": \"^1.0.12\",\n    \"bun-types\": \"latest\",\n    \"typescript\": \"^5.0.0\"\n  }\n}\n",
      "line_count": 53,
      "word_count": 110,
      "title": "Package.Json",
      "summary": "// OUTDATED, you can find the new version at https://github.com/universal-tool-calling-protocol/typescript-utcp/tree/main/packages/code-mode \"name\": \"@utcp/code-mode\",",
      "key_terms": [
        "executing",
        "build",
        "packages",
        "Code",
        "index",
        "mode",
        "dependencies",
        "version",
        "devDependencies",
        "https",
        "code-mode",
        "Contributors",
        "universal-tool",
        "git",
        "files",
        "description",
        "call",
        "scripts",
        "find",
        "MPL"
      ],
      "timestamp": "2025-12-24T18:56:00.015896"
    },
    {
      "file_path": "UPSTREAM\\code-mode\\typescript-library\\README.md",
      "content_type": "documentation",
      "content": "# Code Mode UTCP\n\n[![npm](https://img.shields.io/npm/v/@utcp/code-mode)](https://www.npmjs.com/package/@utcp/code-mode) \n![npm downloads](https://img.shields.io/npm/dt/@utcp/code-mode)\n![GitHub Stars](https://img.shields.io/github/stars/universal-tool-calling-protocol/typescript-utcp)\n\n> **The first plug-and-play Code Mode library that enables tool call via code execution locally.**  \n> Transform your AI agents from clunky tool callers into efficient code executors â€” in just 3 lines.\n\n## Why This Changes Everything\n\nLLMs excel at writing code but struggle with tool calls. Instead of exposing hundreds of tools directly, give them ONE tool that executes TypeScript code with access to your entire toolkit.\n\n**Research from [Apple](https://machinelearning.apple.com/research/codeact), [Cloudflare](https://blog.cloudflare.com/code-mode/) and [Anthropic](https://www.anthropic.com/engineering/code-execution-with-mcp) proves:**\n- **60% faster execution** than traditional tool calling\n- **68% fewer tokens** consumed  \n- **88% fewer API round trips**\n- **98.7% reduction in context overhead** for complex workflows\n\n## Comprehensive Benchmarks\n\nIndependent [Python benchmark study](https://github.com/imran31415/codemode_python_benchmark) validates the performance claims with **$9,536/year cost savings** at 1,000 scenarios/day:\n\n| Scenario Complexity | Traditional | Code Mode | **Improvement** |\n|---------------------|-------------|-----------|----------------|\n| **Simple (2-3 tools)** | 3 iterations | 1 execution | **67% faster** |\n| **Medium (4-7 tools)** | 8 iterations | 1 execution | **75% faster** |\n| **Complex (8+ tools)** | 16 iterations | 1 execution | **88% faster** |\n\n### **Why Code Mode Dominates:**\n\n   **Batching Advantage** - Single code block replaces multiple API calls  \n   **Cognitive Efficiency** - LLMs excel at code generation vs. tool orchestration  \n   **Computational Efficiency** - No context re-processing between operations\n\n**Real-world results:** Independent benchmarks demonstrate significant cost savings, with **$9,536/year savings** possible at enterprise scale (1,000 scenarios/day).\n\n## Get Started in 3 Lines\n\n```typescript\nimport { CodeModeUtcpClient } from '@utcp/code-mode';\n\nconst client = await CodeModeUtcpClient.create();                    // 1. Initialize\nawait client.registerManual({ name: 'github', /* MCP config */ });  // 2. Add tools  \nconst { result } = await client.callToolChain(`/* TypeScript */`);   // 3. Execute code\n```\n\nThat's it. Your AI agent can now execute complex workflows in a single request instead of dozens.\n\n## What You Get\n\n### **Progressive Tool Discovery**\n```typescript\n// Agent discovers tools dynamically, loads only what it needs\nconst tools = await client.searchTools('github pull request');\n// Instead of 500 tool definitions â†’ 3 relevant tools\n```\n\n### **Natural Code Execution**  \n```typescript\nconst { result, logs } = await client.callToolChain(`\n  // Chain multiple operations in one request\n  const pr = await github.get_pull_request({ owner: 'microsoft', repo: 'vscode', pull_number: 1234 });\n  const comments = await github.get_pull_request_comments({ owner: 'microsoft', repo: 'vscode', pull_number: 1234 });\n  const reviews = await github.get_pull_request_reviews({ owner: 'microsoft', repo: 'vscode', pull_number: 1234 });\n  \n  // Process data efficiently in-sandbox\n  return {\n    title: pr.title,\n    commentCount: comments.length,\n    approvals: reviews.filter(r => r.state === 'APPROVED').length\n  };\n`);\n// Single API call replaces 15+ traditional tool calls\n```\n\n### **Auto-Generated TypeScript Interfaces**\n```typescript\nnamespace github {\n  interface get_pull_requestInput {\n    /** Repository owner */\n    owner: string;\n    /** Repository name */ \n    repo: string;\n    /** Pull request number */\n    pull_number: number;\n  }\n}\n```\n\n## Enterprise-Ready\n\n- **Secure VM Sandboxing** â€“ Node.js isolates prevent unauthorized access\n- **Timeout Protection** â€“ Configurable execution limits prevent runaway code  \n- **Complete Observability** â€“ Full console output capture and error handling\n- **Zero External Dependencies** â€“ Tools only accessible through registered UTCP/MCP servers\n- **Runtime Introspection** â€“ Dynamic interface discovery for adaptive workflows\n\n## Universal Protocol Support\n\nWorks with **any tool ecosystem:**\n\n| Protocol | Description | Usage |\n|----------|-------------|-------|\n| **MCP** | Model Context Protocol servers | `call_template_type: 'mcp'` |\n| **HTTP** | REST APIs with auto-discovery | `call_template_type: 'http'` |  \n| **File** | Local JSON/YAML configurations | `call_template_type: 'file'` |\n| **CLI** | Command-line tool execution | `call_template_type: 'cli'` |\n\n## Installation\n\n```bash\nnpm install @utcp/code-mode\n```\n\n## Even Easier: Ready-to-Use MCP Server\n\n**Want Code Mode without any setup?** Use our plug-and-play MCP server with Claude Desktop or any MCP client:\n\n```json\n{\n  \"mcpServers\": {\n    \"code-mode\": {\n      \"command\": \"npx\",\n      \"args\": [\"@utcp/mcp-bridge\"],\n      \"env\": {\n        \"UTCP_CONFIG_FILE\": \"/path/to/your/.utcp_config.json\"\n      }\n    }\n  }\n}\n```\n\n**That's it!** No installation, no Node.js knowledge required. The [UTCP-MCP Bridge](https://github.com/universal-tool-calling-protocol/utcp-mcp) automatically:\n- Downloads and runs the latest version via `npx`\n- Loads your tool configurations from JSON\n- Provides code execution capabilities to Claude Desktop\n- Gives you `call_tool_chain` as an MCP tool for TypeScript execution\n\n**Perfect for non-developers** who want Code Mode power in Claude Desktop!\n\n## Direct TypeScript Usage\n\n### 1. **MCP Server Integration**\nConnect to any Model Context Protocol server:\n\n```typescript\nimport { CodeModeUtcpClient } from '@utcp/code-mode';\n\nconst client = await CodeModeUtcpClient.create();\n\n// Connect to GitHub MCP server\nawait client.registerManual({\n  name: 'github',\n  call_template_type: 'mcp',\n  config: {\n    mcpServers: {\n      github: {\n        command: 'docker',\n        args: ['run', '-i', '--rm', '-e', 'GITHUB_PERSONAL_ACCESS_TOKEN', 'mcp/github'],\n        env: { GITHUB_PERSONAL_ACCESS_TOKEN: process.env.GITHUB_TOKEN }\n      }\n    }\n  }\n});\n```\n\n### 2. **Execute Multi-Step Workflows**\nReplace 15+ tool calls with a single code execution:\n\n```typescript\nconst { result, logs } = await client.callToolChain(`\n  // Traditional: 4 separate API round trips â†’ Code Mode: 1 execution\n  const pr = await github.get_pull_request({ owner: 'microsoft', repo: 'vscode', pull_number: 1234 });\n  const comments = await github.get_pull_request_comments({ owner: 'microsoft', repo: 'vscode', pull_number: 1234 });\n  const reviews = await github.get_pull_request_reviews({ owner: 'microsoft', repo: 'vscode', pull_number: 1234 });\n  const files = await github.get_pull_request_files({ owner: 'microsoft', repo: 'vscode', pull_number: 1234 });\n  \n  // Process data in-sandbox (no token overhead)\n  const summary = {\n    title: pr.title,\n    state: pr.state,\n    author: pr.user.login,\n    stats: {\n      comments: comments.length,\n      reviews: reviews.length, \n      filesChanged: files.length,\n      approvals: reviews.filter(r => r.state === 'APPROVED').length\n    },\n    topDiscussion: comments.slice(0, 3).map(c => ({\n      author: c.user.login,\n      preview: c.body.substring(0, 100) + '...'\n    }))\n  };\n  \n  console.log(\\`PR \"\\${pr.title}\" analysis complete\\`);\n  return summary;\n`);\n\nconsole.log('Analysis Result:', result);\n// console output: 'PR \"Fix memory leak in hooks\" analysis complete'\n```\n\n---\n\n## Advanced Features\n\n### **Multi-Protocol Tool Chains**\nMix and match different tool ecosystems in a single execution:\n\n```typescript\n// Register multiple tool sources\nawait client.registerManual({ name: 'github', call_template_type: 'mcp', /* config */ });\nawait client.registerManual({ name: 'slack', call_template_type: 'http', /* config */ });\nawait client.registerManual({ name: 'db', call_template_type: 'file', file_path: './db-tools.json' }); // This loads a UTCP manual from a json file\n\nconst result = await client.callToolChain(`\n  // Fetch PR data from GitHub (MCP)\n  const pr = await github.get_pull_request({ owner: 'company', repo: 'api', pull_number: 42 });\n  \n  // Query deployment status from database (File)\n  const deployment = await db.get_deployment_status({ pr_id: pr.id });\n  \n  // Send notification to Slack (HTTP)\n  await slack.post_message({\n    channel: '#releases',\n    text: \\`PR #42 \"\\${pr.title}\" deployed to \\${deployment.environment}\\`\n  });\n  \n  return { pr: pr.title, environment: deployment.environment };\n`);\n```\n\n### **Runtime Interface Introspection**\nTools can dynamically discover and adapt to available interfaces:\n\n```typescript\nconst result = await client.callToolChain(`\n  // Discover available tools at runtime\n  console.log('Available interfaces:', __interfaces);\n  \n  // Get specific tool interface for validation\n  const prInterface = __getToolInterface('github.get_pull_request');\n  console.log('PR tool expects:', prInterface);\n  \n  // Use interface info for dynamic workflows\n  const hasSlackTools = __interfaces.includes('namespace slack');\n  if (hasSlackTools) {\n    await slack.post_message({ channel: '#dev', text: 'Analysis complete' });\n  }\n  \n  return { toolsAvailable: hasSlackTools };\n`);\n```\n\n### **Context-Efficient Data Processing**\nProcess large datasets without bloating the model's context:\n\n```typescript\nconst result = await client.callToolChain(`\n  // Fetch large dataset\n  const allIssues = await github.list_repository_issues({ owner: 'facebook', repo: 'react' });\n  console.log('Fetched', allIssues.length, 'total issues');\n  \n  // Process efficiently in-sandbox\n  const criticalBugs = allIssues\n    .filter(issue => issue.labels.some(l => l.name === 'bug'))\n    .filter(issue => issue.labels.some(l => l.name === 'high priority'))\n    .map(issue => ({\n      number: issue.number,\n      title: issue.title,\n      author: issue.user.login,\n      daysOld: Math.floor((Date.now() - new Date(issue.created_at)) / (1000 * 60 * 60 * 24))\n    }))\n    .sort((a, b) => b.daysOld - a.daysOld);\n  \n  // Only return processed summary (not 10,000 raw issues)\n  return {\n    totalIssues: allIssues.length,\n    criticalBugs: criticalBugs.slice(0, 10), // Top 10 oldest critical bugs\n    summary: \\`Found \\${criticalBugs.length} critical bugs, oldest is \\${criticalBugs[0]?.daysOld} days old\\`\n  };\n`);\n```\n\n### **Error Handling & Observability**\nBuilt-in error handling with complete execution transparency:\n\n```typescript\nconst { result, logs } = await client.callToolChain(`\n  try {\n    console.log('Starting multi-step workflow...');\n    \n    const data = await external_api.fetch_data({ id: 'user-123' });\n    console.log('Data fetched successfully');\n    \n    const processed = await data_processor.transform(data);\n    console.warn('Processing completed with', processed.warnings.length, 'warnings');\n    \n    return processed;\n  } catch (error) {\n    console.error('Workflow failed:', error.message);\n    throw error; // Propagates to outer error handling\n  }\n`, 30000); // 30-second timeout\n\n// Complete observability\nconsole.log('Result:', result);\nconsole.log('Execution logs:', logs);\n// ['Starting multi-step workflow...', 'Data fetched successfully', '[WARN] Processing completed with 2 warnings']\n```\n\n### **Custom Timeouts**\nConfigure execution limits for different workload types:\n\n```typescript\n// Quick operations (5 seconds)\nconst quickResult = await client.callToolChain(`return await ping.check();`, 5000);\n\n// Heavy data processing (2 minutes) \nconst heavyResult = await client.callToolChain(`\n  const bigData = await database.export_full_dataset();\n  return await analytics.process_dataset(bigData);\n`, 120000);\n```\n\n---\n\n## AI Agent Integration\n\nPlug-and-play with any AI framework. The built-in prompt template handles all the complexity:\n\n```typescript\nimport { CodeModeUtcpClient } from '@utcp/code-mode';\n\nconst systemPrompt = `\nYou are an AI assistant with access to tools via UTCP CodeMode.\n${CodeModeUtcpClient.AGENT_PROMPT_TEMPLATE}\nAdditional instructions...\n`;\n\n// Works with any AI library\nconst response = await openai.chat.completions.create({\n  model: 'gpt-4',\n  messages: [\n    { role: 'system', content: systemPrompt },\n    { role: 'user', content: 'Analyze the latest PR in microsoft/vscode' }\n  ]\n});\n```\n\n**The template provides comprehensive guidance on:**\n- Tool discovery workflow (`searchTools` â†’ `__interfaces` â†’ `callToolChain`)\n- Hierarchical access patterns (`manual.tool()` syntax)  \n- Interface introspection (`__getToolInterface()`)\n- Error handling and best practices\n\n---\n\n## API Reference\n\n### **Core Methods**\n\n#### `callToolChain(code: string, timeout?: number)`\nExecute TypeScript code with full tool access and observability.\n- **Returns**: `{result: any, logs: string[]}` with execution result and captured console output\n- **Default timeout**: 30 seconds\n\n#### `getAllToolsTypeScriptInterfaces()`\nGenerate complete TypeScript interfaces for IDE integration.\n- **Returns**: String containing all interface definitions with namespaces\n\n#### `searchTools(query: string)` *(from UtcpClient)*\nDiscover tools using natural language queries.\n- **Returns**: Array of relevant tools with descriptions and interfaces\n\n### **Static Methods**\n\n#### `CodeModeUtcpClient.create(root_dir?, config?)`\nCreate a new client instance with optional configuration.\n\n#### `CodeModeUtcpClient.AGENT_PROMPT_TEMPLATE`\nProduction-ready prompt template for AI agents.\n\n---\n\n## Security & Performance\n\n### **Secure by Design**\n- **Node.js VM sandboxing** â€“ Isolated execution context\n- **No filesystem access** â€“ Tools only through registered servers  \n- **Timeout protection** â€“ Configurable execution limits\n- **Zero network access** â€“ No external dependencies or API keys exposed\n\n### **Performance Optimized**\n- **Minimal memory footprint** â€“ VM contexts are lightweight\n- **Efficient tool caching** â€“ TypeScript interfaces cached automatically\n- **Streaming console output** â€“ Real-time log capture without buffering\n- **Identifier sanitization** â€“ Handles invalid TypeScript identifiers gracefully\n\n---\n\n## Development Experience\n\n### **IDE Integration**\nGenerate TypeScript definitions for full IntelliSense support:\n\n```bash\n# Generate tool interfaces  \nconst interfaces = await client.getAllToolsTypeScriptInterfaces();\nawait fs.writeFile('generated-tools.d.ts', interfaces);\n\n# Add to tsconfig.json\n{\n  \"compilerOptions\": {\n    \"typeRoots\": [\"./generated-tools.d.ts\"]\n  }\n}\n```\n\n### **Debug & Monitor**\nBuilt-in observability for production deployments:\n\n```typescript\nconst { result, logs } = await client.callToolChain(userCode);\n\n// Ship logs to your monitoring system\nlogs.forEach(log => {\n  if (log.startsWith('[ERROR]')) monitoring.error(log);\n  if (log.startsWith('[WARN]')) monitoring.warn(log);\n});\n```\n\n---\n\n## Why Choose Code Mode UTCP?\n\n| Traditional Tool Calling | **Code Mode UTCP** | **Improvement** |\n|--------------------------|-------------------|----------------|\n| 15+ API round trips | **1 code execution** | **15x fewer requests** |\n| 50,000+ context tokens | **2,000 tokens** | **96% token reduction** |\n| 16 iterations (complex) | **1 iteration** | **88% faster** |\n| Higher token costs | **68% token reduction** | **$9,536/year savings** |\n| Manual error handling | **Automatic capture & logs** | **Zero-config observability** |\n| Tool-by-tool discovery | **Dynamic semantic search** | **Progressive disclosure** |\n| Vendor/protocol lock-in | **Universal compatibility** | **MCP, HTTP, File, CLI** |\n\n### **Benchmark Methodology**\nThe [comprehensive Python study](https://github.com/imran31415/codemode_python_benchmark) tested **16 realistic scenarios** across:\n- **Financial workflows** (invoicing, expense tracking)  \n- **DevOps operations** (deployments, monitoring)\n- **Data processing** (analysis, reporting)\n- **Business automation** (CRM, notifications)\n\n**Models tested:** Claude Haiku, Gemini Flash  \n**Pricing basis:** $0.25/1M input, $1.25/1M output tokens  \n**Scale:** 1,000 scenarios/day = $9,536/year savings with Code Mode\n\n## Learn More\n\n- **[Cloudflare Research](https://blog.cloudflare.com/code-mode/)** â€“ Original code mode whitepaper\n- **[Anthropic Study](https://www.anthropic.com/engineering/code-execution-with-mcp)** â€“ MCP code execution benefits\n- **[Python Benchmark Study](https://github.com/imran31415/codemode_python_benchmark)** â€“ Comprehensive performance analysis\n- **[Ready-to-Use MCP Server](https://github.com/universal-tool-calling-protocol/utcp-mcp)** â€“ Plug-and-play Claude Desktop integration\n- **[UTCP Specification](https://github.com/universal-tool-calling-protocol/typescript-utcp)** â€“ Official TypeScript implementation  \n- **[Report Issues](https://github.com/universal-tool-calling-protocol/typescript-utcp/issues)** â€“ Bug reports and feature requests\n\n## License\n\n**MPL-2.0** â€“ Open source with commercial-friendly terms.\n",
      "line_count": 471,
      "word_count": 1950,
      "title": "Code Mode UTCP",
      "summary": "[![npm](https://img.shields.io/npm/v/@utcp/code-mode)](https://www.npmjs.com/package/@utcp/code-mode) ![npm downloads](https://img.shields.io/npm/dt/@utcp/code-mode)",
      "key_terms": [
        "Batching",
        "comprehensive",
        "const",
        "chat",
        "Model",
        "img",
        "Optimized",
        "Code",
        "gracefully",
        "filesystem",
        "mode",
        "Found",
        "Efficient",
        "Dominates",
        "multiple",
        "CodeModeUtcpClient",
        "dynamically",
        "APPROVED",
        "orchestration",
        "heavyResult"
      ],
      "timestamp": "2025-12-24T18:56:00.062747"
    },
    {
      "file_path": "UPSTREAM\\code-mode\\typescript-library\\tsconfig.json",
      "content_type": "configuration",
      "content": "{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"composite\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"],\n  \"references\": []\n}\n",
      "line_count": 11,
      "word_count": 18,
      "title": "Tsconfig.Json",
      "summary": "\"compilerOptions\": { \"outDir\": \"./dist\",",
      "key_terms": [
        "rootDir",
        "composite",
        "exclude",
        "include",
        "references",
        "compilerOptions",
        "dist",
        "src",
        "outDir",
        "true"
      ],
      "timestamp": "2025-12-24T18:56:00.094410"
    },
    {
      "file_path": "UPSTREAM\\code-mode\\typescript-library\\tsup.config.ts",
      "content_type": "code",
      "content": "import { defineConfig } from 'tsup';\n\nexport default defineConfig({\n  entry: ['src/index.ts'],\n  format: ['esm', 'cjs'],\n  dts: {\n    compilerOptions: {\n      composite: false,\n      paths: {},\n    },\n  },\n  splitting: false,\n  sourcemap: true,\n  clean: true,\n  outDir: 'dist',\n  external: ['@utcp/sdk'],\n});\n",
      "line_count": 18,
      "word_count": 35,
      "title": "Tsup.Config.Ts",
      "summary": "import { defineConfig } from 'tsup'; export default defineConfig({",
      "key_terms": [
        "from",
        "sourcemap",
        "composite",
        "paths",
        "entry",
        "clean",
        "utcp",
        "outDir",
        "index",
        "format",
        "default",
        "ts",
        "cjs",
        "false",
        "import",
        "export",
        "sdk",
        "dist",
        "splitting",
        "tsup"
      ],
      "timestamp": "2025-12-24T18:56:00.112508"
    },
    {
      "file_path": "UPSTREAM\\code-mode\\typescript-library\\src\\code_mode_utcp_client.ts",
      "content_type": "code",
      "content": "// OUTDATED, you can find the new version at https://github.com/universal-tool-calling-protocol/typescript-utcp/tree/main/packages/code-mode\nimport { UtcpClient, Tool, JsonSchema, UtcpClientConfig } from '@utcp/sdk';\nimport { createContext, runInContext } from 'vm';\n\n/**\n * CodeModeUtcpClient extends UtcpClient to provide TypeScript code execution capabilities.\n * This allows executing TypeScript code that can directly call registered tools as functions.\n */\nexport class CodeModeUtcpClient extends UtcpClient {\n  private toolFunctionCache: Map<string, string> = new Map();\n\n  /**\n   * Standard prompt template for AI agents using CodeModeUtcpClient.\n   * This provides guidance on how to properly discover and use tools within code execution.\n   */\n  public static readonly AGENT_PROMPT_TEMPLATE = `\n## UTCP CodeMode Tool Usage Guide\n\nYou have access to a CodeModeUtcpClient that allows you to execute TypeScript code with access to registered tools. Follow this workflow:\n\n### 1. Tool Discovery Phase\n**Always start by discovering available tools:**\n- Tools are organized by manual namespace (e.g., \\`manual_name.tool_name\\`)\n- Use hierarchical access patterns: \\`await manual.tool({ param: value })\\`\n- Multiple manuals can contain tools with the same name - namespaces prevent conflicts\n\n### 2. Interface Introspection\n**Understand tool contracts before using them:**\n- Access \\`__interfaces\\` to see all available TypeScript interface definitions\n- Use \\`__getToolInterface('manual.tool')\\` to get specific tool interfaces\n- Interfaces show required inputs, expected outputs, and descriptions\n- Look for \"Access as: manual.tool(args)\" comments for usage patterns\n\n### 3. Code Execution Guidelines\n**When writing code for \\`callToolChain\\`:**\n- Use \\`await manual.tool({ param: value })\\` syntax for all tool calls\n- Tools are async functions that return promises\n- You have access to standard JavaScript globals: \\`console\\`, \\`JSON\\`, \\`Math\\`, \\`Date\\`, etc.\n- All console output (\\`console.log\\`, \\`console.error\\`, etc.) is automatically captured and returned\n- Build properly structured input objects based on interface definitions\n- Handle errors appropriately with try/catch blocks\n- Chain tool calls by using results from previous calls\n\n### 4. Best Practices\n- **Discover first, code second**: Always explore available tools before writing execution code\n- **Respect namespaces**: Use full \\`manual.tool\\` names to avoid conflicts\n- **Parse interfaces**: Use interface information to construct proper input objects\n- **Error handling**: Wrap tool calls in try/catch for robustness\n- **Data flow**: Chain tools by passing outputs as inputs to subsequent tools\n\n### 5. Available Runtime Context\n- \\`__interfaces\\`: String containing all TypeScript interface definitions\n- \\`__getToolInterface(toolName)\\`: Function to get specific tool interface\n- All registered tools as \\`manual.tool\\` functions\n- Standard JavaScript built-ins for data processing\n\nRemember: Always discover and understand available tools before attempting to use them in code execution.\n`.trim();\n\n  /**\n   * Creates a new CodeModeUtcpClient instance.\n   * This creates a regular UtcpClient and then upgrades it to a CodeModeUtcpClient\n   * with all the same configuration and additional code execution capabilities.\n   * \n   * @param root_dir The root directory for the client to resolve relative paths from\n   * @param config The configuration for the client\n   * @returns A new CodeModeUtcpClient instance\n   */\n  public static async create(\n    root_dir: string = process.cwd(),\n    config: UtcpClientConfig | null = null\n  ): Promise<CodeModeUtcpClient> {\n    // Create a regular UtcpClient first\n    const baseClient = await UtcpClient.create(root_dir, config);\n    \n    // Create a CodeModeUtcpClient using the same configuration\n    const codeModeClient = Object.setPrototypeOf(baseClient, CodeModeUtcpClient.prototype) as CodeModeUtcpClient;\n    \n    // Initialize the cache\n    (codeModeClient as any).toolFunctionCache = new Map();\n    \n    return codeModeClient;\n  }\n\n  /**\n   * Sanitizes an identifier to be a valid TypeScript identifier.\n   * Replaces any non-alphanumeric character (except underscore) with underscore\n   * and ensures the first character is not a number.\n   * \n   * @param name The name to sanitize\n   * @returns Sanitized identifier\n   */\n  private sanitizeIdentifier(name: string): string {\n    return name\n      .replace(/[^a-zA-Z0-9_]/g, '_')\n      .replace(/^[0-9]/, '_$&');\n  }\n\n  /**\n   * Converts a Tool object into a TypeScript function interface string.\n   * This generates the function signature that can be used in TypeScript code.\n   * \n   * @param tool The Tool object to convert\n   * @returns TypeScript function interface as a string\n   */\n  public toolToTypeScriptInterface(tool: Tool): string {\n    if (this.toolFunctionCache.has(tool.name)) {\n      return this.toolFunctionCache.get(tool.name)!;\n    }\n\n    // Generate hierarchical interface structure\n    let interfaceContent: string;\n    let accessPattern: string;\n    \n    if (tool.name.includes('.')) {\n      const [manualName, ...toolParts] = tool.name.split('.');\n      const sanitizedManualName = this.sanitizeIdentifier(manualName);\n      const toolName = toolParts.map(part => this.sanitizeIdentifier(part)).join('_');\n      accessPattern = `${sanitizedManualName}.${toolName}`;\n      \n      // Generate interfaces within namespace\n      const inputInterfaceContent = this.jsonSchemaToObjectContent(tool.inputs);\n      const outputInterfaceContent = this.jsonSchemaToObjectContent(tool.outputs);\n      \n      interfaceContent = `\nnamespace ${sanitizedManualName} {\n  interface ${toolName}Input {\n${inputInterfaceContent}\n  }\n\n  interface ${toolName}Output {\n${outputInterfaceContent}\n  }\n}`;\n    } else {\n      // No manual namespace, generate flat interfaces\n      const sanitizedToolName = this.sanitizeIdentifier(tool.name);\n      accessPattern = sanitizedToolName;\n      const inputType = this.jsonSchemaToTypeScript(tool.inputs, `${sanitizedToolName}Input`);\n      const outputType = this.jsonSchemaToTypeScript(tool.outputs, `${sanitizedToolName}Output`);\n      interfaceContent = `${inputType}\\n\\n${outputType}`;\n    }\n    const interfaceString = `\n${interfaceContent}\n\n/**\n * ${tool.description}\n * Tags: ${tool.tags.join(', ')}\n * Access as: ${accessPattern}(args)\n */`;\n\n    this.toolFunctionCache.set(tool.name, interfaceString);\n    return interfaceString;\n  }\n\n  /**\n   * Converts all registered tools to TypeScript interface definitions.\n   * This provides the complete type definitions for all available tools.\n   * \n   * @returns A complete TypeScript interface definition string\n   */\n  public async getAllToolsTypeScriptInterfaces(): Promise<string> {\n    const tools = await this.getTools();\n    const interfaces = tools.map(tool => this.toolToTypeScriptInterface(tool));\n    \n    return `// Auto-generated TypeScript interfaces for UTCP tools\n${interfaces.join('\\n\\n')}`;\n  }\n\n  /**\n   * Executes TypeScript code with access to registered tools and captures console output.\n   * The code can call tools directly as functions and has access to standard JavaScript globals.\n   * \n   * @param code TypeScript code to execute  \n   * @param timeout Optional timeout in milliseconds (default: 30000)\n   * @returns Object containing both the execution result and captured console logs\n   */\n  public async callToolChain(code: string, timeout: number = 30000): Promise<{result: any, logs: string[]}> {\n    const tools = await this.getTools();\n    \n    // Create the execution context with tool functions and log capture\n    const logs: string[] = [];\n    const context = await this.createExecutionContext(tools, logs);\n    \n    try {\n      // Create VM context\n      const vmContext = createContext(context);\n      \n      // Wrap the user code in an async function and execute it\n      const wrappedCode = `\n        (async () => {\n          ${code}\n        })()\n      `;\n      \n      // Execute with timeout\n      const result = await this.runWithTimeout(wrappedCode, vmContext, timeout);\n      return { result, logs };\n    } catch (error) {\n      return { result: null, logs: [...logs, `[ERROR] Code execution failed: ${error instanceof Error ? error.message : String(error)}`] };\n    }\n  }\n\n  /**\n   * Runs code in VM context with timeout support.\n   * \n   * @param code Code to execute\n   * @param context VM context\n   * @param timeout Timeout in milliseconds\n   * @returns Execution result\n   */\n  private async runWithTimeout(code: string, context: any, timeout: number): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new Error(`Code execution timed out after ${timeout}ms`));\n      }, timeout);\n\n      try {\n        const result = runInContext(code, context);\n        \n        // Handle both sync and async results\n        Promise.resolve(result)\n          .then(finalResult => {\n            clearTimeout(timeoutId);\n            resolve(finalResult);\n          })\n          .catch(error => {\n            clearTimeout(timeoutId);\n            reject(error);\n          });\n      } catch (error) {\n        clearTimeout(timeoutId);\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Creates the execution context for running TypeScript code.\n   * This context includes tool functions and basic JavaScript globals.\n   * \n   * @param tools Array of tools to make available\n   * @param logs Optional array to capture console.log output\n   * @returns Execution context object\n   */\n  private async createExecutionContext(tools: Tool[], logs?: string[]): Promise<Record<string, any>> {\n    // Create console object (either capturing logs or using standard console)\n    const consoleObj = logs ? {\n      log: (...args: any[]) => {\n        logs.push(args.map(arg => \n          typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)\n        ).join(' '));\n      },\n      error: (...args: any[]) => {\n        logs.push('[ERROR] ' + args.map(arg => \n          typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)\n        ).join(' '));\n      },\n      warn: (...args: any[]) => {\n        logs.push('[WARN] ' + args.map(arg => \n          typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)\n        ).join(' '));\n      },\n      info: (...args: any[]) => {\n        logs.push('[INFO] ' + args.map(arg => \n          typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)\n        ).join(' '));\n      }\n    } : console;\n\n    const context: Record<string, any> = {\n      // Add basic utilities\n      console: consoleObj,\n      JSON,\n      Promise,\n      Array,\n      Object,\n      String,\n      Number,\n      Boolean,\n      Math,\n      Date,\n      \n      // Add TypeScript interface definitions for reference\n      __interfaces: await this.getAllToolsTypeScriptInterfaces(),\n      __getToolInterface: (toolName: string) => {\n        const tool = tools.find(t => t.name === toolName);\n        return tool ? this.toolToTypeScriptInterface(tool) : null;\n      }\n    };\n\n    // Add tool functions to context organized by manual name\n    for (const tool of tools) {\n      if (tool.name.includes('.')) {\n        const [manualName, ...toolParts] = tool.name.split('.');\n        const sanitizedManualName = this.sanitizeIdentifier(manualName);\n        const toolName = toolParts.map(part => this.sanitizeIdentifier(part)).join('_');\n        \n        // Create manual namespace object if it doesn't exist\n        if (!context[sanitizedManualName]) {\n          context[sanitizedManualName] = {};\n        }\n        \n        // Add the tool function to the manual namespace\n        context[sanitizedManualName][toolName] = async (args: Record<string, any>) => {\n          try {\n            return await this.callTool(tool.name, args);\n          } catch (error) {\n            throw new Error(`Error calling tool '${tool.name}': ${error instanceof Error ? error.message : String(error)}`);\n          }\n        };\n      } else {\n        // If no dot, add directly to root context (no manual name)\n        const sanitizedToolName = this.sanitizeIdentifier(tool.name);\n        context[sanitizedToolName] = async (args: Record<string, any>) => {\n          try {\n            return await this.callTool(tool.name, args);\n          } catch (error) {\n            throw new Error(`Error calling tool '${tool.name}': ${error instanceof Error ? error.message : String(error)}`);\n          }\n        };\n      }\n    }\n\n    return context;\n  }\n\n  /**\n   * Converts a JSON Schema to TypeScript object content (properties only, no interface wrapper).\n   * This generates the content inside an interface definition.\n   * \n   * @param schema JSON Schema to convert\n   * @returns TypeScript interface properties as string\n   */\n  private jsonSchemaToObjectContent(schema: JsonSchema): string {\n    if (!schema || typeof schema !== 'object' || schema.type !== 'object') {\n      return '    [key: string]: any;';\n    }\n\n    const properties = schema.properties || {};\n    const required = schema.required || [];\n    const lines: string[] = [];\n\n    for (const [propName, propSchema] of Object.entries(properties)) {\n      const isRequired = required.includes(propName);\n      const optionalMarker = isRequired ? '' : '?';\n      const description = (propSchema as any).description || '';\n      const tsType = this.jsonSchemaToTypeScriptType(propSchema as JsonSchema);\n\n      if (description) {\n        lines.push(`    /** ${description} */`);\n      }\n      lines.push(`    ${propName}${optionalMarker}: ${tsType};`);\n    }\n\n    return lines.length > 0 ? lines.join('\\n') : '    [key: string]: any;';\n  }\n\n  /**\n   * Converts a JSON Schema to TypeScript interface definition.\n   * This handles the most common JSON Schema patterns used in UTCP tools.\n   * \n   * @param schema JSON Schema to convert\n   * @param typeName Name for the generated TypeScript type\n   * @returns TypeScript type definition as string\n   */\n  private jsonSchemaToTypeScript(schema: JsonSchema, typeName: string): string {\n    if (!schema || typeof schema !== 'object') {\n      return `type ${typeName} = any;`;\n    }\n\n    // Handle different schema types\n    switch (schema.type) {\n      case 'object':\n        return this.objectSchemaToTypeScript(schema, typeName);\n      case 'array':\n        return this.arraySchemaToTypeScript(schema, typeName);\n      case 'string':\n        return this.primitiveSchemaToTypeScript(schema, typeName, 'string');\n      case 'number':\n      case 'integer':\n        return this.primitiveSchemaToTypeScript(schema, typeName, 'number');\n      case 'boolean':\n        return this.primitiveSchemaToTypeScript(schema, typeName, 'boolean');\n      case 'null':\n        return `type ${typeName} = null;`;\n      default:\n        // Handle union types or fallback to any\n        if (Array.isArray(schema.type)) {\n          const types = schema.type.map(t => this.mapJsonTypeToTS(t)).join(' | ');\n          return `type ${typeName} = ${types};`;\n        }\n        return `type ${typeName} = any;`;\n    }\n  }\n\n  /**\n   * Converts an object JSON Schema to TypeScript interface.\n   */\n  private objectSchemaToTypeScript(schema: JsonSchema, typeName: string): string {\n    if (!schema.properties) {\n      return `interface ${typeName} {\n  [key: string]: any;\n}`;\n    }\n\n    const properties = Object.entries(schema.properties).map(([key, propSchema]) => {\n      const isRequired = schema.required?.includes(key) ?? false;\n      const optional = isRequired ? '' : '?';\n      const propType = this.jsonSchemaToTypeScriptType(propSchema);\n      const description = propSchema.description ? `  /** ${propSchema.description} */\\n` : '';\n      \n      return `${description}  ${key}${optional}: ${propType};`;\n    }).join('\\n');\n\n    return `interface ${typeName} {\n${properties}\n}`;\n  }\n\n  /**\n   * Converts an array JSON Schema to TypeScript type.\n   */\n  private arraySchemaToTypeScript(schema: JsonSchema, typeName: string): string {\n    if (!schema.items) {\n      return `type ${typeName} = any[];`;\n    }\n\n    const itemType = Array.isArray(schema.items) \n      ? schema.items.map(item => this.jsonSchemaToTypeScriptType(item)).join(' | ')\n      : this.jsonSchemaToTypeScriptType(schema.items);\n\n    return `type ${typeName} = (${itemType})[];`;\n  }\n\n  /**\n   * Converts a primitive JSON Schema to TypeScript type with enum support.\n   */\n  private primitiveSchemaToTypeScript(schema: JsonSchema, typeName: string, baseType: string): string {\n    if (schema.enum) {\n      const enumValues = schema.enum.map(val => \n        typeof val === 'string' ? `\"${val}\"` : String(val)\n      ).join(' | ');\n      return `type ${typeName} = ${enumValues};`;\n    }\n\n    return `type ${typeName} = ${baseType};`;\n  }\n\n  /**\n   * Converts a JSON Schema to a TypeScript type (not a full type definition).\n   */\n  private jsonSchemaToTypeScriptType(schema: JsonSchema): string {\n    if (!schema || typeof schema !== 'object') {\n      return 'any';\n    }\n\n    if (schema.enum) {\n      return schema.enum.map(val => \n        typeof val === 'string' ? `\"${val}\"` : String(val)\n      ).join(' | ');\n    }\n\n    switch (schema.type) {\n      case 'object':\n        if (!schema.properties) return '{ [key: string]: any }';\n        const props = Object.entries(schema.properties).map(([key, propSchema]) => {\n          const isRequired = schema.required?.includes(key) ?? false;\n          const optional = isRequired ? '' : '?';\n          const propType = this.jsonSchemaToTypeScriptType(propSchema);\n          return `${key}${optional}: ${propType}`;\n        }).join('; ');\n        return `{ ${props} }`;\n      \n      case 'array':\n        if (!schema.items) return 'any[]';\n        const itemType = Array.isArray(schema.items)\n          ? schema.items.map(item => this.jsonSchemaToTypeScriptType(item)).join(' | ')\n          : this.jsonSchemaToTypeScriptType(schema.items);\n        return `(${itemType})[]`;\n      \n      case 'string':\n        return 'string';\n      case 'number':\n      case 'integer':\n        return 'number';\n      case 'boolean':\n        return 'boolean';\n      case 'null':\n        return 'null';\n      \n      default:\n        if (Array.isArray(schema.type)) {\n          return schema.type.map(t => this.mapJsonTypeToTS(t)).join(' | ');\n        }\n        return 'any';\n    }\n  }\n\n  /**\n   * Maps basic JSON Schema types to TypeScript types.\n   */\n  private mapJsonTypeToTS(type: string): string {\n    switch (type) {\n      case 'string': return 'string';\n      case 'number':\n      case 'integer': return 'number';\n      case 'boolean': return 'boolean';\n      case 'null': return 'null';\n      case 'object': return 'object';\n      case 'array': return 'any[]';\n      default: return 'any';\n    }\n  }\n}\n",
      "line_count": 516,
      "word_count": 2107,
      "title": "Code Mode Utcp Client.Ts",
      "summary": "// OUTDATED, you can find the new version at https://github.com/universal-tool-calling-protocol/typescript-utcp/tree/main/packages/code-mode import { UtcpClient, Tool, JsonSchema, UtcpClientConfig } f...",
      "key_terms": [
        "const",
        "contain",
        "packages",
        "interfaceString",
        "etc",
        "convert",
        "Code",
        "either",
        "Record",
        "mode",
        "reject",
        "toolName",
        "CodeModeUtcpClient",
        "Creates",
        "Tags",
        "if",
        "capturing",
        "that",
        "interface",
        "basic"
      ],
      "timestamp": "2025-12-24T18:56:00.158133"
    },
    {
      "file_path": "UPSTREAM\\code-mode\\typescript-library\\src\\index.ts",
      "content_type": "code",
      "content": "// OUTDATED, you can find the new version at https://github.com/universal-tool-calling-protocol/typescript-utcp/tree/main/packages/code-mode\n/**\n * Code Mode plugin for UTCP.\n * Enables TypeScript code execution with direct access to registered tools.\n */\n\n// Export all public APIs\nexport { CodeModeUtcpClient } from './code_mode_utcp_client';\n\n// Type exports for better TypeScript support\nexport type {\n  Tool,\n  JsonSchema,\n  UtcpClientConfig,\n} from '@utcp/sdk';\n",
      "line_count": 16,
      "word_count": 56,
      "title": "Index.Ts",
      "summary": "// OUTDATED, you can find the new version at https://github.com/universal-tool-calling-protocol/typescript-utcp/tree/main/packages/code-mode * Code Mode plugin for UTCP.",
      "key_terms": [
        "from",
        "tree",
        "packages",
        "UtcpClientConfig",
        "at",
        "calling-protocol",
        "universal",
        "Type",
        "find",
        "support",
        "Code",
        "utcp",
        "calling",
        "mode",
        "with",
        "Tool",
        "tool",
        "Utcp",
        "type",
        "github"
      ],
      "timestamp": "2025-12-24T18:56:00.175397"
    },
    {
      "file_path": "UPSTREAM\\code-mode\\typescript-library\\tests\\code_mode_utcp_client.test.ts",
      "content_type": "code",
      "content": "// OUTDATED, you can find the new version at https://github.com/universal-tool-calling-protocol/typescript-utcp/tree/main/packages/code-mode\n\n/**\n * Tests for CodeModeUtcpClient\n * This validates the code mode functionality using direct-call tools\n */\n\nimport { test, expect, describe, beforeAll, afterAll } from 'bun:test';\nimport { CodeModeUtcpClient } from '../src/index';\nimport { addFunctionToUtcpDirectCall } from '@utcp/direct-call';\n\n// Test utility functions\nconst testResults: Record<string, any> = {};\n\n// Setup test tools using direct-call\nbeforeAll(async () => {\n  // Register test functions as direct-call tools\n  \n  // Simple math function\n  addFunctionToUtcpDirectCall('add', async (a: number, b: number) => {\n    testResults.addCalled = { a, b, timestamp: Date.now() };\n    return { result: a + b, operation: 'addition' };\n  });\n\n  // String manipulation function\n  addFunctionToUtcpDirectCall('greet', async (name: string, formal: boolean = false) => {\n    testResults.greetCalled = { name, formal, timestamp: Date.now() };\n    const greeting = formal ? `Good day, ${name}` : `Hey ${name}!`;\n    return { greeting, isFormal: formal };\n  });\n\n  // Complex object handling function\n  addFunctionToUtcpDirectCall('processData', async (data: any, options: any = {}) => {\n    testResults.processDataCalled = { data, options, timestamp: Date.now() };\n    return {\n      processedData: {\n        ...data,\n        processed: true,\n        processedAt: new Date().toISOString(),\n        options\n      },\n      metadata: {\n        itemCount: Array.isArray(data) ? data.length : 1,\n        hasOptions: Object.keys(options).length > 0\n      }\n    };\n  });\n\n  // Function that throws an error\n  addFunctionToUtcpDirectCall('throwError', async (message: string) => {\n    testResults.throwErrorCalled = { message, timestamp: Date.now() };\n    throw new Error(message);\n  });\n\n  // Function with no parameters\n  addFunctionToUtcpDirectCall('getCurrentTime', async () => {\n    testResults.getCurrentTimeCalled = { timestamp: Date.now() };\n    return { \n      timestamp: Date.now(),\n      iso: new Date().toISOString()\n    };\n  });\n\n  // Array processing function\n  addFunctionToUtcpDirectCall('sumArray', async (numbers: number[]) => {\n    testResults.sumArrayCalled = { numbers, timestamp: Date.now() };\n    return {\n      sum: numbers.reduce((a, b) => a + b, 0),\n      count: numbers.length,\n      average: numbers.length > 0 ? numbers.reduce((a, b) => a + b, 0) / numbers.length : 0\n    };\n  });\n});\n\ndescribe('CodeModeUtcpClient', () => {\n  let client: CodeModeUtcpClient;\n\n  beforeAll(async () => {\n    // Create client\n    client = await CodeModeUtcpClient.create();\n\n    // First register the manual provider function\n    addFunctionToUtcpDirectCall('getTestManual', async () => {\n      return {\n        utcp_version: '1.0.0',\n        manual_version: '1.0.0',\n        tools: [\n          {\n            name: 'add',\n            description: 'Adds two numbers together',\n            inputs: {\n              type: 'object',\n              properties: {\n                a: { type: 'number', description: 'First number' },\n                b: { type: 'number', description: 'Second number' }\n              },\n              required: ['a', 'b']\n            },\n            outputs: {\n              type: 'object',\n              properties: {\n                result: { type: 'number', description: 'Sum of the numbers' },\n                operation: { type: 'string', description: 'Type of operation' }\n              },\n              required: ['result', 'operation']\n            },\n            tags: ['math', 'arithmetic'],\n            tool_call_template: {\n              call_template_type: 'direct-call',\n              callable_name: 'add'\n            }\n          },\n          {\n            name: 'greet',\n            description: 'Generates a greeting message',\n            inputs: {\n              type: 'object',\n              properties: {\n                name: { type: 'string', description: 'Name to greet' },\n                formal: { type: 'boolean', description: 'Whether to use formal greeting', default: false }\n              },\n              required: ['name']\n            },\n            outputs: {\n              type: 'object',\n              properties: {\n                greeting: { type: 'string', description: 'The greeting message' },\n                isFormal: { type: 'boolean', description: 'Whether the greeting was formal' }\n              },\n              required: ['greeting', 'isFormal']\n            },\n            tags: ['text', 'greeting'],\n            tool_call_template: {\n              call_template_type: 'direct-call',\n              callable_name: 'greet'\n            }\n          },\n          {\n            name: 'processData',\n            description: 'Processes data with optional configuration',\n            inputs: {\n              type: 'object',\n              properties: {\n                data: { description: 'Data to process' },\n                options: { type: 'object', description: 'Processing options', default: {} }\n              },\n              required: ['data']\n            },\n            outputs: {\n              type: 'object',\n              properties: {\n                processedData: { description: 'The processed data' },\n                metadata: { type: 'object', description: 'Processing metadata' }\n              },\n              required: ['processedData', 'metadata']\n            },\n            tags: ['processing', 'data'],\n            tool_call_template: {\n              call_template_type: 'direct-call',\n              callable_name: 'processData'\n            }\n          },\n          {\n            name: 'throwError',\n            description: 'Throws an error for testing error handling',\n            inputs: {\n              type: 'object',\n              properties: {\n                message: { type: 'string', description: 'Error message' }\n              },\n              required: ['message']\n            },\n            outputs: {\n              type: 'object',\n              properties: {}\n            },\n            tags: ['testing', 'error'],\n            tool_call_template: {\n              call_template_type: 'direct-call',\n              callable_name: 'throwError'\n            }\n          },\n          {\n            name: 'getCurrentTime',\n            description: 'Gets the current timestamp',\n            inputs: {\n              type: 'object',\n              properties: {},\n              required: []\n            },\n            outputs: {\n              type: 'object',\n              properties: {\n                timestamp: { type: 'number', description: 'Unix timestamp' },\n                iso: { type: 'string', description: 'ISO date string' }\n              },\n              required: ['timestamp', 'iso']\n            },\n            tags: ['time', 'utility'],\n            tool_call_template: {\n              call_template_type: 'direct-call',\n              callable_name: 'getCurrentTime'\n            }\n          },\n          {\n            name: 'sumArray',\n            description: 'Calculates sum and statistics of a number array',\n            inputs: {\n              type: 'object',\n              properties: {\n                numbers: {\n                  type: 'array',\n                  items: { type: 'number' },\n                  description: 'Array of numbers to sum'\n                }\n              },\n              required: ['numbers']\n            },\n            outputs: {\n              type: 'object',\n              properties: {\n                sum: { type: 'number', description: 'Sum of all numbers' },\n                count: { type: 'number', description: 'Count of numbers' },\n                average: { type: 'number', description: 'Average of numbers' }\n              },\n              required: ['sum', 'count', 'average']\n            },\n            tags: ['math', 'array', 'statistics'],\n            tool_call_template: {\n              call_template_type: 'direct-call',\n              callable_name: 'sumArray'\n            }\n          }\n        ]\n      };\n    });\n\n    // Now register the manual that uses the getTestManual function\n    try {\n      const result = await client.registerManual({\n        name: 'test_tools',\n        call_template_type: 'direct-call',\n        callable_name: 'getTestManual'\n      });\n      \n      if (!result.success) {\n        console.error('Manual registration failed:', result.errors);\n        throw new Error(`Manual registration failed: ${result.errors.join(', ')}`);\n      }\n    } catch (error) {\n      console.error('Manual registration error:', error);\n      throw error;\n    }\n  });\n\n  afterAll(async () => {\n    if (client) {\n      await client.close();\n    }\n  });\n\n  test('should create CodeModeUtcpClient instance', async () => {\n    expect(client).toBeDefined();\n    expect(client).toBeInstanceOf(CodeModeUtcpClient);\n  });\n\n  test('should have registered tools', async () => {\n    const tools = await client.getTools();\n    expect(tools.length).toBeGreaterThan(0);\n    \n    const toolNames = tools.map(t => t.name.split('.').pop());\n    expect(toolNames).toContain('add');\n    expect(toolNames).toContain('greet');\n    expect(toolNames).toContain('processData');\n  });\n\n  test('should convert tool to TypeScript interface', async () => {\n    const tools = await client.getTools();\n    const addTool = tools.find(t => t.name.endsWith('.add'));\n    expect(addTool).toBeDefined();\n\n    const tsInterface = client.toolToTypeScriptInterface(addTool!);\n    expect(tsInterface).toContain('namespace test_tools');\n    expect(tsInterface).toContain('interface addInput');\n    expect(tsInterface).toContain('interface addOutput');\n    expect(tsInterface).toContain('a: number');\n    expect(tsInterface).toContain('b: number');\n    expect(tsInterface).toContain('result: number');\n    expect(tsInterface).toContain('operation: string');\n    expect(tsInterface).toContain('Access as: test_tools.add(args)');\n  });\n\n  test('should generate all tools TypeScript interfaces', async () => {\n    const interfaces = await client.getAllToolsTypeScriptInterfaces();\n    expect(interfaces).toContain('// Auto-generated TypeScript interfaces for UTCP tools');\n    expect(interfaces).toContain('namespace test_tools');\n    expect(interfaces).toContain('interface addInput');\n    expect(interfaces).toContain('interface greetInput');\n    expect(interfaces).toContain('interface processDataInput');\n  });\n\n  test('should execute simple code with basic operations', async () => {\n    const code = `\n      const x = 5;\n      const y = 10;\n      return x + y;\n    `;\n    \n    const { result } = await client.callToolChain(code);\n    expect(result).toBe(15);\n  });\n\n  test('should execute code that calls a simple tool', async () => {\n    // Clear previous call records\n    delete testResults.addCalled;\n    \n    const code = `\n      const result = await test_tools.add({ a: 15, b: 25 });\n      return result;\n    `;\n    \n    const { result } = await client.callToolChain(code);\n    expect(result.result).toBe(40);\n    expect(result.operation).toBe('addition');\n    \n    // Verify the tool was called with correct parameters\n    expect(testResults.addCalled).toBeDefined();\n    expect(testResults.addCalled.a).toBe(15);\n    expect(testResults.addCalled.b).toBe(25);\n  });\n\n  test('should execute code with multiple tool calls', async () => {\n    // Clear previous call records\n    delete testResults.addCalled;\n    delete testResults.greetCalled;\n    \n    const code = `\n      const mathResult = await test_tools.add({ a: 10, b: 5 });\n      const greetResult = await test_tools.greet({ name: \"Alice\", formal: true });\n      \n      return {\n        math: mathResult,\n        greeting: greetResult,\n        combined: \\`\\${greetResult.greeting} The sum is \\${mathResult.result}\\`\n      };\n    `;\n    \n    const { result } = await client.callToolChain(code);\n    expect(result.math.result).toBe(15);\n    expect(result.greeting.greeting).toBe(\"Good day, Alice\");\n    expect(result.greeting.isFormal).toBe(true);\n    expect(result.combined).toBe(\"Good day, Alice The sum is 15\");\n    \n    // Verify both tools were called\n    expect(testResults.addCalled).toBeDefined();\n    expect(testResults.greetCalled).toBeDefined();\n  });\n\n  test('should handle complex data structures', async () => {\n    delete testResults.processDataCalled;\n    \n    const code = `\n      const complexData = {\n        users: [\n          { name: \"John\", age: 30 },\n          { name: \"Jane\", age: 25 }\n        ],\n        settings: { theme: \"dark\", notifications: true }\n      };\n      \n      const result = await test_tools.processData({ \n        data: complexData, \n        options: { validate: true, transform: \"uppercase\" } \n      });\n      \n      return result;\n    `;\n    \n    const { result } = await client.callToolChain(code);\n    expect(result.processedData.processed).toBe(true);\n    expect(result.processedData.users).toBeDefined();\n    expect(result.metadata.itemCount).toBe(1);\n    expect(result.metadata.hasOptions).toBe(true);\n    \n    // Verify the tool was called with the complex data\n    expect(testResults.processDataCalled).toBeDefined();\n    expect(testResults.processDataCalled.data.users.length).toBe(2);\n    expect(testResults.processDataCalled.options.validate).toBe(true);\n  });\n\n  test('should handle arrays and array processing tools', async () => {\n    delete testResults.sumArrayCalled;\n    \n    const code = `\n      const numbers = [1, 2, 3, 4, 5, 10];\n      const stats = await test_tools.sumArray({ numbers });\n      \n      return {\n        original: numbers,\n        statistics: stats,\n        doubled: numbers.map(n => n * 2)\n      };\n    `;\n    \n    const { result } = await client.callToolChain(code);\n    expect(result.statistics.sum).toBe(25);\n    expect(result.statistics.count).toBe(6);\n    expect(result.statistics.average).toBe(25/6);\n    expect(result.doubled).toEqual([2, 4, 6, 8, 10, 20]);\n    \n    // Verify the tool was called correctly\n    expect(testResults.sumArrayCalled).toBeDefined();\n    expect(testResults.sumArrayCalled.numbers).toEqual([1, 2, 3, 4, 5, 10]);\n  });\n\n  test('should handle tool calls with no parameters', async () => {\n    delete testResults.getCurrentTimeCalled;\n    \n    const code = `\n      const timeResult = await test_tools.getCurrentTime({});\n      return {\n        timeData: timeResult,\n        isRecent: timeResult.timestamp > Date.now() - 5000\n      };\n    `;\n    \n    const { result } = await client.callToolChain(code);\n    expect(result.timeData.timestamp).toBeDefined();\n    expect(result.timeData.iso).toBeDefined();\n    expect(result.isRecent).toBe(true);\n    \n    // Verify the tool was called\n    expect(testResults.getCurrentTimeCalled).toBeDefined();\n  });\n\n  test('should handle tool errors correctly', async () => {\n    const code = `\n      try {\n        await test_tools.throwError({ message: \"Test error message\" });\n        return { error: false };\n      } catch (error) {\n        return { \n          error: true, \n          message: error.message,\n          caught: true\n        };\n      }\n    `;\n    \n    const { result } = await client.callToolChain(code);\n    expect(result.error).toBe(true);\n    expect(result.caught).toBe(true);\n    expect(result.message).toContain(\"Test error message\");\n  });\n\n  test('should handle code execution timeout', async () => {\n    const code = `\n      // Infinite loop to test timeout\n      while (true) {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      }\n      return { completed: true };\n    `;\n    \n    await expect(client.callToolChain(code, 1000)).rejects.toThrow();\n  });\n\n  test('should handle code syntax errors', async () => {\n    const invalidCode = `\n      const invalid syntax here\n      return result;\n    `;\n    \n    await expect(client.callToolChain(invalidCode)).rejects.toThrow();\n  });\n\n  test('should have access to basic JavaScript globals', async () => {\n    const code = `\n      return {\n        mathPi: Math.PI,\n        dateNow: Date.now(),\n        arrayMethods: Array.isArray([1, 2, 3]),\n        jsonStringify: JSON.stringify({ test: true }),\n        objectKeys: Object.keys({ a: 1, b: 2 })\n      };\n    `;\n    \n    const { result } = await client.callToolChain(code);\n    expect(result.mathPi).toBe(Math.PI);\n    expect(typeof result.dateNow).toBe('number');\n    expect(result.arrayMethods).toBe(true);\n    expect(result.jsonStringify).toBe('{\"test\":true}');\n    expect(result.objectKeys).toEqual(['a', 'b']);\n  });\n\n  test('should have access to TypeScript interfaces in execution context', async () => {\n    const code = `\n      return {\n        hasInterfaces: typeof __interfaces === 'string',\n        interfacesContainNamespace: __interfaces.includes('namespace test_tools'),\n        canGetSpecificInterface: typeof __getToolInterface === 'function',\n        addToolInterface: __getToolInterface('test_tools.add'),\n        interfaceIsString: typeof __getToolInterface('test_tools.add') === 'string'\n      };\n    `;\n    \n    const { result } = await client.callToolChain(code);\n    expect(result.hasInterfaces).toBe(true);\n    expect(result.interfacesContainNamespace).toBe(true);\n    expect(result.canGetSpecificInterface).toBe(true);\n    expect(result.addToolInterface).toBeTruthy();\n    expect(result.interfaceIsString).toBe(true);\n  });\n\n  test('should execute complex chained operations', async () => {\n    // Clear call records\n    Object.keys(testResults).forEach(key => delete testResults[key]);\n    \n    const code = `\n      // Step 1: Get some numbers and process them\n      const numbers = [5, 10, 15, 20];\n      const arrayStats = await test_tools.sumArray({ numbers });\n      \n      // Step 2: Use the sum in another calculation\n      const addResult = await test_tools.add({ a: arrayStats.sum, b: 100 });\n      \n      // Step 3: Create a greeting with the result\n      const greeting = await test_tools.greet({ name: \"CodeMode\", formal: false });\n      \n      // Step 4: Process all the data together\n      const finalData = await test_tools.processData({\n        data: {\n          arrayStats,\n          addResult,\n          greeting,\n          executionTime: Date.now()\n        },\n        options: {\n          includeMetadata: true,\n          format: \"enhanced\"\n        }\n      });\n      \n      return {\n        steps: {\n          arrayProcessing: arrayStats,\n          addition: addResult,\n          greeting: greeting,\n          finalProcessing: finalData\n        },\n        summary: {\n          originalSum: arrayStats.sum,\n          finalSum: addResult.result,\n          greetingMessage: greeting.greeting,\n          chainCompleted: true\n        }\n      };\n    `;\n    \n    const result = await client.callToolChain(code, 15000);\n    \n    // Verify the chain worked correctly\n    expect(result.result.steps.arrayProcessing.sum).toBe(50);\n    expect(result.result.steps.addition.result).toBe(150);\n    expect(result.result.steps.greeting.greeting).toBe(\"Hey CodeMode!\");\n    expect(result.result.steps.finalProcessing.processedData.processed).toBe(true);\n    expect(result.result.summary.chainCompleted).toBe(true);\n    \n    // Verify all tools were called in the correct order\n    expect(testResults.sumArrayCalled).toBeDefined();\n    expect(testResults.addCalled).toBeDefined();\n    expect(testResults.greetCalled).toBeDefined();\n    expect(testResults.processDataCalled).toBeDefined();\n    \n    // Verify the parameters were passed correctly through the chain\n    expect(testResults.addCalled.a).toBe(50); // Sum from array\n    expect(testResults.addCalled.b).toBe(100);\n    expect(testResults.greetCalled.name).toBe(\"CodeMode\");\n    expect(testResults.greetCalled.formal).toBe(false);\n  });\n\n  test('should provide agent prompt template', () => {\n    const promptTemplate = CodeModeUtcpClient.AGENT_PROMPT_TEMPLATE;\n    \n    expect(typeof promptTemplate).toBe('string');\n    expect(promptTemplate.length).toBeGreaterThan(0);\n    expect(promptTemplate).toContain('Tool Discovery Phase');\n    expect(promptTemplate).toContain('Interface Introspection');\n    expect(promptTemplate).toContain('Code Execution Guidelines');\n    expect(promptTemplate).toContain('await manual.tool');\n    expect(promptTemplate).toContain('__interfaces');\n    expect(promptTemplate).toContain('__getToolInterface');\n    expect(promptTemplate).toContain('Discover first, code second');\n  });\n\n  test('should capture console.log output with callToolChain', async () => {\n    const code = `\n      console.log('First log message');\n      console.log('Number:', 42);\n      console.log('Object:', { name: 'test', value: 123 });\n      \n      const addResult = await test_tools.add({ a: 10, b: 20 });\n      console.log('Addition result:', addResult);\n      \n      return addResult.result;\n    `;\n    \n    const { result, logs } = await client.callToolChain(code);\n    \n    expect(result).toBe(30);\n    expect(logs).toHaveLength(4);\n    expect(logs[0]).toBe('First log message');\n    expect(logs[1]).toBe('Number: 42');\n    expect(logs[2]).toContain('\"name\": \"test\"');\n    expect(logs[2]).toContain('\"value\": 123');\n    expect(logs[3]).toContain('Addition result:');\n    expect(logs[3]).toContain('\"result\": 30');\n  });\n\n  test('should capture console error and warn with callToolChain', async () => {\n    const code = `\n      console.log('Regular log');\n      console.error('This is an error');\n      console.warn('This is a warning');\n      console.info('This is info');\n      \n      return 'done';\n    `;\n    \n    const { result, logs } = await client.callToolChain(code);\n    \n    expect(result).toBe('done');\n    expect(logs).toHaveLength(4);\n    expect(logs[0]).toBe('Regular log');\n    expect(logs[1]).toBe('[ERROR] This is an error');\n    expect(logs[2]).toBe('[WARN] This is a warning');\n    expect(logs[3]).toBe('[INFO] This is info');\n  });\n});\n\n// Export for potential manual testing\nexport { testResults };\n",
      "line_count": 643,
      "word_count": 1905,
      "title": "Code Mode Utcp Client.Test.Ts",
      "summary": "// OUTDATED, you can find the new version at https://github.com/universal-tool-calling-protocol/typescript-utcp/tree/main/packages/code-mode * Tests for CodeModeUtcpClient",
      "key_terms": [
        "close",
        "const",
        "packages",
        "convert",
        "Type",
        "Code",
        "Setup",
        "Record",
        "utility",
        "afterAll",
        "mode",
        "greetCalled",
        "multiple",
        "CodeModeUtcpClient",
        "if",
        "that",
        "interface",
        "Processing",
        "basic",
        "correct"
      ],
      "timestamp": "2025-12-24T18:56:00.221706"
    }
  ],
  "timestamp": "2025-12-24T18:56:00.221706"
}