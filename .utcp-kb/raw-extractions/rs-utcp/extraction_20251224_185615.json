{
  "repository": "rs-utcp",
  "commit_hash": "25a068bc7a1abc296dc06bd8e15a9c5541cc9adf",
  "commit_timestamp": "1764667854",
  "file_count": 82,
  "extractions": [
    {
      "file_path": "UPSTREAM\\rs-utcp\\build.rs",
      "content_type": "code",
      "content": "fn main() {\n    println!(\"cargo:rerun-if-changed=src/grpcpb/utcp.proto\");\n    let out_dir = std::path::Path::new(\"src/grpcpb/generated\");\n    if !out_dir.exists() {\n        std::fs::create_dir_all(out_dir).expect(\"failed to create gRPC output directory\");\n    }\n    tonic_build::configure()\n        .build_server(true)\n        .out_dir(out_dir)\n        .compile(&[\"src/grpcpb/utcp.proto\"], &[\"src/grpcpb\"])\n        .expect(\"Failed to compile gRPC protos\");\n}\n",
      "line_count": 13,
      "word_count": 29,
      "title": "Build.Rs",
      "summary": "fn main() { println!(\"cargo:rerun-if-changed=src/grpcpb/utcp.proto\");",
      "key_terms": [
        "generated",
        "changed",
        "output",
        "rerun",
        "Path",
        "cargo",
        "configure",
        "utcp",
        "create",
        "println",
        "failed",
        "gRPC",
        "directory",
        "compile",
        "std",
        "main",
        "rerun-if",
        "exists",
        "protos",
        "path"
      ],
      "timestamp": "2025-12-24T18:56:12.897185"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\Cargo.toml",
      "content_type": "other",
      "content": "[package]\nname = \"rs-utcp\"\nversion = \"0.3.0\"\nedition = \"2021\"\ndescription = \"Rust implementation of the Universal Tool Calling Protocol (UTCP).\"\nlicense = \"MIT OR Apache-2.0\"\nrepository = \"https://github.com/universal-tool-calling-protocol/rs-utcp\"\nhomepage = \"https://github.com/universal-tool-calling-protocol/rs-utcp\"\ndocumentation = \"https://docs.rs/rs-utcp\"\nreadme = \"README.md\"\nkeywords = [\"utcp\", \"tool-calling\", \"protocol\", \"ai\"]\ncategories = [\"development-tools\", \"network-programming\"]\n\n[dependencies]\ntokio = { version = \"1.0\", features = [\"full\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\nserde_yaml = \"0.9\"\nasync-trait = \"0.1\"\nanyhow = \"1.0\"\nonce_cell = \"1.19\"\n\nthiserror = \"1.0\"\nreqwest = { version = \"0.11\", features = [\"json\", \"stream\", \"gzip\", \"deflate\", \"brotli\"] }\nfutures = \"0.3\"\nregex = \"1.0\"\ntokio-tungstenite = \"0.21\"\npin-project = \"1.0\"\ntonic = { version = \"0.11\", features = [\"transport\", \"tls\"] }\nprost = \"0.12\"\nprost-types = \"0.12\"\nbase64 = \"0.21\"\nbytes = \"1\"\nrhai = { version = \"1.18\", features = [\"serde\"] }\neventsource-stream = \"0.2\"\nwebrtc = \"0.14\"\n\n[build-dependencies]\ntonic-build = \"0.11\"\n\n[dev-dependencies]\ntempfile = \"3\"\nhyper = { version = \"0.14\", features = [\"full\"] }\ntokio-tungstenite = \"0.21\"\nfutures-util = \"0.3\"\nprost = \"0.12\"\ntonic = { version = \"0.11\", features = [\"transport\", \"tls\"] }\ntokio-stream = { version = \"0.1\", features = [\"net\"] }\naxum = \"0.6\"\nuuid = { version = \"1\", features = [\"v4\"] }\ncriterion = { version = \"0.5\", features = [\"async_tokio\", \"html_reports\"] }\n\n[[bench]]\nname = \"tool_operations\"\nharness = false\n\n[[bench]]\nname = \"protocol_comparison\"\nharness = false\n\n[[bench]]\nname = \"codemode_execution\"\nharness = false\n\n[[bench]]\nname = \"call_tool_comparison\"\nharness = false\n",
      "line_count": 68,
      "word_count": 252,
      "title": "Cargo.Toml",
      "summary": "name = \"rs-utcp\" version = \"0.3.0\"",
      "key_terms": [
        "build",
        "project",
        "futures",
        "async",
        "network-programming",
        "md",
        "tokio-tungstenite",
        "dev-dependencies",
        "dependencies",
        "Rust",
        "version",
        "Calling",
        "tool-calling",
        "https",
        "development-tools",
        "universal-tool",
        "readme",
        "ai",
        "hyper",
        "description"
      ],
      "timestamp": "2025-12-24T18:56:12.919718"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\CHANGELOG.md",
      "content_type": "documentation",
      "content": "# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [Unreleased]\n\n## [0.3.0]\n\n### Added\n- **Protocol Restrictions** - Fine-grained control over allowed communication protocols:\n  - Added `allowed_communication_protocols` field to `CallTemplate`, `ManualV1`, and `BaseProvider`\n  - Implemented secure-by-default behavior: tools default to only allowing their own protocol type\n  - Added validation in `call_tool` and `call_tool_stream` to enforce protocol restrictions\n  - Added filtering logic during manual loading to skip tools with disallowed protocols\n  - Comprehensive test suite for protocol restriction scenarios\n\n## [0.2.9]\n\n### Added\n- **Call Template Handlers** - Added handlers and registration for 10 new call template types:\n  - websocket, grpc, graphql, tcp, udp, sse, mcp, webrtc, http_stream, and text\n  - Expands provider support across streaming, network, and RPC protocols\n- **Unit Tests** - Added unit tests for websocket, grpc, and mcp to validate call_template_type and field mapping\n\n### Changed\n- **Template Normalization** - Normalized key fields per template (e.g., url, headers, host/port, operation_type, timeout_ms, signaling_server)\n\n## [0.2.8]\n\n### Security\n- **Codemode Security Hardening** - Comprehensive security improvements:\n  - **Code Validation**: Pre-execution validation for dangerous patterns and size limits (100KB max)\n  - **Timeout Enforcement**: Strict timeout enforcement (5s default, 45s max) via `tokio::time::timeout`\n  - **Output Size Limits**: Maximum output size of 10MB to prevent memory exhaustion\n  - **Enhanced Sandboxing**: Centralized security constants for all Rhai limits\n  - **Function-Level Security**:\n    - `call_tool()`: Tool name validation (max 200 chars)\n    - `call_tool_stream()`: Stream item limit (10,000 max), memory exhaustion prevention\n    - `search_tools()`: Query length limit (1,000 chars), result limit (500 max)\n    - `sprintf()`: Format string limits, argument truncation, DoS prevention\n  - **Dangerous Pattern Detection**: Blocked `eval()`, `import`, `fn`, infinite loops\n\n### Changed\n- Codemode timeout parameter is now strictly enforced (was previously ignored)\n- All Rhai security limits now use centralized constants for easier auditing\n\n### Added\n- 9 new security-focused tests for Codemode validation\n\n## [0.2.7]\n\n### Added\n- **GraphQL Subscription Support** - Implemented `call_tool_stream` for GraphQL subscriptions:\n  - WebSocket-based subscription transport using the `graphql-transport-ws` protocol\n  - Automatic conversion of HTTP/HTTPS URLs to ws:// wss:// for subscriptions\n  - Support for all authentication methods (API Key, Basic Auth) in WebSocket headers\n  - Proper handling of subscription lifecycle (connection_init, subscribe, next, complete, error)\n  - Real-time streaming of subscription data through the `StreamResult` interface\n  - Added `graphql_subscription.rs` example demonstrating stock price updates streaming\n  - Comprehensive test coverage for subscription protocol implementation\n\n### Changed\n- GraphQL transport now validates that `call_tool_stream` is only used for subscription operations\n\n## [0.2.6] - 2025-11-29\n\n### Security\n- **Transport Security Integration**:\n  - Enforced URL security (HTTPS/TLS) in HTTP, WebRTC, and MCP transports.\n  - Enforced response size limits (10MB) in HTTP, WebRTC, and MCP transports to prevent DoS.\n  - Added message size validation for WebRTC data channels.\n  - Enforced path traversal protection in Text transport (validates script and tool paths).\n\n### Fixed\n- Fixed unused variable warning in WebRTC transport.\n\n## [0.2.5] - 2025-11-29\n\n### Added\n- **Security Module** - New `security` module with validators for:\n  - Command injection prevention (validates commands and arguments)\n  - Path traversal protection (validates file paths)\n  - URL security enforcement (HTTPS/TLS validation)\n  - Size limit validation (DoS prevention)\n  - Timeout validation\n- **GitHub Actions Security Workflow** - Automated security auditing:\n  - cargo-audit for dependency vulnerability scanning\n  - Dependency review for pull requests\n  - Clippy security lints\n\n### Changed\n- **Authentication Credentials Protection** - Implemented custom `Debug` trait for:\n  - `ApiKeyAuth` - Redacts API keys in debug output\n  - `BasicAuth` - Redacts passwords in debug output\n  - `OAuth2Auth` - Redacts client secrets in debug output\n- **MCP Stdio Transport** - Added command injection prevention:\n  - Validates command names for dangerous shell characters\n  - Validates arguments for shell operators and command substitution\n- **Codemode Security** - Enhanced Rhai script sandboxing:\n  - Set operation limits (100,000 max operations) to prevent infinite loops\n  - Set expression depth limits (64/32) to prevent stack overflow\n  - Set string size limit (1MB) to prevent memory exhaustion\n  - Set array/map size limits (10,000) to prevent memory exhaustion\n  - Set module limit (16) to restrict imports\n  - File I/O disabled by default\n\n### Security\n- **Fixed RUSTSEC-2025-0009**: Upgraded `webrtc` from 0.9 to 0.14, which removed the vulnerable `ring 0.16.20` dependency and now uses only the safe `ring 0.17.14+`\n  - Resolves: Some AES functions may panic when overflow checking is enabled\n  - Impact: Prevents potential denial of service in WebRTC transport\n- Prevents credential leakage through debug logs and error messages\n- Mitigates command injection attacks in CLI and MCP stdio providers\n- Protects against DoS attacks through Rhai script abuse\n- Automated dependency vulnerability monitoring via GitHub Actions\n\n## [0.2.4] - 2025-11-28\n\n### Added\n- **Performance Benchmarks** - Comprehensive Criterion.rs benchmark suite covering:\n  - Tool operations (registration, search, client initialization, tag matching)\n  - Protocol comparison (HTTP, CLI, WebSocket, MCP, gRPC, SSE)\n  - Codemode execution (script complexity, `call_tool` overhead, multiple calls)\n  - Detailed README in `benches/` with usage instructions and performance baselines\n- Criterion as a dev-dependency with async_tokio and html_reports features\n\n## [0.2.3] - 2025-11-28\n\n### Added\n- Documentation updates (#14)\n- Search tool optimizations (#15)\n\n### Changed\n- Refactoring session for codebase improvements\n- Updated dependencies (Cargo.lock)\n\n## [0.2.2] - 2025-11-27\n\n### Added\n- Apache 2.0 `LICENSE` file to make the MIT/Apache-2.0 licensing explicit\n- CI runs `cargo-llvm-cov` and uploads an HTML coverage report artifact\n- Regression tests covering plugin registration for call template handlers and custom communication protocols\n\n### Changed\n- Communication protocol registry now uses an internal `RwLock` so protocols can be registered globally without mutable access and snapshots stay thread-safe\n\n### Fixed\n- Strip provider prefixes before invoking GraphQL, HTTP stream, WebSocket, and SSE tools so prefixed tool names hit the correct endpoints\n\n## [0.2.1] - 2025-11-27\n\n### Added\n- Call template handler registry so plugins can register new `call_template_type` converters\n- Global communication protocol registry (`register_communication_protocol`) for pluggable protocols\n- Unit tests covering provider-prefix stripping for HTTP stream, SSE, WebSocket, and GraphQL protocols\n\n### Changed\n- Transports renamed to communication protocols throughout the client API while keeping backward compatibility\n- Documentation refreshed to describe the new registries and plugin extension points\n- Dependency update: added `once_cell` for global registry initialization\n\n### Fixed\n- Strip provider prefixes when calling HTTP stream, SSE, WebSocket, and GraphQL protocols to avoid 404s (e.g., `http_stream_server` example)\n\n## [0.2.0] - 2025-11-26\n\n### Added\n- Performance optimizations (#11)\n- Enhanced internal architecture for better scalability\n\n## [0.1.9] - 2025-11-26\n\n### Added\n- WebRTC transport updates and improvements (#8)\n- Comprehensive unit tests for all providers (#9)\n- GitHub Actions workflow updates\n\n### Changed\n- Updated README with latest examples\n- Improved test coverage\n\n## [0.1.8] - 2025-11-26\n\n### Changed\n- Version bumped to `1.0.0` to align with UTCP v1.0.0 specification\n- Updated all examples to use v1.0 configuration format (`manual_call_templates` instead of `providers`)\n- CLI transport: Fixed and improved implementation\n- Code refactoring for better maintainability\n\n### Added\n- v1.0.0 UTCP specification support with automatic migration from v0.1\n- `manual_call_templates` configuration option (replaces `providers`)\n- `call_template_type` field (replaces `provider_type`)\n- `UtcpClient::create()` async factory method\n- `with_manual_path()` configuration helper\n- Comprehensive migration documentation\n\n## [0.1.7] - 2025-11-26\n\n### Added\n- Unit tests for all provider types\n- Comprehensive test coverage for transports\n- More tests for WebRTC, WebSocket, MCP, and other transports (#9)\n\n### Changed\n- Updated README with latest features and examples\n- Improved documentation structure\n\n### Fixed\n- Various bug fixes and improvements\n\n## [0.1.6] - 2025-11-26\n\n### Added\n- Orchestrator example demonstrating LLM integration (#7)\n- Example showing codemode orchestration with Gemini\n\n### Changed\n- Updated Cargo.lock\n\n## [0.1.5] - 2025-11-26\n\n### Added\n- OpenAPI converter for automatic tool discovery from OpenAPI specs (#6)\n- Automatic conversion of OpenAPI endpoints to UTCP tools\n- Support for OpenAPI 3.0 specification parsing\n\n### Changed\n- Improved codemode orchestrator with better error handling (#5)\n- Enhanced LLM integration capabilities\n- Updated Cargo.toml and Cargo.lock\n\n## [0.1.4] - 2025-11-26\n\n### Fixed\n- Bug fixes in codemode orchestrator\n- Improved error handling in orchestrator flow\n\n## [0.1.2] - 2025-11-26\n\n### Added\n- MCP SSE (Server-Sent Events) transport support (#3)\n- Streaming capabilities for MCP providers\n- SSE event handling and parsing\n\n### Changed\n- Updated Cargo.lock\n- Enhanced README documentation\n\n## [0.1.1] - 2025-11-26\n\n### Changed\n- Refactored `UtcpClient` constructor (#2)\n  - Unified constructor into single async `new` function\n  - Automatic provider loading from config\n  - Removed old synchronous constructor\n  - Updated all examples to use new unified constructor\n- Updated Cargo.lock\n- Improved README documentation\n\n## [0.1.0] - 2025-11-25\n\n### Added\n- Initial implementation of UTCP client for Rust\n- Support for multiple transport protocols:\n  - **HTTP**: Full HTTP provider with UTCP manifest support\n  - **MCP (Model Context Protocol)**: stdio-based transport\n  - **WebSocket**: Real-time bidirectional communication\n  - **gRPC**: High-performance RPC protocol\n  - **CLI**: Execute local binaries as tools\n  - **GraphQL**: Query-based tool calling\n  - **TCP/UDP**: Low-level network transports\n  - **SSE**: Server-Sent Events for streaming\n  - **WebRTC**: Peer-to-peer data channels with signaling\n  - **HTTP Stream**: Streaming HTTP responses\n  - **Text**: File-based tool provider\n- **Codemode** scripting environment powered by Rhai\n  - Execute Rhai scripts with access to registered tools\n  - `call_tool()` and `call_tool_stream()` functions in scripts\n  - Sandboxed execution environment\n- **CodemodeOrchestrator** for LLM-driven workflows\n  - 4-step orchestration: Decide ‚Üí Select ‚Üí Generate ‚Üí Execute\n  - Integration with LLM for dynamic script generation\n  - Tool selection and discovery\n- **Tag-based tool search strategy**\n  - Semantic search across registered tools\n  - Configurable search scoring\n- **In-memory tool repository**\n  - Fast tool lookup and management\n  - Provider and tool registration\n- **Configuration management**\n  - JSON-based provider configuration\n  - Auto-loading providers from file\n  - Variable substitution support\n  - Environment variable integration\n- **Streaming support**\n  - Stream results for applicable transports\n  - Async stream handling with `StreamResult` trait\n- **Comprehensive examples**\n  - Basic usage examples\n  - Provider demonstrations for all transports\n  - Server examples for testing\n  - Codemode evaluation examples\n  - Orchestrator integration examples\n\n### Infrastructure\n- Build system with protocol buffer support (gRPC)\n- Extensive test coverage (90+ tests)\n- Example servers for testing various transports\n- GitHub Actions CI/CD pipeline\n- Comprehensive documentation and README\n\n### Initial Commits (2025-11-25)\n- `43d162c`: First commit - Project initialization\n- `53ff07f`: Initialize rs-utcp structure\n- `ff02864`: Add examples for all transports\n- `45754a1`: Fix Cargo.toml configuration\n- `7bd7d73`: Update README with usage instructions\n- `039478d`: Refactoring session for code organization\n- `de67148`: Update README documentation\n- `03434b3`: Major refactoring of rs-utcp architecture\n- `3135524`: Various fixes\n- `972336b`: Additional improvements\n- `95f1a02`: Add stdio MCP transport (#1)\n\n## Project History\n\n### Development Timeline\n- **2025-11-25**: Project inception and initial development\n  - Core architecture established\n  - Multiple transport protocols implemented\n  - Example infrastructure created\n  \n- **2025-11-26**: Feature expansion and testing\n  - MCP SSE transport added\n  - OpenAPI converter integration\n  - Codemode orchestrator improvements\n  - WebRTC transport enhancements\n  - Comprehensive test coverage\n  - Migration to v1.0.0 specification\n\n- **2025-11-27**: Stabilization and Refactoring\n  - Transports refactored to \"Communication Protocols\"\n  - Global registry implementation\n  - Plugin system enhancements\n  - Comprehensive unit testing\n\n- **2025-11-28**: Performance and Documentation\n  - Comprehensive benchmarking suite added\n  - Search algorithm optimizations\n  - Documentation improvements\n  - CI/CD pipeline enhancements\n\n### Key Milestones\n- **v0.1.0** (2025-11-25): Initial release with 12 transport types and codemode support\n- **v0.1.1** (2025-11-26): Unified async constructor API\n- **v0.1.2** (2025-11-26): MCP SSE transport support\n- **v0.1.5** (2025-11-26): OpenAPI converter integration\n- **v0.1.7** (2025-11-26): Comprehensive testing and documentation\n- **v0.2.0** (2025-11-26): Performance optimizations and architecture improvements\n- **v0.2.1** (2025-11-27): Protocol registry and plugin system\n- **v0.2.4** (2025-11-28): Comprehensive performance benchmarks suite\n\n## Migration Guide\n\nFor upgrading from v0.1.x to v1.0.0, the library provides automatic migration:\n- Configuration files using `providers` are automatically converted to `manual_call_templates`\n- All v0.1 code continues to work without changes\n- See the official [UTCP Migration Guide](https://www.utcp.io/migration-v0.1-to-v1.0) for details\n\n## Links\n\n- **UTCP Specification**: https://www.utcp.io\n- **Official Migration Guide**: https://www.utcp.io/migration-v0.1-to-v1.0\n- **GitHub Repository**: https://github.com/universal-tool-calling-protocol/rs-utcp\n- **Documentation**: https://docs.rs/rs-utcp\n\n---\n\n*Note: This changelog is generated from git history and follows the Keep a Changelog format.*\n",
      "line_count": 383,
      "word_count": 1995,
      "title": "Changelog",
      "summary": "All notable changes to this project will be documented in this file. The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),",
      "key_terms": [
        "Model",
        "chars",
        "extension",
        "Code",
        "during",
        "helper",
        "providers",
        "global",
        "Migration",
        "subscribe",
        "Cargo",
        "multiple",
        "orchestration",
        "licensing",
        "auditing",
        "Async",
        "that",
        "sse",
        "interface",
        "established"
      ],
      "timestamp": "2025-12-24T18:56:12.944413"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\README.md",
      "content_type": "documentation",
      "content": "<p align=\"center\">\n  <img src=\"https://github.com/user-attachments/assets/9c3a9645-7e21-47d9-8bd2-59ad5ae3d3bc\" alt=\"UTCP Logo\" width=\"256\" height=\"256\">\n</p>\n\n<h1 align=\"center\">rs-utcp</h1>\n\n<p align=\"center\">\n  <strong>Universal Tool Calling Protocol Client for Rust</strong>\n</p>\n\n<p align=\"center\">\n  <a href=\"https://crates.io/crates/rs-utcp\"><img src=\"https://img.shields.io/crates/v/rs-utcp.svg\" alt=\"Crates.io\"></a>\n  <a href=\"https://docs.rs/rs-utcp\"><img src=\"https://docs.rs/rs-utcp/badge.svg\" alt=\"Documentation\"></a>\n  <a href=\"https://github.com/universal-tool-calling-protocol/rs-utcp/blob/main/LICENSE\"><img src=\"https://img.shields.io/badge/license-MIT%2FApache--2.0-blue.svg\" alt=\"License\"></a>\n  <a href=\"https://github.com/universal-tool-calling-protocol/rs-utcp/actions\"><img src=\"https://github.com/universal-tool-calling-protocol/rs-utcp/workflows/CI/badge.svg\" alt=\"CI\"></a>\n</p>\n\n<p align=\"center\">\n  A powerful, async-first Rust implementation of the <a href=\"https://www.utcp.io\">Universal Tool Calling Protocol (UTCP)</a>\n</p>\n\n---\n\n## üåü Features\n\n- **üîå 12 Communication Protocols (formerly transports)** - HTTP, MCP, WebSocket, gRPC, CLI, GraphQL, TCP, UDP, SSE, WebRTC, HTTP Streams, and Text-based\n- **üöÄ Async/Await Native** - Built with Tokio for high-performance concurrent operations\n- **üì¶ Config-Driven** - Load tool providers from JSON with automatic discovery and registration\n- **üîç Smart Tool Discovery** - Tag-based semantic search across all registered tools\n- **ü§ñ LLM Integration** - Built-in Codemode orchestrator for AI-driven workflows\n- **üîÑ Auto-Migration** - Seamless compatibility with UTCP v0.1 and v1.0 formats\n- **üìù OpenAPI Support** - Automatic tool generation from OpenAPI 3.0 specifications\n- **üîê Multi-Auth** - Support for API keys, Basic Auth, OAuth2, and custom authentication\n- **üíæ Streaming** - First-class support for streaming responses across compatible communication protocols\n- **üß™ Well-Tested** - 90+ tests ensuring reliability and correctness\n\n## üì¶ Installation\n\nAdd `rs-utcp` to your `Cargo.toml`:\n\n```toml\n[dependencies]\nrs-utcp = \"0.1.8\"\ntokio = { version = \"1.0\", features = [\"full\"] }\n```\n\nOr use `cargo add`:\n\n```bash\ncargo add rs-utcp\ncargo add tokio --features full\n```\n\n## üöÄ Quick Start\n\n### Basic Usage\n\n```rust\nuse rs_utcp::{\n    config::UtcpClientConfig,\n    repository::in_memory::InMemoryToolRepository,\n    tag::tag_search::TagSearchStrategy,\n    UtcpClient, UtcpClientInterface,\n};\nuse std::{collections::HashMap, sync::Arc};\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    // 1. Configure the client\n    let config = UtcpClientConfig::new()\n        .with_manual_path(\"providers.json\".into());\n    \n    // 2. Set up repository and search\n    let repo = Arc::new(InMemoryToolRepository::new());\n    let search = Arc::new(TagSearchStrategy::new(repo.clone(), 1.0));\n    \n    // 3. Create the client\n    let client = UtcpClient::create(config, repo, search).await?;\n    \n    // 4. Discover tools\n    let tools = client.search_tools(\"weather\", 10).await?;\n    println!(\"Found {} tools\", tools.len());\n    \n    // 5. Call a tool\n    let mut args = HashMap::new();\n    args.insert(\"city\".to_string(), serde_json::json!(\"London\"));\n    \n    let result = client.call_tool(\"weather.get_forecast\", args).await?;\n    println!(\"Result: {}\", serde_json::to_string_pretty(&result)?);\n    \n    Ok(())\n}\n```\n\n### Configuration File (`providers.json`)\n\n```json\n{\n  \"manual_version\": \"1.0.0\",\n  \"utcp_version\": \"0.3.0\",\n  \"allowed_communication_protocols\": [\"http\", \"mcp\"],\n  \"info\": {\n    \"title\": \"Example UTCP Manual\",\n    \"version\": \"1.0.0\",\n    \"description\": \"Manual v1.0 with tools\"\n  },\n  \"tools\": [\n    {\n      \"name\": \"get_forecast\",\n      \"description\": \"Get current weather for a city\",\n      \"inputs\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"city\": { \"type\": \"string\", \"description\": \"City name\" },\n          \"units\": { \"type\": \"string\", \"enum\": [\"metric\", \"imperial\"] }\n        },\n        \"required\": [\"city\"]\n      },\n      \"outputs\": { \"type\": \"object\" },\n      \"tool_call_template\": {\n        \"call_template_type\": \"http\",\n        \"name\": \"weather_api\",\n        \"url\": \"https://api.weather.example.com/tools\",\n        \"http_method\": \"GET\",\n        \"headers\": { \"Accept\": \"application/json\" }\n      },\n      \"tags\": [\"weather\", \"demo\"]\n    },\n    {\n      \"name\": \"read_file\",\n      \"description\": \"Read a text file via MCP stdio\",\n      \"inputs\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"path\": { \"type\": \"string\", \"description\": \"File path\" }\n        },\n        \"required\": [\"path\"]\n      },\n      \"outputs\": { \"type\": \"object\" },\n      \"tool_call_template\": {\n        \"call_template_type\": \"mcp\",\n        \"name\": \"file_tools\",\n        \"command\": \"python3\",\n        \"args\": [\"mcp_server.py\"]\n      },\n      \"tags\": [\"mcp\", \"filesystem\"]\n    }\n  ],\n  \"load_variables_from\": [\n    {\n      \"variable_loader_type\": \"dotenv\",\n      \"env_file_path\": \".env\"\n    }\n  ]\n}\n```\n\n## üîå Supported Communication Protocols\n\nrs-utcp supports a comprehensive range of communication protocols, each with full async support:\n\n### Production-Ready Protocols\n\n| Protocol | Description | Status | Streaming |\n|-----------|-------------|--------|-----------|\n| **HTTP** | REST APIs with UTCP manifest or OpenAPI | ‚úÖ Stable | ‚ùå |\n| **MCP** | Model Context Protocol (stdio & SSE) | ‚úÖ Stable | ‚úÖ |\n| **WebRTC** | P2P data channels with signaling | ‚úÖ Stable | ‚úÖ |\n| **WebSocket** | Real-time bidirectional communication | ‚úÖ Stable | ‚úÖ |\n| **CLI** | Execute local binaries as tools | ‚úÖ Stable | ‚ùå |\n| **gRPC** | High-performance RPC with TLS & auth metadata | ‚úÖ Stable | ‚úÖ |\n| **GraphQL** | Query-based tool calling with type-aware variables | ‚úÖ Stable | ‚ùå |\n| **SSE** | Server-Sent Events | ‚úÖ Stable | ‚úÖ |\n| **HTTP Streams** | Streaming HTTP responses | ‚úÖ Stable | ‚úÖ |\n| **TCP** | Low-level socket transport (framed JSON) | ‚úÖ Stable | ‚úÖ |\n| **UDP** | Low-level datagram transport | ‚úÖ Stable | ‚ùå |\n| **Text** | File-based tool providers (JS/SH/Python/exe) | ‚úÖ Stable | ‚ùå |\n\n## üí° Examples\n\n### HTTP Provider with OpenAPI\n\n```rust\nuse rs_utcp::openapi::OpenApiConverter;\n\n// Automatically convert OpenAPI spec to UTCP tools\nlet converter = OpenApiConverter::new_from_url(\n    \"https://petstore.swagger.io/v2/swagger.json\",\n    Some(\"petstore\".to_string())\n).await?;\n\nlet manual = converter.convert();\nprintln!(\"Discovered {} tools from OpenAPI spec\", manual.tools.len());\n```\n\n### MCP Stdio Provider\n\n```rust\nlet config = serde_json::json!({\n    \"manual_call_templates\": [{\n        \"call_template_type\": \"mcp\",\n        \"name\": \"calculator\",\n        \"command\": \"python3\",\n        \"args\": [\"calculator_server.py\"],\n        \"env_vars\": {\n            \"DEBUG\": \"1\"\n        }\n    }]\n});\n\nlet client = create_client_from_config(config).await?;\nlet result = client.call_tool(\"calculator.add\", \n    HashMap::from([\n        (\"a\".to_string(), json!(5)),\n        (\"b\".to_string(), json!(3))\n    ])\n).await?;\n```\n\n### Streaming Tools\n\n```rust\n// Call a streaming tool\nlet mut stream = client.call_tool_stream(\n    \"sse_provider.events\",\n    HashMap::new()\n).await?;\n\n// Process stream results\nwhile let Some(item) = stream.next().await {\n    match item {\n        Ok(value) => println!(\"Received: {}\", value),\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n\nstream.close().await?;\n```\n\n### WebRTC Peer-to-Peer\n\nWebRTC enables direct peer-to-peer tool calling:\n\n```bash\n# Terminal 1: Start WebRTC server with signaling\ncargo run --example webrtc_server\n\n# Terminal 2: Connect and call tools\ncargo run --example webrtc_client\n```\n\nSee [`examples/webrtc_server/`](examples/webrtc_server/) for the complete implementation.\n\n## ü§ñ Codemode & LLM Orchestration\n\nrs-utcp includes a powerful **Codemode** feature that enables dynamic script execution with full access to registered tools. This is perfect for LLM-driven workflows.\n\n### Codemode Basics\n\n```rust\nuse rs_utcp::plugins::codemode::{CodeModeUtcp, CodeModeArgs};\n\nlet codemode = CodeModeUtcp::new(client);\n\n// Execute a Rhai script that calls tools\nlet script = r#\"\n    let weather = call_tool(\"weather.get_forecast\", #{\n        \"city\": \"Tokyo\"\n    });\n    \n    let summary = call_tool(\"ai.summarize\", #{\n        \"text\": weather.to_string()\n    });\n    \n    summary\n\"#;\n\nlet result = codemode.execute(CodeModeArgs {\n    code: script.to_string(),\n    timeout: Some(30_000),\n}).await?;\n\nprintln!(\"Result: {:?}\", result.value);\n```\n\n### LLM Orchestration\n\nThe `CodemodeOrchestrator` provides a 4-step AI-driven workflow:\n\n1. **Decide** - LLM determines if tools are needed\n2. **Select** - LLM chooses relevant tools\n3. **Generate** - LLM writes a Rhai script\n4. **Execute** - Script runs in sandboxed environment\n\n```rust\nuse rs_utcp::plugins::codemode::CodemodeOrchestrator;\n\nlet codemode = Arc::new(CodeModeUtcp::new(client));\nlet llm_model = Arc::new(YourLLMModel::new());\nlet orchestrator = CodemodeOrchestrator::new(codemode, llm_model);\n\n// Let the LLM figure out how to accomplish the task\nlet result = orchestrator\n    .call_prompt(\"Get the weather in Paris and summarize it\")\n    .await?;\n\nmatch result {\n    Some(value) => println!(\"LLM completed task: {}\", value),\n    None => println!(\"No tools needed for this request\"),\n}\n```\n\nSee the [Gemini example](examples/orchestrator_gemini.rs) for a complete LLM integration.\n\n### Codemode Security\n\nCodemode executes scripts in a **hardened sandbox** with comprehensive security measures:\n\n- ‚úÖ **Code Validation** - Pre-execution checks for dangerous patterns and size limits\n- ‚úÖ **Timeout Enforcement** - Strict timeouts (5s default, 30s max) prevent runaway scripts\n- ‚úÖ **Resource Limits** - Memory, CPU, and output size constraints\n- ‚úÖ **Sandboxed Execution** - Rhai scripts run isolated from the file system and OS\n\nSee [SECURITY.md](SECURITY.md) for complete security documentation.\n\n## üéØ Use Cases\n\n### 1. **Multi-Protocol API Gateway**\nCall tools across HTTP, gRPC, and MCP from a single unified interface.\n\n### 2. **LLM Agent Toolkit**\nProvide language models with a consistent way to execute tools regardless of their implementation.\n\n### 3. **Microservices Orchestration**\nCoordinate calls across heterogeneous services using different protocols.\n\n### 4. **Plugin System**\nBuild extensible applications where plugins can be added via configuration.\n\n### 5. **Testing & Mocking**\nEasily swap implementations (e.g., HTTP ‚Üí CLI) for testing without code changes.\n\n## üìö Documentation\n\n- **[API Documentation](https://docs.rs/rs-utcp)** - Complete API reference\n- **[UTCP Specification](https://www.utcp.io)** - Protocol specification\n- **[Examples](/examples)** - Working examples for all transports\n- **[SECURITY](SECURITY.md)** - Security features and best practices\n- **[CHANGELOG](CHANGELOG.md)** - Version history and changes\n\n## üß™ Testing\n\nRun the comprehensive test suite:\n\n```bash\n# Run all tests\ncargo test\n\n# Run with output\ncargo test -- --nocapture\n\n# Run specific test\ncargo test test_http_transport\n\n# Run examples\ncargo run --example basic_usage\ncargo run --example all_providers\n```\n\n## üèóÔ∏è Architecture\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                   UtcpClient                        ‚îÇ\n‚îÇ  (Unified interface for all tool operations)       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                  ‚îÇ\n         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n         ‚îÇ                   ‚îÇ\n  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n  ‚îÇ  Repository ‚îÇ   ‚îÇ Communication   ‚îÇ\n  ‚îÇ             ‚îÇ   ‚îÇ Protocols       ‚îÇ\n  ‚îÇ  - Tools    ‚îÇ   ‚îÇ  - HTTP         ‚îÇ\n  ‚îÇ  - Search   ‚îÇ   ‚îÇ  - MCP          ‚îÇ\n  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ  - gRPC         ‚îÇ\n                    ‚îÇ  - WebSocket    ‚îÇ\n                    ‚îÇ  - CLI          ‚îÇ\n                    ‚îÇ  - etc.         ‚îÇ\n                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n### Key Components\n\n- **UtcpClient** - Main entry point for all operations\n- **CommunicationProtocolRegistry** (was TransportRegistry) - Manages all communication protocol implementations\n- **Call template handlers** - Registry that maps `call_template_type` to provider builders\n- **ToolRepository** - Stores and indexes discovered tools\n- **SearchStrategy** - Semantic search across tools\n- **Codemode** - Script execution environment\n- **Loader** - Configuration and provider loading\n\n### Plugin registration (custom protocols)\n\nRegister new communication protocols and call template handlers before constructing your client:\n\n```rust\nuse std::sync::Arc;\nuse rs_utcp::call_templates::register_call_template_handler;\nuse rs_utcp::transports::register_communication_protocol;\n\nfn myproto_template_handler(template: serde_json::Value) -> anyhow::Result<serde_json::Value> {\n    // normalize/augment the template into a provider config\n    Ok(template)\n}\n\nregister_call_template_handler(\"myproto\", myproto_template_handler);\nregister_communication_protocol(\"myproto\", Arc::new(MyProtocol::new())); // implements CommunicationProtocol\n```\n\n## üîß Advanced Configuration\n\n### Authentication\n\n```json\n{\n  \"manual_call_templates\": [{\n    \"call_template_type\": \"http\",\n    \"name\": \"secure_api\",\n    \"url\": \"https://api.example.com\",\n    \"auth\": {\n      \"auth_type\": \"api_key\",\n      \"api_key\": \"${API_KEY}\",\n      \"var_name\": \"X-API-Key\",\n      \"location\": \"header\"\n    }\n  }]\n}\n```\n\n### Environment Variables\n\n```json\n{\n  \"load_variables_from\": [\n    {\n      \"variable_loader_type\": \"dotenv\",\n      \"env_file_path\": \".env\"\n    }\n  ],\n  \"variables\": {\n    \"DEFAULT_TIMEOUT\": \"30000\"\n  }\n}\n```\n\n### Protocol Restrictions\n\nYou can restrict which communication protocols are allowed for a manual or provider using the `allowed_communication_protocols` field. This provides a secure-by-default mechanism where tools can only use their own protocol unless explicitly allowed.\n\n```json\n{\n  \"manual_version\": \"1.0.0\",\n  \"info\": { \"title\": \"Restricted Manual\", \"version\": \"1.0.0\" },\n  \"allowed_communication_protocols\": [\"http\", \"cli\"],\n  \"tools\": [\n    {\n      \"name\": \"http_tool\",\n      \"tool_call_template\": {\n        \"call_template_type\": \"http\",\n        \"url\": \"http://example.com\"\n      }\n    },\n    {\n      \"name\": \"cli_tool\",\n      \"tool_call_template\": {\n        \"call_template_type\": \"cli\",\n        \"command\": \"echo\"\n      }\n    }\n  ]\n}\n```\n\nIf `allowed_communication_protocols` is not specified, it defaults to only allowing the tool's own protocol type. Tools attempting to use disallowed protocols will be filtered out during registration, and calls will fail validation.\n\n### Custom Search Strategy\n\n```rust\nuse rs_utcp::tools::ToolSearchStrategy;\nuse async_trait::async_trait;\n\nstruct MySearchStrategy;\n\n#[async_trait]\nimpl ToolSearchStrategy for MySearchStrategy {\n    async fn search_tools(&self, query: &str, limit: usize) \n        -> anyhow::Result<Vec<Tool>> \n    {\n        // Your custom search logic\n        Ok(vec![])\n    }\n}\n```\n\n## ü§ù Contributing\n\nContributions are welcome! Here's how you can help:\n\n1. **Found a bug?** Open an issue\n2. **Have a feature idea?** Start a discussion\n3. **Want to contribute code?** Submit a PR\n\n### Development Setup\n\n```bash\n# Clone the repository\ngit clone https://github.com/universal-tool-calling-protocol/rs-utcp.git\ncd rs-utcp\n\n# Run tests\ncargo test\n\n# Format code\ncargo fmt\n\n# Run lints\ncargo clippy\n\n# Build all examples\ncargo build --examples\n```\n\n## üìú License\n\nLicensed under either of:\n\n- Apache License, Version 2.0 ([LICENSE-APACHE](LICENSE-APACHE) or http://www.apache.org/licenses/LICENSE-2.0)\n- MIT license ([LICENSE-MIT](LICENSE-MIT) or http://opensource.org/licenses/MIT)\n\nat your option.\n\n## üôè Acknowledgments\n\n- Inspired by [go-utcp](https://github.com/universal-tool-calling-protocol/go-utcp)\n- Built on the [UTCP specification](https://www.utcp.io)\n- Powered by the amazing Rust async ecosystem\n\n## üì¨ Contact & Support\n\n- **Issues**: [GitHub Issues](https://github.com/universal-tool-calling-protocol/rs-utcp/issues)\n- **Discussions**: [GitHub Discussions](https://github.com/universal-tool-calling-protocol/rs-utcp/discussions)\n- **UTCP Community**: [utcp.io](https://www.utcp.io)\n\n---\n\n<p align=\"center\">\n  Made with ‚ù§Ô∏è by the UTCP community\n</p>\n",
      "line_count": 559,
      "word_count": 1792,
      "title": "Readme.Md",
      "summary": "<p align=\"center\"> <img src=\"https://github.com/user-attachments/assets/9c3a9645-7e21-47d9-8bd2-59ad5ae3d3bc\" alt=\"UTCP Logo\" width=\"256\" height=\"256\">",
      "key_terms": [
        "Crates",
        "comprehensive",
        "close",
        "Model",
        "Architecture",
        "Auto-Migration",
        "etc",
        "img",
        "convert",
        "Toolkit",
        "Code",
        "Setup",
        "either",
        "indexes",
        "fmt",
        "filesystem",
        "nocapture",
        "Clone",
        "during",
        "providers"
      ],
      "timestamp": "2025-12-24T18:56:13.015969"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\benches\\call_tool_comparison.rs",
      "content_type": "code",
      "content": "use async_trait::async_trait;\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse rs_utcp::{\n    config::UtcpClientConfig,\n    plugins::codemode::{CodeModeArgs, CodeModeUtcp},\n    providers::base::{BaseProvider, Provider, ProviderType},\n    repository::in_memory::InMemoryToolRepository,\n    tag::tag_search::TagSearchStrategy,\n    tools::{Tool, ToolInputOutputSchema},\n    transports::{\n        registry::register_communication_protocol,\n        stream::{boxed_vec_stream, StreamResult},\n        CommunicationProtocol,\n    },\n    UtcpClient, UtcpClientInterface,\n};\nuse serde_json::{json, Value};\nuse std::{collections::HashMap, sync::Arc};\nuse tokio::runtime::Runtime;\n\n// --- Mock Protocol for Benchmarking ---\n\n#[derive(Debug)]\nstruct BenchmarkProtocol;\n\n#[async_trait]\nimpl CommunicationProtocol for BenchmarkProtocol {\n    async fn register_tool_provider(&self, _prov: &dyn Provider) -> anyhow::Result<Vec<Tool>> {\n        Ok(vec![\n            Tool {\n                name: \"echo\".to_string(),\n                description: \"Echo tool\".to_string(),\n                inputs: ToolInputOutputSchema {\n                    type_: \"object\".to_string(),\n                    properties: None,\n                    required: None,\n                    description: None,\n                    title: None,\n                    items: None,\n                    enum_: None,\n                    minimum: None,\n                    maximum: None,\n                    format: None,\n                },\n                outputs: ToolInputOutputSchema {\n                    type_: \"object\".to_string(),\n                    properties: None,\n                    required: None,\n                    description: None,\n                    title: None,\n                    items: None,\n                    enum_: None,\n                    minimum: None,\n                    maximum: None,\n                    format: None,\n                },\n                tags: vec![],\n                average_response_size: None,\n                provider: None,\n            },\n            Tool {\n                name: \"stream\".to_string(),\n                description: \"Streaming tool\".to_string(),\n                inputs: ToolInputOutputSchema {\n                    type_: \"object\".to_string(),\n                    properties: None,\n                    required: None,\n                    description: None,\n                    title: None,\n                    items: None,\n                    enum_: None,\n                    minimum: None,\n                    maximum: None,\n                    format: None,\n                },\n                outputs: ToolInputOutputSchema {\n                    type_: \"object\".to_string(),\n                    properties: None,\n                    required: None,\n                    description: None,\n                    title: None,\n                    items: None,\n                    enum_: None,\n                    minimum: None,\n                    maximum: None,\n                    format: None,\n                },\n                tags: vec![],\n                average_response_size: None,\n                provider: None,\n            },\n        ])\n    }\n\n    async fn deregister_tool_provider(&self, _prov: &dyn Provider) -> anyhow::Result<()> {\n        Ok(())\n    }\n\n    async fn call_tool(\n        &self,\n        _tool_name: &str,\n        args: HashMap<String, Value>,\n        _prov: &dyn Provider,\n    ) -> anyhow::Result<Value> {\n        // Simple echo\n        Ok(json!(args))\n    }\n\n    async fn call_tool_stream(\n        &self,\n        _tool_name: &str,\n        _args: HashMap<String, Value>,\n        _prov: &dyn Provider,\n    ) -> anyhow::Result<Box<dyn StreamResult>> {\n        // Return a stream of 10 items\n        let items: Vec<Value> = (0..10).map(|i| json!({\"chunk\": i})).collect();\n        Ok(boxed_vec_stream(items))\n    }\n}\n\n// --- Helper to setup client ---\n\nasync fn create_bench_client() -> Arc<UtcpClient> {\n    // Register our benchmark protocol under \"http_stream\" to hijack it\n    // We use HttpStream provider type because it maps to \"http_stream\" key\n    register_communication_protocol(\"http_stream\", Arc::new(BenchmarkProtocol));\n\n    let config = UtcpClientConfig::new();\n    let repo = Arc::new(InMemoryToolRepository::new());\n    let search = Arc::new(TagSearchStrategy::new(repo.clone(), 1.0));\n    let client = UtcpClient::create(config, repo, search).await.unwrap();\n\n    // Register a provider that uses our hijacked protocol\n    let provider = BaseProvider {\n        name: \"bench\".to_string(),\n        provider_type: ProviderType::HttpStream,\n        auth: None,\n        allowed_communication_protocols: vec![\"http_stream\".to_string()].into(),\n    };\n\n    client\n        .register_tool_provider(Arc::new(provider))\n        .await\n        .unwrap();\n\n    Arc::new(client)\n}\n\n// --- Benchmarks ---\n\nfn bench_call_tool_comparison(c: &mut Criterion) {\n    let rt = Runtime::new().unwrap();\n    let mut group = c.benchmark_group(\"call_tool_comparison\");\n\n    // Setup client once\n    let client = rt.block_on(create_bench_client());\n    let codemode = CodeModeUtcp::new(client.clone());\n\n    group.bench_function(\"native\", |b| {\n        b.to_async(&rt).iter(|| async {\n            let mut args = HashMap::new();\n            args.insert(\"msg\".to_string(), json!(\"hello\"));\n            client\n                .call_tool(black_box(\"bench.echo\"), black_box(args))\n                .await\n                .unwrap()\n        });\n    });\n\n    group.bench_function(\"codemode\", |b| {\n        let script = r#\"call_tool(\"bench.echo\", #{ \"msg\": \"hello\" })\"#;\n        b.to_async(&rt).iter(|| async {\n            let args = CodeModeArgs {\n                code: black_box(script.to_string()),\n                timeout: Some(5000),\n            };\n            codemode.execute(black_box(args)).await.unwrap()\n        });\n    });\n\n    group.finish();\n}\n\nfn bench_call_tool_stream_comparison(c: &mut Criterion) {\n    let rt = Runtime::new().unwrap();\n    let mut group = c.benchmark_group(\"call_tool_stream_comparison\");\n\n    let client = rt.block_on(create_bench_client());\n    let codemode = CodeModeUtcp::new(client.clone());\n\n    group.bench_function(\"native\", |b| {\n        b.to_async(&rt).iter(|| async {\n            let args = HashMap::new();\n            let mut stream = client\n                .call_tool_stream(black_box(\"bench.stream\"), black_box(args))\n                .await\n                .unwrap();\n\n            // Consume the stream\n            let mut count = 0;\n            while let Ok(Some(_)) = stream.next().await {\n                count += 1;\n            }\n            black_box(count)\n        });\n    });\n\n    group.bench_function(\"codemode\", |b| {\n        // Rhai script to consume stream\n        let script = r#\"\n            let stream = call_tool_stream(\"bench.stream\", #{});\n            stream.len()\n        \"#;\n        b.to_async(&rt).iter(|| async {\n            let args = CodeModeArgs {\n                code: black_box(script.to_string()),\n                timeout: Some(5000),\n            };\n            codemode.execute(black_box(args)).await.unwrap()\n        });\n    });\n\n    group.finish();\n}\n\nfn bench_call_many_tools_comparison(c: &mut Criterion) {\n    let rt = Runtime::new().unwrap();\n    let mut group = c.benchmark_group(\"call_many_tools_comparison\");\n\n    let client = rt.block_on(create_bench_client());\n    let codemode = CodeModeUtcp::new(client.clone());\n    let tool_count = 50;\n\n    group.bench_function(\"native\", |b| {\n        b.to_async(&rt).iter(|| async {\n            for i in 0..tool_count {\n                let mut args = HashMap::new();\n                args.insert(\"msg\".to_string(), json!(format!(\"hello {}\", i)));\n                client\n                    .call_tool(black_box(\"bench.echo\"), black_box(args))\n                    .await\n                    .unwrap();\n            }\n        });\n    });\n\n    group.bench_function(\"codemode\", |b| {\n        let script = format!(\n            r#\"\n            for i in 0..{} {{\n                call_tool(\"bench.echo\", #{{ \"msg\": \"hello \" + i }});\n            }}\n        \"#,\n            tool_count\n        );\n\n        b.to_async(&rt).iter(|| async {\n            let args = CodeModeArgs {\n                code: black_box(script.clone()),\n                timeout: Some(10000),\n            };\n            codemode.execute(black_box(args)).await.unwrap()\n        });\n    });\n\n    group.finish();\n}\n\ncriterion_group!(\n    benches,\n    bench_call_tool_comparison,\n    bench_call_tool_stream_comparison,\n    bench_call_many_tools_comparison,\n);\ncriterion_main!(benches);\n",
      "line_count": 276,
      "word_count": 623,
      "title": "Call Tool Comparison.Rs",
      "summary": "use async_trait::async_trait; use criterion::{black_box, criterion_group, criterion_main, Criterion};",
      "key_terms": [
        "Result",
        "rt",
        "async",
        "search",
        "Setup",
        "format",
        "uses",
        "Utcp",
        "providers",
        "codemode",
        "repo",
        "finish",
        "InMemoryToolRepository",
        "native",
        "let",
        "that",
        "hello",
        "under",
        "struct",
        "Benchmarks"
      ],
      "timestamp": "2025-12-24T18:56:13.055424"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\benches\\codemode_execution.rs",
      "content_type": "code",
      "content": "use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion};\nuse rs_utcp::{\n    config::UtcpClientConfig,\n    plugins::codemode::{CodeModeArgs, CodeModeUtcp},\n    repository::in_memory::InMemoryToolRepository,\n    tag::tag_search::TagSearchStrategy,\n    UtcpClient,\n};\nuse serde_json::json;\nuse std::fs;\nuse std::sync::Arc;\nuse tempfile::NamedTempFile;\nuse tokio::runtime::Runtime;\n\n/// Helper to create a client from a config JSON\nasync fn create_client_from_config(config_json: serde_json::Value) -> Arc<UtcpClient> {\n    let temp_file = NamedTempFile::new().unwrap();\n    fs::write(temp_file.path(), serde_json::to_vec(&config_json).unwrap()).unwrap();\n\n    let config = UtcpClientConfig::new().with_providers_file(temp_file.path().to_path_buf());\n    let repo = Arc::new(InMemoryToolRepository::new());\n    let search = Arc::new(TagSearchStrategy::new(repo.clone(), 1.0));\n\n    Arc::new(UtcpClient::new(config, repo, search).await.unwrap())\n}\n\n/// Benchmark basic Rhai script execution\nfn bench_simple_script_execution(c: &mut Criterion) {\n    let rt = Runtime::new().unwrap();\n\n    c.bench_function(\"codemode_simple_script\", |b| {\n        let codemode = rt.block_on(async {\n            let config = UtcpClientConfig::new();\n            let repo = Arc::new(InMemoryToolRepository::new());\n            let search = Arc::new(TagSearchStrategy::new(repo.clone(), 1.0));\n            let client = UtcpClient::create(config, repo, search).await.unwrap();\n\n            CodeModeUtcp::new(Arc::new(client))\n        });\n\n        b.to_async(&rt).iter(|| async {\n            let script = \"42 + 58\";\n            let args = CodeModeArgs {\n                code: black_box(script.to_string()),\n                timeout: Some(5000),\n            };\n\n            let result = codemode.execute(black_box(args)).await.unwrap();\n            black_box(result)\n        });\n    });\n}\n\n/// Benchmark script execution with different complexity levels\nfn bench_script_complexity(c: &mut Criterion) {\n    let rt = Runtime::new().unwrap();\n    let mut group = c.benchmark_group(\"codemode_complexity\");\n\n    let codemode = rt.block_on(async {\n        let config = UtcpClientConfig::new();\n        let repo = Arc::new(InMemoryToolRepository::new());\n        let search = Arc::new(TagSearchStrategy::new(repo.clone(), 1.0));\n        let client = UtcpClient::create(config, repo, search).await.unwrap();\n\n        CodeModeUtcp::new(Arc::new(client))\n    });\n\n    // Simple arithmetic\n    group.bench_function(\"arithmetic\", |b| {\n        b.to_async(&rt).iter(|| async {\n            let script = \"let x = 10; let y = 20; x + y * 2\";\n            let args = CodeModeArgs {\n                code: black_box(script.to_string()),\n                timeout: Some(5000),\n            };\n\n            let result = codemode.execute(black_box(args)).await.unwrap();\n            black_box(result)\n        });\n    });\n\n    // Loop execution\n    group.bench_function(\"loop_100\", |b| {\n        b.to_async(&rt).iter(|| async {\n            let script = r#\"\n                let sum = 0;\n                for i in 0..100 {\n                    sum += i;\n                }\n                sum\n            \"#;\n            let args = CodeModeArgs {\n                code: black_box(script.to_string()),\n                timeout: Some(5000),\n            };\n\n            let result = codemode.execute(black_box(args)).await.unwrap();\n            black_box(result)\n        });\n    });\n\n    // Array operations\n    group.bench_function(\"array_operations\", |b| {\n        b.to_async(&rt).iter(|| async {\n            let script = r#\"\n                let arr = [];\n                for i in 0..50 {\n                    arr.push(i * 2);\n                }\n                arr.len()\n            \"#;\n            let args = CodeModeArgs {\n                code: black_box(script.to_string()),\n                timeout: Some(5000),\n            };\n\n            let result = codemode.execute(black_box(args)).await.unwrap();\n            black_box(result)\n        });\n    });\n\n    // Map operations\n    group.bench_function(\"map_operations\", |b| {\n        b.to_async(&rt).iter(|| async {\n            let script = r#\"\n                let map = #{};\n                for i in 0..50 {\n                    map[`key_${i}`] = i * 2;\n                }\n                map.len()\n            \"#;\n            let args = CodeModeArgs {\n                code: black_box(script.to_string()),\n                timeout: Some(5000),\n            };\n\n            let result = codemode.execute(black_box(args)).await.unwrap();\n            black_box(result)\n        });\n    });\n\n    group.finish();\n}\n\n/// Benchmark codemode call_tool function (key feature!)\nfn bench_codemode_call_tool(c: &mut Criterion) {\n    let rt = Runtime::new().unwrap();\n\n    c.bench_function(\"codemode_call_tool_cli\", |b| {\n        let codemode = rt.block_on(async {\n            let config_json = json!({\n                \"manual_call_templates\": [{\n                    \"call_template_type\": \"cli\",\n                    \"name\": \"test_provider\",\n                    \"command\": \"echo\",\n                    \"tools\": [{\n                        \"name\": \"greet\",\n                        \"description\": \"Greet someone\",\n                        \"inputs\": {\"type\": \"object\"},\n                        \"outputs\": {\"type\": \"object\"},\n                        \"tags\": [\"greeting\"],\n                        \"tool_call_template\": {\n                            \"call_template_type\": \"cli\",\n                            \"command\": \"echo\",\n                            \"args\": [\"Hello, {{name}}!\"]\n                        }\n                    }]\n                }]\n            });\n\n            let client = create_client_from_config(config_json).await;\n            CodeModeUtcp::new(client)\n        });\n\n        b.to_async(&rt).iter(|| async {\n            // Script that calls a tool\n            let script = r#\"\n                let result = call_tool(\"test_provider.greet\", #{\n                    \"name\": \"World\"\n                });\n                result\n            \"#;\n            let args = CodeModeArgs {\n                code: black_box(script.to_string()),\n                timeout: Some(5000),\n            };\n\n            let result = codemode.execute(black_box(args)).await.unwrap();\n            black_box(result)\n        });\n    });\n}\n\n/// Benchmark multiple tool calls in sequence\nfn bench_codemode_multiple_tool_calls(c: &mut Criterion) {\n    let rt = Runtime::new().unwrap();\n    let mut group = c.benchmark_group(\"codemode_multiple_calls\");\n\n    for call_count in [1, 3, 5].iter() {\n        group.bench_with_input(\n            BenchmarkId::from_parameter(call_count),\n            call_count,\n            |b, &count| {\n                let codemode = rt.block_on(async {\n                    let config_json = json!({\n                        \"manual_call_templates\": [{\n                            \"call_template_type\": \"cli\",\n                            \"name\": \"test_provider\",\n                            \"command\": \"echo\",\n                            \"tools\": [{\n                                \"name\": \"echo\",\n                                \"description\": \"Echo a message\",\n                                \"inputs\": {\"type\": \"object\"},\n                                \"outputs\": {\"type\": \"object\"},\n                                \"tags\": [\"utility\"],\n                                \"tool_call_template\": {\n                                    \"call_template_type\": \"cli\",\n                                    \"command\": \"echo\",\n                                    \"args\": [\"{{message}}\"]\n                                }\n                            }]\n                        }]\n                    });\n\n                    let client = create_client_from_config(config_json).await;\n                    CodeModeUtcp::new(client)\n                });\n                b.to_async(&rt).iter(|| async {\n                    // Generate script with multiple tool calls\n                    let mut script = String::from(\"let results = [];\\n\");\n                    for i in 0..count {\n                        script.push_str(&format!(\n                            \"results.push(call_tool(\\\"test_provider.echo\\\", #{{\\\"message\\\": \\\"msg_{}\\\"}}));\\n\",\n                            i\n                        ));\n                    }\n                    script.push_str(\"results.len()\");\n\n                    let args = CodeModeArgs {\n                        code: black_box(script),\n                        timeout: Some(10000),\n                    };\n\n                    let result = codemode.execute(black_box(args)).await.unwrap();\n                    black_box(result)\n                });\n            },\n        );\n    }\n\n    group.finish();\n}\n\n/// Benchmark script parsing overhead\nfn bench_script_sizes(c: &mut Criterion) {\n    let rt = Runtime::new().unwrap();\n    let mut group = c.benchmark_group(\"codemode_script_size\");\n\n    for line_count in [10, 50, 100, 200].iter() {\n        group.bench_with_input(\n            BenchmarkId::from_parameter(line_count),\n            line_count,\n            |b, &count| {\n                let codemode = rt.block_on(async {\n                    let config = UtcpClientConfig::new();\n                    let repo = Arc::new(InMemoryToolRepository::new());\n                    let search = Arc::new(TagSearchStrategy::new(repo.clone(), 1.0));\n                    let client = UtcpClient::create(config, repo, search).await.unwrap();\n\n                    CodeModeUtcp::new(Arc::new(client))\n                });\n\n                // Generate a script with many lines\n                let mut script = String::from(\"let sum = 0;\\n\");\n                for i in 0..count {\n                    script.push_str(&format!(\"sum += {};\\n\", i));\n                }\n                script.push_str(\"sum\");\n\n                b.to_async(&rt).iter(|| async {\n                    let args = CodeModeArgs {\n                        code: black_box(script.clone()),\n                        timeout: Some(10000),\n                    };\n\n                    let result = codemode.execute(black_box(args)).await.unwrap();\n                    black_box(result)\n                });\n            },\n        );\n    }\n\n    group.finish();\n}\n\n/// Benchmark string operations in Rhai\nfn bench_string_operations(c: &mut Criterion) {\n    let rt = Runtime::new().unwrap();\n\n    c.bench_function(\"codemode_string_concat\", |b| {\n        let codemode = rt.block_on(async {\n            let config = UtcpClientConfig::new();\n            let repo = Arc::new(InMemoryToolRepository::new());\n            let search = Arc::new(TagSearchStrategy::new(repo.clone(), 1.0));\n            let client = UtcpClient::create(config, repo, search).await.unwrap();\n\n            CodeModeUtcp::new(Arc::new(client))\n        });\n\n        b.to_async(&rt).iter(|| async {\n            let script = r#\"\n                let result = \"\";\n                for i in 0..20 {\n                    result += `item_${i}_`;\n                }\n                result\n            \"#;\n            let args = CodeModeArgs {\n                code: black_box(script.to_string()),\n                timeout: Some(5000),\n            };\n\n            let result = codemode.execute(black_box(args)).await.unwrap();\n            black_box(result)\n        });\n    });\n}\n\n/// Benchmark function definitions and calls\nfn bench_function_calls(c: &mut Criterion) {\n    let rt = Runtime::new().unwrap();\n\n    c.bench_function(\"codemode_function_calls\", |b| {\n        let codemode = rt.block_on(async {\n            let config = UtcpClientConfig::new();\n            let repo = Arc::new(InMemoryToolRepository::new());\n            let search = Arc::new(TagSearchStrategy::new(repo.clone(), 1.0));\n            let client = UtcpClient::create(config, repo, search).await.unwrap();\n\n            CodeModeUtcp::new(Arc::new(client))\n        });\n\n        b.to_async(&rt).iter(|| async {\n            let script = r#\"\n                fn fibonacci(n) {\n                    if n <= 1 {\n                        return n;\n                    }\n                    return fibonacci(n - 1) + fibonacci(n - 2);\n                }\n                fibonacci(10)\n            \"#;\n            let args = CodeModeArgs {\n                code: black_box(script.to_string()),\n                timeout: Some(5000),\n            };\n\n            let result = codemode.execute(black_box(args)).await.unwrap();\n            black_box(result)\n        });\n    });\n}\n\ncriterion_group!(\n    benches,\n    bench_simple_script_execution,\n    bench_script_complexity,\n    bench_codemode_call_tool,\n    bench_codemode_multiple_tool_calls,\n    bench_script_sizes,\n    bench_string_operations,\n    bench_function_calls,\n);\ncriterion_main!(benches);\n",
      "line_count": 375,
      "word_count": 908,
      "title": "Codemode Execution.Rs",
      "summary": "use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion}; use rs_utcp::{",
      "key_terms": [
        "fibonacci",
        "arr",
        "rt",
        "async",
        "search",
        "World",
        "utility",
        "format",
        "Utcp",
        "codemode",
        "repo",
        "finish",
        "string",
        "multiple",
        "InMemoryToolRepository",
        "Loop",
        "path",
        "let",
        "if",
        "that"
      ],
      "timestamp": "2025-12-24T18:56:13.103249"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\benches\\protocol_comparison.rs",
      "content_type": "code",
      "content": "use criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse rs_utcp::{\n    config::UtcpClientConfig, repository::in_memory::InMemoryToolRepository,\n    tag::tag_search::TagSearchStrategy, UtcpClient, UtcpClientInterface,\n};\nuse serde_json::json;\nuse std::fs;\nuse std::{collections::HashMap, sync::Arc};\nuse tempfile::NamedTempFile;\nuse tokio::runtime::Runtime;\n\n/// Helper to create a client from a config JSON\nasync fn create_client_from_config(config_json: serde_json::Value) -> Arc<UtcpClient> {\n    let temp_file = NamedTempFile::new().unwrap();\n    fs::write(temp_file.path(), serde_json::to_vec(&config_json).unwrap()).unwrap();\n\n    let config = UtcpClientConfig::new().with_providers_file(temp_file.path().to_path_buf());\n    let repo = Arc::new(InMemoryToolRepository::new());\n    let search = Arc::new(TagSearchStrategy::new(repo.clone(), 1.0));\n\n    Arc::new(UtcpClient::new(config, repo, search).await.unwrap())\n}\n\n/// Benchmark CLI tool calling (actual execution)\nfn bench_cli_tool_call(c: &mut Criterion) {\n    let rt = Runtime::new().unwrap();\n\n    c.bench_function(\"cli_echo_call\", |b| {\n        let client = rt.block_on(async {\n            let config_json = json!({\n                \"manual_call_templates\": [{\n                    \"call_template_type\": \"cli\",\n                    \"name\": \"echo_provider\",\n                    \"command\": \"echo\",\n                    \"tools\": [{\n                        \"name\": \"echo\",\n                        \"description\": \"Echo a message\",\n                        \"inputs\": {\"type\": \"object\"},\n                        \"outputs\": {\"type\": \"object\"},\n                        \"tags\": [\"utility\"],\n                        \"tool_call_template\": {\n                            \"call_template_type\": \"cli\",\n                            \"command\": \"echo\",\n                            \"args\": [\"{{message}}\"]\n                        }\n                    }]\n                }]\n            });\n\n            create_client_from_config(config_json).await\n        });\n\n        b.to_async(&rt).iter(|| async {\n            let mut args = HashMap::new();\n            args.insert(\"message\".to_string(), json!(\"benchmark\"));\n\n            let _ = client\n                .call_tool(black_box(\"echo_provider.echo\"), black_box(args))\n                .await.expect(\"call_tool failed\");\n        });\n    });\n}\n\n/// Compare provider initialization overhead across different types\nfn bench_provider_comparison(c: &mut Criterion) {\n    let rt = Runtime::new().unwrap();\n    let mut group = c.benchmark_group(\"provider_initialization\");\n\n    // HTTP Provider\n    group.bench_function(\"http\", |b| {\n        b.to_async(&rt).iter(|| async {\n            let config_json = json!({\n                \"manual_call_templates\": [{\n                    \"call_template_type\": \"http\",\n                    \"name\": \"http_test\",\n                    \"url\": \"http://localhost:9999/tools\",\n                    \"http_method\": \"GET\"\n                }]\n            });\n\n            let client = create_client_from_config(black_box(config_json)).await;\n            black_box(client)\n        });\n    });\n\n    // CLI Provider\n    group.bench_function(\"cli\", |b| {\n        b.to_async(&rt).iter(|| async {\n            let config_json = json!({\n                \"manual_call_templates\": [{\n                    \"call_template_type\": \"cli\",\n                    \"name\": \"cli_test\",\n                    \"command\": \"echo\"\n                }]\n            });\n\n            let client = create_client_from_config(black_box(config_json)).await;\n            black_box(client)\n        });\n    });\n\n    // WebSocket Provider (registration only, no connection)\n    group.bench_function(\"websocket\", |b| {\n        b.to_async(&rt).iter(|| async {\n            let config_json = json!({\n                \"manual_call_templates\": [{\n                    \"call_template_type\": \"websocket\",\n                    \"name\": \"ws_test\",\n                    \"url\": \"ws://localhost:9999\"\n                }]\n            });\n\n            let client = create_client_from_config(black_box(config_json)).await;\n            black_box(client)\n        });\n    });\n\n    // MCP Provider\n    group.bench_function(\"mcp\", |b| {\n        b.to_async(&rt).iter(|| async {\n            let config_json = json!({\n                \"manual_call_templates\": [{\n                    \"call_template_type\": \"mcp\",\n                    \"name\": \"mcp_test\",\n                    \"command\": \"python3\",\n                    \"args\": [\"server.py\"]\n                }]\n            });\n\n            let client = create_client_from_config(black_box(config_json)).await;\n            black_box(client)\n        });\n    });\n\n    // gRPC Provider\n    group.bench_function(\"grpc\", |b| {\n        b.to_async(&rt).iter(|| async {\n            let config_json = json!({\n                \"manual_call_templates\": [{\n                    \"call_template_type\": \"grpc\",\n                    \"name\": \"grpc_test\",\n                    \"url\": \"http://localhost:9999\"\n                }]\n            });\n\n            let client = create_client_from_config(black_box(config_json)).await;\n            black_box(client)\n        });\n    });\n\n    // SSE Provider\n    group.bench_function(\"sse\", |b| {\n        b.to_async(&rt).iter(|| async {\n            let config_json = json!({\n                \"manual_call_templates\": [{\n                    \"call_template_type\": \"sse\",\n                    \"name\": \"sse_test\",\n                    \"url\": \"http://localhost:9999/events\"\n                }]\n            });\n\n            let client = create_client_from_config(black_box(config_json)).await;\n            black_box(client)\n        });\n    });\n\n    group.finish();\n}\n\n/// Benchmark loading multiple providers at once\nfn bench_multi_provider_loading(c: &mut Criterion) {\n    let rt = Runtime::new().unwrap();\n\n    c.bench_function(\"load_6_providers\", |b| {\n        b.to_async(&rt).iter(|| async {\n            let config_json = json!({\n                \"manual_call_templates\": [\n                    {\n                        \"call_template_type\": \"http\",\n                        \"name\": \"http_provider\",\n                        \"url\": \"http://localhost:8001/tools\"\n                    },\n                    {\n                        \"call_template_type\": \"cli\",\n                        \"name\": \"cli_provider\",\n                        \"command\": \"echo\"\n                    },\n                    {\n                        \"call_template_type\": \"websocket\",\n                        \"name\": \"ws_provider\",\n                        \"url\": \"ws://localhost:8002\"\n                    },\n                    {\n                        \"call_template_type\": \"mcp\",\n                        \"name\": \"mcp_provider\",\n                        \"command\": \"python3\",\n                        \"args\": [\"server.py\"]\n                    },\n                    {\n                        \"call_template_type\": \"grpc\",\n                        \"name\": \"grpc_provider\",\n                        \"url\": \"http://localhost:8003\"\n                    },\n                    {\n                        \"call_template_type\": \"sse\",\n                        \"name\": \"sse_provider\",\n                        \"url\": \"http://localhost:8004/events\"\n                    }\n                ]\n            });\n\n            let client = create_client_from_config(black_box(config_json)).await;\n            black_box(client)\n        });\n    });\n}\n\ncriterion_group!(\n    benches,\n    bench_cli_tool_call,\n    bench_provider_comparison,\n    bench_multi_provider_loading,\n);\ncriterion_main!(benches);\n",
      "line_count": 225,
      "word_count": 458,
      "title": "Protocol Comparison.Rs",
      "summary": "use criterion::{black_box, criterion_group, criterion_main, Criterion}; use rs_utcp::{",
      "key_terms": [
        "grpc",
        "rt",
        "async",
        "search",
        "localhost",
        "WebSocket",
        "utility",
        "Utcp",
        "websocket",
        "only",
        "providers",
        "repo",
        "finish",
        "multiple",
        "InMemoryToolRepository",
        "path",
        "let",
        "sse",
        "CLI",
        "object"
      ],
      "timestamp": "2025-12-24T18:56:13.151450"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\benches\\README.md",
      "content_type": "documentation",
      "content": "# Performance Benchmarks\n\nThis directory contains comprehensive performance benchmarks for the `rs-utcp` library using [Criterion.rs](https://github.com/bheisler/criterion.rs).\n\n## Benchmark Suites\n\n### 1. Tool Operations (`tool_operations.rs`)\n\nMeasures core UTCP client operations:\n\n- **Tool Registration**: Performance with varying numbers of tools (10, 50, 100, 500)\n- **Tool Search**: Search performance across different repository sizes\n- **Client Initialization**: Overhead of creating a new client\n- **Tool Call Overhead**: Impact of different argument counts\n- **Tag Matching**: Performance of the tag-based search algorithm\n\n### 2. Protocol Comparison (`protocol_comparison.rs`)\n\nCompares different communication protocol implementations:\n\n- **Provider Registration**: Overhead for HTTP, CLI, WebSocket, MCP protocols\n- **Serialization**: JSON serialization performance for different provider types\n- **CLI Tool Calls**: Actual execution performance for CLI-based tools\n\n### 3. Codemode Execution (`codemode_execution.rs`)\n\nBenchmarks the Rhai script execution engine:\n\n- **Script Complexity**: Simple arithmetic, loops, arrays, maps\n- **Script Size**: Performance with varying script lengths (10-200 lines)\n- **String Operations**: String concatenation and manipulation\n- **Function Calls**: Recursive function execution (e.g., Fibonacci)\n\n## Running Benchmarks\n\n### Run All Benchmarks\n\n```bash\ncargo bench\n```\n\n### Run Specific Benchmark Suite\n\n```bash\n# Tool operations only\ncargo bench --bench tool_operations\n\n# Protocol comparison only\ncargo bench --bench protocol_comparison\n\n# Codemode execution only\ncargo bench --bench codemode_execution\n```\n\n### Run Specific Benchmark\n\n```bash\n# Run only tool registration benchmarks\ncargo bench --bench tool_operations tool_registration\n\n# Run only search benchmarks with 100 tools\ncargo bench --bench tool_operations \"tool_search/100\"\n```\n\n### Generate Flamegraphs (Optional)\n\nInstall cargo-flamegraph:\n```bash\ncargo install flamegraph\n```\n\nRun with flamegraph:\n```bash\ncargo bench --bench tool_operations -- --profile-time=5\n```\n\n## Interpreting Results\n\nCriterion generates HTML reports in `target/criterion/`. Open `target/criterion/report/index.html` in your browser to view:\n\n- **Throughput**: Operations per second\n- **Latency**: Time per operation (mean, median, std dev)\n- **Comparison**: Performance changes between runs\n- **Violin Plots**: Distribution of measurements\n- **Regression**: Historical performance tracking\n\n### Example Output\n\n```\ntool_registration/10    time:   [125.43 ¬µs 127.89 ¬µs 130.67 ¬µs]\ntool_registration/50    time:   [623.21 ¬µs 631.45 ¬µs 640.89 ¬µs]\ntool_registration/100   time:   [1.2534 ms 1.2689 ms 1.2851 ms]\ntool_registration/500   time:   [6.3421 ms 6.4123 ms 6.4891 ms]\n```\n\n## Performance Baselines\n\nExpected performance on a modern system (Apple M1/M2 or equivalent):\n\n| Operation | Size | Expected Time |\n|-----------|------|---------------|\n| Tool Registration | 100 tools | ~1-2 ms |\n| Tool Search | 100 tools | ~50-100 ¬µs |\n| Client Init | Empty | ~100-200 ¬µs |\n| Simple Script | 10 lines | ~50-100 ¬µs |\n| CLI Tool Call | Echo | ~2-5 ms |\n\n## CI Integration\n\nBenchmarks can be run in CI to detect performance regressions:\n\n```yaml\n- name: Run benchmarks\n  run: cargo bench --no-fail-fast\n  \n- name: Upload benchmark results\n  uses: actions/upload-artifact@v4\n  with:\n    name: benchmark-results\n    path: target/criterion\n```\n\n## Optimizing Performance\n\nIf you find slow performance:\n\n1. **Tool Registration**: Consider batching tool registrations\n2. **Search**: Use more specific tags to reduce search space\n3. **Codemode**: Keep scripts small and avoid deep recursion\n4. **Protocols**: Choose the right protocol for your use case:\n   - **CLI**: Fast for local tools\n   - **HTTP**: Good for REST APIs\n   - **gRPC**: Best for high-throughput RPC\n   - **MCP**: Ideal for stdio-based tools\n\n## Adding New Benchmarks\n\nTo add a new benchmark:\n\n1. Create a new file in `benches/` or add to an existing one\n2. Use the Criterion API:\n\n```rust\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\n\nfn my_benchmark(c: &mut Criterion) {\n    c.bench_function(\"my_operation\", |b| {\n        b.iter(|| {\n            // Your code to benchmark\n            black_box(expensive_operation())\n        });\n    });\n}\n\ncriterion_group!(benches, my_benchmark);\ncriterion_main!(benches);\n```\n\n3. Add to `Cargo.toml`:\n\n```toml\n[[bench]]\nname = \"my_benchmark\"\nharness = false\n```\n\n## Resources\n\n- [Criterion.rs Documentation](https://bheisler.github.io/criterion.rs/book/)\n- [Rust Performance Book](https://nnethercote.github.io/perf-book/)\n- [Benchmarking Best Practices](https://easyperf.net/blog/)\n",
      "line_count": 172,
      "word_count": 594,
      "title": "Performance Benchmarks",
      "summary": "This directory contains comprehensive performance benchmarks for the `rs-utcp` library using [Criterion.rs](https://github.com/bheisler/criterion.rs). Measures core UTCP client operations:",
      "key_terms": [
        "Operations",
        "implementations",
        "comprehensive",
        "upload-artifact",
        "Historical",
        "Matching",
        "loops",
        "Plots",
        "search",
        "yaml",
        "If",
        "based",
        "WebSocket",
        "index",
        "uses",
        "high",
        "batching",
        "only",
        "small",
        "Serialization"
      ],
      "timestamp": "2025-12-24T18:56:13.183349"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\benches\\tool_operations.rs",
      "content_type": "code",
      "content": "use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion};\nuse rs_utcp::{\n    config::UtcpClientConfig, repository::in_memory::InMemoryToolRepository,\n    tag::tag_search::TagSearchStrategy, UtcpClient, UtcpClientInterface,\n};\nuse serde_json::json;\nuse std::fs;\nuse std::{collections::HashMap, sync::Arc};\nuse tempfile::NamedTempFile;\nuse tokio::runtime::Runtime;\n\n/// Helper function to create a client with tools from config\nasync fn create_client_with_tools(tool_count: usize) -> Arc<UtcpClient> {\n    let mut tools = vec![];\n    for i in 0..tool_count {\n        tools.push(json!({\n            \"name\": format!(\"tool_{}\", i),\n            \"description\": format!(\"Description for tool {}\", i),\n            \"inputs\": {\"type\": \"object\"},\n            \"outputs\": {\"type\": \"object\"},\n            \"tags\": [\n                format!(\"category_{}\", i % 5),\n                format!(\"type_{}\", i % 3),\n                \"common\"\n            ]\n        }));\n    }\n\n    let config_content = json!({\n        \"manual_call_templates\": [{\n            \"call_template_type\": \"cli\",\n            \"name\": \"test_provider\",\n            \"command\": \"echo\",\n            \"tools\": tools\n        }]\n    });\n\n    let temp_file = NamedTempFile::new().unwrap();\n    fs::write(\n        temp_file.path(),\n        serde_json::to_vec(&config_content).unwrap(),\n    )\n    .unwrap();\n\n    let config = UtcpClientConfig::new().with_providers_file(temp_file.path().to_path_buf());\n    let repo = Arc::new(InMemoryToolRepository::new());\n    let search = Arc::new(TagSearchStrategy::new(repo.clone(), 1.0));\n\n    Arc::new(UtcpClient::new(config, repo, search).await.unwrap())\n}\n\n/// Benchmark tool search performance with different repository sizes\nfn bench_tool_search(c: &mut Criterion) {\n    let rt = Runtime::new().unwrap();\n    let mut group = c.benchmark_group(\"tool_search\");\n\n    for tool_count in [10, 50, 100, 500].iter() {\n        group.bench_with_input(\n            BenchmarkId::from_parameter(tool_count),\n            tool_count,\n            |b, &count| {\n                let client = rt.block_on(create_client_with_tools(count));\n\n                b.to_async(&rt).iter(|| async {\n                    let results = client\n                        .search_tools(black_box(\"category_2\"), black_box(10))\n                        .await\n                        .unwrap();\n                    black_box(results)\n                });\n            },\n        );\n    }\n\n    group.finish();\n}\n\n/// Benchmark client initialization with different configurations\nfn bench_client_initialization(c: &mut Criterion) {\n    let rt = Runtime::new().unwrap();\n\n    c.bench_function(\"client_init_empty\", |b| {\n        b.to_async(&rt).iter(|| async {\n            let config = UtcpClientConfig::new();\n            let repo = Arc::new(InMemoryToolRepository::new());\n            let search = Arc::new(TagSearchStrategy::new(repo.clone(), 1.0));\n\n            let client = UtcpClient::create(black_box(config), black_box(repo), black_box(search))\n                .await\n                .unwrap();\n\n            black_box(client)\n        });\n    });\n}\n\n/// Benchmark tool calling with different argument sizes\nfn bench_tool_call_overhead(c: &mut Criterion) {\n    let rt = Runtime::new().unwrap();\n    let mut group = c.benchmark_group(\"tool_call_overhead\");\n\n    for arg_count in [0, 5, 10, 20].iter() {\n        group.bench_with_input(\n            BenchmarkId::from_parameter(arg_count),\n            arg_count,\n            |b, &count| {\n                let client = rt.block_on(async {\n                    let config_content = json!({\n                        \"manual_call_templates\": [{\n                            \"call_template_type\": \"cli\",\n                            \"name\": \"test_provider\",\n                            \"command\": \"echo\",\n                            \"tools\": [{\n                                \"name\": \"echo\",\n                                \"description\": \"Echo tool\",\n                                \"inputs\": {\"type\": \"object\"},\n                                \"outputs\": {\"type\": \"object\"},\n                                \"tags\": [\"test\"]\n                            }]\n                        }]\n                    });\n\n                    let temp_file = NamedTempFile::new().unwrap();\n                    fs::write(\n                        temp_file.path(),\n                        serde_json::to_vec(&config_content).unwrap(),\n                    )\n                    .unwrap();\n\n                    let config =\n                        UtcpClientConfig::new().with_providers_file(temp_file.path().to_path_buf());\n                    let repo = Arc::new(InMemoryToolRepository::new());\n                    let search = Arc::new(TagSearchStrategy::new(repo.clone(), 1.0));\n\n                    Arc::new(UtcpClient::new(config, repo, search).await.unwrap())\n                });\n\n                b.to_async(&rt).iter(|| async {\n                    let mut args = HashMap::new();\n                    for i in 0..count {\n                        args.insert(\n                            format!(\"arg_{}\", i),\n                            serde_json::json!(format!(\"value_{}\", i)),\n                        );\n                    }\n\n                    // Call the echo tool\n                    let _ = client\n                        .call_tool(black_box(\"test_provider.echo\"), black_box(args))\n                        .await;\n                });\n            },\n        );\n    }\n\n    group.finish();\n}\n\n/// Benchmark tag matching algorithm performance\nfn bench_tag_matching(c: &mut Criterion) {\n    let rt = Runtime::new().unwrap();\n    let mut group = c.benchmark_group(\"tag_matching\");\n\n    for tag_count in [2, 5, 10, 20].iter() {\n        group.bench_with_input(\n            BenchmarkId::from_parameter(tag_count),\n            tag_count,\n            |b, &count| {\n                let client = rt.block_on(async {\n                    // Create 100 tools with varying tag counts\n                    let mut tools = vec![];\n                    for i in 0..100 {\n                        let mut tags = vec![];\n                        for j in 0..count {\n                            tags.push(format!(\"tag_{}_{}\", i % 10, j));\n                        }\n\n                        tools.push(json!({\n                            \"name\": format!(\"tool_{}\", i),\n                            \"description\": format!(\"Tool {}\", i),\n                            \"inputs\": {\"type\": \"object\"},\n                            \"outputs\": {\"type\": \"object\"},\n                            \"tags\": tags\n                        }));\n                    }\n\n                    let config_content = json!({\n                        \"manual_call_templates\": [{\n                            \"call_template_type\": \"cli\",\n                            \"name\": \"test_provider\",\n                            \"command\": \"echo\",\n                            \"tools\": tools\n                        }]\n                    });\n\n                    let temp_file = NamedTempFile::new().unwrap();\n                    fs::write(\n                        temp_file.path(),\n                        serde_json::to_vec(&config_content).unwrap(),\n                    )\n                    .unwrap();\n\n                    let config =\n                        UtcpClientConfig::new().with_providers_file(temp_file.path().to_path_buf());\n                    let repo = Arc::new(InMemoryToolRepository::new());\n                    let search = Arc::new(TagSearchStrategy::new(repo.clone(), 1.0));\n\n                    Arc::new(UtcpClient::new(config, repo, search).await.unwrap())\n                });\n\n                b.to_async(&rt).iter(|| async {\n                    let results = client\n                        .search_tools(black_box(\"tag_5\"), black_box(10))\n                        .await\n                        .unwrap();\n                    black_box(results)\n                });\n            },\n        );\n    }\n\n    group.finish();\n}\n\ncriterion_group!(\n    benches,\n    bench_tool_search,\n    bench_client_initialization,\n    bench_tool_call_overhead,\n    bench_tag_matching,\n);\ncriterion_main!(benches);\n",
      "line_count": 233,
      "word_count": 525,
      "title": "Tool Operations.Rs",
      "summary": "use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion}; use rs_utcp::{",
      "key_terms": [
        "rt",
        "async",
        "search",
        "format",
        "Utcp",
        "repo",
        "finish",
        "InMemoryToolRepository",
        "path",
        "let",
        "object",
        "function",
        "description",
        "await",
        "collections",
        "echo",
        "TagSearchStrategy",
        "runtime",
        "performance",
        "Helper"
      ],
      "timestamp": "2025-12-24T18:56:13.214852"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\all_providers.rs",
      "content_type": "code",
      "content": "//! Showcase for every provider/transport. Mirrors go-utcp example set.\n//! Each section is opt-in via environment variables so you can run what you have\n//! endpoints for without the others failing.\n//!\n//! Example:\n//!   DEMO_HTTP_URL=https://httpbin.org/post \\\n//!   DEMO_WS_URL=wss://echo.websocket.events \\\n//!   cargo run --example all_providers\n\nuse anyhow::Result;\nuse rs_utcp::UtcpClientInterface;\nuse serde_json::json;\nuse std::collections::HashMap;\nuse std::path::PathBuf;\nuse tokio::time::{timeout, Duration};\n\n#[path = \"common/mod.rs\"]\nmod common;\n\nfn env(key: &str) -> Option<String> {\n    std::env::var(key).ok()\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    println!(\"Running provider demos (set DEMO_* env vars to enable a block):\");\n\n    if let Err(e) = demo_http().await {\n        eprintln!(\"HTTP demo error: {e}\");\n    }\n    if let Err(e) = demo_cli().await {\n        eprintln!(\"CLI demo error: {e}\");\n    }\n    if let Err(e) = demo_websocket().await {\n        eprintln!(\"WebSocket demo error: {e}\");\n    }\n    if let Err(e) = demo_graphql().await {\n        eprintln!(\"GraphQL demo error: {e}\");\n    }\n    if let Err(e) = demo_grpc().await {\n        eprintln!(\"gRPC demo error: {e}\");\n    }\n    if let Err(e) = demo_tcp().await {\n        eprintln!(\"TCP demo error: {e}\");\n    }\n    if let Err(e) = demo_udp().await {\n        eprintln!(\"UDP demo error: {e}\");\n    }\n    if let Err(e) = demo_sse().await {\n        eprintln!(\"SSE demo error: {e}\");\n    }\n    if let Err(e) = demo_http_stream().await {\n        eprintln!(\"HTTP stream demo error: {e}\");\n    }\n    if let Err(e) = demo_mcp().await {\n        eprintln!(\"MCP demo error: {e}\");\n    }\n    if let Err(e) = demo_text().await {\n        eprintln!(\"Text demo error: {e}\");\n    }\n    if let Err(e) = demo_webrtc().await {\n        eprintln!(\"WebRTC demo error: {e}\");\n    }\n\n    Ok(())\n}\n\nasync fn demo_http() -> Result<()> {\n    let Some(url) = env(\"DEMO_HTTP_URL\") else {\n        println!(\"  ‚ñ´Ô∏è HTTP: set DEMO_HTTP_URL to run\");\n        return Ok(());\n    };\n\n    println!(\"  ‚ñ∂Ô∏è HTTP -> {url}\");\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"http\"],\n        \"info\": {\n            \"title\": \"HTTP Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"HTTP Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"echo\",\n            \"description\": \"HTTP echo tool\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"http\",\n                \"name\": \"http_demo\",\n                \"url\": url,\n                \"http_method\": \"POST\"\n            }\n        }]\n    }))\n    .await?;\n\n    let mut args = HashMap::new();\n    args.insert(\"echo\".into(), json!(\"hello from rust-utcp\"));\n    let value = client.call_tool(\"http_demo.echo\", args).await?;\n    println!(\"    response: {value}\");\n    Ok(())\n}\n\nasync fn demo_cli() -> Result<()> {\n    let Some(cmd) = env(\"DEMO_CLI_CMD\") else {\n        println!(\"  ‚ñ´Ô∏è CLI: set DEMO_CLI_CMD (e.g., echo '{{\\\"tools\\\":[]}}') to run\");\n        return Ok(());\n    };\n    println!(\"  ‚ñ∂Ô∏è CLI -> {cmd}\");\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"cli\"],\n        \"info\": {\n            \"title\": \"CLI Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"CLI Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"echo\",\n            \"description\": \"CLI echo tool\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"cli\",\n                \"name\": \"cli_demo\",\n                \"command\": cmd\n            }\n        }]\n    }))\n    .await?;\n\n    let mut args = HashMap::new();\n    args.insert(\"msg\".into(), json!(\"hello cli\"));\n    let value = client.call_tool(\"cli_demo.echo\", args).await;\n    println!(\"    call result: {:?}\", value);\n    Ok(())\n}\n\nasync fn demo_websocket() -> Result<()> {\n    let Some(url) = env(\"DEMO_WS_URL\") else {\n        println!(\"  ‚ñ´Ô∏è WebSocket: set DEMO_WS_URL to run (e.g., wss://echo.websocket.events)\");\n        return Ok(());\n    };\n    println!(\"  ‚ñ∂Ô∏è WebSocket -> {url}\");\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"websocket\"],\n        \"info\": {\n            \"title\": \"WebSocket Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"WebSocket Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"echo\",\n            \"description\": \"WebSocket echo tool\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"websocket\",\n                \"name\": \"ws_demo\",\n                \"url\": url\n            }\n        }]\n    }))\n    .await?;\n\n    let mut args = HashMap::new();\n    args.insert(\"text\".into(), json!(\"hello websocket\"));\n    let value = client.call_tool(\"ws_demo.echo\", args).await;\n    println!(\"    call result: {:?}\", value);\n    Ok(())\n}\n\nasync fn demo_graphql() -> Result<()> {\n    let Some(url) = env(\"DEMO_GRAPHQL_URL\") else {\n        println!(\"  ‚ñ´Ô∏è GraphQL: set DEMO_GRAPHQL_URL to run\");\n        return Ok(());\n    };\n    println!(\"  ‚ñ∂Ô∏è GraphQL -> {url}\");\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"graphql\"],\n        \"info\": {\n            \"title\": \"GraphQL Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"GraphQL Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"hello\",\n            \"description\": \"GraphQL hello tool\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"graphql\",\n                \"name\": \"graphql_demo\",\n                \"url\": url\n            }\n        }]\n    }))\n    .await?;\n\n    let mut args = HashMap::new();\n    args.insert(\"name\".into(), json!(\"rust-utcp\"));\n    let value = client.call_tool(\"graphql_demo.hello\", args).await;\n    println!(\"    call result: {:?}\", value);\n    Ok(())\n}\n\nasync fn demo_grpc() -> Result<()> {\n    let (Some(host), Some(port)) = (env(\"DEMO_GRPC_HOST\"), env(\"DEMO_GRPC_PORT\")) else {\n        println!(\"  ‚ñ´Ô∏è gRPC: set DEMO_GRPC_HOST and DEMO_GRPC_PORT to run\");\n        return Ok(());\n    };\n    let port: u16 = port.parse().unwrap_or(50051);\n    println!(\"  ‚ñ∂Ô∏è gRPC -> {host}:{port}\");\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"grpc\"],\n        \"info\": {\n            \"title\": \"gRPC Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"gRPC Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"echo\",\n            \"description\": \"gRPC echo tool\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"grpc\",\n                \"name\": \"grpc_demo\",\n                \"host\": host,\n                \"port\": port\n            }\n        }]\n    }))\n    .await?;\n\n    let mut args = HashMap::new();\n    args.insert(\"echo\".into(), json!(\"hello grpc\"));\n    let value = client.call_tool(\"grpc_demo.echo\", args).await;\n    println!(\"    call result: {:?}\", value);\n    Ok(())\n}\n\nasync fn demo_tcp() -> Result<()> {\n    let Some(addr) = env(\"DEMO_TCP_ADDR\") else {\n        println!(\"  ‚ñ´Ô∏è TCP: set DEMO_TCP_ADDR (host:port) to run\");\n        return Ok(());\n    };\n    let (host, port) = split_host_port(&addr)?;\n    println!(\"  ‚ñ∂Ô∏è TCP -> {addr}\");\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"tcp\"],\n        \"info\": {\n            \"title\": \"TCP Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"TCP Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"echo\",\n            \"description\": \"TCP echo tool\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"tcp\",\n                \"name\": \"tcp_demo\",\n                \"host\": host,\n                \"port\": port\n            }\n        }]\n    }))\n    .await?;\n\n    let mut args = HashMap::new();\n    args.insert(\"ping\".into(), json!(\"pong\"));\n    let value = client.call_tool(\"tcp_demo.echo\", args).await;\n    println!(\"    call result: {:?}\", value);\n    Ok(())\n}\n\nasync fn demo_udp() -> Result<()> {\n    let Some(addr) = env(\"DEMO_UDP_ADDR\") else {\n        println!(\"  ‚ñ´Ô∏è UDP: set DEMO_UDP_ADDR (host:port) to run\");\n        return Ok(());\n    };\n    let (host, port) = split_host_port(&addr)?;\n    println!(\"  ‚ñ∂Ô∏è UDP -> {addr}\");\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"udp\"],\n        \"info\": {\n            \"title\": \"UDP Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"UDP Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"echo\",\n            \"description\": \"UDP echo tool\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"udp\",\n                \"name\": \"udp_demo\",\n                \"host\": host,\n                \"port\": port\n            }\n        }]\n    }))\n    .await?;\n\n    let mut args = HashMap::new();\n    args.insert(\"ping\".into(), json!(\"pong\"));\n    let value = client.call_tool(\"udp_demo.echo\", args).await;\n    println!(\"    call result: {:?}\", value);\n    Ok(())\n}\n\nasync fn demo_sse() -> Result<()> {\n    let Some(url) = env(\"DEMO_SSE_URL\") else {\n        println!(\"  ‚ñ´Ô∏è SSE: set DEMO_SSE_URL to run\");\n        return Ok(());\n    };\n    println!(\"  ‚ñ∂Ô∏è SSE -> {url}\");\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"sse\"],\n        \"info\": {\n            \"title\": \"SSE Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"SSE Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"stream\",\n            \"description\": \"SSE stream tool\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"sse\",\n                \"name\": \"sse_demo\",\n                \"url\": url\n            }\n        }]\n    }))\n    .await?;\n\n    let mut args = HashMap::new();\n    args.insert(\"topic\".into(), json!(\"demo\"));\n    let mut stream = client.call_tool_stream(\"sse_demo.stream\", args).await?;\n    let item = timeout(Duration::from_secs(5), stream.next()).await;\n    println!(\"    first event: {:?}\", item);\n    let _ = stream.close().await;\n    Ok(())\n}\n\nasync fn demo_http_stream() -> Result<()> {\n    let Some(url) = env(\"DEMO_HTTP_STREAM_URL\") else {\n        println!(\"  ‚ñ´Ô∏è HTTP Stream: set DEMO_HTTP_STREAM_URL to run\");\n        return Ok(());\n    };\n    println!(\"  ‚ñ∂Ô∏è HTTP Stream -> {url}\");\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"http_stream\"],\n        \"info\": {\n            \"title\": \"HTTP Stream Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"HTTP Stream Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"stream\",\n            \"description\": \"HTTP stream tool\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"http_stream\",\n                \"name\": \"http_stream_demo\",\n                \"url\": url\n            }\n        }]\n    }))\n    .await?;\n\n    let mut args = HashMap::new();\n    args.insert(\"query\".into(), json!(\"stream me\"));\n    let mut stream = client\n        .call_tool_stream(\"http_stream_demo.stream\", args)\n        .await?;\n    let item = timeout(Duration::from_secs(5), stream.next()).await;\n    println!(\"    first chunk: {:?}\", item);\n    let _ = stream.close().await;\n    Ok(())\n}\n\nasync fn demo_mcp() -> Result<()> {\n    let Some(url) = env(\"DEMO_MCP_URL\") else {\n        println!(\"  ‚ñ´Ô∏è MCP: set DEMO_MCP_URL to run\");\n        return Ok(());\n    };\n    println!(\"  ‚ñ∂Ô∏è MCP -> {url}\");\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"mcp\"],\n        \"info\": {\n            \"title\": \"MCP Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"MCP Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"echo\",\n            \"description\": \"MCP echo tool\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"mcp\",\n                \"name\": \"mcp_demo\",\n                \"url\": url\n            }\n        }]\n    }))\n    .await?;\n    let tools = client.search_tools(\"\", 10).await?;\n    println!(\"    tools: {}\", tools.len());\n\n    let mut args = HashMap::new();\n    args.insert(\"name\".into(), json!(\"echo\"));\n    let value = client.call_tool(\"mcp_demo.echo\", args).await;\n    println!(\"    call result: {:?}\", value);\n    Ok(())\n}\n\nasync fn demo_text() -> Result<()> {\n    let Some(path) = env(\"DEMO_TEXT_PATH\") else {\n        println!(\n            \"  ‚ñ´Ô∏è Text: set DEMO_TEXT_PATH to a folder containing tools.json and scripts to run\"\n        );\n        return Ok(());\n    };\n    let base_path = PathBuf::from(path);\n    println!(\"  ‚ñ∂Ô∏è Text -> {}\", base_path.display());\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"text\"],\n        \"info\": {\n            \"title\": \"Text Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"Text Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"hello\",\n            \"description\": \"Text hello tool\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"text\",\n                \"name\": \"text_demo\",\n                \"base_path\": base_path\n            }\n        }]\n    }))\n    .await?;\n    let tools = client.search_tools(\"\", 10).await?;\n    println!(\"    tools: {}\", tools.len());\n\n    let mut args = HashMap::new();\n    args.insert(\"name\".into(), json!(\"world\"));\n    let value = client.call_tool(\"text_demo.hello\", args).await;\n    println!(\"    call result: {:?}\", value);\n    Ok(())\n}\n\nasync fn demo_webrtc() -> Result<()> {\n    let Some(sig) = env(\"DEMO_WEBRTC_SIGNALING\") else {\n        println!(\"  ‚ñ´Ô∏è WebRTC: set DEMO_WEBRTC_SIGNALING to run (transport currently a stub)\");\n        return Ok(());\n    };\n    println!(\"  ‚ñ∂Ô∏è WebRTC -> {sig}\");\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"webrtc\"],\n        \"info\": {\n            \"title\": \"WebRTC Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"WebRTC Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"echo\",\n            \"description\": \"WebRTC echo tool\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"webrtc\",\n                \"name\": \"webrtc_demo\",\n                \"signaling_server\": sig\n            }\n        }]\n    }))\n    .await?;\n\n    let mut args = HashMap::new();\n    args.insert(\"message\".into(), json!(\"hello p2p\"));\n    let value = client.call_tool(\"webrtc_demo.echo\", args).await;\n    println!(\"    call result: {:?}\", value);\n    Ok(())\n}\n\nfn split_host_port(addr: &str) -> Result<(String, u16)> {\n    let mut parts = addr.split(':');\n    let host = parts.next().unwrap_or_default().to_string();\n    let port = parts\n        .next()\n        .ok_or_else(|| anyhow::anyhow!(\"Missing port in {addr}\"))?\n        .parse()?;\n    Ok((host, port))\n}\n",
      "line_count": 530,
      "word_count": 1531,
      "title": "All Providers.Rs",
      "summary": "//! Showcase for every provider/transport. Mirrors go-utcp example set. //! Each section is opt-in via environment variables so you can run what you have",
      "key_terms": [
        "close",
        "grpc",
        "Result",
        "sig",
        "async",
        "error",
        "display",
        "WebSocket",
        "info",
        "Duration",
        "Utcp",
        "websocket",
        "vars",
        "me",
        "failing",
        "version",
        "path",
        "https",
        "if",
        "let"
      ],
      "timestamp": "2025-12-24T18:56:13.262171"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\basic_usage.rs",
      "content_type": "code",
      "content": "// Example: Using rust-utcp to register and call tools\n\nuse std::{collections::HashMap, convert::Infallible, net::SocketAddr};\n\nuse hyper::service::{make_service_fn, service_fn};\nuse hyper::{Body, Method, Request, Response, Server, StatusCode};\nuse rs_utcp::UtcpClientInterface;\nuse serde_json::json;\n\n#[path = \"common/mod.rs\"]\nmod common;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    // Spin up a tiny HTTP provider that returns a weather-like manifest.\n    let addr = spawn_demo_server().await?;\n    println!(\"Started demo HTTP provider at http://{addr}/tools\");\n\n    // Load providers via create() factory method using a temp JSON file (manual v1.0 with tools).\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"http\"],\n        \"info\": {\n            \"title\": \"Basic Usage Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"Basic Usage Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"get_current_weather\",\n            \"description\": \"Return a mock weather payload\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"http\",\n                \"name\": \"weather_api\",\n                \"url\": format!(\"http://{addr}/tools\"),\n                \"http_method\": \"POST\"\n            }\n        }]\n    }))\n    .await?;\n\n    println!(\"‚úì UTCP Client initialized with all transports\");\n    println!(\"  Providers loaded from temporary config via create() factory\\n\");\n\n    // Example 1: List available tools\n    println!(\"üì° Example 1: Listing provider tools\");\n    let tools = client.search_tools(\"\", 10).await?;\n    for tool in &tools {\n        println!(\"  - {}: {}\", tool.name, tool.description);\n    }\n\n    // Example 2: Search for tools\n    println!(\"\\nüîç Example 2: Search Tools\");\n    let matching = client.search_tools(\"weather\", 5).await?;\n    println!(\"  Found {} tools matching 'weather'\", matching.len());\n\n    // Example 3: Call a tool\n    println!(\"\\n‚ö° Example 3: Call Tool\");\n    let mut args = HashMap::new();\n    args.insert(\"city\".to_string(), serde_json::json!(\"London\"));\n    args.insert(\"units\".to_string(), serde_json::json!(\"metric\"));\n    let result = client\n        .call_tool(\"weather_api.get_current_weather\", args)\n        .await?;\n    println!(\"  Result: {}\", serde_json::to_string_pretty(&result)?);\n\n    // Example 4: List available transports\n    println!(\"\\nüìã Example 4: Available Transports\");\n    let transports = client.get_transports();\n    println!(\"  {} transports available:\", transports.len());\n    for (name, _) in &transports {\n        println!(\"    - {}\", name);\n    }\n\n    println!(\"\\n‚ú® Demo complete!\");\n\n    Ok(())\n}\n\nasync fn spawn_demo_server() -> anyhow::Result<SocketAddr> {\n    let make_svc =\n        make_service_fn(|_conn| async { Ok::<_, Infallible>(service_fn(handle_request)) });\n    let server = Server::try_bind(&([127, 0, 0, 1], 0).into())?;\n    let addr = server.local_addr();\n    tokio::spawn(server.serve(make_svc));\n    Ok(addr)\n}\n\nasync fn handle_request(req: Request<Body>) -> Result<Response<Body>, Infallible> {\n    match (req.method(), req.uri().path()) {\n        (&Method::GET, \"/tools\") => {\n            let manifest = json!({\n                \"tools\": [{\n                    \"name\": \"get_current_weather\",\n                    \"description\": \"Return a mock weather payload\",\n                    \"inputs\": { \"type\": \"object\" },\n                    \"outputs\": { \"type\": \"object\" },\n                    \"tags\": [\"weather\", \"demo\"]\n                }]\n            });\n            Ok(json_response(StatusCode::OK, manifest))\n        }\n        (&Method::POST, \"/tools\") => {\n            let body_bytes = hyper::body::to_bytes(req.into_body())\n                .await\n                .unwrap_or_default();\n            let mut value: serde_json::Value =\n                serde_json::from_slice(&body_bytes).unwrap_or_else(|_| json!({}));\n            value[\"provider\"] = json!(\"weather_api\");\n            Ok(json_response(StatusCode::OK, value))\n        }\n        _ => Ok(Response::builder()\n            .status(StatusCode::NOT_FOUND)\n            .body(Body::empty())\n            .unwrap()),\n    }\n}\n\nfn json_response(status: StatusCode, body: serde_json::Value) -> Response<Body> {\n    Response::builder()\n        .status(status)\n        .header(\"content-type\", \"application/json\")\n        .body(Body::from(body.to_string()))\n        .unwrap()\n}\n",
      "line_count": 128,
      "word_count": 394,
      "title": "Basic Usage.Rs",
      "summary": "// Example: Using rust-utcp to register and call tools use std::{collections::HashMap, convert::Infallible, net::SocketAddr};",
      "key_terms": [
        "London",
        "up",
        "Result",
        "async",
        "convert",
        "Available",
        "info",
        "format",
        "Utcp",
        "available",
        "providers",
        "Found",
        "req",
        "units",
        "application",
        "using",
        "version",
        "path",
        "let",
        "that"
      ],
      "timestamp": "2025-12-24T18:56:13.295166"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\graphql_subscription.rs",
      "content_type": "code",
      "content": "// Example demonstrating GraphQL subscription support with call_tool_stream\nuse futures::{SinkExt, StreamExt};\nuse rs_utcp::UtcpClientInterface;\nuse serde_json::json;\nuse std::time::Duration;\nuse tokio::net::TcpListener;\nuse tokio::time::sleep;\nuse tokio_tungstenite::{accept_async, tungstenite::Message};\n\n#[path = \"common/mod.rs\"]\nmod common;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    // Spawn a GraphQL subscription server\n    let addr = spawn_graphql_subscription_server().await?;\n    println!(\"Started GraphQL subscription server at ws://{}\", addr);\n\n    // Give the server time to start\n    sleep(Duration::from_millis(100)).await;\n\n    // Create a UTCP client with a GraphQL subscription provider\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"graphql\"],\n        \"info\": {\n            \"title\": \"GraphQL Subscription Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"GraphQL Subscription Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"stockPriceUpdates\",\n            \"description\": \"Stream stock price updates\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"graphql\",\n                \"name\": \"stock_sub\",\n                \"url\": format!(\"http://{}\", addr),\n                \"operation_type\": \"subscription\"\n            }\n        }]\n    }))\n    .await?;\n\n    println!(\"Subscribing to stock price updates...\");\n\n    // Call the subscription tool and get a stream\n    let mut stream = client\n        .call_tool_stream(\"stock_sub.stockPriceUpdates\", Default::default())\n        .await?;\n\n    // Consume streaming results\n    let mut count = 0;\n    while let Ok(Some(value)) = stream.next().await {\n        println!(\"üìà Update #{}: {}\", count + 1, value);\n        count += 1;\n        if count >= 5 {\n            // Stop after 5 updates\n            break;\n        }\n    }\n\n    println!(\"\\n‚úÖ Received {} stock price updates\", count);\n    stream.close().await?;\n    Ok(())\n}\n\n/// Spawns a GraphQL subscription server that implements the graphql-transport-ws protocol\nasync fn spawn_graphql_subscription_server() -> anyhow::Result<std::net::SocketAddr> {\n    let listener = TcpListener::bind(\"127.0.0.1:0\").await?;\n    let addr = listener.local_addr()?;\n\n    tokio::spawn(async move {\n        loop {\n            if let Ok((stream, _)) = listener.accept().await {\n                tokio::spawn(async move {\n                    if let Ok(mut ws) = accept_async(stream).await {\n                        // Handle GraphQL subscription protocol\n                        while let Some(msg) = ws.next().await {\n                            match msg {\n                                Ok(Message::Text(text)) => {\n                                    let payload: serde_json::Value =\n                                        serde_json::from_str(&text).unwrap_or_default();\n\n                                    match payload.get(\"type\").and_then(|v| v.as_str()) {\n                                        Some(\"connection_init\") => {\n                                            // Send connection_ack\n                                            let _ = ws\n                                                .send(Message::Text(\n                                                    json!({ \"type\": \"connection_ack\" }).to_string(),\n                                                ))\n                                                .await;\n                                        }\n                                        Some(\"subscribe\") => {\n                                            // Send periodic stock price updates\n                                            for i in 1..=10 {\n                                                let price = 100.0 + (i as f64 * 2.5);\n                                                let update = json!({\n                                                    \"id\": \"1\",\n                                                    \"type\": \"next\",\n                                                    \"payload\": {\n                                                        \"data\": {\n                                                            \"stockPriceUpdates\": {\n                                                                \"symbol\": \"UTCP\",\n                                                                \"price\": price,\n                                                                \"update\": i\n                                                            }\n                                                        }\n                                                    }\n                                                });\n\n                                                if ws\n                                                    .send(Message::Text(update.to_string()))\n                                                    .await\n                                                    .is_err()\n                                                {\n                                                    return;\n                                                }\n\n                                                sleep(Duration::from_secs(1)).await;\n                                            }\n\n                                            // Send complete message\n                                            let _ = ws\n                                                .send(Message::Text(\n                                                    json!({\n                                                        \"id\": \"1\",\n                                                        \"type\": \"complete\"\n                                                    })\n                                                    .to_string(),\n                                                ))\n                                                .await;\n                                            return;\n                                        }\n                                        _ => {}\n                                    }\n                                }\n                                Ok(Message::Close(_)) => return,\n                                Err(_) => return,\n                                _ => {}\n                            }\n                        }\n                    }\n                });\n            }\n        }\n    });\n\n    Ok(addr)\n}\n",
      "line_count": 153,
      "word_count": 392,
      "title": "Graphql Subscription.Rs",
      "summary": "// Example demonstrating GraphQL subscription support with call_tool_stream use futures::{SinkExt, StreamExt};",
      "key_terms": [
        "close",
        "Result",
        "futures",
        "async",
        "id",
        "info",
        "Duration",
        "format",
        "Utcp",
        "subscribe",
        "Subscription",
        "version",
        "path",
        "let",
        "if",
        "that",
        "streaming",
        "Message",
        "object",
        "price"
      ],
      "timestamp": "2025-12-24T18:56:13.319837"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\load_from_json.rs",
      "content_type": "code",
      "content": "// Example: Loading providers from JSON file\n\nuse rs_utcp::config::UtcpClientConfig;\nuse rs_utcp::repository::in_memory::InMemoryToolRepository;\nuse rs_utcp::tag::tag_search::TagSearchStrategy;\nuse rs_utcp::{UtcpClient, UtcpClientInterface};\nuse std::path::PathBuf;\nuse std::sync::Arc;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    println!(\"üöÄ Loading UTCP Client from manual with tools (providers.json)\\n\");\n\n    // Create configuration with manual file path (v1.0 format with tools)\n    let config = UtcpClientConfig::new()\n        .with_manual_path(PathBuf::from(\"examples/providers.json\"))\n        .with_variable(\"API_KEY\".to_string(), \"my-secret-api-key\".to_string());\n\n    // Create repository and search strategy\n    let repo = Arc::new(InMemoryToolRepository::new());\n    let search = Arc::new(TagSearchStrategy::new(repo.clone(), 1.0));\n\n    // Create client using v1.0 async factory method and auto-load providers from JSON\n    let client = UtcpClient::create(config, repo, search).await?;\n\n    println!(\"\\nüìã Listing all available tools:\");\n    match client.search_tools(\"\", 100).await {\n        Ok(tools) => {\n            if tools.is_empty() {\n                println!(\"  No tools found. The providers.json file may not contain valid tool definitions.\");\n            } else {\n                for tool in &tools {\n                    println!(\"  - {}\", tool.name);\n                    println!(\"    Description: {}\", tool.description);\n                    println!(\"    Tags: {:?}\", tool.tags);\n                    println!();\n                }\n            }\n        }\n        Err(e) => {\n            eprintln!(\"  Error listing tools: {}\", e);\n        }\n    }\n\n    println!(\"‚ú® Demo complete!\");\n\n    Ok(())\n}\n",
      "line_count": 49,
      "word_count": 156,
      "title": "Load From Json.Rs",
      "summary": "// Example: Loading providers from JSON file use rs_utcp::config::UtcpClientConfig;",
      "key_terms": [
        "Result",
        "contain",
        "async",
        "search",
        "format",
        "Utcp",
        "available",
        "providers",
        "repo",
        "found",
        "Error",
        "InMemoryToolRepository",
        "using",
        "path",
        "Tags",
        "let",
        "if",
        "load",
        "description",
        "definitions"
      ],
      "timestamp": "2025-12-24T18:56:13.348754"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\mcp_stdio.rs",
      "content_type": "code",
      "content": "// Example: Using MCP stdio transport\n//\n// This example demonstrates how to use the MCP transport with stdio communication.\n// It spawns an MCP server as a child process and communicates with it over stdin/stdout.\n\nuse rs_utcp::UtcpClientInterface;\nuse serde_json::json;\nuse std::collections::HashMap;\n\n#[path = \"common/mod.rs\"]\nmod common;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    println!(\"üöÄ MCP Stdio Transport Example\\n\");\n\n    // Example 1: Using MCP stdio with node (if you have an MCP server)\n    // Uncomment this if you have a real MCP server installed\n    /*\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"mcp\"],\n        \"info\": {\n            \"title\": \"MCP Stdio Demo (Node)\",\n            \"version\": \"1.0.0\",\n            \"description\": \"MCP Stdio Demo Manual (Node)\"\n        },\n        \"tools\": [{\n            \"name\": \"filesystem\",\n            \"description\": \"Filesystem tools from MCP server\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"mcp\",\n                \"name\": \"filesystem\",\n                \"command\": \"node\",\n                \"args\": [\"/path/to/mcp-server/index.js\"],\n                \"env_vars\": {\n                    \"MCP_DEBUG\": \"1\"\n                }\n            }\n        }]\n    }))\n    .await?;\n    */\n\n    // Example 2: Using the example stdio MCP server (Python)\n    // First, run: python examples/mcp_stdio_server.py\n    println!(\"üì° Creating UTCP client with MCP stdio provider\");\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"mcp\"],\n        \"info\": {\n            \"title\": \"MCP Stdio Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"MCP Stdio Demo Manual\"\n        },\n        \"tools\": [\n            {\n                \"name\": \"add\",\n                \"description\": \"Add two numbers\",\n                \"inputs\": { \"type\": \"object\" },\n                \"outputs\": { \"type\": \"object\" },\n                \"tool_call_template\": {\n                    \"call_template_type\": \"mcp\",\n                    \"name\": \"calculator\",\n                    \"command\": \"python3\",\n                    \"args\": [\"examples/mcp_stdio_server.py\"]\n                }\n            },\n            {\n                \"name\": \"multiply\",\n                \"description\": \"Multiply two numbers\",\n                \"inputs\": { \"type\": \"object\" },\n                \"outputs\": { \"type\": \"object\" },\n                \"tool_call_template\": {\n                    \"call_template_type\": \"mcp\",\n                    \"name\": \"calculator\",\n                    \"command\": \"python3\",\n                    \"args\": [\"examples/mcp_stdio_server.py\"]\n                }\n            }\n        ]\n    }))\n    .await?;\n\n    println!(\"‚úì UTCP Client initialized with MCP stdio transport\\n\");\n\n    // List available tools from the stdio MCP server\n    println!(\"üìã Listing available tools:\");\n    let tools = client.search_tools(\"\", 10).await?;\n    for tool in &tools {\n        println!(\"  ‚Ä¢ {}: {}\", tool.name, tool.description);\n    }\n\n    // Example 3: Call a tool via stdio\n    println!(\"\\n‚ö° Calling 'add' tool:\");\n    let mut args = HashMap::new();\n    args.insert(\"a\".to_string(), json!(5));\n    args.insert(\"b\".to_string(), json!(3));\n\n    let result = client.call_tool(\"calculator.add\", args).await?;\n    println!(\"  Result: {}\", serde_json::to_string_pretty(&result)?);\n\n    // Example 4: Call another tool\n    println!(\"\\n‚ö° Calling 'multiply' tool:\");\n    let mut args2 = HashMap::new();\n    args2.insert(\"a\".to_string(), json!(7));\n    args2.insert(\"b\".to_string(), json!(6));\n\n    let result2 = client.call_tool(\"calculator.multiply\", args2).await?;\n    println!(\"  Result: {}\", serde_json::to_string_pretty(&result2)?);\n\n    println!(\"\\n‚ú® Demo complete!\");\n    println!(\"\\nNote: MCP stdio transport communicates with processes via stdin/stdout\");\n    println!(\"      This is useful for local tools, sandboxed environments, and\");\n    println!(\"      language-agnostic tool providers.\");\n\n    Ok(())\n}\n",
      "line_count": 123,
      "word_count": 385,
      "title": "Mcp Stdio.Rs",
      "summary": "// Example: Using MCP stdio transport // This example demonstrates how to use the MCP transport with stdio communication.",
      "key_terms": [
        "Result",
        "Python",
        "async",
        "info",
        "filesystem",
        "index",
        "Utcp",
        "available",
        "It",
        "providers",
        "version",
        "Calling",
        "path",
        "if",
        "let",
        "calculator",
        "how",
        "object",
        "language-agnostic",
        "description"
      ],
      "timestamp": "2025-12-24T18:56:13.373134"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\mcp_stdio_server.py",
      "content_type": "code",
      "content": "#!/usr/bin/env python3\n\"\"\"\nSimple MCP (Model Context Protocol) stdio server example.\n\nThis is a minimal MCP server that communicates over stdin/stdout using JSON-RPC 2.0.\nIt implements a basic calculator with add, subtract, multiply, and divide operations.\n\"\"\"\n\nimport sys\nimport json\n\n\ndef handle_tools_list(request_id):\n    \"\"\"Return the list of available tools.\"\"\"\n    return {\n        \"jsonrpc\": \"2.0\",\n        \"id\": request_id,\n        \"result\": {\n            \"tools\": [\n                {\n                    \"name\": \"add\",\n                    \"description\": \"Add two numbers\",\n                    \"inputs\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"a\": {\"type\": \"number\", \"description\": \"First number\"},\n                            \"b\": {\"type\": \"number\", \"description\": \"Second number\"}\n                        },\n                        \"required\": [\"a\", \"b\"]\n                    },\n                    \"outputs\": {\"type\": \"number\"},\n                    \"tags\": [\"math\", \"calculator\"]\n                },\n                {\n                    \"name\": \"subtract\",\n                    \"description\": \"Subtract two numbers\",\n                    \"inputs\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"a\": {\"type\": \"number\", \"description\": \"First number\"},\n                            \"b\": {\"type\": \"number\", \"description\": \"Second number\"}\n                        },\n                        \"required\": [\"a\", \"b\"]\n                    },\n                    \"outputs\": {\"type\": \"number\"},\n                    \"tags\": [\"math\", \"calculator\"]\n                },\n                {\n                    \"name\": \"multiply\",\n                    \"description\": \"Multiply two numbers\",\n                    \"inputs\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"a\": {\"type\": \"number\", \"description\": \"First number\"},\n                            \"b\": {\"type\": \"number\", \"description\": \"Second number\"}\n                        },\n                        \"required\": [\"a\", \"b\"]\n                    },\n                    \"outputs\": {\"type\": \"number\"},\n                    \"tags\": [\"math\", \"calculator\"]\n                },\n                {\n                    \"name\": \"divide\",\n                    \"description\": \"Divide two numbers\",\n                    \"inputs\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"a\": {\"type\": \"number\", \"description\": \"Numerator\"},\n                            \"b\": {\"type\": \"number\", \"description\": \"Denominator\"}\n                        },\n                        \"required\": [\"a\", \"b\"]\n                    },\n                    \"outputs\": {\"type\": \"number\"},\n                    \"tags\": [\"math\", \"calculator\"]\n                }\n            ]\n        }\n    }\n\n\ndef handle_tools_call(request_id, params):\n    \"\"\"Execute a tool call.\"\"\"\n    tool_name = params.get(\"name\")\n    arguments = params.get(\"arguments\", {})\n    \n    try:\n        a = arguments.get(\"a\")\n        b = arguments.get(\"b\")\n        \n        if a is None or b is None:\n            return {\n                \"jsonrpc\": \"2.0\",\n                \"id\": request_id,\n                \"error\": {\n                    \"code\": -32602,\n                    \"message\": \"Missing required arguments 'a' and 'b'\"\n                }\n            }\n        \n        # Perform the calculation\n        if tool_name == \"add\":\n            result = a + b\n        elif tool_name == \"subtract\":\n            result = a - b\n        elif tool_name == \"multiply\":\n            result = a * b\n        elif tool_name == \"divide\":\n            if b == 0:\n                return {\n                    \"jsonrpc\": \"2.0\",\n                    \"id\": request_id,\n                    \"error\": {\n                        \"code\": -32000,\n                        \"message\": \"Division by zero\"\n                    }\n                }\n            result = a / b\n        else:\n            return {\n                \"jsonrpc\": \"2.0\",\n                \"id\": request_id,\n                \"error\": {\n                    \"code\": -32601,\n                    \"message\": f\"Unknown tool: {tool_name}\"\n                }\n            }\n        \n        return {\n            \"jsonrpc\": \"2.0\",\n            \"id\": request_id,\n            \"result\": {\n                \"result\": result,\n                \"tool\": tool_name,\n                \"arguments\": arguments\n            },\n            \"final\": True\n        }\n    except Exception as e:\n        return {\n            \"jsonrpc\": \"2.0\",\n            \"id\": request_id,\n            \"error\": {\n                \"code\": -32000,\n                \"message\": str(e)\n            }\n        }\n\n\ndef main():\n    \"\"\"Main event loop for the MCP server.\"\"\"\n    # Log to stderr so it doesn't interfere with JSON-RPC on stdout\n    print(\"MCP Calculator Server started\", file=sys.stderr)\n    \n    for line in sys.stdin:\n        line = line.strip()\n        if not line:\n            continue\n        \n        try:\n            request = json.loads(line)\n            method = request.get(\"method\")\n            request_id = request.get(\"id\", 1)\n            params = request.get(\"params\", {})\n            \n            # Handle different MCP methods\n            if method == \"tools/list\":\n                response = handle_tools_list(request_id)\n            elif method == \"tools/call\":\n                response = handle_tools_call(request_id, params)\n            else:\n                response = {\n                    \"jsonrpc\": \"2.0\",\n                    \"id\": request_id,\n                    \"error\": {\n                        \"code\": -32601,\n                        \"message\": f\"Method not found: {method}\"\n                    }\n                }\n            \n            # Send response to stdout\n            print(json.dumps(response), flush=True)\n            \n        except json.JSONDecodeError as e:\n            error_response = {\n                \"jsonrpc\": \"2.0\",\n                \"id\": None,\n                \"error\": {\n                    \"code\": -32700,\n                    \"message\": f\"Parse error: {e}\"\n                }\n            }\n            print(json.dumps(error_response), flush=True)\n        except Exception as e:\n            error_response = {\n                \"jsonrpc\": \"2.0\",\n                \"id\": None,\n                \"error\": {\n                    \"code\": -32603,\n                    \"message\": f\"Internal error: {e}\"\n                }\n            }\n            print(json.dumps(error_response), flush=True)\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "line_count": 207,
      "word_count": 518,
      "title": "Mcp Stdio Server.Py",
      "summary": "Simple MCP (Model Context Protocol) stdio server example. This is a minimal MCP server that communicates over stdin/stdout using JSON-RPC 2.0.",
      "key_terms": [
        "interfere",
        "Subtract",
        "Division",
        "Model",
        "number",
        "error",
        "list",
        "id",
        "started",
        "available",
        "minimal",
        "It",
        "found",
        "Log",
        "except",
        "Return",
        "using",
        "Execute",
        "if",
        "that"
      ],
      "timestamp": "2025-12-24T18:56:13.404639"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\mcp_stream_example.rs",
      "content_type": "code",
      "content": "// Example: MCP Streaming with SSE\n//\n// This example demonstrates how to use MCP streaming capabilities\n// for both HTTP and stdio transports.\n\nuse hyper::service::{make_service_fn, service_fn};\nuse hyper::{Body, Method, Request, Response, Server, StatusCode};\nuse rs_utcp::config::UtcpClientConfig;\nuse rs_utcp::providers::mcp::McpProvider;\nuse rs_utcp::repository::in_memory::InMemoryToolRepository;\nuse rs_utcp::tag::tag_search::TagSearchStrategy;\nuse rs_utcp::{UtcpClient, UtcpClientInterface};\nuse serde_json::json;\nuse std::collections::HashMap;\nuse std::convert::Infallible;\nuse std::net::SocketAddr;\nuse std::sync::Arc;\nuse tokio::time::{sleep, Duration};\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    println!(\"üîÑ MCP Streaming Example\\n\");\n\n    // Start a local MCP server that supports SSE\n    let addr = spawn_mcp_server().await?;\n    println!(\"  ‚úì Started local MCP server at http://{}\", addr);\n\n    // Create repository and search strategy\n    let repo = Arc::new(InMemoryToolRepository::new());\n    let search = Arc::new(TagSearchStrategy::new(repo.clone(), 1.0));\n    let config = UtcpClientConfig::default();\n\n    // Create client\n    let client = UtcpClient::new(config, repo.clone(), search).await?;\n\n    // Example 1: HTTP-based MCP provider with SSE streaming\n    println!(\"\\nüì° Example 1: HTTP MCP Provider with SSE\");\n    let http_provider = Arc::new(McpProvider::new(\n        \"http_mcp\".to_string(),\n        format!(\"http://{}/mcp\", addr),\n        None,\n    ));\n\n    match client.register_tool_provider(http_provider.clone()).await {\n        Ok(tools) => {\n            println!(\n                \"  ‚úì Registered HTTP MCP provider with {} tools\",\n                tools.len()\n            );\n\n            // Try to stream results from a tool\n            if let Some(tool) = tools.first() {\n                let mut args = HashMap::new();\n                args.insert(\"query\".to_string(), serde_json::json!(\"test\"));\n\n                println!(\"  ‚Üí Streaming results from tool: {}\", tool.name);\n                match client.call_tool_stream(&tool.name, args).await {\n                    Ok(mut stream) => {\n                        while let Ok(Some(value)) = stream.next().await {\n                            println!(\"  üì¶ Received: {}\", serde_json::to_string_pretty(&value)?);\n                        }\n                        stream.close().await?;\n                    }\n                    Err(e) => println!(\"  ‚ö† Stream error: {}\", e),\n                }\n            }\n        }\n        Err(e) => println!(\"  ‚ö† Failed to register HTTP provider: {}\", e),\n    }\n\n    // Example 2: Stdio-based MCP provider with streaming\n    println!(\"\\nüìù Example 2: Stdio MCP Provider with Streaming\");\n    let stdio_provider = Arc::new(McpProvider::new_stdio(\n        \"stdio_mcp\".to_string(),\n        \"python3\".to_string(),\n        Some(vec![\"examples/mcp_stdio_server.py\".to_string()]),\n        None,\n    ));\n\n    match client.register_tool_provider(stdio_provider.clone()).await {\n        Ok(tools) => {\n            println!(\n                \"  ‚úì Registered stdio MCP provider with {} tools\",\n                tools.len()\n            );\n\n            // Try to stream results from the 'add' tool\n            let mut args = HashMap::new();\n            args.insert(\"a\".to_string(), serde_json::json!(10));\n            args.insert(\"b\".to_string(), serde_json::json!(20));\n\n            println!(\"  ‚Üí Streaming results from tool: stdio_mcp.add\");\n            match client.call_tool_stream(\"stdio_mcp.add\", args).await {\n                Ok(mut stream) => {\n                    while let Ok(Some(value)) = stream.next().await {\n                        println!(\"  üì¶ Received: {}\", serde_json::to_string_pretty(&value)?);\n                    }\n                    stream.close().await?;\n                }\n                Err(e) => println!(\"  ‚ö† Stream error: {}\", e),\n            }\n        }\n        Err(e) => println!(\"  ‚ö† Failed to register stdio provider: {}\", e),\n    }\n\n    println!(\"\\n‚ú® Demo complete!\");\n    Ok(())\n}\n\nasync fn spawn_mcp_server() -> anyhow::Result<SocketAddr> {\n    let make_svc = make_service_fn(|_conn| async { Ok::<_, Infallible>(service_fn(handle)) });\n    let server = Server::try_bind(&([127, 0, 0, 1], 0).into())?;\n    let addr = server.local_addr();\n    tokio::spawn(server.serve(make_svc));\n    Ok(addr)\n}\n\nasync fn handle(req: Request<Body>) -> Result<Response<Body>, Infallible> {\n    if req.method() != Method::POST {\n        return Ok(Response::builder()\n            .status(StatusCode::METHOD_NOT_ALLOWED)\n            .body(Body::empty())\n            .unwrap());\n    }\n\n    let accept_header = req\n        .headers()\n        .get(\"Accept\")\n        .and_then(|h| h.to_str().ok())\n        .unwrap_or(\"\");\n    let is_sse = accept_header.contains(\"text/event-stream\");\n\n    let body = hyper::body::to_bytes(req.into_body())\n        .await\n        .unwrap_or_default();\n    let payload: serde_json::Value = serde_json::from_slice(&body).unwrap_or(json!({}));\n    let method = payload.get(\"method\").and_then(|m| m.as_str()).unwrap_or(\"\");\n\n    match method {\n        \"tools/list\" => {\n            let resp = json!({\n                \"jsonrpc\": \"2.0\",\n                \"result\": { \"tools\": [{\n                    \"name\": \"stream_echo\",\n                    \"description\": \"Echo args with streaming\",\n                    \"inputs\": { \"type\": \"object\" },\n                    \"outputs\": { \"type\": \"object\" },\n                    \"tags\": [\"mcp\", \"stream\"]\n                }]},\n                \"id\": payload.get(\"id\").cloned().unwrap_or(json!(1))\n            });\n            Ok(json_response(StatusCode::OK, resp))\n        }\n        \"tools/call\" => {\n            if is_sse {\n                // Return SSE stream\n                let (mut tx, body) = Body::channel();\n\n                tokio::spawn(async move {\n                    let messages = vec![\"Hello\", \"from\", \"SSE\", \"stream!\"];\n\n                    for msg in messages {\n                        let data = json!({\n                            \"type\": \"chunk\",\n                            \"content\": msg\n                        });\n                        let event = format!(\"data: {}\\n\\n\", data.to_string());\n                        if tx.send_data(event.into()).await.is_err() {\n                            break;\n                        }\n                        sleep(Duration::from_millis(200)).await;\n                    }\n\n                    // Send final event if needed, or just close\n                    // For this demo, we'll just close the stream\n                });\n\n                Ok(Response::builder()\n                    .status(StatusCode::OK)\n                    .header(\"Content-Type\", \"text/event-stream\")\n                    .header(\"Cache-Control\", \"no-cache\")\n                    .header(\"Connection\", \"keep-alive\")\n                    .body(body)\n                    .unwrap())\n            } else {\n                let resp = json!({\n                    \"jsonrpc\": \"2.0\",\n                    \"result\": payload.get(\"params\").cloned().unwrap_or(json!({})),\n                    \"id\": payload.get(\"id\").cloned().unwrap_or(json!(1))\n                });\n                Ok(json_response(StatusCode::OK, resp))\n            }\n        }\n        _ => Ok(Response::builder()\n            .status(StatusCode::BAD_REQUEST)\n            .body(Body::empty())\n            .unwrap()),\n    }\n}\n\nfn json_response(status: StatusCode, body: serde_json::Value) -> Response<Body> {\n    Response::builder()\n        .status(status)\n        .header(\"content-type\", \"application/json\")\n        .body(Body::from(body.to_string()))\n        .unwrap()\n}\n",
      "line_count": 208,
      "word_count": 598,
      "title": "Mcp Stream Example.Rs",
      "summary": "// Example: MCP Streaming with SSE // This example demonstrates how to use MCP streaming capabilities",
      "key_terms": [
        "close",
        "we",
        "Result",
        "async",
        "search",
        "error",
        "headers",
        "convert",
        "Type",
        "based",
        "list",
        "id",
        "tx",
        "Duration",
        "format",
        "Utcp",
        "cloned",
        "providers",
        "repo",
        "req"
      ],
      "timestamp": "2025-12-24T18:56:13.452597"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\orchestrator_gemini.rs",
      "content_type": "code",
      "content": "//! End-to-end demo showing how to pair the codemode orchestrator with a Gemini model.\n//! Requires:\n//! - GEMINI_API_KEY in env (and optional GEMINI_MODEL, defaults to gemini-pro)\n//! - Network access to Google's Generative Language API\n//!\n//! Run:\n//!   GEMINI_API_KEY=your_key_here cargo run --example orchestrator_gemini -- \"Send hello via the echo tool\"\n\nuse std::{convert::Infallible, net::SocketAddr, sync::Arc};\n\nuse anyhow::{anyhow, Result};\nuse async_trait::async_trait;\nuse hyper::service::{make_service_fn, service_fn};\nuse hyper::{Body, Method, Request, Response, Server, StatusCode};\nuse reqwest::Client;\nuse rs_utcp::plugins::codemode::{CodeModeArgs, CodeModeUtcp, CodemodeOrchestrator, LlmModel};\nuse serde_json::{json, Value};\n\n#[path = \"common/mod.rs\"]\nmod common;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let prompt = std::env::args()\n        .nth(1)\n        .unwrap_or_else(|| \"Echo 'hello from orchestrator' back to me\".to_string());\n\n    // Spin up a tiny local HTTP provider with a single echo tool.\n    let addr = spawn_http_server().await?;\n    let echo_url = format!(\"http://{addr}/tools\");\n\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"http\"],\n        \"info\": {\n            \"title\": \"Orchestrator Gemini Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"HTTP Demo Manual for Gemini Orchestrator\"\n        },\n        \"tools\": [{\n            \"name\": \"echo\",\n            \"description\": \"Echo a message\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"http\",\n                \"name\": \"http_demo\",\n                \"url\": echo_url,\n                \"http_method\": \"POST\"\n            }\n        }]\n    }))\n    .await?;\n\n    let codemode = Arc::new(CodeModeUtcp::new(client));\n    let model = Arc::new(GeminiModel::from_env()?);\n    let orchestrator = CodemodeOrchestrator::new(codemode.clone(), model);\n\n    println!(\"Prompt: {prompt}\");\n    match orchestrator.call_prompt(&prompt).await? {\n        Some(value) => println!(\n            \"Orchestrator result:\\n{}\",\n            serde_json::to_string_pretty(&value)?\n        ),\n        None => println!(\"Model decided no tools were needed.\"),\n    }\n\n    // Direct codemode call for comparison\n    let snippet = r#\"call_tool(\"http_demo.echo\", #{\"message\": \"hello from codemode directly\"})\"#;\n    let direct = codemode\n        .execute(CodeModeArgs {\n            code: snippet.to_string(),\n            timeout: Some(5_000),\n        })\n        .await?;\n    println!(\n        \"Direct snippet result:\\n{}\",\n        serde_json::to_string_pretty(&direct.value)?\n    );\n\n    Ok(())\n}\n\n/// Minimal Gemini model that satisfies the LlmModel trait using the Generative Language REST API.\nstruct GeminiModel {\n    client: Client,\n    api_key: String,\n    model: String,\n    endpoint: String,\n}\n\nimpl GeminiModel {\n    fn from_env() -> Result<Self> {\n        let api_key =\n            std::env::var(\"GEMINI_API_KEY\").map_err(|_| anyhow!(\"GEMINI_API_KEY is required\"))?;\n        let model =\n            std::env::var(\"GEMINI_MODEL\").unwrap_or_else(|_| \"gemini-3-pro-preview\".to_string());\n        let endpoint = std::env::var(\"GEMINI_ENDPOINT\")\n            .unwrap_or_else(|_| \"https://generativelanguage.googleapis.com\".to_string());\n        Ok(Self {\n            client: Client::builder().build()?,\n            api_key,\n            model,\n            endpoint,\n        })\n    }\n}\n\n#[async_trait]\nimpl LlmModel for GeminiModel {\n    async fn complete(&self, prompt: &str) -> Result<Value> {\n        let url = format!(\n            \"{}/v1beta/models/{}:generateContent?key={}\",\n            self.endpoint, self.model, self.api_key\n        );\n        let body = json!({\n            \"contents\": [{\n                \"parts\": [{ \"text\": prompt }]\n            }]\n        });\n\n        let resp = self.client.post(&url).json(&body).send().await?;\n        if !resp.status().is_success() {\n            return Err(anyhow!(\n                \"Gemini request failed: {}\",\n                resp.text().await.unwrap_or_default()\n            ));\n        }\n        let value: Value = resp.json().await?;\n        if let Some(text) = value[\"candidates\"]\n            .get(0)\n            .and_then(|c| c.get(\"content\"))\n            .and_then(|c| c.get(\"parts\"))\n            .and_then(|p| p.get(0))\n            .and_then(|p| p.get(\"text\"))\n            .and_then(|t| t.as_str())\n        {\n            return Ok(Value::String(text.to_string()));\n        }\n        Ok(value)\n    }\n}\n\nasync fn spawn_http_server() -> Result<SocketAddr> {\n    let make_svc =\n        make_service_fn(|_conn| async { Ok::<_, Infallible>(service_fn(handle_request)) });\n    let server = Server::try_bind(&([127, 0, 0, 1], 0).into())?;\n    let addr = server.local_addr();\n    tokio::spawn(server.serve(make_svc));\n    Ok(addr)\n}\n\nasync fn handle_request(req: Request<Body>) -> Result<Response<Body>, Infallible> {\n    match (req.method(), req.uri().path()) {\n        (&Method::GET, \"/tools\") => {\n            let manifest = json!({\n                \"tools\": [{\n                    \"name\": \"echo\",\n                    \"description\": \"Echo a message\",\n                    \"inputs\": { \"type\": \"object\", \"properties\": { \"message\": { \"type\": \"string\" } }, \"required\": [\"message\"] },\n                    \"outputs\": { \"type\": \"object\" },\n                    \"tags\": [\"demo\", \"echo\"]\n                }]\n            });\n            Ok(json_response(StatusCode::OK, manifest))\n        }\n        (&Method::POST, \"/tools\") => {\n            let body_bytes = hyper::body::to_bytes(req.into_body())\n                .await\n                .unwrap_or_default();\n            let value: serde_json::Value =\n                serde_json::from_slice(&body_bytes).unwrap_or_else(|_| json!({}));\n            Ok(json_response(StatusCode::OK, value))\n        }\n        _ => Ok(Response::builder()\n            .status(StatusCode::NOT_FOUND)\n            .body(Body::empty())\n            .unwrap()),\n    }\n}\n\nfn json_response(status: StatusCode, body: serde_json::Value) -> Response<Body> {\n    Response::builder()\n        .status(status)\n        .header(\"content-type\", \"application/json\")\n        .body(Body::from(body.to_string()))\n        .unwrap()\n}\n",
      "line_count": 190,
      "word_count": 525,
      "title": "Orchestrator Gemini.Rs",
      "summary": "//! End-to-end demo showing how to pair the codemode orchestrator with a Gemini model. //! Requires:",
      "key_terms": [
        "build",
        "showing",
        "Result",
        "Model",
        "preview",
        "up",
        "async",
        "satisfies",
        "convert",
        "info",
        "format",
        "generativelanguage",
        "Utcp",
        "me",
        "decided",
        "generateContent",
        "pro",
        "codemode",
        "req",
        "string"
      ],
      "timestamp": "2025-12-24T18:56:13.484481"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\providers.json",
      "content_type": "configuration",
      "content": "{\n    \"manual_version\": \"1.0.0\",\n    \"utcp_version\": \"0.3.0\",\n    \"info\": {\n        \"title\": \"Example UTCP Tools Manual\",\n        \"version\": \"1.0.0\",\n        \"description\": \"Demonstration of v1.0 manual format with tools\"\n    },\n    \"allowed_communication_protocols\": [\n        \"http\",\n        \"cli\"\n    ],\n    \"tools\": [\n        {\n            \"name\": \"get_weather\",\n            \"description\": \"Get current weather for a city\",\n            \"inputs\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"city\": {\n                        \"type\": \"string\",\n                        \"description\": \"City name\"\n                    },\n                    \"units\": {\n                        \"type\": \"string\",\n                        \"enum\": [\n                            \"metric\",\n                            \"imperial\"\n                        ],\n                        \"description\": \"Temperature units\"\n                    }\n                },\n                \"required\": [\n                    \"city\"\n                ]\n            },\n            \"outputs\": {\n                \"type\": \"object\"\n            },\n            \"tool_call_template\": {\n                \"call_template_type\": \"http\",\n                \"name\": \"weather_api\",\n                \"url\": \"https://api.weather.example.com/tools\",\n                \"http_method\": \"GET\",\n                \"headers\": {\n                    \"Accept\": \"application/json\"\n                }\n            },\n            \"tags\": [\n                \"weather\",\n                \"demo\"\n            ]\n        },\n        {\n            \"name\": \"git_status\",\n            \"description\": \"Get git repository status\",\n            \"inputs\": {\n                \"type\": \"object\"\n            },\n            \"outputs\": {\n                \"type\": \"object\"\n            },\n            \"tool_call_template\": {\n                \"call_template_type\": \"cli\",\n                \"name\": \"git_tools\",\n                \"command\": \"git\",\n                \"working_dir\": \"/path/to/repo\"\n            },\n            \"tags\": [\n                \"git\",\n                \"version-control\"\n            ]\n        },\n        {\n            \"name\": \"api_call\",\n            \"description\": \"Make authenticated API call\",\n            \"inputs\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"endpoint\": {\n                        \"type\": \"string\",\n                        \"description\": \"API endpoint path\"\n                    }\n                }\n            },\n            \"outputs\": {\n                \"type\": \"object\"\n            },\n            \"tool_call_template\": {\n                \"call_template_type\": \"http\",\n                \"name\": \"api_with_auth\",\n                \"url\": \"https://api.example.com/utcp\",\n                \"http_method\": \"GET\",\n                \"auth\": {\n                    \"auth_type\": \"api_key\",\n                    \"api_key\": \"${API_KEY}\",\n                    \"var_name\": \"X-API-Key\",\n                    \"location\": \"header\"\n                }\n            },\n            \"tags\": [\n                \"api\",\n                \"authenticated\"\n            ]\n        }\n    ],\n    \"load_variables_from\": [\n        {\n            \"variable_loader_type\": \"dotenv\",\n            \"env_file_path\": \".env\"\n        }\n    ]\n}\n",
      "line_count": 114,
      "word_count": 204,
      "title": "Providers.Json",
      "summary": "\"manual_version\": \"1.0.0\", \"utcp_version\": \"0.3.0\",",
      "key_terms": [
        "Example",
        "current",
        "env",
        "headers",
        "outputs",
        "Tools",
        "city",
        "info",
        "utcp",
        "with",
        "format",
        "endpoint",
        "Accept",
        "auth",
        "enum",
        "type",
        "url",
        "metric",
        "GET",
        "method"
      ],
      "timestamp": "2025-12-24T18:56:13.521815"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\cli_program\\main.rs",
      "content_type": "code",
      "content": "use std::collections::HashMap;\nuse std::env;\n\nuse rs_utcp::{tools::Tool, UtcpClientInterface};\nuse serde_json::json;\nuse tokio::io::AsyncReadExt;\n\n#[path = \"../common/mod.rs\"]\nmod common;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    // Support being invoked as the CLI provider itself\n    if env::args().nth(1) == Some(\"--cli-mode\".to_string()) {\n        return run_cli_mode().await;\n    }\n\n    // Normal example: spawn self as CLI provider\n    let self_path = env::current_exe()?;\n    let command_name = format!(\"{} --cli-mode\", self_path.display());\n\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"cli\"],\n\n        \"info\": {\n            \"title\": \"CLI Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"CLI Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"echo\",\n            \"description\": \"CLI Echo\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"cli\",\n                \"name\": \"cli_demo\",\n                \"command_name\": command_name\n            }\n        }]\n    }))\n    .await?;\n    let tools = client.search_tools(\"\", 10).await?;\n    println!(\n        \"Tools: {:?}\",\n        tools.iter().map(|t| &t.name).collect::<Vec<_>>()\n    );\n\n    let mut args = HashMap::new();\n    args.insert(\"message\".into(), serde_json::json!(\"hello cli\"));\n    let res: serde_json::Value = client.call_tool(\"cli_demo.echo\", args).await?;\n    println!(\"Result: {}\", serde_json::to_string_pretty(&res)?);\n    Ok(())\n}\n\nasync fn run_cli_mode() -> anyhow::Result<()> {\n    let mut args = env::args().skip(2).collect::<Vec<_>>();\n    if args.is_empty() {\n        // discovery mode: print manifest\n        let tool = Tool {\n            name: \"echo\".to_string(),\n            description: \"Echo args\".to_string(),\n            inputs: rs_utcp::tools::ToolInputOutputSchema {\n                type_: \"object\".to_string(),\n                properties: None,\n                required: None,\n                description: None,\n                title: None,\n                items: None,\n                enum_: None,\n                minimum: None,\n                maximum: None,\n                format: None,\n            },\n            outputs: rs_utcp::tools::ToolInputOutputSchema {\n                type_: \"object\".to_string(),\n                properties: None,\n                required: None,\n                description: None,\n                title: None,\n                items: None,\n                enum_: None,\n                minimum: None,\n                maximum: None,\n                format: None,\n            },\n            tags: vec![\"cli\".to_string()],\n            average_response_size: None,\n            provider: None,\n        };\n        println!(\"{}\", json!({ \"tools\": [tool] }));\n        return Ok(());\n    }\n\n    // call mode: call <provider> <tool>\n    if args.len() < 2 {\n        eprintln!(\"usage: <bin> --cli-mode call <provider> <tool>\");\n        std::process::exit(1);\n    }\n    let tool_name = args.pop().unwrap();\n    let provider = args.pop().unwrap();\n    if provider.is_empty() || tool_name.is_empty() {\n        eprintln!(\"invalid call\");\n        std::process::exit(1);\n    }\n\n    // read args from stdin\n    let mut stdin_data = String::new();\n    tokio::io::stdin().read_to_string(&mut stdin_data).await?;\n    let args_json: serde_json::Value = serde_json::from_str(&stdin_data).unwrap_or(json!({}));\n\n    println!(\"{}\", args_json);\n    Ok(())\n}\n",
      "line_count": 117,
      "word_count": 288,
      "title": "Main.Rs",
      "summary": "use std::collections::HashMap; use std::env;",
      "key_terms": [
        "Result",
        "async",
        "display",
        "pop",
        "info",
        "mode",
        "format",
        "Utcp",
        "usage",
        "version",
        "path",
        "if",
        "let",
        "hello",
        "exit",
        "CLI",
        "object",
        "description",
        "being",
        "title"
      ],
      "timestamp": "2025-12-24T18:56:13.553299"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\codemode_eval\\main.rs",
      "content_type": "code",
      "content": "use std::{convert::Infallible, net::SocketAddr};\n\nuse hyper::service::{make_service_fn, service_fn};\nuse hyper::{Body, Method, Request, Response, Server, StatusCode};\nuse rs_utcp::plugins::codemode::{CodeModeArgs, CodeModeUtcp};\nuse serde_json::json;\n\n#[path = \"../common/mod.rs\"]\nmod common;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    // Spin up a tiny in-process HTTP server for the codemode demo.\n    let addr = spawn_http_server().await?;\n    let echo_url = format!(\"http://{addr}/tools\");\n\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"http\"],\n        \"info\": {\n            \"title\": \"Codemode HTTP Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"Codemode HTTP Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"echo\",\n            \"description\": \"Echo a message\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"http\",\n                \"name\": \"http_demo\",\n                \"url\": echo_url,\n                \"http_method\": \"POST\"\n            }\n        }]\n    }))\n    .await?;\n\n    // Create codemode orchestrator\n    let codemode = CodeModeUtcp::new(client.clone());\n\n    // Example 1: direct JSON snippet passthrough\n    let args = CodeModeArgs {\n        code: r#\"{\"hello\": \"world\"}\"#.to_string(),\n        timeout: Some(2_000),\n    };\n    let res = codemode.execute(args).await?;\n    println!(\n        \"JSON passthrough -> {}\",\n        serde_json::to_string_pretty(&res.value)?\n    );\n\n    // Example 2: Rust-like snippet with call_tool helper\n    let snippet = r#\"\n        let a = 2 + 3;\n        let b = call_tool(\"http_demo.echo\", #{\"message\": \"from codemode\"});\n        b // return value so we can print the echo result\n    \"#;\n\n    let res = codemode\n        .execute(CodeModeArgs {\n            code: snippet.to_string(),\n            timeout: Some(5_000),\n        })\n        .await?;\n    println!(\n        \"Snippet result -> {}\",\n        serde_json::to_string_pretty(&res.value)?\n    );\n\n    Ok(())\n}\n\nasync fn spawn_http_server() -> anyhow::Result<SocketAddr> {\n    let make_svc =\n        make_service_fn(|_conn| async { Ok::<_, Infallible>(service_fn(handle_request)) });\n    let server = Server::try_bind(&([127, 0, 0, 1], 0).into())?;\n    let addr = server.local_addr();\n    tokio::spawn(server.serve(make_svc));\n    Ok(addr)\n}\n\nasync fn handle_request(req: Request<Body>) -> Result<Response<Body>, Infallible> {\n    match (req.method(), req.uri().path()) {\n        (&Method::GET, \"/tools\") => {\n            let manifest = json!({\n                \"tools\": [{\n                    \"name\": \"echo\",\n                    \"description\": \"Echo a message\",\n                    \"inputs\": { \"type\": \"object\" },\n                    \"outputs\": { \"type\": \"object\" },\n                    \"tags\": [\"demo\", \"echo\"]\n                }]\n            });\n            Ok(json_response(StatusCode::OK, manifest))\n        }\n        (&Method::POST, \"/tools\") => {\n            let body_bytes = hyper::body::to_bytes(req.into_body())\n                .await\n                .unwrap_or_default();\n            let value: serde_json::Value =\n                serde_json::from_slice(&body_bytes).unwrap_or_else(|_| json!({}));\n            Ok(json_response(StatusCode::OK, value))\n        }\n        _ => Ok(Response::builder()\n            .status(StatusCode::NOT_FOUND)\n            .body(Body::empty())\n            .unwrap()),\n    }\n}\n\nfn json_response(status: StatusCode, body: serde_json::Value) -> Response<Body> {\n    Response::builder()\n        .status(status)\n        .header(\"content-type\", \"application/json\")\n        .body(Body::from(body.to_string()))\n        .unwrap()\n}\n",
      "line_count": 121,
      "word_count": 319,
      "title": "Main.Rs",
      "summary": "use std::{convert::Infallible, net::SocketAddr}; use hyper::service::{make_service_fn, service_fn};",
      "key_terms": [
        "we",
        "up",
        "Result",
        "async",
        "convert",
        "info",
        "format",
        "Utcp",
        "helper",
        "codemode",
        "req",
        "passthrough",
        "application",
        "Rust",
        "version",
        "path",
        "let",
        "status",
        "hello",
        "demo"
      ],
      "timestamp": "2025-12-24T18:56:13.602433"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\common\\mod.rs",
      "content_type": "code",
      "content": "use std::fs;\nuse std::sync::Arc;\n\nuse anyhow::Result;\nuse rs_utcp::config::UtcpClientConfig;\nuse rs_utcp::repository::in_memory::InMemoryToolRepository;\nuse rs_utcp::tag::tag_search::TagSearchStrategy;\nuse rs_utcp::UtcpClient;\nuse serde_json::Value;\nuse tempfile::NamedTempFile;\n\n/// Create a UTCP client by writing the provided provider JSON to a temp file and\n/// loading it through `new`.\npub async fn client_from_providers(providers: Value) -> Result<Arc<UtcpClient>> {\n    client_from_providers_with_config(providers, UtcpClientConfig::default()).await\n}\n\n/// Same as `client_from_providers`, but lets callers tweak the client config first.\npub async fn client_from_providers_with_config(\n    providers: Value,\n    config: UtcpClientConfig,\n) -> Result<Arc<UtcpClient>> {\n    let repo = Arc::new(InMemoryToolRepository::new());\n    let search = Arc::new(TagSearchStrategy::new(repo.clone(), 1.0));\n\n    let providers_file = NamedTempFile::new()?;\n    fs::write(providers_file.path(), serde_json::to_vec(&providers)?)?;\n    let config = config.with_providers_file(providers_file.path().to_path_buf());\n\n    let client = UtcpClient::new(config, repo, search).await?;\n    Ok(Arc::new(client))\n}\n",
      "line_count": 33,
      "word_count": 101,
      "title": "Mod.Rs",
      "summary": "use std::fs; use std::sync::Arc;",
      "key_terms": [
        "write",
        "Result",
        "UtcpClientConfig",
        "TagSearchStrategy",
        "pub",
        "async",
        "search",
        "config",
        "through",
        "NamedTempFile",
        "as",
        "utcp",
        "file",
        "Utcp",
        "it",
        "and",
        "providers",
        "repo",
        "default",
        "UTCP"
      ],
      "timestamp": "2025-12-24T18:56:13.628853"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\graphql_server\\main.rs",
      "content_type": "code",
      "content": "use std::{convert::Infallible, net::SocketAddr};\n\nuse hyper::service::{make_service_fn, service_fn};\nuse hyper::{Body, Method, Request, Response, Server, StatusCode};\nuse rs_utcp::UtcpClientInterface;\nuse serde_json::json;\n\n#[path = \"../common/mod.rs\"]\nmod common;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    let addr = spawn_graphql_server().await?;\n    println!(\"Started GraphQL demo at http://{addr}/graphql\");\n\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"graphql\"],\n        \"info\": {\n            \"title\": \"GraphQL Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"GraphQL Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"hello\",\n            \"description\": \"GraphQL Hello\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"graphql\",\n                \"name\": \"graphql_demo\",\n                \"url\": format!(\"http://{addr}/graphql\")\n            }\n        }]\n    }))\n    .await?;\n    let tools = client.search_tools(\"\", 10).await?;\n    println!(\n        \"Tools: {:?}\",\n        tools.iter().map(|t| &t.name).collect::<Vec<_>>()\n    );\n\n    let mut args = std::collections::HashMap::new();\n    args.insert(\"name\".into(), serde_json::json!(\"rust-utcp\"));\n    let res = client.call_tool(\"graphql_demo.hello\", args).await?;\n    println!(\"Result: {}\", serde_json::to_string_pretty(&res)?);\n    Ok(())\n}\n\nasync fn spawn_graphql_server() -> anyhow::Result<SocketAddr> {\n    let make_svc = make_service_fn(|_conn| async { Ok::<_, Infallible>(service_fn(handle)) });\n    let server = Server::try_bind(&([127, 0, 0, 1], 0).into())?;\n    let addr = server.local_addr();\n    tokio::spawn(server.serve(make_svc));\n    Ok(addr)\n}\n\nasync fn handle(req: Request<Body>) -> Result<Response<Body>, Infallible> {\n    if req.method() != Method::POST || req.uri().path() != \"/graphql\" {\n        return Ok(Response::builder()\n            .status(StatusCode::NOT_FOUND)\n            .body(Body::empty())\n            .unwrap());\n    }\n\n    let body_bytes = hyper::body::to_bytes(req.into_body())\n        .await\n        .unwrap_or_default();\n    let payload: serde_json::Value = serde_json::from_slice(&body_bytes).unwrap_or_default();\n    let query = payload\n        .get(\"query\")\n        .and_then(|v| v.as_str())\n        .unwrap_or_default();\n\n    if query.contains(\"__schema\") {\n        let resp = json!({\n            \"data\": {\n                \"__schema\": {\n                    \"queryType\": { \"fields\": [ { \"name\": \"hello\", \"description\": \"Hello field\"} ] },\n                    \"mutationType\": null,\n                    \"subscriptionType\": null\n                }\n            }\n        });\n        return Ok(json_response(StatusCode::OK, resp));\n    }\n\n    let data = json!({ \"hello\": format!(\"Hello, {}\", payload.get(\"variables\").and_then(|v| v.get(\"name\")).and_then(|v| v.as_str()).unwrap_or(\"world\")) });\n    Ok(json_response(StatusCode::OK, json!({ \"data\": data })))\n}\n\nfn json_response(status: StatusCode, body: serde_json::Value) -> Response<Body> {\n    Response::builder()\n        .status(status)\n        .header(\"content-type\", \"application/json\")\n        .body(Body::from(body.to_string()))\n        .unwrap()\n}\n",
      "line_count": 100,
      "word_count": 255,
      "title": "Main.Rs",
      "summary": "use std::{convert::Infallible, net::SocketAddr}; use hyper::service::{make_service_fn, service_fn};",
      "key_terms": [
        "null",
        "Result",
        "async",
        "convert",
        "info",
        "format",
        "Utcp",
        "req",
        "application",
        "version",
        "path",
        "let",
        "if",
        "status",
        "hello",
        "demo",
        "Hello",
        "fields",
        "object",
        "hyper"
      ],
      "timestamp": "2025-12-24T18:56:13.654264"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\grpc_server\\main.rs",
      "content_type": "code",
      "content": "use std::net::SocketAddr;\n\nuse rs_utcp::{\n    grpcpb::generated::{\n        utcp_service_server::{UtcpService, UtcpServiceServer},\n        Empty, Manual, Tool as PbTool, ToolCallRequest, ToolCallResponse,\n    },\n    UtcpClientInterface,\n};\nuse tokio_stream::wrappers::TcpListenerStream;\nuse tonic::{transport::Server, Request, Response, Status};\n\n#[path = \"../common/mod.rs\"]\nmod common;\n\n#[derive(Default)]\nstruct DemoGrpc;\n\n#[tonic::async_trait]\nimpl UtcpService for DemoGrpc {\n    async fn get_manual(&self, _req: Request<Empty>) -> Result<Response<Manual>, Status> {\n        let tool = PbTool {\n            name: \"echo\".into(),\n            description: \"Echo arguments\".into(),\n        };\n        Ok(Response::new(Manual {\n            version: \"1.0\".into(),\n            tools: vec![tool],\n        }))\n    }\n\n    async fn call_tool(\n        &self,\n        req: Request<ToolCallRequest>,\n    ) -> Result<Response<ToolCallResponse>, Status> {\n        let args = req.into_inner().args_json;\n        Ok(Response::new(ToolCallResponse { result_json: args }))\n    }\n\n    type CallToolStreamStream = futures_util::stream::Empty<Result<ToolCallResponse, Status>>;\n    async fn call_tool_stream(\n        &self,\n        _request: Request<ToolCallRequest>,\n    ) -> Result<Response<Self::CallToolStreamStream>, Status> {\n        Ok(Response::new(futures_util::stream::empty()))\n    }\n}\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    let addr = spawn_grpc_server().await?;\n    println!(\"Started gRPC demo at {addr}\");\n\n    let client = common::client_from_providers(serde_json::json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"grpc\"],\n        \"info\": {\n            \"title\": \"gRPC Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"gRPC Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"echo\",\n            \"description\": \"gRPC echo tool\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"grpc\",\n                \"name\": \"grpc_demo\",\n                \"host\": \"127.0.0.1\",\n                \"port\": addr.port()\n            }\n        }]\n    }))\n    .await?;\n\n    let mut args = std::collections::HashMap::new();\n    args.insert(\"message\".into(), serde_json::json!(\"hello grpc\"));\n    let res = client.call_tool(\"grpc_demo.echo\", args).await?;\n    println!(\"Result: {}\", serde_json::to_string_pretty(&res)?);\n    Ok(())\n}\n\nasync fn spawn_grpc_server() -> anyhow::Result<SocketAddr> {\n    let listener = tokio::net::TcpListener::bind(\"127.0.0.1:0\").await?;\n    let addr = listener.local_addr()?;\n    tokio::spawn(async move {\n        Server::builder()\n            .add_service(UtcpServiceServer::new(DemoGrpc::default()))\n            .serve_with_incoming(TcpListenerStream::new(listener))\n            .await\n            .unwrap();\n    });\n    Ok(addr)\n}\n",
      "line_count": 97,
      "word_count": 219,
      "title": "Main.Rs",
      "summary": "use std::net::SocketAddr; use rs_utcp::{",
      "key_terms": [
        "grpc",
        "Result",
        "async",
        "info",
        "Utcp",
        "ToolCallRequest",
        "req",
        "Self",
        "version",
        "path",
        "let",
        "Empty",
        "hello",
        "demo",
        "struct",
        "ToolCallResponse",
        "object",
        "description",
        "title",
        "await"
      ],
      "timestamp": "2025-12-24T18:56:13.676675"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\http_server\\main.rs",
      "content_type": "code",
      "content": "use std::{convert::Infallible, net::SocketAddr};\n\nuse hyper::service::{make_service_fn, service_fn};\nuse hyper::{Body, Method, Request, Response, Server, StatusCode};\nuse rs_utcp::UtcpClientInterface;\nuse serde_json::json;\n\n#[path = \"../common/mod.rs\"]\nmod common;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    // Spin up an in-process HTTP server that serves a manifest and echoes back POST bodies.\n    let addr = spawn_demo_server().await?;\n    println!(\"Started demo HTTP server at http://{addr}/tools\");\n\n    // Build UTCP client from a manual with tools\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"http\"],\n        \"info\": {\n            \"title\": \"HTTP Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"HTTP Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"echo\",\n            \"description\": \"HTTP Echo\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"http\",\n                \"name\": \"demo\",\n                \"url\": format!(\"http://{addr}/tools\"),\n                \"http_method\": \"POST\"\n            }\n        }]\n    }))\n    .await?;\n    let tools = client.search_tools(\"\", 10).await?;\n    println!(\n        \"Registered tools: {:?}\",\n        tools.iter().map(|t| t.name.clone()).collect::<Vec<_>>()\n    );\n\n    // Call the tool\n    let mut args = std::collections::HashMap::new();\n    args.insert(\"message\".into(), serde_json::json!(\"hello from rust-utcp\"));\n    let result: serde_json::Value = client.call_tool(\"demo.echo\", args).await?;\n    println!(\"Tool result: {}\", serde_json::to_string_pretty(&result)?);\n\n    Ok(())\n}\n\nasync fn spawn_demo_server() -> anyhow::Result<SocketAddr> {\n    let make_svc =\n        make_service_fn(|_conn| async { Ok::<_, Infallible>(service_fn(handle_request)) });\n\n    let server = Server::try_bind(&([127, 0, 0, 1], 0).into())?;\n    let addr = server.local_addr();\n    tokio::spawn(server.serve(make_svc));\n    Ok(addr)\n}\n\nasync fn handle_request(req: Request<Body>) -> Result<Response<Body>, Infallible> {\n    match (req.method(), req.uri().path()) {\n        // Serve a simple UTCP manifest\n        (&Method::GET, \"/tools\") => {\n            let manifest = json!({\n                \"tools\": [{\n                    \"name\": \"echo\",\n                    \"description\": \"Echo a message\",\n                    \"inputs\": { \"type\": \"object\" },\n                    \"outputs\": { \"type\": \"object\" },\n                    \"tags\": [\"demo\", \"echo\"]\n                }]\n            });\n            Ok(json_response(StatusCode::OK, manifest))\n        }\n        // Accept tool calls and echo back the JSON args\n        (&Method::POST, \"/tools\") => {\n            let body_bytes = hyper::body::to_bytes(req.into_body())\n                .await\n                .unwrap_or_default();\n            let value: serde_json::Value =\n                serde_json::from_slice(&body_bytes).unwrap_or_else(|_| json!({}));\n            Ok(json_response(StatusCode::OK, value))\n        }\n        _ => Ok(Response::builder()\n            .status(StatusCode::NOT_FOUND)\n            .body(Body::empty())\n            .unwrap()),\n    }\n}\n\nfn json_response(status: StatusCode, body: serde_json::Value) -> Response<Body> {\n    Response::builder()\n        .status(status)\n        .header(\"content-type\", \"application/json\")\n        .body(Body::from(body.to_string()))\n        .unwrap()\n}\n",
      "line_count": 104,
      "word_count": 288,
      "title": "Main.Rs",
      "summary": "use std::{convert::Infallible, net::SocketAddr}; use hyper::service::{make_service_fn, service_fn};",
      "key_terms": [
        "up",
        "Result",
        "async",
        "convert",
        "info",
        "format",
        "Utcp",
        "echoes",
        "req",
        "application",
        "version",
        "path",
        "let",
        "that",
        "status",
        "hello",
        "demo",
        "object",
        "hyper",
        "description"
      ],
      "timestamp": "2025-12-24T18:56:13.724627"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\http_stream_server\\main.rs",
      "content_type": "code",
      "content": "use std::{convert::Infallible, net::SocketAddr, time::Duration};\n\nuse futures_util::stream::{self, StreamExt};\nuse hyper::service::{make_service_fn, service_fn};\nuse hyper::{Body, Method, Request, Response, Server, StatusCode};\nuse rs_utcp::UtcpClientInterface;\nuse serde_json::json;\n\n#[path = \"../common/mod.rs\"]\nmod common;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    let addr = spawn_stream_server().await?;\n    println!(\"Started HTTP stream demo at http://{addr}/tools\");\n\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"http_stream\"],\n        \"info\": {\n            \"title\": \"HTTP Stream Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"HTTP Stream Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"echo\",\n            \"description\": \"Stream back JSON chunks\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"http_stream\",\n                \"name\": \"http_stream_demo\",\n                \"url\": format!(\"http://{addr}/tools\")\n            }\n        }]\n    }))\n    .await?;\n\n    let mut args = std::collections::HashMap::new();\n    args.insert(\"query\".into(), serde_json::json!(\"streaming\"));\n    let mut stream = client\n        .call_tool_stream(\"http_stream_demo.echo\", args)\n        .await?;\n    while let Some(chunk) = stream.next().await? {\n        println!(\"Chunk: {}\", serde_json::to_string_pretty(&chunk)?);\n        break; // show first chunk for brevity\n    }\n    Ok(())\n}\n\nasync fn spawn_stream_server() -> anyhow::Result<SocketAddr> {\n    let make_svc = make_service_fn(|_conn| async { Ok::<_, Infallible>(service_fn(handle)) });\n    let server = Server::try_bind(&([127, 0, 0, 1], 0).into())?;\n    let addr = server.local_addr();\n    tokio::spawn(server.serve(make_svc));\n    Ok(addr)\n}\n\nasync fn handle(req: Request<Body>) -> Result<Response<Body>, Infallible> {\n    match (req.method(), req.uri().path()) {\n        (&Method::GET, \"/tools\") | (&Method::POST, \"/tools\") => {\n            let manifest = json!({\n                \"tools\": [{\n                    \"name\": \"echo\",\n                    \"description\": \"Stream back JSON chunks\",\n                    \"inputs\": { \"type\": \"object\" },\n                    \"outputs\": { \"type\": \"object\" },\n                    \"tags\": [\"http_stream\"]\n                }]\n            });\n            Ok(json_response(StatusCode::OK, manifest))\n        }\n        (&Method::POST, \"/tools/echo\") => {\n            let chunks = stream::iter(0..3).then(|i| async move {\n                tokio::time::sleep(Duration::from_millis(100)).await;\n                Ok::<_, Infallible>(json!({\"chunk\": i, \"msg\": \"hi\"}).to_string())\n            });\n            let body_stream = Body::wrap_stream(chunks);\n            Ok(Response::builder()\n                .status(StatusCode::OK)\n                .header(\"content-type\", \"application/json\")\n                .body(body_stream)\n                .unwrap())\n        }\n        _ => Ok(Response::builder()\n            .status(StatusCode::NOT_FOUND)\n            .body(Body::empty())\n            .unwrap()),\n    }\n}\n\nfn json_response(status: StatusCode, body: serde_json::Value) -> Response<Body> {\n    Response::builder()\n        .status(status)\n        .header(\"content-type\", \"application/json\")\n        .body(Body::from(body.to_string()))\n        .unwrap()\n}\n",
      "line_count": 100,
      "word_count": 263,
      "title": "Main.Rs",
      "summary": "use std::{convert::Infallible, net::SocketAddr, time::Duration}; use futures_util::stream::{self, StreamExt};",
      "key_terms": [
        "Result",
        "async",
        "convert",
        "info",
        "Duration",
        "format",
        "Utcp",
        "req",
        "application",
        "Chunk",
        "version",
        "path",
        "let",
        "status",
        "demo",
        "streaming",
        "object",
        "hyper",
        "description",
        "show"
      ],
      "timestamp": "2025-12-24T18:56:13.756628"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\mcp_server\\main.rs",
      "content_type": "code",
      "content": "use std::{convert::Infallible, net::SocketAddr};\n\nuse hyper::service::{make_service_fn, service_fn};\nuse hyper::{Body, Method, Request, Response, Server, StatusCode};\nuse rs_utcp::UtcpClientInterface;\nuse serde_json::json;\n#[path = \"../common/mod.rs\"]\nmod common;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    let addr = spawn_mcp_server().await?;\n    println!(\"Started MCP demo at http://{addr}\");\n\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"mcp\"],\n        \"info\": {\n            \"title\": \"MCP Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"MCP Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"echo\",\n            \"description\": \"Echo args via MCP\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"mcp\",\n                \"name\": \"mcp_demo\",\n                \"url\": format!(\"http://{addr}\")\n            }\n        }]\n    }))\n    .await?;\n    let tools = client.search_tools(\"\", 10).await?;\n    println!(\n        \"Tools: {:?}\",\n        tools.iter().map(|t| &t.name).collect::<Vec<_>>()\n    );\n\n    let mut args = std::collections::HashMap::new();\n    args.insert(\"name\".into(), serde_json::json!(\"world\"));\n    let res = client.call_tool(\"mcp_demo.echo\", args).await?;\n    println!(\"Result: {}\", serde_json::to_string_pretty(&res)?);\n    Ok(())\n}\n\nasync fn spawn_mcp_server() -> anyhow::Result<SocketAddr> {\n    let make_svc = make_service_fn(|_conn| async { Ok::<_, Infallible>(service_fn(handle)) });\n    let server = Server::try_bind(&([127, 0, 0, 1], 0).into())?;\n    let addr = server.local_addr();\n    tokio::spawn(server.serve(make_svc));\n    Ok(addr)\n}\n\nasync fn handle(req: Request<Body>) -> Result<Response<Body>, Infallible> {\n    if req.method() != Method::POST {\n        return Ok(Response::builder()\n            .status(StatusCode::METHOD_NOT_ALLOWED)\n            .body(Body::empty())\n            .unwrap());\n    }\n    let body = hyper::body::to_bytes(req.into_body())\n        .await\n        .unwrap_or_default();\n    let payload: serde_json::Value = serde_json::from_slice(&body).unwrap_or(json!({}));\n    let method = payload.get(\"method\").and_then(|m| m.as_str()).unwrap_or(\"\");\n\n    match method {\n        \"tools/list\" => {\n            let resp = json!({\n                \"jsonrpc\": \"2.0\",\n                \"result\": { \"tools\": [{\n                    \"name\": \"echo\",\n                    \"description\": \"Echo args\",\n                    \"inputs\": { \"type\": \"object\" },\n                    \"outputs\": { \"type\": \"object\" },\n                    \"tags\": [\"mcp\"]\n                }]},\n                \"id\": payload.get(\"id\").cloned().unwrap_or(json!(1))\n            });\n            Ok(json_response(StatusCode::OK, resp))\n        }\n        \"tools/call\" => {\n            let resp = json!({\n                \"jsonrpc\": \"2.0\",\n                \"result\": payload.get(\"params\").cloned().unwrap_or(json!({})),\n                \"id\": payload.get(\"id\").cloned().unwrap_or(json!(1))\n            });\n            Ok(json_response(StatusCode::OK, resp))\n        }\n        _ => Ok(Response::builder()\n            .status(StatusCode::BAD_REQUEST)\n            .body(Body::empty())\n            .unwrap()),\n    }\n}\n\nfn json_response(status: StatusCode, body: serde_json::Value) -> Response<Body> {\n    Response::builder()\n        .status(status)\n        .header(\"content-type\", \"application/json\")\n        .body(Body::from(body.to_string()))\n        .unwrap()\n}\n",
      "line_count": 108,
      "word_count": 264,
      "title": "Main.Rs",
      "summary": "use std::{convert::Infallible, net::SocketAddr}; use hyper::service::{make_service_fn, service_fn};",
      "key_terms": [
        "Result",
        "async",
        "convert",
        "list",
        "id",
        "info",
        "format",
        "Utcp",
        "cloned",
        "req",
        "application",
        "version",
        "path",
        "let",
        "if",
        "status",
        "demo",
        "object",
        "hyper",
        "description"
      ],
      "timestamp": "2025-12-24T18:56:13.803486"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\sse_server\\main.rs",
      "content_type": "code",
      "content": "use std::{convert::Infallible, net::SocketAddr, time::Duration};\n\nuse futures_util::stream::{self, StreamExt};\nuse hyper::service::{make_service_fn, service_fn};\nuse hyper::{Body, Method, Request, Response, Server, StatusCode};\nuse rs_utcp::UtcpClientInterface;\nuse serde_json::json;\n\n#[path = \"../common/mod.rs\"]\nmod common;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    let addr = spawn_sse_server().await?;\n    println!(\"Started SSE demo at http://{addr}/tools\");\n\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"sse\"],\n        \"info\": {\n            \"title\": \"SSE Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"SSE Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"echo\",\n            \"description\": \"Stream events\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"sse\",\n                \"name\": \"sse_demo\",\n                \"url\": format!(\"http://{addr}/tools\")\n            }\n        }]\n    }))\n    .await?;\n    let tools = client.search_tools(\"\", 10).await?;\n    println!(\n        \"Tools: {:?}\",\n        tools.iter().map(|t| &t.name).collect::<Vec<_>>()\n    );\n\n    let mut args = std::collections::HashMap::new();\n    args.insert(\"topic\".into(), serde_json::json!(\"demo\"));\n    let mut stream = client.call_tool_stream(\"sse_demo.echo\", args).await?;\n    if let Some(item) = stream.next().await? {\n        println!(\"First event: {}\", serde_json::to_string_pretty(&item)?);\n    }\n    Ok(())\n}\n\nasync fn spawn_sse_server() -> anyhow::Result<SocketAddr> {\n    let make_svc = make_service_fn(|_conn| async { Ok::<_, Infallible>(service_fn(handle)) });\n    let server = Server::try_bind(&([127, 0, 0, 1], 0).into())?;\n    let addr = server.local_addr();\n    tokio::spawn(server.serve(make_svc));\n    Ok(addr)\n}\n\nasync fn handle(req: Request<Body>) -> Result<Response<Body>, Infallible> {\n    match (req.method(), req.uri().path()) {\n        (&Method::GET, \"/tools\") => {\n            let manifest = json!({\n                \"tools\": [{\n                    \"name\": \"echo\",\n                    \"description\": \"Stream events\",\n                    \"inputs\": { \"type\": \"object\" },\n                    \"outputs\": { \"type\": \"object\" },\n                    \"tags\": [\"sse\"]\n                }]\n            });\n            Ok(json_response(StatusCode::OK, manifest))\n        }\n        (&Method::POST, \"/tools/echo\") => {\n            // Emit a few data events\n            let events = stream::iter(0..3).then(|i| async move {\n                tokio::time::sleep(Duration::from_millis(100)).await;\n                Ok::<_, Infallible>(format!(\"data: {}\\n\\n\", json!({\"idx\": i, \"msg\": \"hello\"})))\n            });\n            let body = Body::wrap_stream(events);\n            Ok(Response::builder()\n                .status(StatusCode::OK)\n                .header(\"content-type\", \"text/event-stream\")\n                .body(body)\n                .unwrap())\n        }\n        _ => Ok(Response::builder()\n            .status(StatusCode::NOT_FOUND)\n            .body(Body::empty())\n            .unwrap()),\n    }\n}\n\nfn json_response(status: StatusCode, body: serde_json::Value) -> Response<Body> {\n    Response::builder()\n        .status(status)\n        .header(\"content-type\", \"application/json\")\n        .body(Body::from(body.to_string()))\n        .unwrap()\n}\n",
      "line_count": 103,
      "word_count": 264,
      "title": "Main.Rs",
      "summary": "use std::{convert::Infallible, net::SocketAddr, time::Duration}; use futures_util::stream::{self, StreamExt};",
      "key_terms": [
        "Result",
        "async",
        "convert",
        "info",
        "Duration",
        "format",
        "Utcp",
        "idx",
        "req",
        "application",
        "version",
        "path",
        "let",
        "if",
        "sse",
        "status",
        "hello",
        "demo",
        "object",
        "event-stream"
      ],
      "timestamp": "2025-12-24T18:56:13.857789"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\tcp_server\\main.rs",
      "content_type": "code",
      "content": "use std::net::SocketAddr;\n\nuse rs_utcp::UtcpClientInterface;\nuse serde_json::Value;\nuse tokio::io::{AsyncReadExt, AsyncWriteExt};\nuse tokio::net::TcpListener;\n\n#[path = \"../common/mod.rs\"]\nmod common;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    let addr = spawn_tcp_server().await?;\n    println!(\"Started TCP demo at {addr}\");\n\n    let client = common::client_from_providers(serde_json::json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"tcp\"],\n        \"info\": {\n            \"title\": \"TCP Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"TCP Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"echo\",\n            \"description\": \"TCP Echo\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"tcp\",\n                \"name\": \"tcp_demo\",\n                \"host\": addr.ip().to_string(),\n                \"port\": addr.port()\n            }\n        }]\n    }))\n    .await?;\n\n    let mut args = std::collections::HashMap::new();\n    args.insert(\"message\".into(), serde_json::json!(\"hello tcp\"));\n    let res = client.call_tool(\"tcp_demo.echo\", args).await?;\n    println!(\"Result: {}\", serde_json::to_string_pretty(&res)?);\n    Ok(())\n}\n\nasync fn spawn_tcp_server() -> anyhow::Result<SocketAddr> {\n    let listener = TcpListener::bind(\"127.0.0.1:0\").await?;\n    let addr = listener.local_addr()?;\n    tokio::spawn(async move {\n        loop {\n            let Ok((mut socket, _)) = listener.accept().await else {\n                break;\n            };\n            tokio::spawn(async move {\n                let mut buf = Vec::new();\n                if socket.read_to_end(&mut buf).await.is_ok() {\n                    let val: Value = serde_json::from_slice(&buf).unwrap_or(Value::Null);\n                    let _ = socket.write_all(val.to_string().as_bytes()).await;\n                }\n            });\n        }\n    });\n    Ok(addr)\n}\n",
      "line_count": 66,
      "word_count": 159,
      "title": "Main.Rs",
      "summary": "use std::net::SocketAddr; use rs_utcp::UtcpClientInterface;",
      "key_terms": [
        "Result",
        "async",
        "buf",
        "info",
        "ip",
        "Utcp",
        "version",
        "path",
        "let",
        "if",
        "hello",
        "demo",
        "object",
        "description",
        "title",
        "await",
        "move",
        "collections",
        "echo",
        "Value"
      ],
      "timestamp": "2025-12-24T18:56:13.874786"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\udp_server\\main.rs",
      "content_type": "code",
      "content": "use std::net::SocketAddr;\n\nuse rs_utcp::UtcpClientInterface;\nuse serde_json::Value;\nuse tokio::net::UdpSocket;\n\n#[path = \"../common/mod.rs\"]\nmod common;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    let addr = spawn_udp_server().await?;\n    println!(\"Started UDP demo at {addr}\");\n\n    let client = common::client_from_providers(serde_json::json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"udp\"],\n        \"info\": {\n            \"title\": \"UDP Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"UDP Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"echo\",\n            \"description\": \"UDP Echo\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"udp\",\n                \"name\": \"udp_demo\",\n                \"host\": addr.ip().to_string(),\n                \"port\": addr.port()\n            }\n        }]\n    }))\n    .await?;\n\n    let mut args = std::collections::HashMap::new();\n    args.insert(\"message\".into(), serde_json::json!(\"hello udp\"));\n    let res: serde_json::Value = client.call_tool(\"udp_demo.echo\", args).await?;\n    println!(\"Result: {}\", serde_json::to_string_pretty(&res)?);\n    Ok(())\n}\n\nasync fn spawn_udp_server() -> anyhow::Result<SocketAddr> {\n    let socket = UdpSocket::bind(\"127.0.0.1:0\").await?;\n    let addr = socket.local_addr()?;\n    tokio::spawn(async move {\n        let mut buf = vec![0u8; 2048];\n        loop {\n            let Ok((len, peer)) = socket.recv_from(&mut buf).await else {\n                break;\n            };\n            let val: Value = serde_json::from_slice(&buf[..len]).unwrap_or(Value::Null);\n            let _ = socket.send_to(val.to_string().as_bytes(), peer).await;\n        }\n    });\n    Ok(addr)\n}\n",
      "line_count": 61,
      "word_count": 150,
      "title": "Main.Rs",
      "summary": "use std::net::SocketAddr; use rs_utcp::UtcpClientInterface;",
      "key_terms": [
        "common",
        "Result",
        "at",
        "async",
        "Interface",
        "outputs",
        "loop",
        "buf",
        "info",
        "ip",
        "utcp",
        "Utcp",
        "println",
        "message",
        "type",
        "vec",
        "protocol",
        "UtcpClientInterface",
        "len",
        "bind"
      ],
      "timestamp": "2025-12-24T18:56:13.904549"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\webrtc_client\\main.rs",
      "content_type": "code",
      "content": "// WebRTC Server Example\n// This server demonstrates how to implement a WebRTC-based tool provider\n// It includes a signaling server and WebRTC peer connection handling\n\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{json, Value};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\nuse webrtc::api::APIBuilder;\nuse webrtc::data_channel::data_channel_message::DataChannelMessage;\nuse webrtc::data_channel::RTCDataChannel;\nuse webrtc::ice_transport::ice_server::RTCIceServer;\nuse webrtc::peer_connection::configuration::RTCConfiguration;\nuse webrtc::peer_connection::sdp::session_description::RTCSessionDescription;\nuse webrtc::peer_connection::RTCPeerConnection;\n\n// HTTP server for signaling\nuse axum::{extract::State, http::StatusCode, response::Json, routing::post, Router};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct SignalingOffer {\n    #[serde(rename = \"type\")]\n    offer_type: String,\n    sdp: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct SignalingAnswer {\n    sdp: String,\n}\n\n#[derive(Clone)]\nstruct AppState {\n    peer_connections: Arc<Mutex<HashMap<String, Arc<RTCPeerConnection>>>>,\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    println!(\"=== WebRTC Tool Provider Server ===\\n\");\n\n    // Shared state\n    let state = AppState {\n        peer_connections: Arc::new(Mutex::new(HashMap::new())),\n    };\n\n    // Build HTTP server for signaling\n    let app = Router::new()\n        .route(\"/offer\", post(handle_offer))\n        .route(\"/health\", axum::routing::get(|| async { \"OK\" }))\n        .with_state(state);\n\n    let addr = \"127.0.0.1:8080\";\n    println!(\"üöÄ Starting signaling server on {}\", addr);\n    println!(\"üì° Clients can connect to: http://{}/offer\\n\", addr);\n\n    println!(\"‚úì Server ready!\\n\");\n    println!(\"Available tools:\");\n    println!(\"  - echo: Echoes back the input\");\n    println!(\"  - uppercase: Converts text to uppercase\");\n    println!(\"  - stream_numbers: Streams numbers from 1 to N\\n\");\n\n    let addr_socket: std::net::SocketAddr = addr.parse()?;\n    axum::Server::bind(&addr_socket)\n        .serve(app.into_make_service())\n        .await?;\n\n    Ok(())\n}\n\nasync fn handle_offer(\n    State(state): State<AppState>,\n    Json(offer): Json<SignalingOffer>,\n) -> Result<Json<SignalingAnswer>, (StatusCode, String)> {\n    println!(\"üì• Received WebRTC offer\");\n\n    match create_peer_connection_and_answer(&state, &offer.sdp).await {\n        Ok(answer_sdp) => {\n            println!(\"‚úì Created answer and established connection\\n\");\n            Ok(Json(SignalingAnswer { sdp: answer_sdp }))\n        }\n        Err(e) => {\n            eprintln!(\"‚úó Failed to create answer: {}\", e);\n            Err((\n                StatusCode::INTERNAL_SERVER_ERROR,\n                format!(\"Failed to create answer: {}\", e),\n            ))\n        }\n    }\n}\n\nasync fn create_peer_connection_and_answer(state: &AppState, offer_sdp: &str) -> Result<String> {\n    // Configure WebRTC\n    let config = RTCConfiguration {\n        ice_servers: vec![RTCIceServer {\n            urls: vec![\"stun:stun.l.google.com:19302\".to_string()],\n            ..Default::default()\n        }],\n        ..Default::default()\n    };\n\n    // Create API and peer connection\n    let api = APIBuilder::new().build();\n    let peer_connection = Arc::new(api.new_peer_connection(config).await?);\n\n    // Set up data channel handler\n    // pc_clone removed as it was unused\n    peer_connection.on_data_channel(Box::new(move |data_channel: Arc<RTCDataChannel>| {\n        println!(\"üì® Data channel opened: {}\", data_channel.label());\n        let dc = data_channel.clone();\n\n        Box::pin(async move {\n            // Handle incoming messages\n            dc.on_message(Box::new(move |msg: DataChannelMessage| {\n                let dc_clone = data_channel.clone();\n                Box::pin(async move {\n                    if let Err(e) = handle_tool_call(&dc_clone, &msg.data).await {\n                        eprintln!(\"Error handling tool call: {}\", e);\n                    }\n                })\n            }));\n        })\n    }));\n\n    // Set remote description (offer)\n    let offer = RTCSessionDescription::offer(offer_sdp.to_string())?;\n    peer_connection.set_remote_description(offer).await?;\n\n    // Create answer\n    let answer = peer_connection.create_answer(None).await?;\n    peer_connection\n        .set_local_description(answer.clone())\n        .await?;\n\n    // Store peer connection\n    let connection_id = uuid::Uuid::new_v4().to_string();\n    state\n        .peer_connections\n        .lock()\n        .await\n        .insert(connection_id, peer_connection);\n\n    Ok(answer.sdp)\n}\n\nasync fn handle_tool_call(channel: &Arc<RTCDataChannel>, data: &[u8]) -> Result<()> {\n    // Parse request\n    let request: Value = serde_json::from_slice(data)?;\n\n    println!(\"üîß Received tool call: {}\", request);\n\n    let method = request\n        .get(\"method\")\n        .and_then(|v| v.as_str())\n        .ok_or_else(|| anyhow!(\"Missing method\"))?;\n\n    let response = match method {\n        \"list_tools\" => handle_list_tools(),\n        \"call_tool\" => handle_call_tool(&request).await?,\n        \"call_tool_stream\" => {\n            handle_call_tool_stream(channel, &request).await?;\n            return Ok(()); // Streaming handled separately\n        }\n        _ => json!({\n            \"error\": format!(\"Unknown method: {}\", method)\n        }),\n    };\n\n    // Send response\n    let response_bytes = serde_json::to_vec(&response)?;\n    channel.send(&response_bytes.into()).await?;\n\n    Ok(())\n}\n\nfn handle_list_tools() -> Value {\n    json!({\n        \"tools\": [\n            {\n                \"name\": \"echo\",\n                \"description\": \"Echoes back the input text\",\n                \"inputs\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Text to echo\"\n                        }\n                    },\n                    \"required\": [\"text\"]\n                },\n                \"outputs\": {\n                    \"type\": \"object\"\n                }\n            },\n            {\n                \"name\": \"uppercase\",\n                \"description\": \"Converts text to uppercase\",\n                \"inputs\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Text to convert\"\n                        }\n                    },\n                    \"required\": [\"text\"]\n                },\n                \"outputs\": {\n                    \"type\": \"object\"\n                }\n            },\n            {\n                \"name\": \"stream_numbers\",\n                \"description\": \"Streams numbers from 1 to count\",\n                \"inputs\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"count\": {\n                            \"type\": \"integer\",\n                            \"description\": \"How many numbers to stream\"\n                        }\n                    },\n                    \"required\": [\"count\"]\n                },\n                \"outputs\": {\n                    \"type\": \"object\"\n                }\n            }\n        ]\n    })\n}\n\nasync fn handle_call_tool(request: &Value) -> Result<Value> {\n    let params = request\n        .get(\"params\")\n        .ok_or_else(|| anyhow!(\"Missing params\"))?;\n\n    let tool_name = params\n        .get(\"tool\")\n        .and_then(|v| v.as_str())\n        .ok_or_else(|| anyhow!(\"Missing tool name\"))?;\n\n    let args = params\n        .get(\"args\")\n        .and_then(|v| v.as_object())\n        .ok_or_else(|| anyhow!(\"Missing args\"))?;\n\n    println!(\"  Tool: {}\", tool_name);\n    println!(\"  Args: {}\", serde_json::to_string(args)?);\n\n    let result = match tool_name {\n        \"echo\" => {\n            let text = args.get(\"text\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            json!({ \"result\": text })\n        }\n        \"uppercase\" => {\n            let text = args.get(\"text\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            json!({ \"result\": text.to_uppercase() })\n        }\n        _ => json!({ \"error\": format!(\"Unknown tool: {}\", tool_name) }),\n    };\n\n    println!(\"  ‚úì Result: {}\\n\", result);\n    Ok(json!({ \"result\": result }))\n}\n\nasync fn handle_call_tool_stream(channel: &Arc<RTCDataChannel>, request: &Value) -> Result<()> {\n    let params = request\n        .get(\"params\")\n        .ok_or_else(|| anyhow!(\"Missing params\"))?;\n\n    let tool_name = params\n        .get(\"tool\")\n        .and_then(|v| v.as_str())\n        .ok_or_else(|| anyhow!(\"Missing tool name\"))?;\n\n    let args = params\n        .get(\"args\")\n        .and_then(|v| v.as_object())\n        .ok_or_else(|| anyhow!(\"Missing args\"))?;\n\n    println!(\"  üåä Streaming tool: {}\", tool_name);\n\n    match tool_name {\n        \"stream_numbers\" => {\n            let count = args.get(\"count\").and_then(|v| v.as_i64()).unwrap_or(5);\n\n            for i in 1..=count {\n                tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;\n                let item = json!({ \"number\": i });\n                let item_bytes = serde_json::to_vec(&item)?;\n                channel.send(&item_bytes.into()).await?;\n                println!(\"    ‚Üí Sent: {}\", i);\n            }\n            println!(\"  ‚úì Stream complete\\n\");\n        }\n        _ => {\n            let error = json!({ \"error\": format!(\"Tool {} doesn't support streaming\", tool_name) });\n            let error_bytes = serde_json::to_vec(&error)?;\n            channel.send(&error_bytes.into()).await?;\n        }\n    }\n\n    Ok(())\n}\n",
      "line_count": 308,
      "word_count": 791,
      "title": "Main.Rs",
      "summary": "// WebRTC Server Example // This server demonstrates how to implement a WebRTC-based tool provider",
      "key_terms": [
        "build",
        "up",
        "Result",
        "extract",
        "async",
        "number",
        "WebRTC-based",
        "error",
        "convert",
        "based",
        "Available",
        "Duration",
        "Clone",
        "format",
        "Json",
        "It",
        "connect",
        "string",
        "Error",
        "lock"
      ],
      "timestamp": "2025-12-24T18:56:13.932002"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\webrtc_server\\main.rs",
      "content_type": "code",
      "content": "// WebRTC Transport Example\n// This example demonstrates how to use the WebRTC transport for peer-to-peer tool calling\n\nuse anyhow::Result;\nuse rs_utcp::auth::{ApiKeyAuth, AuthConfig};\nuse rs_utcp::providers::base::{BaseProvider, ProviderType};\nuse rs_utcp::providers::webrtc::{IceServer, WebRtcProvider};\nuse rs_utcp::transports::webrtc::WebRtcTransport;\nuse rs_utcp::transports::ClientTransport;\nuse serde_json::json;\nuse std::collections::HashMap;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    println!(\"=== WebRTC Transport Example ===\\n\");\n\n    // 1. Configure ICE servers (STUN/TURN)\n    let ice_servers = vec![\n        // Public STUN server\n        IceServer {\n            urls: vec![\"stun:stun.l.google.com:19302\".to_string()],\n            username: None,\n            credential: None,\n        },\n        // Optional: Add TURN server for NAT traversal\n        // IceServer {\n        //     urls: vec![\"turn:turn.example.com:3478\".to_string()],\n        //     username: Some(\"username\".to_string()),\n        //     credential: Some(\"password\".to_string()),\n        // },\n    ];\n\n    // 2. Create WebRTC provider with signaling server\n    let provider = WebRtcProvider {\n        base: BaseProvider {\n            name: \"example-webrtc-provider\".to_string(),\n            provider_type: ProviderType::Webrtc,\n            allowed_communication_protocols: Some(vec![\"webrtc\".to_string()]),\n            // Optional: Add authentication for signaling server\n            auth: Some(AuthConfig::ApiKey(ApiKeyAuth {\n                auth_type: rs_utcp::auth::AuthType::ApiKey,\n                api_key: \"your-api-key\".to_string(),\n                var_name: \"Authorization\".to_string(),\n                location: \"header\".to_string(),\n            })),\n        },\n        // Signaling server endpoint (points to the local webrtc_server example)\n        signaling_server: \"http://127.0.0.1:8080/offer\".to_string(),\n        ice_servers,\n        channel_label: \"utcp-data\".to_string(),\n        ordered: true, // Ordered delivery\n        max_packet_life_time: None,\n        max_retransmits: None,\n    };\n\n    // 3. Create WebRTC transport\n    let transport = WebRtcTransport::new();\n    println!(\"‚úì WebRTC transport created\");\n\n    // 4. Register provider and discover available tools\n    println!(\"\\nüì° Establishing WebRTC connection and discovering tools...\");\n    match transport.register_tool_provider(&provider).await {\n        Ok(tools) => {\n            println!(\"‚úì Connection established successfully!\");\n            println!(\"‚úì Discovered {} tools:\", tools.len());\n            for tool in &tools {\n                println!(\"  - {}: {}\", tool.name, tool.description);\n            }\n\n            // 5. Call a tool (example)\n            if !tools.is_empty() {\n                let tool_name = &tools[0].name;\n                println!(\"\\nüîß Calling tool: {}\", tool_name);\n\n                let mut args = HashMap::new();\n                args.insert(\"input\".to_string(), json!(\"Hello from WebRTC!\"));\n\n                match transport.call_tool(tool_name, args, &provider).await {\n                    Ok(result) => {\n                        println!(\"‚úì Tool result: {}\", serde_json::to_string_pretty(&result)?);\n                    }\n                    Err(e) => {\n                        eprintln!(\"‚úó Tool call failed: {}\", e);\n                    }\n                }\n\n                // 6. Demonstrate streaming (if supported)\n                println!(\"\\nüåä Testing streaming capability...\");\n                let mut stream_args = HashMap::new();\n                stream_args.insert(\"count\".to_string(), json!(5));\n\n                match transport\n                    .call_tool_stream(tool_name, stream_args, &provider)\n                    .await\n                {\n                    Ok(mut stream) => {\n                        println!(\"‚úì Stream established\");\n                        loop {\n                            match stream.next().await {\n                                Ok(Some(value)) => println!(\"  ‚Ä¢ Stream item: {}\", value),\n                                Ok(None) => break,\n                                Err(e) => {\n                                    eprintln!(\"  ‚úó Stream error: {}\", e);\n                                    break;\n                                }\n                            }\n                        }\n                        println!(\"‚úì Stream completed\");\n                    }\n                    Err(e) => {\n                        eprintln!(\"‚úó Streaming failed: {}\", e);\n                    }\n                }\n            }\n\n            // 7. Clean up\n            println!(\"\\nüßπ Cleaning up connection...\");\n            transport.deregister_tool_provider(&provider).await?;\n            println!(\"‚úì Connection closed\");\n        }\n        Err(e) => {\n            eprintln!(\"‚úó Failed to establish WebRTC connection: {}\", e);\n            eprintln!(\"\\nTroubleshooting:\");\n            eprintln!(\"  1. Ensure your signaling server is running and accessible\");\n            eprintln!(\"  2. Check your ICE server configuration\");\n            eprintln!(\"  3. Verify network connectivity and firewall settings\");\n            eprintln!(\"  4. Confirm authentication credentials are correct\");\n        }\n    }\n\n    println!(\"\\n=== Example complete ===\");\n    Ok(())\n}\n\n/*\n * SIGNALING SERVER REQUIREMENTS\n *\n * Your signaling server should implement the following endpoint:\n *\n * POST /offer\n * Request:\n * {\n *   \"type\": \"offer\",\n *   \"sdp\": \"<SDP_OFFER_STRING>\"\n * }\n *\n * Response:\n * {\n *   \"sdp\": \"<SDP_ANSWER_STRING>\"\n * }\n *\n * The signaling server is responsible for:\n * 1. Accepting WebRTC offers from clients\n * 2. Forwarding offers to the peer (tool provider)\n * 3. Returning the peer's answer to the client\n *\n * Example signaling server implementations:\n * - WebSocket-based signaling\n * - HTTP REST API (as shown above)\n * - Socket.IO signaling\n *\n * TOOL PROVIDER REQUIREMENTS\n *\n * The remote peer should:\n * 1. Listen for offers via the signaling server\n * 2. Create answer and send back via signaling server\n * 3. Establish data channel with label \"utcp-data\"\n * 4. Listen for JSON messages on the data channel\n * 5. Respond with tool results as JSON\n *\n * Tool Call Message Format:\n * {\n *   \"method\": \"list_tools\" | \"call_tool\" | \"call_tool_stream\",\n *   \"params\": {\n *     \"tool\": \"tool_name\",\n *     \"args\": { ... }\n *   }\n * }\n *\n * Response Format:\n * {\n *   \"result\": { ... },\n *   \"error\": \"error message\" (optional)\n * }\n */\n",
      "line_count": 186,
      "word_count": 610,
      "title": "Main.Rs",
      "summary": "// WebRTC Transport Example // This example demonstrates how to use the WebRTC transport for peer-to-peer tool calling",
      "key_terms": [
        "implementations",
        "ClientTransport",
        "Result",
        "up",
        "async",
        "error",
        "IO",
        "based",
        "WebSocket",
        "available",
        "providers",
        "AuthConfig",
        "Confirm",
        "Calling",
        "let",
        "SIGNALING",
        "if",
        "established",
        "supported",
        "Public"
      ],
      "timestamp": "2025-12-24T18:56:13.979714"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\examples\\websocket_server\\main.rs",
      "content_type": "code",
      "content": "use std::net::SocketAddr;\n\nuse futures_util::{SinkExt, StreamExt};\nuse rs_utcp::UtcpClientInterface;\nuse serde_json::json;\nuse tokio::net::TcpListener;\nuse tokio_tungstenite::{accept_async, tungstenite::protocol::Message};\n\n#[path = \"../common/mod.rs\"]\nmod common;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    let addr = spawn_ws_server().await?;\n    println!(\"Started WS demo at ws://{addr}/tools\");\n\n    let client = common::client_from_providers(json!({\n        \"manual_version\": \"1.0.0\",\n        \"utcp_version\": \"0.3.0\",\n        \"allowed_communication_protocols\": [\"websocket\"],\n        \"info\": {\n            \"title\": \"WebSocket Demo\",\n            \"version\": \"1.0.0\",\n            \"description\": \"WebSocket Demo Manual\"\n        },\n        \"tools\": [{\n            \"name\": \"echo\",\n            \"description\": \"Echo a message\",\n            \"inputs\": { \"type\": \"object\" },\n            \"outputs\": { \"type\": \"object\" },\n            \"tool_call_template\": {\n                \"call_template_type\": \"websocket\",\n                \"name\": \"ws_demo\",\n                \"url\": format!(\"ws://{addr}/tools\")\n            }\n        }]\n    }))\n    .await?;\n    let tools = client.search_tools(\"\", 10).await?;\n    println!(\n        \"Tools: {:?}\",\n        tools.iter().map(|t| &t.name).collect::<Vec<_>>()\n    );\n\n    let mut args = std::collections::HashMap::new();\n    args.insert(\"message\".into(), serde_json::json!(\"hello ws\"));\n    let res = client.call_tool(\"ws_demo.echo\", args).await?;\n    println!(\"Result: {}\", serde_json::to_string_pretty(&res)?);\n    Ok(())\n}\n\nasync fn spawn_ws_server() -> anyhow::Result<SocketAddr> {\n    let listener = TcpListener::bind(\"127.0.0.1:0\").await?;\n    let addr = listener.local_addr()?;\n    tokio::spawn(async move {\n        while let Ok((stream, _)) = listener.accept().await {\n            tokio::spawn(async move {\n                let mut ws = accept_async(stream).await.expect(\"ws accept\");\n                while let Some(msg) = ws.next().await {\n                    match msg {\n                        Ok(Message::Text(text)) if text == \"manual\" => {\n                            let manifest = json!({\n                                \"tools\": [{\n                                    \"name\": \"echo\",\n                                    \"description\": \"Echo a message\",\n                                    \"inputs\": {\"type\": \"object\"},\n                                    \"outputs\": {\"type\": \"object\"},\n                                    \"tags\": [\"ws\"]\n                                }]\n                            });\n                            let _ = ws.send(Message::Text(manifest.to_string())).await;\n                        }\n                        Ok(Message::Text(text)) => {\n                            // Echo back parsed JSON\n                            let val: serde_json::Value =\n                                serde_json::from_str(&text).unwrap_or(json!({}));\n                            let _ = ws.send(Message::Text(val.to_string())).await;\n                            break;\n                        }\n                        Ok(Message::Close(_)) | Err(_) => break,\n                        _ => {}\n                    }\n                }\n            });\n        }\n    });\n    Ok(addr)\n}\n",
      "line_count": 89,
      "word_count": 226,
      "title": "Main.Rs",
      "summary": "use std::net::SocketAddr; use futures_util::{SinkExt, StreamExt};",
      "key_terms": [
        "Result",
        "async",
        "WebSocket",
        "info",
        "format",
        "Utcp",
        "websocket",
        "version",
        "path",
        "let",
        "if",
        "hello",
        "demo",
        "Message",
        "object",
        "description",
        "title",
        "await",
        "move",
        "ws"
      ],
      "timestamp": "2025-12-24T18:56:14.011771"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\allowed_protocols_tests.rs",
      "content_type": "code",
      "content": "use crate::config::UtcpClientConfig;\nuse crate::loader::load_providers_with_tools_from_file;\nuse crate::providers::base::{BaseProvider, Provider, ProviderType};\nuse crate::repository::in_memory::InMemoryToolRepository;\nuse crate::tools::{Tool, ToolInputOutputSchema, ToolSearchStrategy};\nuse crate::{UtcpClient, UtcpClientInterface};\nuse anyhow::Result;\nuse async_trait::async_trait;\nuse std::io::Write;\nuse std::sync::Arc;\nuse tempfile::NamedTempFile;\n\nstruct MockSearchStrategy;\n\n#[async_trait]\nimpl ToolSearchStrategy for MockSearchStrategy {\n    async fn search_tools(&self, _query: &str, _limit: usize) -> Result<Vec<Tool>> {\n        Ok(vec![])\n    }\n}\n\n#[tokio::test]\nasync fn test_manual_default_protocol_restriction() {\n    // Manual without allowed_communication_protocols should only register tools matching the tool's own protocol\n    let mut file = NamedTempFile::new().unwrap();\n    write!(\n        file,\n        r#\"{{\n            \"manual_version\": \"1.0.0\",\n            \"utcp_version\": \"0.2.0\",\n            \"info\": {{ \"title\": \"Test Manual\", \"version\": \"1.0.0\" }},\n            \"tools\": [\n                {{\n                    \"name\": \"http_tool\",\n                    \"description\": \"HTTP tool\",\n                    \"inputs\": {{ \"type\": \"object\" }},\n                    \"outputs\": {{ \"type\": \"object\" }},\n                    \"tool_call_template\": {{\n                        \"call_template_type\": \"http\",\n                        \"name\": \"http_provider\",\n                        \"url\": \"http://example.com\",\n                        \"http_method\": \"GET\"\n                    }}\n                }}\n            ]\n        }}\"#\n    )\n    .unwrap();\n\n    let config = UtcpClientConfig::default();\n    let loaded = load_providers_with_tools_from_file(file.path(), &config)\n        .await\n        .unwrap();\n\n    // Should register the HTTP tool since it matches its own protocol\n    assert_eq!(loaded.len(), 1);\n    assert!(loaded[0].tools.is_some());\n    assert_eq!(loaded[0].tools.as_ref().unwrap().len(), 1);\n\n    // Verify provider has default allowed protocols (only http)\n    let allowed = loaded[0].provider.allowed_protocols();\n    assert_eq!(allowed, vec![\"http\".to_string()]);\n}\n\n#[tokio::test]\nasync fn test_manual_explicit_multi_protocol_allowlist() {\n    // Manual with allowed_communication_protocols should register tools matching allowed protocols\n    let mut file = NamedTempFile::new().unwrap();\n    write!(\n        file,\n        r#\"{{\n            \"manual_version\": \"1.0.0\",\n            \"utcp_version\": \"0.2.0\",\n            \"info\": {{ \"title\": \"Multi Protocol Manual\", \"version\": \"1.0.0\" }},\n            \"allowed_communication_protocols\": [\"http\", \"cli\"],\n            \"tools\": [\n                {{\n                    \"name\": \"http_tool\",\n                    \"description\": \"HTTP tool\",\n                    \"inputs\": {{ \"type\": \"object\" }},\n                    \"outputs\": {{ \"type\": \"object\" }},\n                    \"tool_call_template\": {{\n                        \"call_template_type\": \"http\",\n                        \"name\": \"http_provider\",\n                        \"url\": \"http://example.com\",\n                        \"http_method\": \"GET\"\n                    }}\n                }},\n                {{\n                    \"name\": \"cli_tool\",\n                    \"description\": \"CLI tool\",\n                    \"inputs\": {{ \"type\": \"object\" }},\n                    \"outputs\": {{ \"type\": \"object\" }},\n                    \"tool_call_template\": {{\n                        \"call_template_type\": \"cli\",\n                        \"name\": \"cli_provider\",\n                        \"command\": \"echo hello\"\n                    }}\n                }}\n            ]\n        }}\"#\n    )\n    .unwrap();\n\n    let config = UtcpClientConfig::default();\n    let loaded = load_providers_with_tools_from_file(file.path(), &config)\n        .await\n        .unwrap();\n\n    // Should register both HTTP and CLI tools\n    assert_eq!(loaded.len(), 2);\n\n    // Verify both providers were created with correct types\n    let types: Vec<_> = loaded.iter().map(|l| l.provider.type_()).collect();\n    assert!(types.contains(&ProviderType::Http));\n    assert!(types.contains(&ProviderType::Cli));\n}\n\n#[tokio::test]\nasync fn test_manual_filters_disallowed_protocols() {\n    // Manual should filter out tools with disallowed protocols\n    let mut file = NamedTempFile::new().unwrap();\n    write!(\n        file,\n        r#\"{{\n            \"manual_version\": \"1.0.0\",\n            \"utcp_version\": \"0.2.0\",\n            \"info\": {{ \"title\": \"Filtered Manual\", \"version\": \"1.0.0\" }},\n            \"allowed_communication_protocols\": [\"http\"],\n            \"tools\": [\n                {{\n                    \"name\": \"http_tool\",\n                    \"description\": \"HTTP tool\",\n                    \"inputs\": {{ \"type\": \"object\" }},\n                    \"outputs\": {{ \"type\": \"object\" }},\n                    \"tool_call_template\": {{\n                        \"call_template_type\": \"http\",\n                        \"name\": \"http_provider\",\n                        \"url\": \"http://example.com\",\n                        \"http_method\": \"GET\"\n                    }}\n                }},\n                {{\n                    \"name\": \"cli_tool\",\n                    \"description\": \"CLI tool\",\n                    \"inputs\": {{ \"type\": \"object\" }},\n                    \"outputs\": {{ \"type\": \"object\" }},\n                    \"tool_call_template\": {{\n                        \"call_template_type\": \"cli\",\n                        \"name\": \"cli_provider\",\n                        \"command\": \"echo hello\"\n                    }}\n                }}\n            ]\n        }}\"#\n    )\n    .unwrap();\n\n    let config = UtcpClientConfig::default();\n    let loaded = load_providers_with_tools_from_file(file.path(), &config)\n        .await\n        .unwrap();\n\n    // Should only register HTTP tool, CLI tool should be filtered out\n    assert_eq!(loaded.len(), 1);\n    assert_eq!(loaded[0].provider.type_(), ProviderType::Http);\n}\n\n#[tokio::test]\nasync fn test_empty_array_defaults_to_own_protocol() {\n    // Empty allowed_communication_protocols array should behave same as undefined\n    let mut file = NamedTempFile::new().unwrap();\n    write!(\n        file,\n        r#\"{{\n            \"manual_version\": \"1.0.0\",\n            \"utcp_version\": \"0.2.0\",\n            \"info\": {{ \"title\": \"Empty Array Manual\", \"version\": \"1.0.0\" }},\n            \"allowed_communication_protocols\": [],\n            \"tools\": [\n                {{\n                    \"name\": \"http_tool\",\n                    \"description\": \"HTTP tool\",\n                    \"inputs\": {{ \"type\": \"object\" }},\n                    \"outputs\": {{ \"type\": \"object\" }},\n                    \"tool_call_template\": {{\n                        \"call_template_type\": \"http\",\n                        \"name\": \"http_provider\",\n                        \"url\": \"http://example.com\",\n                        \"http_method\": \"GET\"\n                    }}\n                }}\n            ]\n        }}\"#\n    )\n    .unwrap();\n\n    let config = UtcpClientConfig::default();\n    let loaded = load_providers_with_tools_from_file(file.path(), &config)\n        .await\n        .unwrap();\n\n    // With empty array, should not filter (behaves as if undefined)\n    // Actually based on our implementation, empty is treated as \"not set\"\n    assert_eq!(loaded.len(), 1);\n}\n\n#[tokio::test]\nasync fn test_provider_allowed_protocols_method() {\n    // Test that Provider trait's allowed_protocols method works correctly\n    let provider_with_allowed = BaseProvider {\n        name: \"test\".to_string(),\n        provider_type: ProviderType::Http,\n        auth: None,\n        allowed_communication_protocols: Some(vec![\"http\".to_string(), \"cli\".to_string()]),\n    };\n\n    let allowed = provider_with_allowed.allowed_protocols();\n    assert_eq!(allowed, vec![\"http\".to_string(), \"cli\".to_string()]);\n\n    let provider_without_allowed = BaseProvider {\n        name: \"test2\".to_string(),\n        provider_type: ProviderType::Cli,\n        auth: None,\n        allowed_communication_protocols: None,\n    };\n\n    let default_allowed = provider_without_allowed.allowed_protocols();\n    assert_eq!(default_allowed, vec![\"cli\".to_string()]);\n\n    let provider_empty_allowed = BaseProvider {\n        name: \"test3\".to_string(),\n        provider_type: ProviderType::Tcp,\n        auth: None,\n        allowed_communication_protocols: Some(vec![]),\n    };\n\n    let empty_allowed = provider_empty_allowed.allowed_protocols();\n    assert_eq!(empty_allowed, vec![\"tcp\".to_string()]);\n}\n\n#[tokio::test]\nasync fn test_call_tool_validates_allowed_protocols() {\n    // Test that call_tool checks allowed protocols\n    let config = UtcpClientConfig::default();\n    let repo = Arc::new(InMemoryToolRepository::new());\n    let strategy = Arc::new(MockSearchStrategy);\n\n    let client = UtcpClient::new(config, repo.clone(), strategy)\n        .await\n        .unwrap();\n\n    // Create a provider with restricted protocols\n    let provider = Arc::new(BaseProvider {\n        name: \"test_provider\".to_string(),\n        provider_type: ProviderType::Http,\n        auth: None,\n        allowed_communication_protocols: Some(vec![\"cli\".to_string()]), // Only allow CLI, but this is HTTP\n    });\n\n    let default_schema = ToolInputOutputSchema {\n        type_: \"object\".to_string(),\n        properties: None,\n        required: None,\n        description: None,\n        title: None,\n        items: None,\n        enum_: None,\n        minimum: None,\n        maximum: None,\n        format: None,\n    };\n\n    let tool = Tool {\n        name: \"test_provider.test_tool\".to_string(),\n        description: \"Test\".to_string(),\n        inputs: default_schema.clone(),\n        outputs: default_schema,\n        tags: vec![],\n        average_response_size: None,\n        provider: None,\n    };\n\n    // Register the provider with tools\n    let result = client\n        .register_tool_provider_with_tools(provider.clone(), vec![tool])\n        .await;\n\n    // Registration should succeed\n    assert!(result.is_ok());\n\n    // But calling the tool should fail due to protocol mismatch\n    let call_result = client\n        .call_tool(\"test_provider.test_tool\", std::collections::HashMap::new())\n        .await;\n\n    assert!(call_result.is_err());\n    let err_msg = call_result.unwrap_err().to_string();\n    assert!(err_msg.contains(\"not allowed\"));\n    assert!(err_msg.contains(\"http\"));\n    assert!(err_msg.contains(\"cli\"));\n}\n",
      "line_count": 303,
      "word_count": 766,
      "title": "Allowed Protocols Tests.Rs",
      "summary": "use crate::config::UtcpClientConfig; use crate::loader::load_providers_with_tools_from_file;",
      "key_terms": [
        "Result",
        "async",
        "based",
        "info",
        "format",
        "Utcp",
        "same",
        "only",
        "providers",
        "repo",
        "Test",
        "since",
        "treated",
        "has",
        "InMemoryToolRepository",
        "version",
        "path",
        "let",
        "if",
        "that"
      ],
      "timestamp": "2025-12-24T18:56:14.059079"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\call_templates.rs",
      "content_type": "code",
      "content": "use std::collections::HashMap;\nuse std::sync::RwLock;\n\nuse anyhow::{anyhow, Result};\nuse once_cell::sync::Lazy;\nuse serde_json::{Map, Value};\n\n/// Function that converts a call template value into a provider value.\npub type CallTemplateHandler = fn(Value) -> Result<Value>;\n\n/// Global registry of call template handlers keyed by call_template_type.\npub static CALL_TEMPLATE_HANDLERS: Lazy<RwLock<HashMap<String, CallTemplateHandler>>> =\n    Lazy::new(|| {\n        let mut handlers: HashMap<String, CallTemplateHandler> = HashMap::new();\n        handlers.insert(\"http\".to_string(), http_call_template_handler);\n        handlers.insert(\"cli\".to_string(), cli_call_template_handler);\n        handlers.insert(\"websocket\".to_string(), websocket_call_template_handler);\n        handlers.insert(\"grpc\".to_string(), grpc_call_template_handler);\n        handlers.insert(\"graphql\".to_string(), graphql_call_template_handler);\n        handlers.insert(\"tcp\".to_string(), tcp_call_template_handler);\n        handlers.insert(\"udp\".to_string(), udp_call_template_handler);\n        handlers.insert(\"sse\".to_string(), sse_call_template_handler);\n        handlers.insert(\"mcp\".to_string(), mcp_call_template_handler);\n        handlers.insert(\"webrtc\".to_string(), webrtc_call_template_handler);\n        handlers.insert(\"http_stream\".to_string(), http_stream_call_template_handler);\n        handlers.insert(\"text\".to_string(), text_call_template_handler);\n        RwLock::new(handlers)\n    });\n\n/// Register or override a call template handler for a call_template_type.\npub fn register_call_template_handler(key: &str, handler: CallTemplateHandler) {\n    let mut handlers = CALL_TEMPLATE_HANDLERS\n        .write()\n        .expect(\"call template handler registry poisoned\");\n    handlers.insert(key.to_string(), handler);\n}\n\n/// Convert a call template into a provider representation using registered handlers.\npub fn call_template_to_provider(template: Value) -> Result<Value> {\n    let call_template_type = template\n        .as_object()\n        .and_then(|obj| obj.get(\"call_template_type\"))\n        .and_then(|v| v.as_str())\n        .ok_or_else(|| anyhow!(\"Missing call_template_type\"))?\n        .to_string();\n\n    let handler = {\n        let handlers = CALL_TEMPLATE_HANDLERS\n            .read()\n            .expect(\"call template handler registry poisoned\");\n        handlers.get(&call_template_type).copied()\n    }\n    .unwrap_or(default_call_template_handler);\n\n    handler(template)\n}\n\nfn normalize_common_template(mut template: Value) -> Result<(String, Map<String, Value>)> {\n    let mut obj = template\n        .as_object_mut()\n        .ok_or_else(|| anyhow!(\"call template must be an object\"))?\n        .clone();\n\n    let ctype = obj\n        .get(\"call_template_type\")\n        .and_then(|v| v.as_str())\n        .ok_or_else(|| anyhow!(\"Missing call_template_type\"))?\n        .to_string();\n\n    let name = obj\n        .get(\"name\")\n        .and_then(|v| v.as_str())\n        .unwrap_or(&ctype)\n        .to_string();\n    obj.entry(\"name\").or_insert(Value::String(name.clone()));\n\n    obj.insert(\"provider_type\".to_string(), Value::String(ctype.clone()));\n    obj.insert(\"type\".to_string(), Value::String(ctype.clone()));\n\n    Ok((ctype, obj))\n}\n\nfn default_call_template_handler(template: Value) -> Result<Value> {\n    let (_, obj) = normalize_common_template(template)?;\n    Ok(Value::Object(obj))\n}\n\nfn http_call_template_handler(template: Value) -> Result<Value> {\n    let (_, mut obj) = normalize_common_template(template)?;\n\n    if let Some(method) = obj.remove(\"method\").or_else(|| obj.remove(\"http_method\")) {\n        obj.insert(\"http_method\".to_string(), method);\n    }\n    if !obj.contains_key(\"http_method\") {\n        obj.insert(\"http_method\".to_string(), Value::String(\"GET\".to_string()));\n    }\n    if let Some(body_field) = obj.remove(\"body_field\") {\n        obj.insert(\"body_field\".to_string(), body_field);\n    }\n    if let Some(headers) = obj.remove(\"headers\") {\n        obj.insert(\"headers\".to_string(), headers);\n    }\n    if let Some(url) = obj.remove(\"url\") {\n        obj.insert(\"url\".to_string(), url);\n    }\n    if !obj.contains_key(\"url\") {\n        obj.insert(\n            \"url\".to_string(),\n            Value::String(\"http://localhost\".to_string()),\n        );\n    }\n\n    Ok(Value::Object(obj))\n}\n\nfn cli_call_template_handler(template: Value) -> Result<Value> {\n    let (_, mut obj) = normalize_common_template(template)?;\n\n    if let Some(cmd) = obj.remove(\"command\") {\n        obj.insert(\"command_name\".to_string(), cmd);\n    } else if let Some(commands) = obj.get(\"commands\").and_then(|v| v.as_array()) {\n        let first = commands\n            .get(0)\n            .and_then(|c| c.get(\"command\"))\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"bash -c \\\"\\\"\");\n        obj.insert(\"command_name\".to_string(), Value::String(first.to_string()));\n    }\n\n    if let Some(env) = obj.remove(\"env_vars\") {\n        obj.insert(\"env_vars\".to_string(), env);\n    }\n    if let Some(cwd) = obj.remove(\"working_dir\") {\n        obj.insert(\"working_dir\".to_string(), cwd);\n    }\n\n    Ok(Value::Object(obj))\n}\n\nfn websocket_call_template_handler(template: Value) -> Result<Value> {\n    let (_, mut obj) = normalize_common_template(template)?;\n    if let Some(url) = obj.remove(\"url\") {\n        obj.insert(\"url\".to_string(), url);\n    }\n    if let Some(protocol) = obj.remove(\"protocol\") {\n        obj.insert(\"protocol\".to_string(), protocol);\n    }\n    if let Some(keep_alive) = obj.remove(\"keep_alive\") {\n        obj.insert(\"keep_alive\".to_string(), keep_alive);\n    }\n    if let Some(headers) = obj.remove(\"headers\") {\n        obj.insert(\"headers\".to_string(), headers);\n    }\n    Ok(Value::Object(obj))\n}\n\nfn grpc_call_template_handler(template: Value) -> Result<Value> {\n    let (_, mut obj) = normalize_common_template(template)?;\n    if let Some(host) = obj.remove(\"host\") {\n        obj.insert(\"host\".to_string(), host);\n    }\n    if let Some(port) = obj.remove(\"port\") {\n        obj.insert(\"port\".to_string(), port);\n    }\n    if let Some(use_ssl) = obj.remove(\"use_ssl\") {\n        obj.insert(\"use_ssl\".to_string(), use_ssl);\n    }\n    Ok(Value::Object(obj))\n}\n\nfn graphql_call_template_handler(template: Value) -> Result<Value> {\n    let (_, mut obj) = normalize_common_template(template)?;\n    if let Some(url) = obj.remove(\"url\") {\n        obj.insert(\"url\".to_string(), url);\n    }\n    if let Some(op_type) = obj.remove(\"operation_type\") {\n        obj.insert(\"operation_type\".to_string(), op_type);\n    }\n    if let Some(op_name) = obj.remove(\"operation_name\") {\n        obj.insert(\"operation_name\".to_string(), op_name);\n    }\n    if let Some(headers) = obj.remove(\"headers\") {\n        obj.insert(\"headers\".to_string(), headers);\n    }\n    Ok(Value::Object(obj))\n}\n\nfn tcp_call_template_handler(template: Value) -> Result<Value> {\n    let (_, mut obj) = normalize_common_template(template)?;\n    if let Some(host) = obj.remove(\"host\") {\n        obj.insert(\"host\".to_string(), host);\n    }\n    if let Some(port) = obj.remove(\"port\") {\n        obj.insert(\"port\".to_string(), port);\n    }\n    if let Some(timeout) = obj.remove(\"timeout_ms\") {\n        obj.insert(\"timeout_ms\".to_string(), timeout);\n    }\n    Ok(Value::Object(obj))\n}\n\nfn udp_call_template_handler(template: Value) -> Result<Value> {\n    let (_, mut obj) = normalize_common_template(template)?;\n    if let Some(host) = obj.remove(\"host\") {\n        obj.insert(\"host\".to_string(), host);\n    }\n    if let Some(port) = obj.remove(\"port\") {\n        obj.insert(\"port\".to_string(), port);\n    }\n    if let Some(timeout) = obj.remove(\"timeout_ms\") {\n        obj.insert(\"timeout_ms\".to_string(), timeout);\n    }\n    Ok(Value::Object(obj))\n}\n\nfn sse_call_template_handler(template: Value) -> Result<Value> {\n    let (_, mut obj) = normalize_common_template(template)?;\n    if let Some(url) = obj.remove(\"url\") {\n        obj.insert(\"url\".to_string(), url);\n    }\n    if let Some(headers) = obj.remove(\"headers\") {\n        obj.insert(\"headers\".to_string(), headers);\n    }\n    if let Some(body_field) = obj.remove(\"body_field\") {\n        obj.insert(\"body_field\".to_string(), body_field);\n    }\n    if let Some(header_fields) = obj.remove(\"header_fields\") {\n        obj.insert(\"header_fields\".to_string(), header_fields);\n    }\n    Ok(Value::Object(obj))\n}\n\nfn mcp_call_template_handler(template: Value) -> Result<Value> {\n    let (_, mut obj) = normalize_common_template(template)?;\n    // HTTP fields\n    if let Some(url) = obj.remove(\"url\") {\n        obj.insert(\"url\".to_string(), url);\n    }\n    if let Some(headers) = obj.remove(\"headers\") {\n        obj.insert(\"headers\".to_string(), headers);\n    }\n    // Stdio fields\n    if let Some(cmd) = obj.remove(\"command\") {\n        obj.insert(\"command\".to_string(), cmd);\n    }\n    if let Some(args) = obj.remove(\"args\") {\n        obj.insert(\"args\".to_string(), args);\n    }\n    if let Some(env) = obj.remove(\"env_vars\") {\n        obj.insert(\"env_vars\".to_string(), env);\n    }\n    Ok(Value::Object(obj))\n}\n\nfn webrtc_call_template_handler(template: Value) -> Result<Value> {\n    let (_, mut obj) = normalize_common_template(template)?;\n    if let Some(sig) = obj.remove(\"signaling_server\") {\n        obj.insert(\"signaling_server\".to_string(), sig);\n    }\n    if let Some(ice) = obj.remove(\"ice_servers\") {\n        obj.insert(\"ice_servers\".to_string(), ice);\n    }\n    if let Some(label) = obj.remove(\"channel_label\") {\n        obj.insert(\"channel_label\".to_string(), label);\n    }\n    if let Some(ordered) = obj.remove(\"ordered\") {\n        obj.insert(\"ordered\".to_string(), ordered);\n    }\n    if let Some(life) = obj.remove(\"max_packet_life_time\") {\n        obj.insert(\"max_packet_life_time\".to_string(), life);\n    }\n    if let Some(retx) = obj.remove(\"max_retransmits\") {\n        obj.insert(\"max_retransmits\".to_string(), retx);\n    }\n    Ok(Value::Object(obj))\n}\n\nfn http_stream_call_template_handler(template: Value) -> Result<Value> {\n    let (_, mut obj) = normalize_common_template(template)?;\n    if let Some(url) = obj.remove(\"url\") {\n        obj.insert(\"url\".to_string(), url);\n    }\n    if let Some(method) = obj.remove(\"http_method\") {\n        obj.insert(\"http_method\".to_string(), method);\n    }\n    if let Some(headers) = obj.remove(\"headers\") {\n        obj.insert(\"headers\".to_string(), headers);\n    }\n    Ok(Value::Object(obj))\n}\n\nfn text_call_template_handler(template: Value) -> Result<Value> {\n    let (_, mut obj) = normalize_common_template(template)?;\n    if let Some(path) = obj.remove(\"base_path\") {\n        obj.insert(\"base_path\".to_string(), path);\n    }\n    Ok(Value::Object(obj))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn test_websocket_template() {\n        let template = json!({\n            \"call_template_type\": \"websocket\",\n            \"name\": \"ws-tool\",\n            \"url\": \"ws://localhost:8080\",\n            \"protocol\": \"json-rpc\"\n        });\n        let result = call_template_to_provider(template).unwrap();\n        assert_eq!(result[\"provider_type\"], \"websocket\");\n        assert_eq!(result[\"url\"], \"ws://localhost:8080\");\n        assert_eq!(result[\"protocol\"], \"json-rpc\");\n    }\n\n    #[test]\n    fn test_grpc_template() {\n        let template = json!({\n            \"call_template_type\": \"grpc\",\n            \"name\": \"grpc-tool\",\n            \"host\": \"localhost\",\n            \"port\": 50051,\n            \"use_ssl\": true\n        });\n        let result = call_template_to_provider(template).unwrap();\n        assert_eq!(result[\"provider_type\"], \"grpc\");\n        assert_eq!(result[\"host\"], \"localhost\");\n        assert_eq!(result[\"port\"], 50051);\n        assert_eq!(result[\"use_ssl\"], true);\n    }\n\n    #[test]\n    fn test_mcp_template() {\n        let template = json!({\n            \"call_template_type\": \"mcp\",\n            \"name\": \"mcp-tool\",\n            \"command\": \"python\",\n            \"args\": [\"server.py\"]\n        });\n        let result = call_template_to_provider(template).unwrap();\n        assert_eq!(result[\"provider_type\"], \"mcp\");\n        assert_eq!(result[\"command\"], \"python\");\n        assert_eq!(result[\"args\"][0], \"server.py\");\n    }\n}\n",
      "line_count": 349,
      "word_count": 925,
      "title": "Call Templates.Rs",
      "summary": "use std::collections::HashMap; use std::sync::RwLock;",
      "key_terms": [
        "grpc",
        "sig",
        "Result",
        "entry",
        "localhost",
        "headers",
        "websocket",
        "rpc",
        "must",
        "using",
        "path",
        "let",
        "if",
        "that",
        "sse",
        "retx",
        "handler",
        "grpc-tool",
        "ws-tool",
        "super"
      ],
      "timestamp": "2025-12-24T18:56:14.106883"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\config.rs",
      "content_type": "code",
      "content": "use anyhow::Result;\nuse async_trait::async_trait;\nuse std::collections::HashMap;\nuse std::path::PathBuf;\nuse std::sync::Arc;\n\n/// Trait for loading configuration variables from various sources.\n#[async_trait]\npub trait UtcpVariablesConfig: Send + Sync {\n    /// Loads all variables from the source.\n    async fn load(&self) -> Result<HashMap<String, String>>;\n    /// Gets a single variable by key.\n    async fn get(&self, key: &str) -> Result<String>;\n}\n\n/// Configuration for the UTCP client, including variables and provider file paths.\n#[derive(Clone)]\npub struct UtcpClientConfig {\n    /// Map of inline variables.\n    pub variables: HashMap<String, String>,\n    /// Path to the providers configuration file.\n    pub providers_file_path: Option<PathBuf>,\n    /// List of variable loaders to use.\n    pub load_variables_from: Vec<Arc<dyn UtcpVariablesConfig>>,\n}\n\nimpl Default for UtcpClientConfig {\n    fn default() -> Self {\n        Self {\n            variables: HashMap::new(),\n            providers_file_path: None,\n            load_variables_from: Vec::new(),\n        }\n    }\n}\n\nimpl UtcpClientConfig {\n    /// Creates a new default configuration.\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Sets the path to the providers configuration file.\n    pub fn with_providers_file(mut self, path: PathBuf) -> Self {\n        self.providers_file_path = Some(path);\n        self\n    }\n\n    /// Adds a single variable to the configuration.\n    pub fn with_variable(mut self, key: String, value: String) -> Self {\n        self.variables.insert(key, value);\n        self\n    }\n\n    /// Adds multiple variables to the configuration.\n    pub fn with_variables(mut self, vars: HashMap<String, String>) -> Self {\n        self.variables.extend(vars);\n        self\n    }\n\n    /// v1.0-style helper to set manual/call template path (reuses providers_file_path).\n    pub fn with_manual_path(mut self, path: PathBuf) -> Self {\n        self.providers_file_path = Some(path);\n        self\n    }\n\n    /// Retrieves a variable value by key, checking inline variables, loaders, and environment variables in order.\n    pub async fn get_variable(&self, key: &str) -> Option<String> {\n        // Check inline variables first\n        if let Some(val) = self.variables.get(key) {\n            return Some(val.clone());\n        }\n\n        // Check variable loaders\n        for loader in &self.load_variables_from {\n            if let Ok(val) = loader.get(key).await {\n                return Some(val);\n            }\n        }\n\n        // Check environment variables\n        std::env::var(key).ok()\n    }\n}\n\n/// A variable loader that reads from a .env file.\npub struct DotEnvLoader {\n    file_path: PathBuf,\n}\n\nimpl DotEnvLoader {\n    /// Creates a new DotEnvLoader for the specified file path.\n    pub fn new(file_path: PathBuf) -> Self {\n        Self { file_path }\n    }\n}\n\n#[async_trait]\nimpl UtcpVariablesConfig for DotEnvLoader {\n    async fn load(&self) -> Result<HashMap<String, String>> {\n        let contents = tokio::fs::read_to_string(&self.file_path).await?;\n        let mut vars = HashMap::new();\n\n        for line in contents.lines() {\n            let line = line.trim();\n            if line.is_empty() || line.starts_with('#') {\n                continue;\n            }\n\n            if let Some((key, value)) = line.split_once('=') {\n                vars.insert(\n                    key.trim().to_string(),\n                    value.trim().trim_matches('\"').to_string(),\n                );\n            }\n        }\n\n        Ok(vars)\n    }\n\n    async fn get(&self, key: &str) -> Result<String> {\n        let vars = self.load().await?;\n        vars.get(key)\n            .cloned()\n            .ok_or_else(|| anyhow::anyhow!(\"Variable {} not found\", key))\n    }\n}\n",
      "line_count": 128,
      "word_count": 414,
      "title": "Config.Rs",
      "summary": "use anyhow::Result; use async_trait::async_trait;",
      "key_terms": [
        "Result",
        "paths",
        "async",
        "Clone",
        "Utcp",
        "helper",
        "loaders",
        "vars",
        "cloned",
        "trim",
        "specified",
        "providers",
        "Sync",
        "found",
        "sources",
        "multiple",
        "Self",
        "Sets",
        "Creates",
        "path"
      ],
      "timestamp": "2025-12-24T18:56:14.138240"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\errors.rs",
      "content_type": "code",
      "content": "use thiserror::Error;\n\n/// Represents errors that can occur within the UTCP client.\n#[derive(Error, Debug)]\npub enum UtcpError {\n    /// Error when a requested tool is not found.\n    #[error(\"Tool not found: {0}\")]\n    ToolNotFound(String),\n    /// Error related to authentication failures.\n    #[error(\"Authentication failed: {0}\")]\n    Authentication(String),\n    /// Error occurring during a tool call execution.\n    #[error(\"Tool call failed: {0}\")]\n    ToolCall(String),\n    /// Error related to invalid configuration.\n    #[error(\"Invalid configuration: {0}\")]\n    Config(String),\n    /// Other errors wrapped by anyhow.\n    #[error(transparent)]\n    Other(#[from] anyhow::Error),\n}\n",
      "line_count": 22,
      "word_count": 75,
      "title": "Errors.Rs",
      "summary": "use thiserror::Error; /// Represents errors that can occur within the UTCP client.",
      "key_terms": [
        "invalid",
        "from",
        "pub",
        "occur",
        "requested",
        "error",
        "occurring",
        "transparent",
        "is",
        "Authentication",
        "wrapped",
        "Tool",
        "thiserror",
        "during",
        "enum",
        "configuration",
        "tool",
        "Utcp",
        "failed",
        "when"
      ],
      "timestamp": "2025-12-24T18:56:14.177796"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\lib.rs",
      "content_type": "code",
      "content": "pub mod auth;\npub mod call_templates;\npub mod config;\npub mod errors;\npub mod grpcpb;\npub mod loader;\npub mod migration;\npub mod openapi;\npub mod plugins;\npub mod providers;\npub mod repository;\npub mod security;\npub mod spec;\npub mod tag;\npub mod tools;\npub mod transports;\n\n#[cfg(test)]\nmod allowed_protocols_tests;\n\nuse anyhow::{anyhow, Result};\nuse async_trait::async_trait;\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\nuse crate::config::UtcpClientConfig;\nuse crate::errors::UtcpError;\nuse crate::openapi::OpenApiConverter;\nuse crate::providers::base::{Provider, ProviderType};\nuse crate::providers::http::HttpProvider;\nuse crate::repository::ToolRepository;\nuse crate::tools::{Tool, ToolSearchStrategy};\nuse crate::transports::registry::{\n    communication_protocols_snapshot, CommunicationProtocolRegistry,\n};\nuse crate::transports::stream::StreamResult;\nuse crate::transports::CommunicationProtocol;\n\n/// UtcpClientInterface defines the core operations for a UTCP client.\n/// It allows registering/deregistering tool providers, calling tools, and searching for tools.\n#[async_trait]\npub trait UtcpClientInterface: Send + Sync {\n    /// Registers a new tool provider and returns the list of tools it offers.\n    async fn register_tool_provider(&self, prov: Arc<dyn Provider>) -> Result<Vec<Tool>>;\n\n    /// Registers a tool provider with a specific set of tools, overriding automatic discovery.\n    async fn register_tool_provider_with_tools(\n        &self,\n        prov: Arc<dyn Provider>,\n        tools: Vec<Tool>,\n    ) -> Result<Vec<Tool>>;\n\n    /// Deregisters an existing tool provider by its name.\n    async fn deregister_tool_provider(&self, provider_name: &str) -> Result<()>;\n\n    /// Calls a specific tool by name with the provided arguments.\n    async fn call_tool(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, serde_json::Value>,\n    ) -> Result<serde_json::Value>;\n\n    /// Searches for tools matching the query string, limited by the count.\n    async fn search_tools(&self, query: &str, limit: usize) -> Result<Vec<Tool>>;\n\n    /// Returns a map of available transports (communication protocols).\n    fn get_transports(&self) -> HashMap<String, Arc<dyn CommunicationProtocol>>;\n\n    /// Alias for get_transports.\n    fn get_communication_protocols(&self) -> HashMap<String, Arc<dyn CommunicationProtocol>> {\n        self.get_transports()\n    }\n\n    /// Calls a tool and returns a stream of results (e.g., for SSE).\n    async fn call_tool_stream(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, serde_json::Value>,\n    ) -> Result<Box<dyn StreamResult>>;\n}\n\n/// UtcpClient is the main entry point for the UTCP library.\n/// It manages tool providers, communication protocols, and tool execution.\npub struct UtcpClient {\n    config: UtcpClientConfig,\n    communication_protocols: CommunicationProtocolRegistry,\n    tool_repository: Arc<dyn ToolRepository>,\n    search_strategy: Arc<dyn ToolSearchStrategy>,\n\n    provider_tools_cache: RwLock<HashMap<String, Vec<Tool>>>,\n    resolved_tools_cache: RwLock<HashMap<String, ResolvedTool>>,\n}\n\n/// ResolvedTool represents a tool that has been resolved to a specific provider and protocol.\n#[derive(Clone)]\nstruct ResolvedTool {\n    provider: Arc<dyn Provider>,\n    protocol: Arc<dyn CommunicationProtocol>,\n    call_name: String,\n}\n\nimpl UtcpClient {\n    /// v1.0-style async factory for symmetry with other language SDKs\n    pub async fn create(\n        config: UtcpClientConfig,\n        repo: Arc<dyn ToolRepository>,\n        strat: Arc<dyn ToolSearchStrategy>,\n    ) -> Result<Self> {\n        Self::new(config, repo, strat).await\n    }\n\n    /// Create a new UtcpClient and automatically load providers from the JSON file specified in config\n    pub async fn new(\n        config: UtcpClientConfig,\n        repo: Arc<dyn ToolRepository>,\n        strat: Arc<dyn ToolSearchStrategy>,\n    ) -> Result<Self> {\n        let communication_protocols = communication_protocols_snapshot();\n\n        let client = Self {\n            config,\n            communication_protocols,\n            tool_repository: repo,\n            search_strategy: strat,\n            provider_tools_cache: RwLock::new(HashMap::new()),\n            resolved_tools_cache: RwLock::new(HashMap::new()),\n        };\n\n        // Load providers if file path is specified\n        if let Some(providers_path) = &client.config.providers_file_path {\n            let providers =\n                crate::loader::load_providers_with_tools_from_file(providers_path, &client.config)\n                    .await?;\n\n            for loaded in providers {\n                let result = if let Some(tools) = loaded.tools {\n                    client\n                        .register_tool_provider_with_tools(loaded.provider.clone(), tools)\n                        .await\n                } else {\n                    client.register_tool_provider(loaded.provider.clone()).await\n                };\n\n                match result {\n                    Ok(tools) => {\n                        println!(\"‚úì Loaded provider with {} tools\", tools.len());\n                    }\n                    Err(e) => {\n                        eprintln!(\"‚úó Failed to load provider: {}\", e);\n                    }\n                }\n            }\n        }\n\n        Ok(client)\n    }\n\n    /// Determines the correct call name for a tool based on its provider type.\n    fn call_name_for_provider(tool_name: &str, provider_type: &ProviderType) -> String {\n        match provider_type {\n            ProviderType::Mcp | ProviderType::Text => tool_name\n                .splitn(2, '.')\n                .nth(1)\n                .unwrap_or(tool_name)\n                .to_string(),\n            _ => tool_name.to_string(),\n        }\n    }\n\n    /// Validates that the protocol is allowed by the provider.\n    fn validate_allowed_protocol(resolved: &ResolvedTool, tool_name: &str) -> Result<()> {\n        let provider_allowed_protocols = resolved.provider.allowed_protocols();\n        let tool_protocol = resolved.provider.type_().as_key();\n\n        if !provider_allowed_protocols.contains(&tool_protocol.to_string()) {\n            return Err(anyhow!(\n                \"Tool '{}' uses communication protocol '{}' which is not allowed by its provider. Allowed protocols: {:?}\",\n                tool_name,\n                tool_protocol,\n                provider_allowed_protocols\n            ));\n        }\n\n        Ok(())\n    }\n\n    /// Resolves a tool name to a `ResolvedTool` containing the provider and protocol.\n    /// Handles both fully qualified names (provider.tool) and bare names.\n    async fn resolve_tool(&self, tool_name: &str) -> Result<ResolvedTool> {\n        {\n            let cache = self.resolved_tools_cache.read().await;\n            if let Some(resolved) = cache.get(tool_name) {\n                return Ok(resolved.clone());\n            }\n        }\n\n        // Legacy qualified name flow\n        if let Some((provider_name, suffix)) = tool_name.split_once('.') {\n            if provider_name.is_empty() {\n                return Err(UtcpError::Config(format!(\"Invalid tool name: {}\", tool_name)).into());\n            }\n\n            let prov = self\n                .tool_repository\n                .get_provider(provider_name)\n                .await?\n                .ok_or_else(|| UtcpError::ToolNotFound(provider_name.to_string()))?;\n            let provider_type = prov.type_();\n\n            let protocol_key = provider_type.as_key().to_string();\n            let protocol = self\n                .communication_protocols\n                .get(&protocol_key)\n                .ok_or_else(|| {\n                    UtcpError::Config(format!(\n                        \"No communication protocol found for provider type: {:?}\",\n                        provider_type\n                    ))\n                })?\n                .clone();\n\n            let call_name = Self::call_name_for_provider(tool_name, &provider_type);\n            let resolved = ResolvedTool {\n                provider: prov.clone(),\n                protocol: protocol.clone(),\n                call_name,\n            };\n\n            let mut cache = self.resolved_tools_cache.write().await;\n            cache.insert(tool_name.to_string(), resolved.clone());\n            cache.insert(suffix.to_string(), resolved.clone());\n            return Ok(resolved);\n        }\n\n        // v1.0 bare tool names: search cached provider tools\n        {\n            let cache = self.provider_tools_cache.read().await;\n            for (prov_name, tools) in cache.iter() {\n                if tools.iter().any(|t| {\n                    t.name\n                        .split_once('.')\n                        .map(|(_, suffix)| suffix == tool_name)\n                        .unwrap_or(false)\n                }) {\n                    let prov = self\n                        .tool_repository\n                        .get_provider(prov_name)\n                        .await?\n                        .ok_or_else(|| UtcpError::ToolNotFound(prov_name.clone()))?;\n                    let provider_type = prov.type_();\n                    let protocol_key = provider_type.as_key().to_string();\n                    let protocol = self\n                        .communication_protocols\n                        .get(&protocol_key)\n                        .ok_or_else(|| {\n                            UtcpError::Config(format!(\n                                \"No communication protocol found for provider type: {:?}\",\n                                provider_type\n                            ))\n                        })?\n                        .clone();\n\n                    let full_name = format!(\"{}.{}\", prov_name, tool_name);\n                    let call_name = Self::call_name_for_provider(&full_name, &provider_type);\n                    let resolved = ResolvedTool {\n                        provider: prov.clone(),\n                        protocol: protocol.clone(),\n                        call_name,\n                    };\n\n                    let mut rcache = self.resolved_tools_cache.write().await;\n                    rcache.insert(full_name, resolved.clone());\n                    rcache.insert(tool_name.to_string(), resolved.clone());\n                    return Ok(resolved);\n                }\n            }\n        }\n\n        Err(UtcpError::ToolNotFound(tool_name.to_string()).into())\n    }\n}\n\n#[async_trait]\nimpl UtcpClientInterface for UtcpClient {\n    async fn register_tool_provider(&self, prov: Arc<dyn Provider>) -> Result<Vec<Tool>> {\n        self.register_tool_provider_with_tools(prov, Vec::new())\n            .await\n    }\n\n    async fn register_tool_provider_with_tools(\n        &self,\n        prov: Arc<dyn Provider>,\n        tools_override: Vec<Tool>,\n    ) -> Result<Vec<Tool>> {\n        let provider_name = prov.name();\n        let provider_type = prov.type_();\n\n        // Check cache first\n        {\n            let cache = self.provider_tools_cache.read().await;\n            if let Some(tools) = cache.get(&provider_name) {\n                return Ok(tools.clone());\n            }\n        }\n\n        // Get communication protocol for this provider type\n        let protocol_key = provider_type.as_key().to_string();\n        let protocol = self\n            .communication_protocols\n            .get(&protocol_key)\n            .ok_or_else(|| {\n                anyhow!(\n                    \"No communication protocol found for provider type: {:?}\",\n                    provider_type\n                )\n            })?\n            .clone();\n\n        // Register with protocol\n        let tools = if !tools_override.is_empty() {\n            tools_override\n        } else if provider_type == ProviderType::Http {\n            if let Some(http_prov) = prov.as_any().downcast_ref::<HttpProvider>() {\n                match OpenApiConverter::new_from_url(&http_prov.url, Some(provider_name.clone()))\n                    .await\n                {\n                    Ok(converter) => {\n                        let manual = converter.convert();\n                        if manual.tools.is_empty() {\n                            protocol.register_tool_provider(prov.as_ref()).await?\n                        } else {\n                            manual.tools\n                        }\n                    }\n                    Err(_) => protocol.register_tool_provider(prov.as_ref()).await?,\n                }\n            } else {\n                protocol.register_tool_provider(prov.as_ref()).await?\n            }\n        } else {\n            protocol.register_tool_provider(prov.as_ref()).await?\n        };\n\n        // Normalize tool names (prefix with provider name)\n        let mut normalized_tools = Vec::new();\n        for mut tool in tools {\n            if !tool.name.starts_with(&format!(\"{}.\", provider_name)) {\n                tool.name = format!(\"{}.{}\", provider_name, tool.name.trim_start_matches('.'));\n            }\n            normalized_tools.push(tool);\n        }\n\n        // Save to repository\n        self.tool_repository\n            .save_provider_with_tools(prov.clone(), normalized_tools.clone())\n            .await?;\n\n        // Update cache\n        {\n            let mut cache = self.provider_tools_cache.write().await;\n            cache.insert(provider_name, normalized_tools.clone());\n        }\n\n        {\n            let mut resolved = self.resolved_tools_cache.write().await;\n            for tool in &normalized_tools {\n                let call_name = Self::call_name_for_provider(&tool.name, &provider_type);\n                let resolved_entry = ResolvedTool {\n                    provider: prov.clone(),\n                    protocol: protocol.clone(),\n                    call_name,\n                };\n\n                // Full name\n                resolved.insert(tool.name.clone(), resolved_entry.clone());\n\n                // Bare name (v1.0 style)\n                if let Some((_, bare)) = tool.name.split_once('.') {\n                    resolved.insert(bare.to_string(), resolved_entry);\n                }\n            }\n        }\n\n        Ok(normalized_tools)\n    }\n\n    async fn deregister_tool_provider(&self, provider_name: &str) -> Result<()> {\n        // Get provider from repository\n        let prov = self\n            .tool_repository\n            .get_provider(provider_name)\n            .await?\n            .ok_or_else(|| anyhow!(\"Provider not found: {}\", provider_name))?;\n\n        // Get communication protocol\n        let provider_type = prov.type_();\n        let protocol_key = provider_type.as_key().to_string();\n        let protocol = self\n            .communication_protocols\n            .get(&protocol_key)\n            .ok_or_else(|| {\n                anyhow!(\n                    \"No communication protocol found for provider type: {:?}\",\n                    provider_type\n                )\n            })?;\n\n        // Deregister from protocol\n        protocol.deregister_tool_provider(prov.as_ref()).await?;\n\n        // Remove from repository\n        self.tool_repository.remove_provider(provider_name).await?;\n\n        // Clear cache\n        {\n            let mut cache = self.provider_tools_cache.write().await;\n            cache.remove(provider_name);\n        }\n        {\n            let mut resolved = self.resolved_tools_cache.write().await;\n            resolved.retain(|tool_name, _| !tool_name.starts_with(&format!(\"{}.\", provider_name)));\n        }\n\n        Ok(())\n    }\n\n    async fn call_tool(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, serde_json::Value>,\n    ) -> Result<serde_json::Value> {\n        let resolved = self.resolve_tool(tool_name).await?;\n\n        // Validate protocol is allowed by the provider\n        Self::validate_allowed_protocol(&resolved, tool_name)?;\n\n        resolved\n            .protocol\n            .call_tool(&resolved.call_name, args, resolved.provider.as_ref())\n            .await\n    }\n\n    async fn search_tools(&self, query: &str, limit: usize) -> Result<Vec<Tool>> {\n        self.search_strategy.search_tools(query, limit).await\n    }\n\n    fn get_transports(&self) -> HashMap<String, Arc<dyn CommunicationProtocol>> {\n        self.communication_protocols.as_map()\n    }\n\n    async fn call_tool_stream(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, serde_json::Value>,\n    ) -> Result<Box<dyn StreamResult>> {\n        let resolved = self.resolve_tool(tool_name).await?;\n\n        // Validate protocol is allowed by the provider\n        Self::validate_allowed_protocol(&resolved, tool_name)?;\n\n        resolved\n            .protocol\n            .call_tool_stream(&resolved.call_name, args, resolved.provider.as_ref())\n            .await\n    }\n}\n",
      "line_count": 468,
      "word_count": 1284,
      "title": "Lib.Rs",
      "summary": "pub mod auth; pub mod call_templates;",
      "key_terms": [
        "Result",
        "entry",
        "async",
        "search",
        "convert",
        "based",
        "list",
        "rcache",
        "prov",
        "Clone",
        "format",
        "uses",
        "available",
        "Utcp",
        "It",
        "specified",
        "providers",
        "Sync",
        "repo",
        "found"
      ],
      "timestamp": "2025-12-24T18:56:14.218407"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\loader.rs",
      "content_type": "code",
      "content": "// Provider loading from JSON files\nuse anyhow::{anyhow, Result};\nuse serde_json::Value;\nuse std::path::Path;\nuse std::sync::Arc;\n\nuse crate::call_templates;\nuse crate::config::UtcpClientConfig;\nuse crate::migration::{migrate_v01_config, validate_v1_config, validate_v1_manual};\nuse crate::providers::base::Provider;\nuse crate::providers::cli::CliProvider;\nuse crate::providers::graphql::GraphqlProvider;\nuse crate::providers::grpc::GrpcProvider;\nuse crate::providers::http::HttpProvider;\nuse crate::providers::http_stream::StreamableHttpProvider;\nuse crate::providers::mcp::McpProvider;\nuse crate::providers::sse::SseProvider;\nuse crate::providers::tcp::TcpProvider;\nuse crate::providers::text::TextProvider;\nuse crate::providers::udp::UdpProvider;\nuse crate::providers::webrtc::WebRtcProvider;\nuse crate::providers::websocket::WebSocketProvider;\nuse crate::spec::ManualV1;\n\n/// Parse a providers JSON file\n/// Supports multiple formats:\n/// - Array: [{\"provider_type\": \"http\", ...}, ...]\n/// - Object with providers array: {\"providers\": [{...}, ...]}\n/// - Object with single provider: {\"providers\": {...}}\n/// - Single provider: {\"provider_type\": \"http\", ...}\npub async fn load_providers_from_file(\n    path: impl AsRef<Path>,\n    config: &UtcpClientConfig,\n) -> Result<Vec<Arc<dyn Provider>>> {\n    Ok(load_providers_with_tools_from_file(path, config)\n        .await?\n        .into_iter()\n        .map(|p| p.provider)\n        .collect())\n}\n\n/// LoadedProvider represents a provider that has been loaded from a configuration file,\n/// optionally including a list of tools if they were defined in the file (e.g. in a manual).\npub struct LoadedProvider {\n    /// The loaded provider instance.\n    pub provider: Arc<dyn Provider>,\n    /// Optional list of tools associated with this provider.\n    pub tools: Option<Vec<crate::tools::Tool>>,\n}\n\n/// Load providers or manuals (v0.1 or v1.0), returning providers and any embedded tools.\npub async fn load_providers_with_tools_from_file(\n    path: impl AsRef<Path>,\n    config: &UtcpClientConfig,\n) -> Result<Vec<LoadedProvider>> {\n    let contents = tokio::fs::read_to_string(path).await?;\n    let json_raw: Value = serde_json::from_str(&contents)?;\n    // Apply v0.1 -> v1.0 migration for configs if needed\n    let json = migrate_v01_config(&json_raw);\n\n    // Validate v1.0 shapes when applicable\n    if let Some(obj) = json.as_object() {\n        if obj.contains_key(\"manual_call_templates\") {\n            validate_v1_config(&json)?;\n        }\n        if obj.contains_key(\"tools\") {\n            validate_v1_manual(&json)?;\n        }\n    }\n\n    // If this is a manual with tools, collect tools per provider\n    if let Some(obj) = json.as_object() {\n        if obj.get(\"tools\").is_some() {\n            let _manual: ManualV1 = serde_json::from_value(json.clone())\n                .map_err(|e| anyhow!(\"Invalid v1.0 manual: {}\", e))?;\n\n            let (providers, tools) = parse_manual_tools_with_providers(json.clone(), config)?;\n            return Ok(providers\n                .into_iter()\n                .zip(tools.into_iter())\n                .map(|(provider, tools)| LoadedProvider {\n                    provider,\n                    tools: Some(tools),\n                })\n                .collect());\n        }\n    }\n\n    let provider_values = parse_providers_json(json)?;\n\n    let mut providers = Vec::new();\n    for (index, mut provider_value) in provider_values.into_iter().enumerate() {\n        // Perform variable substitution\n        substitute_variables(&mut provider_value, config);\n\n        // Create provider\n        let provider = create_provider_from_value(provider_value, index)?;\n        providers.push(LoadedProvider {\n            provider,\n            tools: None,\n        });\n    }\n\n    Ok(providers)\n}\n\n/// Parses the raw JSON value into a list of provider JSON objects.\n/// Handles various formats: array, object with \"providers\", object with \"manual_call_templates\", or single provider object.\nfn parse_providers_json(json: Value) -> Result<Vec<Value>> {\n    match json {\n        // Direct array of providers\n        Value::Array(arr) => Ok(arr),\n\n        // Object that might contain providers\n        Value::Object(obj) => {\n            if obj.get(\"tools\").is_some() {\n                return parse_manual_tools(Value::Object(obj));\n            }\n\n            // v1.0 migration: manual_call_templates -> providers\n            if let Some(templates_value) = obj.get(\"manual_call_templates\") {\n                if let Some(arr) = templates_value.as_array() {\n                    let mut providers = Vec::new();\n                    for template in arr {\n                        providers\n                            .push(call_templates::call_template_to_provider(template.clone())?);\n                    }\n                    return Ok(providers);\n                }\n            }\n\n            if let Some(providers_value) = obj.get(\"providers\") {\n                match providers_value {\n                    // providers is an array\n                    Value::Array(arr) => Ok(arr.clone()),\n                    // providers is a single object\n                    Value::Object(_) => Ok(vec![providers_value.clone()]),\n                    _ => Err(anyhow!(\"'providers' field must be an array or object\")),\n                }\n            } else {\n                // Single provider object (no \"providers\" wrapper)\n                Ok(vec![Value::Object(obj)])\n            }\n        }\n\n        _ => Err(anyhow!(\"JSON root must be array or object\")),\n    }\n}\n\n/// Parse a manual (v0.1 or v1.0) into a list of providers by lifting tool_call_templates.\nfn parse_manual_tools(json: Value) -> Result<Vec<Value>> {\n    let obj = json\n        .as_object()\n        .ok_or_else(|| anyhow!(\"Manual must be an object\"))?;\n    let tools = obj\n        .get(\"tools\")\n        .and_then(|v| v.as_array())\n        .ok_or_else(|| anyhow!(\"Manual missing tools array\"))?;\n\n    let mut providers = Vec::new();\n    for tool in tools {\n        if let Some(provider) = tool_to_provider(tool)? {\n            providers.push(provider);\n        }\n    }\n    Ok(providers)\n}\n\n/// Parses a manual JSON object to extract both providers and their associated tools.\n/// Returns a tuple of (providers, tools_per_provider).\nfn parse_manual_tools_with_providers(\n    json: Value,\n    config: &UtcpClientConfig,\n) -> Result<(Vec<Arc<dyn Provider>>, Vec<Vec<crate::tools::Tool>>)> {\n    let obj = json\n        .as_object()\n        .ok_or_else(|| anyhow!(\"Manual must be an object\"))?;\n    let tools = obj\n        .get(\"tools\")\n        .and_then(|v| v.as_array())\n        .ok_or_else(|| anyhow!(\"Manual missing tools array\"))?;\n\n    // Extract allowed_communication_protocols from manual\n    let manual_allowed_protocols: Option<Vec<String>> = obj\n        .get(\"allowed_communication_protocols\")\n        .and_then(|v| v.as_array())\n        .map(|arr| {\n            arr.iter()\n                .filter_map(|v| v.as_str().map(|s| s.to_string()))\n                .collect()\n        });\n\n    let mut providers = Vec::new();\n    let mut tools_per_provider = Vec::new();\n\n    for (idx, tool_val) in tools.iter().enumerate() {\n        if let Some(provider_val) = tool_to_provider(tool_val)? {\n            let mut provider_val = provider_val.clone();\n            substitute_variables(&mut provider_val, config);\n\n            // If missing provider_type, derive from call_template_type\n            let provider_obj = provider_val\n                .as_object_mut()\n                .ok_or_else(|| anyhow!(\"Provider must be object\"))?;\n\n            let provider_type_str = if provider_obj\n                .get(\"provider_type\")\n                .or_else(|| provider_obj.get(\"type\"))\n                .is_none()\n            {\n                if let Some(ct) = provider_obj.get(\"call_template_type\").cloned() {\n                    provider_obj.insert(\"provider_type\".to_string(), ct.clone());\n                    provider_obj.insert(\"type\".to_string(), ct.clone());\n                    ct.as_str().unwrap_or(\"http\").to_string()\n                } else {\n                  if provider_obj\n                        .get(\"allowed_communication_protocols\")\n                        .is_none()\n                    {\n                        provider_obj.insert(\n                            \"allowed_communication_protocols\".to_string(),\n                            serde_json::to_value(\"http\".to_string())?,\n                        );\n                    }\n                    provider_obj.insert(\"type\".to_string(), Value::String(\"http\".to_string()));\n                    \"http\".to_string()\n                }\n            } else {\n                provider_obj\n                    .get(\"provider_type\")\n                    .or_else(|| provider_obj.get(\"type\"))\n                    .and_then(|v| v.as_str())\n                    .unwrap_or(\"http\")\n                    .to_string()\n            };\n\n            // Propagate manual's allowed_communication_protocols to provider if set\n            if let Some(ref allowed) = manual_allowed_protocols {\n                if !allowed.is_empty() {\n                    // Check if this tool's protocol is allowed\n                    if !allowed.contains(&provider_type_str) {\n                        // Log warning and skip this tool\n                        if let Some(tool_name) = tool_val.get(\"name\").and_then(|v| v.as_str()) {\n                            eprintln!(\n                                \"Warning: Tool '{}' uses communication protocol '{}' which is not in allowed protocols {:?} for manual. Tool will not be registered.\",\n                                tool_name, provider_type_str, allowed\n                            );\n                        }\n                        continue; // Skip this tool\n                    }\n\n                    // Add allowed_communication_protocols to provider\n                    provider_obj.insert(\n                        \"allowed_communication_protocols\".to_string(),\n                        serde_json::to_value(allowed.clone())?,\n                    );\n                }\n            }\n\n            let provider = create_provider_from_value(provider_val, idx)?;\n            let prov_name = provider.name();\n            providers.push(provider);\n\n            let mut tool_value = tool_val.clone();\n            if let Some(obj) = tool_value.as_object_mut() {\n                obj.entry(\"tags\")\n                    .or_insert_with(|| Value::Array(Vec::new()));\n            }\n            let mut tool: crate::tools::Tool = serde_json::from_value(tool_value)?;\n            // Prefix tool name with provider to keep existing naming\n            if !tool.name.starts_with(&format!(\"{}.\", prov_name)) {\n                tool.name = format!(\"{}.{}\", prov_name, tool.name);\n            }\n            tools_per_provider.push(vec![tool]);\n        }\n    }\n\n    Ok((providers, tools_per_provider))\n}\n\n/// Extracts a provider definition from a tool JSON object.\n/// Checks for \"tool_call_template\" or \"provider\" fields.\nfn tool_to_provider(tool: &Value) -> Result<Option<Value>> {\n    let tool_obj = tool\n        .as_object()\n        .ok_or_else(|| anyhow!(\"Tool must be an object\"))?;\n\n    if let Some(tmpl) = tool_obj.get(\"tool_call_template\") {\n        Ok(Some(call_templates::call_template_to_provider(\n            tmpl.clone(),\n        )?))\n    } else if let Some(prov) = tool_obj.get(\"provider\") {\n        Ok(Some(call_templates::call_template_to_provider(\n            prov.clone(),\n        )?))\n    } else {\n        Ok(None)\n    }\n}\n\n/// Creates a Provider instance from a JSON value.\n/// Handles type normalization and defaults.\nfn create_provider_from_value(mut value: Value, index: usize) -> Result<Arc<dyn Provider>> {\n    // Normalize type field: accept both \"type\" and \"provider_type\"\n    let provider_type = {\n        let obj = value\n            .as_object_mut()\n            .ok_or_else(|| anyhow!(\"Provider must be an object\"))?;\n\n        if obj.get(\"provider_type\").is_none() && obj.get(\"type\").is_none() {\n            obj.insert(\n                \"provider_type\".to_string(),\n                Value::String(\"http\".to_string()),\n            );\n            obj.insert(\"type\".to_string(), Value::String(\"http\".to_string()));\n        }\n\n        let ptype = obj\n            .get(\"provider_type\")\n            .or_else(|| obj.get(\"type\"))\n            .and_then(|v| v.as_str())\n            .ok_or_else(|| anyhow!(\"Missing provider_type field\"))?\n            .to_string();\n\n        // Ensure both fields exist\n        obj.insert(\"type\".to_string(), Value::String(ptype.clone()));\n        obj.insert(\"provider_type\".to_string(), Value::String(ptype.clone()));\n\n        // Ensure name field exists\n        if !obj.contains_key(\"name\") {\n            obj.insert(\n                \"name\".to_string(),\n                Value::String(format!(\"{}_{}\", ptype, index)),\n            );\n        }\n\n        ptype\n    };\n\n    // Create provider based on type\n    match provider_type.as_str() {\n        \"http\" => {\n            if !value\n                .get(\"http_method\")\n                .or_else(|| value.get(\"method\"))\n                .is_some()\n            {\n                if let Some(obj) = value.as_object_mut() {\n                    obj.insert(\"http_method\".to_string(), Value::String(\"GET\".to_string()));\n                }\n            }\n            if !value.get(\"url\").is_some() {\n                if let Some(obj) = value.as_object_mut() {\n                    obj.insert(\n                        \"url\".to_string(),\n                        Value::String(\"http://localhost\".to_string()),\n                    );\n                }\n            }\n            let provider: HttpProvider = serde_json::from_value(value)?;\n            Ok(Arc::new(provider))\n        }\n        \"cli\" => {\n            let provider: CliProvider = serde_json::from_value(value)?;\n            Ok(Arc::new(provider))\n        }\n        \"sse\" => {\n            let provider: SseProvider = serde_json::from_value(value)?;\n            Ok(Arc::new(provider))\n        }\n        \"websocket\" => {\n            let provider: WebSocketProvider = serde_json::from_value(value)?;\n            Ok(Arc::new(provider))\n        }\n        \"grpc\" => {\n            let provider: GrpcProvider = serde_json::from_value(value)?;\n            Ok(Arc::new(provider))\n        }\n        \"graphql\" => {\n            let provider: GraphqlProvider = serde_json::from_value(value)?;\n            Ok(Arc::new(provider))\n        }\n        \"tcp\" => {\n            let provider: TcpProvider = serde_json::from_value(value)?;\n            Ok(Arc::new(provider))\n        }\n        \"udp\" => {\n            let provider: UdpProvider = serde_json::from_value(value)?;\n            Ok(Arc::new(provider))\n        }\n        \"http_stream\" => {\n            let provider: StreamableHttpProvider = serde_json::from_value(value)?;\n            Ok(Arc::new(provider))\n        }\n        \"mcp\" => {\n            let provider: McpProvider = serde_json::from_value(value)?;\n            Ok(Arc::new(provider))\n        }\n        \"webrtc\" => {\n            let provider: WebRtcProvider = serde_json::from_value(value)?;\n            Ok(Arc::new(provider))\n        }\n        \"text\" => {\n            let provider: TextProvider = serde_json::from_value(value)?;\n            Ok(Arc::new(provider))\n        }\n        // Add more provider types as they are implemented\n        _ => Err(anyhow!(\"Unsupported provider type: {}\", provider_type)),\n    }\n}\n\n/// Substitutes variables in the JSON value using the provided configuration.\n/// Replaces ${VAR} and $VAR with values from config or environment.\nfn substitute_variables(value: &mut Value, config: &UtcpClientConfig) {\n    match value {\n        Value::String(s) => {\n            // Replace ${VAR} or $VAR patterns\n            let mut result = s.clone();\n\n            // Replace from config variables\n            for (key, val) in &config.variables {\n                result = result.replace(&format!(\"${{{}}}\", key), val);\n                result = result.replace(&format!(\"${}\", key), val);\n            }\n\n            // Also check environment variables for remaining variables\n            if result.contains('$') {\n                for key in config.variables.keys() {\n                    if let Ok(env_val) = std::env::var(key) {\n                        result = result.replace(&format!(\"${}\", key), &env_val);\n                        result = result.replace(&format!(\"${{{}}}\", key), &env_val);\n                    }\n                }\n            }\n\n            *s = result;\n        }\n        Value::Object(obj) => {\n            for (_, v) in obj.iter_mut() {\n                substitute_variables(v, config);\n            }\n        }\n        Value::Array(arr) => {\n            for item in arr.iter_mut() {\n                substitute_variables(item, config);\n            }\n        }\n        _ => {}\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Write;\n    use tempfile::NamedTempFile;\n\n    #[test]\n    fn test_parse_providers_array() {\n        let json = serde_json::json!([\n            {\"provider_type\": \"http\", \"url\": \"http://example.com\"},\n            {\"provider_type\": \"cli\", \"command_name\": \"ls\"}\n        ]);\n\n        let result = parse_providers_json(json).unwrap();\n        assert_eq!(result.len(), 2);\n    }\n\n    #[test]\n    fn test_parse_providers_object_with_array() {\n        let json = serde_json::json!({\n            \"providers\": [\n                {\"provider_type\": \"http\", \"url\": \"http://example.com\"}\n            ]\n        });\n\n        let result = parse_providers_json(json).unwrap();\n        assert_eq!(result.len(), 1);\n    }\n\n    #[test]\n    fn test_parse_single_provider() {\n        let json = serde_json::json!({\n            \"provider_type\": \"http\",\n            \"url\": \"http://example.com\"\n        });\n\n        let result = parse_providers_json(json).unwrap();\n        assert_eq!(result.len(), 1);\n    }\n\n    #[test]\n    fn test_parse_manual_call_templates_converts_to_providers() {\n        let json = serde_json::json!({\n            \"manual_call_templates\": [\n                {\n                    \"name\": \"weather_service\",\n                    \"call_template_type\": \"http\",\n                    \"url\": \"http://example.com\",\n                    \"http_method\": \"GET\"\n                },\n                {\n                    \"name\": \"cli_tool\",\n                    \"call_template_type\": \"cli\",\n                    \"command\": \"echo hi\",\n                    \"working_dir\": \"/tmp\"\n                }\n            ]\n        });\n\n        let result = parse_providers_json(json).unwrap();\n        assert_eq!(result.len(), 2);\n        assert_eq!(\n            result[0]\n                .get(\"provider_type\")\n                .and_then(|v| v.as_str())\n                .unwrap(),\n            \"http\"\n        );\n        assert_eq!(\n            result[1]\n                .get(\"command_name\")\n                .and_then(|v| v.as_str())\n                .unwrap(),\n            \"echo hi\"\n        );\n    }\n\n    #[tokio::test]\n    async fn load_providers_supports_multiple_types() {\n        let mut file = NamedTempFile::new().unwrap();\n        write!(\n            file,\n            r#\"{{\n                \"providers\": [\n                    {{ \"provider_type\": \"sse\", \"name\": \"events\", \"url\": \"http://example.com/sse\" }},\n                    {{ \"provider_type\": \"http_stream\", \"name\": \"stream\", \"url\": \"http://example.com/stream\" }}\n                ]\n            }}\"#\n        )\n        .unwrap();\n\n        let config = UtcpClientConfig::default();\n        let providers = load_providers_from_file(file.path(), &config)\n            .await\n            .unwrap();\n        assert_eq!(providers.len(), 2);\n        assert_eq!(\n            providers[0].type_(),\n            crate::providers::base::ProviderType::Sse\n        );\n        assert_eq!(\n            providers[1].type_(),\n            crate::providers::base::ProviderType::HttpStream\n        );\n    }\n\n    #[tokio::test]\n    async fn load_manual_with_tools_returns_tools() {\n        let mut file = NamedTempFile::new().unwrap();\n        write!(\n            file,\n            r#\"{{\n                \"manual_version\": \"1.0.0\",\n                \"utcp_version\": \"0.2.0\",\n                \"info\": {{ \"title\": \"demo\", \"version\": \"1.0.0\" }},\n                \"tools\": [\n                    {{\n                        \"name\": \"echo\",\n                        \"description\": \"Echo\",\n                        \"inputs\": {{ \"type\": \"object\" }},\n                        \"outputs\": {{ \"type\": \"object\" }},\n                        \"tool_call_template\": {{\n                            \"call_template_type\": \"http\",\n                            \"name\": \"http_tool\",\n                            \"url\": \"http://example.com\",\n                            \"http_method\": \"GET\"\n                        }}\n                    }}\n                ]\n            }}\"#\n        )\n        .unwrap();\n\n        let config = UtcpClientConfig::default();\n        let loaded = load_providers_with_tools_from_file(file.path(), &config)\n            .await\n            .unwrap();\n        assert_eq!(loaded.len(), 1);\n        assert!(loaded[0].tools.as_ref().unwrap()[0]\n            .name\n            .starts_with(&loaded[0].provider.name()));\n    }\n}\n",
      "line_count": 595,
      "word_count": 1619,
      "title": "Loader.Rs",
      "summary": "// Provider loading from JSON files use anyhow::{anyhow, Result};",
      "key_terms": [
        "arr",
        "grpc",
        "Result",
        "contain",
        "Substitutes",
        "extract",
        "async",
        "entry",
        "localhost",
        "If",
        "UdpProvider",
        "based",
        "check",
        "list",
        "prov",
        "info",
        "index",
        "format",
        "uses",
        "websocket"
      ],
      "timestamp": "2025-12-24T18:56:14.281735"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\migration.rs",
      "content_type": "code",
      "content": "use anyhow::{anyhow, Result};\nuse serde_json::{json, Map, Value};\n\nuse crate::call_templates;\n\n/// Best-effort migration of a v0.1 configuration object to the v1.0 shape.\n/// - providers -> manual_call_templates\n/// - provider_type -> call_template_type\n/// - carries over variables/load_variables_from if present\npub fn migrate_v01_config(config: &Value) -> Value {\n    // If already v1.0-ish object, start with a clone to avoid dropping keys.\n    let mut out = match config {\n        Value::Object(obj) => obj.clone(),\n        _ => Map::new(),\n    };\n\n    // Copy through variables and loaders if they exist\n    if let Some(vars) = config.get(\"variables\") {\n        out.insert(\"variables\".to_string(), vars.clone());\n    }\n    if let Some(loaders) = config.get(\"load_variables_from\") {\n        out.insert(\"load_variables_from\".to_string(), loaders.clone());\n    }\n\n    let mut templates = Vec::new();\n    if let Some(providers) = config.get(\"providers\") {\n        match providers {\n            Value::Array(arr) => {\n                for prov in arr {\n                    if let Some(tmpl) = provider_to_call_template(prov) {\n                        templates.push(tmpl);\n                    }\n                }\n            }\n            Value::Object(_) => {\n                if let Some(tmpl) = provider_to_call_template(providers) {\n                    templates.push(tmpl);\n                }\n            }\n            _ => {}\n        }\n    }\n\n    if !templates.is_empty() {\n        out.insert(\"manual_call_templates\".to_string(), Value::Array(templates));\n    }\n\n    if out.is_empty() {\n        config.clone()\n    } else {\n        Value::Object(out)\n    }\n}\n\n/// Best-effort migration of a v0.1 manual to v1.0 structure.\n/// - Adds manual_version/utcp_version/info\n/// - Moves parameters -> inputs, sets a default outputs schema\n/// - Moves provider -> tool_call_template (provider_type -> call_template_type)\npub fn migrate_v01_manual(manual: &Value) -> Value {\n    let mut out = Map::new();\n    out.insert(\n        \"manual_version\".to_string(),\n        Value::String(\"1.0.0\".to_string()),\n    );\n    out.insert(\n        \"utcp_version\".to_string(),\n        Value::String(\"0.2.0\".to_string()),\n    );\n\n    // Info block from provider_info if present\n    if let Some(info) = manual.get(\"provider_info\") {\n        let mut info_map = Map::new();\n        if let Some(name) = info.get(\"name\") {\n            info_map.insert(\"title\".to_string(), name.clone());\n        }\n        if let Some(version) = info.get(\"version\") {\n            info_map.insert(\"version\".to_string(), version.clone());\n        }\n        if let Some(desc) = info.get(\"description\") {\n            info_map.insert(\"description\".to_string(), desc.clone());\n        }\n        out.insert(\"info\".to_string(), Value::Object(info_map));\n    }\n\n    // Tools\n    if let Some(tools) = manual.get(\"tools\").and_then(|t| t.as_array()) {\n        let mut migrated_tools = Vec::new();\n        for tool in tools {\n            if let Some(mut tool_obj) = tool.as_object().cloned() {\n                // parameters -> inputs\n                if let Some(params) = tool_obj.remove(\"parameters\") {\n                    tool_obj.insert(\"inputs\".to_string(), params);\n                }\n                // default outputs to object if missing\n                tool_obj\n                    .entry(\"outputs\".to_string())\n                    .or_insert_with(|| json!({\"type\": \"object\"}));\n\n                // provider -> tool_call_template\n                if let Some(provider) = tool_obj.remove(\"provider\") {\n                    if let Some(mut tmpl_obj) = provider.as_object().cloned() {\n                        if let Some(ptype) = tmpl_obj\n                            .get(\"provider_type\")\n                            .and_then(|v| v.as_str())\n                            .map(|s| s.to_string())\n                        {\n                            tmpl_obj.insert(\"call_template_type\".to_string(), Value::String(ptype));\n                        }\n                        tool_obj.insert(\"tool_call_template\".to_string(), Value::Object(tmpl_obj));\n                    }\n                }\n\n                migrated_tools.push(Value::Object(tool_obj));\n            }\n        }\n        out.insert(\"tools\".to_string(), Value::Array(migrated_tools));\n    }\n\n    Value::Object(out)\n}\n\n/// Converts a provider configuration object into a call template object.\n/// Normalizes fields like `provider_type` to `call_template_type` and ensures HTTP method presence.\npub fn provider_to_call_template(provider: &Value) -> Option<Value> {\n    let mut obj = provider.as_object()?.clone();\n    let ptype = obj\n        .get(\"provider_type\")\n        .or_else(|| obj.get(\"type\"))\n        .and_then(|v| v.as_str())\n        .unwrap_or(\"http\")\n        .to_string();\n    obj.insert(\n        \"call_template_type\".to_string(),\n        Value::String(ptype.clone()),\n    );\n    // Normalize fields that differ between v0.1 providers and v1.0 templates\n    if ptype == \"http\" && obj.get(\"http_method\").is_none() {\n        if let Some(method) = obj.get(\"method\").cloned() {\n            obj.insert(\"http_method\".to_string(), method);\n        }\n    }\n    Some(Value::Object(obj))\n}\n\n/// Convert a call template into a provider representation for backward compatibility.\npub fn call_template_to_provider(template: &Value) -> Option<Value> {\n    call_templates::call_template_to_provider(template.clone()).ok()\n}\n\n/// Basic validation for a v1.0 config. Ensures manual_call_templates exist when no providers.\npub fn validate_v1_config(config: &Value) -> Result<()> {\n    let obj = config\n        .as_object()\n        .ok_or_else(|| anyhow!(\"config must be an object\"))?;\n\n    if obj.get(\"manual_call_templates\").is_none() && obj.get(\"providers\").is_none() {\n        return Err(anyhow!(\n            \"config must include manual_call_templates (v1.0) or providers (legacy)\"\n        ));\n    }\n    Ok(())\n}\n\n/// Basic validation for a v1.0 manual: requires manual_version/utcp_version, tools array,\n/// and each tool must have name/description/inputs/outputs and a tool_call_template or provider.\npub fn validate_v1_manual(manual: &Value) -> Result<()> {\n    let obj = manual\n        .as_object()\n        .ok_or_else(|| anyhow!(\"manual must be an object\"))?;\n    if !obj.contains_key(\"manual_version\") {\n        return Err(anyhow!(\"manual_version is required\"));\n    }\n    if !obj.contains_key(\"utcp_version\") {\n        return Err(anyhow!(\"utcp_version is required\"));\n    }\n\n    let tools = obj\n        .get(\"tools\")\n        .and_then(|v| v.as_array())\n        .ok_or_else(|| anyhow!(\"manual.tools must be an array\"))?;\n\n    for tool in tools {\n        let t = tool\n            .as_object()\n            .ok_or_else(|| anyhow!(\"tool must be an object\"))?;\n        if !t.contains_key(\"name\") {\n            return Err(anyhow!(\"tool missing name\"));\n        }\n        if !t.contains_key(\"description\") {\n            return Err(anyhow!(\"tool missing description\"));\n        }\n        if !t.contains_key(\"inputs\") {\n            return Err(anyhow!(\"tool missing inputs schema\"));\n        }\n        if !t.contains_key(\"outputs\") {\n            return Err(anyhow!(\"tool missing outputs schema\"));\n        }\n        if !(t.contains_key(\"tool_call_template\") || t.contains_key(\"provider\")) {\n            return Err(anyhow!(\n                \"tool missing tool_call_template (v1.0) or provider (legacy)\"\n            ));\n        }\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn migrate_config_providers_to_call_templates() {\n        let config = json!({\n            \"providers\": [\n                { \"provider_type\": \"http\", \"url\": \"http://example.com\", \"http_method\": \"GET\" },\n                { \"provider_type\": \"cli\", \"command_name\": \"echo hi\" }\n            ],\n            \"variables\": { \"API_KEY\": \"x\" }\n        });\n\n        let migrated = migrate_v01_config(&config);\n        assert!(migrated.get(\"manual_call_templates\").is_some());\n        let templates = migrated\n            .get(\"manual_call_templates\")\n            .and_then(|v| v.as_array())\n            .unwrap();\n        assert_eq!(\n            templates[0]\n                .get(\"call_template_type\")\n                .and_then(|v| v.as_str())\n                .unwrap(),\n            \"http\"\n        );\n        assert_eq!(\n            templates[1]\n                .get(\"call_template_type\")\n                .and_then(|v| v.as_str())\n                .unwrap(),\n            \"cli\"\n        );\n        assert_eq!(\n            templates[1]\n                .get(\"command_name\")\n                .and_then(|v| v.as_str())\n                .unwrap(),\n            \"echo hi\"\n        );\n    }\n\n    #[test]\n    fn migrate_manual_sets_versions_and_templates() {\n        let manual = json!({\n            \"utcp_version\": \"0.1.0\",\n            \"provider_info\": { \"name\": \"Weather\", \"version\": \"1.0.0\" },\n            \"tools\": [{\n                \"name\": \"get_weather\",\n                \"description\": \"Get weather data\",\n                \"parameters\": { \"type\": \"object\" },\n                \"provider\": { \"provider_type\": \"http\", \"url\": \"http://api\" }\n            }]\n        });\n\n        let migrated = migrate_v01_manual(&manual);\n        assert_eq!(migrated.get(\"manual_version\").unwrap(), \"1.0.0\");\n        assert_eq!(migrated.get(\"utcp_version\").unwrap(), \"0.2.0\");\n        let tools = migrated.get(\"tools\").and_then(|v| v.as_array()).unwrap();\n        let tool = tools[0].as_object().unwrap();\n        assert!(tool.get(\"inputs\").is_some());\n        assert!(tool.get(\"outputs\").is_some());\n        let tmpl = tool\n            .get(\"tool_call_template\")\n            .and_then(|v| v.as_object())\n            .unwrap();\n        assert_eq!(\n            tmpl.get(\"call_template_type\")\n                .and_then(|v| v.as_str())\n                .unwrap(),\n            \"http\"\n        );\n    }\n\n    #[test]\n    fn validate_manual_and_config() {\n        let config = json!({\n            \"manual_call_templates\": [{\n                \"call_template_type\": \"http\",\n                \"url\": \"http://example.com\",\n                \"http_method\": \"GET\"\n            }]\n        });\n        validate_v1_config(&config).unwrap();\n\n        let manual = json!({\n            \"manual_version\": \"1.0.0\",\n            \"utcp_version\": \"0.2.0\",\n            \"info\": { \"title\": \"x\", \"version\": \"1.0\" },\n            \"tools\": [{\n                \"name\": \"t\",\n                \"description\": \"d\",\n                \"inputs\": { \"type\": \"object\" },\n                \"outputs\": { \"type\": \"object\" },\n                \"tool_call_template\": {\n                    \"call_template_type\": \"http\",\n                    \"url\": \"http://example.com\",\n                    \"http_method\": \"GET\"\n                }\n            }]\n        });\n        validate_v1_manual(&manual).unwrap();\n    }\n}\n",
      "line_count": 313,
      "word_count": 865,
      "title": "Migration.Rs",
      "summary": "use anyhow::{anyhow, Result}; use serde_json::{json, Map, Value};",
      "key_terms": [
        "arr",
        "Result",
        "entry",
        "each",
        "If",
        "through",
        "prov",
        "info",
        "loaders",
        "vars",
        "cloned",
        "providers",
        "must",
        "version",
        "parameters",
        "if",
        "let",
        "that",
        "between",
        "super"
      ],
      "timestamp": "2025-12-24T18:56:14.329645"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\plugin_registration.rs",
      "content_type": "code",
      "content": "use std::collections::HashMap;\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::sync::{Arc, Mutex};\n\nuse async_trait::async_trait;\nuse serde_json::{json, Value};\n\nuse rs_utcp::call_templates::{\n    call_template_to_provider, register_call_template_handler, CALL_TEMPLATE_HANDLERS,\n};\nuse rs_utcp::providers::base::{Provider, ProviderType};\nuse rs_utcp::transports::registry::GLOBAL_COMMUNICATION_PROTOCOLS;\nuse rs_utcp::transports::stream::boxed_vec_stream;\nuse rs_utcp::transports::{\n    communication_protocols_snapshot, register_communication_protocol, CommunicationProtocol,\n};\n\nfn myproto_template_handler(template: Value) -> anyhow::Result<Value> {\n    let mut obj = template.as_object().cloned().unwrap_or_default();\n    obj.insert(\n        \"marker\".to_string(),\n        Value::String(\"handled by myproto\".into()),\n    );\n    Ok(Value::Object(obj))\n}\n\n#[derive(Debug, Default)]\nstruct CountingProtocol {\n    call_count: AtomicUsize,\n    stream_count: AtomicUsize,\n    captured_args: Mutex<Vec<HashMap<String, Value>>>,\n}\n\n#[async_trait]\nimpl CommunicationProtocol for CountingProtocol {\n    async fn register_tool_provider(\n        &self,\n        _prov: &dyn Provider,\n    ) -> anyhow::Result<Vec<rs_utcp::tools::Tool>> {\n        Ok(vec![])\n    }\n\n    async fn deregister_tool_provider(&self, _prov: &dyn Provider) -> anyhow::Result<()> {\n        Ok(())\n    }\n\n    async fn call_tool(\n        &self,\n        _tool_name: &str,\n        args: HashMap<String, Value>,\n        _prov: &dyn Provider,\n    ) -> anyhow::Result<Value> {\n        self.call_count.fetch_add(1, Ordering::SeqCst);\n        self.captured_args.lock().unwrap().push(args.clone());\n        Ok(json!({ \"echo\": args }))\n    }\n\n    async fn call_tool_stream(\n        &self,\n        _tool_name: &str,\n        args: HashMap<String, Value>,\n        _prov: &dyn Provider,\n    ) -> anyhow::Result<Box<dyn rs_utcp::transports::stream::StreamResult>> {\n        self.stream_count.fetch_add(1, Ordering::SeqCst);\n        self.captured_args.lock().unwrap().push(args.clone());\n        Ok(boxed_vec_stream(vec![json!({ \"stream\": args })]))\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct DummyProvider {\n    name: String,\n}\n\nimpl DummyProvider {\n    fn new(name: &str) -> Self {\n        Self {\n            name: name.to_string(),\n        }\n    }\n}\n\nimpl Provider for DummyProvider {\n    fn type_(&self) -> ProviderType {\n        ProviderType::Unknown\n    }\n\n    fn name(&self) -> String {\n        self.name.clone()\n    }\n\n    fn as_any(&self) -> &dyn std::any::Any {\n        self\n    }\n}\n\n#[test]\nfn registering_custom_plugins_makes_them_available() {\n    let key = \"myproto_test\";\n    let registry_before = communication_protocols_snapshot();\n\n    register_call_template_handler(key, myproto_template_handler);\n    let provider = call_template_to_provider(json!({ \"call_template_type\": key })).unwrap();\n    assert_eq!(\n        provider,\n        json!({ \"call_template_type\": key, \"marker\": \"handled by myproto\" })\n    );\n\n    register_communication_protocol(key, Arc::new(CountingProtocol::default()));\n    let snapshot = communication_protocols_snapshot();\n    assert!(\n        snapshot.get(key).is_some(),\n        \"custom communication protocol should be registered\"\n    );\n\n    // Clean up globals to avoid leaking state across tests.\n    if let Ok(mut handlers) = CALL_TEMPLATE_HANDLERS.write() {\n        handlers.remove(key);\n    }\n    if let Ok(mut reg) = GLOBAL_COMMUNICATION_PROTOCOLS.write() {\n        *reg = registry_before;\n    }\n}\n\n#[tokio::test]\nasync fn custom_protocol_call_tool_and_stream_are_invoked() {\n    let key = \"myproto_calls\";\n    let registry_before = communication_protocols_snapshot();\n    let protocol = Arc::new(CountingProtocol::default());\n    register_communication_protocol(key, protocol.clone());\n\n    let snapshot = communication_protocols_snapshot();\n    let proto = snapshot\n        .get(key)\n        .expect(\"custom protocol should be visible in snapshot\");\n\n    let provider = DummyProvider::new(\"dummy\");\n    let mut args = HashMap::new();\n    args.insert(\"foo\".into(), json!(1));\n\n    let call_response = proto\n        .call_tool(\"demo.tool\", args.clone(), &provider)\n        .await\n        .unwrap();\n    assert_eq!(call_response, json!({ \"echo\": args.clone() }));\n    assert_eq!(protocol.call_count.load(Ordering::SeqCst), 1);\n\n    let mut stream = proto\n        .call_tool_stream(\"demo.stream\", args.clone(), &provider)\n        .await\n        .unwrap();\n    assert_eq!(\n        stream.next().await.unwrap(),\n        Some(json!({ \"stream\": args.clone() }))\n    );\n    assert_eq!(stream.next().await.unwrap(), None);\n    assert_eq!(protocol.stream_count.load(Ordering::SeqCst), 1);\n\n    let captured = protocol.captured_args.lock().unwrap();\n    assert_eq!(\n        captured.len(),\n        2,\n        \"call_tool and call_tool_stream should capture args\"\n    );\n\n    if let Ok(mut reg) = GLOBAL_COMMUNICATION_PROTOCOLS.write() {\n        *reg = registry_before;\n    }\n}\n",
      "line_count": 170,
      "word_count": 383,
      "title": "Plugin Registration.Rs",
      "summary": "use std::collections::HashMap; use std::sync::atomic::{AtomicUsize, Ordering};",
      "key_terms": [
        "up",
        "Result",
        "async",
        "Clone",
        "cloned",
        "providers",
        "Self",
        "lock",
        "snapshot",
        "let",
        "if",
        "load",
        "demo",
        "struct",
        "dummy",
        "leaking",
        "await",
        "collections",
        "Value",
        "echo"
      ],
      "timestamp": "2025-12-24T18:56:14.366365"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\security.rs",
      "content_type": "code",
      "content": "use anyhow::{anyhow, Result};\nuse std::path::PathBuf;\n\n/// Security utilities for validating inputs and preventing common vulnerabilities.\n\n/// Validates that a file path is safe and doesn't allow directory traversal.\n///\n/// # Arguments\n/// * `path` - The path to validate\n/// * `allowed_base` - Optional base directory that the path must be within\n///\n/// # Returns\n/// Canonicalized path if valid, error otherwise\npub fn validate_file_path(path: &str, allowed_base: Option<&str>) -> Result<PathBuf> {\n    let path_buf = PathBuf::from(path);\n\n    // Prevent absolute paths from escaping the base\n    if let Some(base) = allowed_base {\n        let canon_path = std::fs::canonicalize(&path_buf)\n            .map_err(|e| anyhow!(\"Failed to canonicalize path '{}': {}\", path, e))?;\n\n        let canon_base = std::fs::canonicalize(base)\n            .map_err(|e| anyhow!(\"Failed to canonicalize base '{}': {}\", base, e))?;\n\n        if !canon_path.starts_with(canon_base) {\n            return Err(anyhow!(\n                \"Path '{}' is outside allowed directory '{}'\",\n                path,\n                base\n            ));\n        }\n\n        Ok(canon_path)\n    } else {\n        // Just canonicalize without base restriction\n        std::fs::canonicalize(&path_buf).map_err(|e| anyhow!(\"Invalid path '{}': {}\", path, e))\n    }\n}\n\n/// Validates a command name against an allowlist.\n/// This helps prevent command injection attacks.\n///\n/// # Arguments\n/// * `command` - The command to validate\n/// * `allowed_commands` - List of permitted command names or paths\n///\n/// # Returns\n/// Ok if command is in allowlist, error otherwise\npub fn validate_command(command: &str, allowed_commands: &[&str]) -> Result<()> {\n    // Check for shell metacharacters that could enable injection\n    const DANGEROUS_CHARS: &[char] = &[\n        '|', '&', ';', '\\n', '`', '$', '(', ')', '<', '>', '\"', '\\'', '\\\\',\n    ];\n\n    if command.chars().any(|c| DANGEROUS_CHARS.contains(&c)) {\n        return Err(anyhow!(\n            \"Command contains dangerous characters: '{}'\",\n            command\n        ));\n    }\n\n    // Extract just the command name (first component of path)\n    let path_buf = PathBuf::from(command);\n    let cmd_name = path_buf\n        .file_name()\n        .and_then(|s| s.to_str())\n        .unwrap_or(command);\n\n    // Check against allowlist\n    if !allowed_commands.is_empty() && !allowed_commands.contains(&cmd_name) {\n        return Err(anyhow!(\n            \"Command '{}' is not in the allowed list. Permitted commands: {:?}\",\n            cmd_name,\n            allowed_commands\n        ));\n    }\n\n    Ok(())\n}\n\n/// Validates command arguments for potentially dangerous content.\n///\n/// # Arguments\n/// * `args` - The arguments to validate\n///\n/// # Returns\n/// Ok if arguments appear safe, error otherwise\npub fn validate_command_args(args: &[String]) -> Result<()> {\n    for arg in args {\n        // Check for shell injection patterns\n        if arg.contains(\"&&\") || arg.contains(\"||\") || arg.contains(\";\") || arg.contains(\"|\") {\n            return Err(anyhow!(\n                \"Argument contains dangerous shell operators: '{}'\",\n                arg\n            ));\n        }\n\n        // Check for command substitution\n        if arg.contains(\"$(\") || arg.contains(\"`\") {\n            return Err(anyhow!(\"Argument contains command substitution: '{}'\", arg));\n        }\n    }\n\n    Ok(())\n}\n\n/// Validates that a URL uses a secure protocol (https://, wss://, etc.)\n///\n/// # Arguments\n/// * `url` - The URL to validate\n/// * `require_tls` - Whether to enforce TLS/SSL\n///\n/// # Returns\n/// Ok if URL is valid and secure, error otherwise\npub fn validate_url_security(url: &str, require_tls: bool) -> Result<()> {\n    let url_lower = url.to_lowercase();\n\n    if require_tls {\n        if !(url_lower.starts_with(\"https://\")\n            || url_lower.starts_with(\"wss://\")\n            || url_lower.starts_with(\"grpcs://\"))\n        {\n            return Err(anyhow!(\n                \"URL must use TLS/SSL (https://, wss://, grpcs://): '{}'\",\n                url\n            ));\n        }\n    }\n\n    // Warn about localhost/127.0.0.1 in production (but allow it)\n    if url_lower.contains(\"localhost\") || url_lower.contains(\"127.0.0.1\") {\n        // This is just informational - don't fail\n        eprintln!(\"Warning: URL uses localhost/127.0.0.1: '{}'\", url);\n    }\n\n    Ok(())\n}\n\n/// Validates the size of input data to prevent DoS attacks.\n///\n/// # Arguments\n/// * `data` - The data to check\n/// * `max_size` - Maximum allowed size in bytes\n///\n/// # Returns\n/// Ok if data is within limits, error otherwise\npub fn validate_size_limit(data: &[u8], max_size: usize) -> Result<()> {\n    if data.len() > max_size {\n        return Err(anyhow!(\n            \"Data size {} bytes exceeds maximum allowed size {} bytes\",\n            data.len(),\n            max_size\n        ));\n    }\n\n    Ok(())\n}\n\n/// Validates a timeout value to ensure it's reasonable.\n///\n/// # Arguments\n/// * `timeout_ms` - Timeout in milliseconds\n/// * `max_timeout_ms` - Maximum allowed timeout\n///\n/// # Returns\n/// Ok if timeout is within limits, error otherwise\npub fn validate_timeout(timeout_ms: u64, max_timeout_ms: u64) -> Result<()> {\n    if timeout_ms == 0 {\n        return Err(anyhow!(\"Timeout cannot be zero\"));\n    }\n\n    if timeout_ms > max_timeout_ms {\n        return Err(anyhow!(\n            \"Timeout {}ms exceeds maximum allowed {}ms\",\n            timeout_ms,\n            max_timeout_ms\n        ));\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_validate_command_rejects_dangerous_chars() {\n        let allowed = vec![\"python3\", \"node\"];\n\n        assert!(validate_command(\"python3\", &allowed).is_ok());\n        assert!(validate_command(\"ls; rm -rf /\", &[]).is_err());\n        assert!(validate_command(\"cat /etc/passwd | grep root\", &[]).is_err());\n        assert!(validate_command(\"echo `whoami`\", &[]).is_err());\n        assert!(validate_command(\"cmd && evil\", &[]).is_err());\n    }\n\n    #[test]\n    fn test_validate_command_allowlist() {\n        let allowed = vec![\"python3\", \"node\", \"npm\"];\n\n        assert!(validate_command(\"python3\", &allowed).is_ok());\n        assert!(validate_command(\"node\", &allowed).is_ok());\n        assert!(validate_command(\"bash\", &allowed).is_err());\n        assert!(validate_command(\"/usr/bin/python3\", &allowed).is_ok()); // Path is ok if basename matches\n    }\n\n    #[test]\n    fn test_validate_command_args() {\n        assert!(validate_command_args(&[\"--help\".to_string()]).is_ok());\n        assert!(validate_command_args(&[\"-v\".to_string(), \"file.txt\".to_string()]).is_ok());\n\n        assert!(validate_command_args(&[\"arg && evil\".to_string()]).is_err());\n        assert!(validate_command_args(&[\"$(whoami)\".to_string()]).is_err());\n        assert!(validate_command_args(&[\"`id`\".to_string()]).is_err());\n        assert!(validate_command_args(&[\"arg | grep\".to_string()]).is_err());\n    }\n\n    #[test]\n    fn test_validate_url_security() {\n        assert!(validate_url_security(\"https://api.example.com\", true).is_ok());\n        assert!(validate_url_security(\"wss://ws.example.com\", true).is_ok());\n        assert!(validate_url_security(\"http://api.example.com\", true).is_err());\n        assert!(validate_url_security(\"http://api.example.com\", false).is_ok());\n    }\n\n    #[test]\n    fn test_validate_size_limit() {\n        let data = vec![0u8; 1000];\n        assert!(validate_size_limit(&data, 2000).is_ok());\n        assert!(validate_size_limit(&data, 500).is_err());\n    }\n\n    #[test]\n    fn test_validate_timeout() {\n        assert!(validate_timeout(1000, 60000).is_ok());\n        assert!(validate_timeout(0, 60000).is_err());\n        assert!(validate_timeout(100000, 60000).is_err());\n    }\n\n    #[test]\n    fn test_validate_file_path() {\n        let temp_dir = TempDir::new().unwrap();\n        let temp_path = temp_dir.path();\n\n        // Create a test file\n        let test_file = temp_path.join(\"test.txt\");\n        fs::write(&test_file, b\"test\").unwrap();\n\n        // Valid path within base\n        let result = validate_file_path(\n            test_file.to_str().unwrap(),\n            Some(temp_path.to_str().unwrap()),\n        );\n        assert!(result.is_ok());\n\n        // Path outside base should fail\n        let outside_path = \"/tmp/outside.txt\";\n        let result = validate_file_path(outside_path, Some(temp_path.to_str().unwrap()));\n        // This will fail because /tmp/outside.txt doesn't exist or is outside temp_dir\n        assert!(result.is_err());\n    }\n}\n",
      "line_count": 266,
      "word_count": 851,
      "title": "Security.Rs",
      "summary": "use anyhow::{anyhow, Result}; use std::path::PathBuf;",
      "key_terms": [
        "Timeout",
        "const",
        "Result",
        "passwd",
        "paths",
        "localhost",
        "error",
        "chars",
        "canonicalize",
        "permitted",
        "etc",
        "Warn",
        "check",
        "list",
        "id",
        "uses",
        "metacharacters",
        "whoami",
        "must",
        "appear"
      ],
      "timestamp": "2025-12-24T18:56:14.403885"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\spec.rs",
      "content_type": "code",
      "content": "use serde::{Deserialize, Serialize};\n\n/// v1.0 call template model (simplified to cover current transports).\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub struct CallTemplate {\n    /// The type of the call template (e.g., \"http\", \"cli\").\n    pub call_template_type: String,\n    /// Optional name for the template.\n    #[serde(default)]\n    pub name: Option<String>,\n    /// URL for HTTP-based templates.\n    #[serde(default)]\n    pub url: Option<String>,\n    /// HTTP method for HTTP-based templates.\n    #[serde(default)]\n    pub http_method: Option<String>,\n    /// Command string for CLI-based templates.\n    #[serde(default)]\n    pub command: Option<String>,\n    /// List of commands for multi-step CLI templates.\n    #[serde(default)]\n    pub commands: Option<Vec<TemplateCommand>>,\n    /// Environment variables to set for the command.\n    #[serde(default)]\n    pub env_vars: Option<std::collections::HashMap<String, String>>,\n    /// Working directory for the command.\n    #[serde(default)]\n    pub working_dir: Option<String>,\n    /// List of allowed communication protocol types (e.g., [\"http\", \"cli\"]).\n    /// If undefined, null, or empty, defaults to only allowing this template's own call_template_type.\n    /// This provides secure-by-default behavior where a manual can only register/call tools\n    /// that use its own protocol unless explicitly configured otherwise.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    #[serde(default)]\n    pub allowed_communication_protocols: Option<Vec<String>>,\n}\n\n/// Represents a single command in a multi-step CLI template.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TemplateCommand {\n    /// The command string to execute.\n    pub command: String,\n    /// Whether to append the output of this command to the final result.\n    #[serde(default)]\n    pub append_to_final_output: Option<bool>,\n}\n\n/// Metadata information about a manual.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ManualInfo {\n    /// Title of the manual.\n    pub title: String,\n    /// Version of the manual.\n    pub version: String,\n    #[serde(default)]\n    /// Optional description of the manual.\n    pub description: Option<String>,\n}\n\n/// Represents a tool definition within a manual.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ManualTool {\n    /// Name of the tool.\n    pub name: String,\n    /// Description of what the tool does.\n    pub description: String,\n    /// JSON schema for the tool's inputs.\n    pub inputs: serde_json::Value,\n    /// JSON schema for the tool's outputs.\n    pub outputs: serde_json::Value,\n    /// Tags associated with the tool.\n    #[serde(default)]\n    pub tags: Vec<String>,\n    /// The call template defining how to execute the tool.\n    #[serde(default)]\n    pub tool_call_template: Option<CallTemplate>,\n    /// Legacy provider definition (deprecated).\n    #[serde(default)]\n    pub provider: Option<CallTemplate>, // legacy in-tool provider\n}\n\n/// Represents a v1.0 Manual structure containing tool definitions and metadata.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ManualV1 {\n    /// Version of the manual format.\n    pub manual_version: String,\n    /// Version of the UTCP protocol.\n    pub utcp_version: String,\n    /// Metadata about the manual.\n    pub info: ManualInfo,\n    /// List of tools defined in the manual.\n    pub tools: Vec<ManualTool>,\n    /// List of allowed communication protocol types for tools in this manual.\n    /// If undefined, null, or empty, defaults to only allowing each tool's own protocol type.\n    /// This provides secure-by-default behavior.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    #[serde(default)]\n    pub allowed_communication_protocols: Option<Vec<String>>,\n}\n",
      "line_count": 101,
      "word_count": 439,
      "title": "Spec.Rs",
      "summary": "use serde::{Deserialize, Serialize}; /// v1.0 call template model (simplified to cover current transports).",
      "key_terms": [
        "output",
        "null",
        "each",
        "If",
        "based",
        "info",
        "Clone",
        "format",
        "only",
        "associated",
        "string",
        "version",
        "Tags",
        "model",
        "Represents",
        "Environment",
        "that",
        "Version",
        "behavior",
        "otherwise"
      ],
      "timestamp": "2025-12-24T18:56:14.441706"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\auth\\mod.rs",
      "content_type": "code",
      "content": "use serde::{Deserialize, Serialize};\nuse thiserror::Error;\n\n/// Supported authentication mechanisms across transports.\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum AuthType {\n    ApiKey,\n    Basic,\n    OAuth2,\n}\n\n/// Contract implemented by auth configs to validate their state and report their type.\npub trait Auth: Send + Sync + std::fmt::Debug {\n    fn auth_type(&self) -> AuthType;\n    fn validate(&self) -> Result<(), AuthError>;\n}\n\n/// Validation errors emitted by auth implementations.\n#[derive(Error, Debug)]\npub enum AuthError {\n    #[error(\"API key must be provided\")]\n    MissingApiKey,\n    #[error(\"Location must be 'header', 'query', or 'cookie'\")]\n    InvalidLocation,\n    #[error(\"Username must be provided\")]\n    MissingUsername,\n    #[error(\"Password must be provided\")]\n    MissingPassword,\n    #[error(\"Token URL must be provided\")]\n    MissingTokenUrl,\n    #[error(\"Client ID must be provided\")]\n    MissingClientId,\n    #[error(\"Client secret must be provided\")]\n    MissingClientSecret,\n}\n\n/// API key authentication descriptor used by HTTP-like transports.\n#[derive(Clone, Serialize, Deserialize)]\npub struct ApiKeyAuth {\n    pub auth_type: AuthType,\n    pub api_key: String,\n    pub var_name: String,\n    pub location: String, // \"header\", \"query\", or \"cookie\"\n}\n\nimpl std::fmt::Debug for ApiKeyAuth {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.debug_struct(\"ApiKeyAuth\")\n            .field(\"auth_type\", &self.auth_type)\n            .field(\"api_key\", &\"[REDACTED]\")\n            .field(\"var_name\", &self.var_name)\n            .field(\"location\", &self.location)\n            .finish()\n    }\n}\n\nimpl ApiKeyAuth {\n    /// Build an API key auth config with common defaults.\n    pub fn new(api_key: String) -> Self {\n        Self {\n            auth_type: AuthType::ApiKey,\n            api_key,\n            var_name: \"X-Api-Key\".to_string(),\n            location: \"header\".to_string(),\n        }\n    }\n}\n\nimpl Auth for ApiKeyAuth {\n    fn auth_type(&self) -> AuthType {\n        AuthType::ApiKey\n    }\n\n    fn validate(&self) -> Result<(), AuthError> {\n        if self.api_key.is_empty() {\n            return Err(AuthError::MissingApiKey);\n        }\n        match self.location.as_str() {\n            \"header\" | \"query\" | \"cookie\" => Ok(()),\n            _ => Err(AuthError::InvalidLocation),\n        }\n    }\n}\n\n/// Basic authentication descriptor.\n#[derive(Clone, Serialize, Deserialize)]\npub struct BasicAuth {\n    pub auth_type: AuthType,\n    pub username: String,\n    pub password: String,\n}\n\nimpl std::fmt::Debug for BasicAuth {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.debug_struct(\"BasicAuth\")\n            .field(\"auth_type\", &self.auth_type)\n            .field(\"username\", &self.username)\n            .field(\"password\", &\"[REDACTED]\")\n            .finish()\n    }\n}\n\nimpl BasicAuth {\n    /// Build a basic auth config from username/password.\n    pub fn new(username: String, password: String) -> Self {\n        Self {\n            auth_type: AuthType::Basic,\n            username,\n            password,\n        }\n    }\n}\n\nimpl Auth for BasicAuth {\n    fn auth_type(&self) -> AuthType {\n        AuthType::Basic\n    }\n\n    fn validate(&self) -> Result<(), AuthError> {\n        if self.username.is_empty() {\n            return Err(AuthError::MissingUsername);\n        }\n        if self.password.is_empty() {\n            return Err(AuthError::MissingPassword);\n        }\n        Ok(())\n    }\n}\n\n/// OAuth2 client credentials descriptor.\n#[derive(Clone, Serialize, Deserialize)]\npub struct OAuth2Auth {\n    pub auth_type: AuthType,\n    pub token_url: String,\n    pub client_id: String,\n    pub client_secret: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub scope: Option<String>,\n}\n\nimpl std::fmt::Debug for OAuth2Auth {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.debug_struct(\"OAuth2Auth\")\n            .field(\"auth_type\", &self.auth_type)\n            .field(\"token_url\", &self.token_url)\n            .field(\"client_id\", &self.client_id)\n            .field(\"client_secret\", &\"[REDACTED]\")\n            .field(\"scope\", &self.scope)\n            .finish()\n    }\n}\n\nimpl OAuth2Auth {\n    pub fn new(\n        token_url: String,\n        client_id: String,\n        client_secret: String,\n        scope: Option<String>,\n    ) -> Self {\n        Self {\n            auth_type: AuthType::OAuth2,\n            token_url,\n            client_id,\n            client_secret,\n            scope,\n        }\n    }\n}\n\nimpl Auth for OAuth2Auth {\n    fn auth_type(&self) -> AuthType {\n        AuthType::OAuth2\n    }\n\n    fn validate(&self) -> Result<(), AuthError> {\n        if self.token_url.is_empty() {\n            return Err(AuthError::MissingTokenUrl);\n        }\n        if self.client_id.is_empty() {\n            return Err(AuthError::MissingClientId);\n        }\n        if self.client_secret.is_empty() {\n            return Err(AuthError::MissingClientSecret);\n        }\n        Ok(())\n    }\n}\n\n/// Untagged wrapper that allows serde to deserialize any auth config and still expose the `Auth` trait.\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum AuthConfig {\n    ApiKey(ApiKeyAuth),\n    Basic(BasicAuth),\n    OAuth2(OAuth2Auth),\n}\n\nimpl Auth for AuthConfig {\n    fn auth_type(&self) -> AuthType {\n        match self {\n            AuthConfig::ApiKey(auth) => auth.auth_type(),\n            AuthConfig::Basic(auth) => auth.auth_type(),\n            AuthConfig::OAuth2(auth) => auth.auth_type(),\n        }\n    }\n\n    fn validate(&self) -> Result<(), AuthError> {\n        match self {\n            AuthConfig::ApiKey(auth) => auth.validate(),\n            AuthConfig::Basic(auth) => auth.validate(),\n            AuthConfig::OAuth2(auth) => auth.validate(),\n        }\n    }\n}\n",
      "line_count": 216,
      "word_count": 554,
      "title": "Mod.Rs",
      "summary": "use serde::{Deserialize, Serialize}; use thiserror::Error;",
      "key_terms": [
        "implementations",
        "Result",
        "AuthError",
        "error",
        "REDACTED",
        "fmt",
        "MissingPassword",
        "Clone",
        "cookie",
        "Sync",
        "Password",
        "must",
        "finish",
        "Error",
        "Self",
        "AuthConfig",
        "if",
        "Contract",
        "that",
        "Supported"
      ],
      "timestamp": "2025-12-24T18:56:14.473486"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\grpcpb\\mod.rs",
      "content_type": "code",
      "content": "pub mod generated {\n    include!(\"generated/grpcpb.rs\");\n}\n",
      "line_count": 4,
      "word_count": 6,
      "title": "Mod.Rs",
      "summary": "pub mod generated { include!(\"generated/grpcpb.rs\");",
      "key_terms": [
        "generated",
        "rs",
        "pub",
        "include",
        "grpcpb",
        "mod"
      ],
      "timestamp": "2025-12-24T18:56:14.489363"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\grpcpb\\generated\\grpcpb.rs",
      "content_type": "code",
      "content": "// This file is @generated by prost-build.\n#[allow(clippy::derive_partial_eq_without_eq)]\n#[derive(Clone, PartialEq, ::prost::Message)]\npub struct Empty {}\n#[allow(clippy::derive_partial_eq_without_eq)]\n#[derive(Clone, PartialEq, ::prost::Message)]\npub struct Tool {\n    #[prost(string, tag = \"1\")]\n    pub name: ::prost::alloc::string::String,\n    #[prost(string, tag = \"2\")]\n    pub description: ::prost::alloc::string::String,\n}\n#[allow(clippy::derive_partial_eq_without_eq)]\n#[derive(Clone, PartialEq, ::prost::Message)]\npub struct Manual {\n    #[prost(string, tag = \"1\")]\n    pub version: ::prost::alloc::string::String,\n    #[prost(message, repeated, tag = \"2\")]\n    pub tools: ::prost::alloc::vec::Vec<Tool>,\n}\n#[allow(clippy::derive_partial_eq_without_eq)]\n#[derive(Clone, PartialEq, ::prost::Message)]\npub struct ToolCallRequest {\n    #[prost(string, tag = \"1\")]\n    pub tool: ::prost::alloc::string::String,\n    #[prost(string, tag = \"2\")]\n    pub args_json: ::prost::alloc::string::String,\n}\n#[allow(clippy::derive_partial_eq_without_eq)]\n#[derive(Clone, PartialEq, ::prost::Message)]\npub struct ToolCallResponse {\n    #[prost(string, tag = \"1\")]\n    pub result_json: ::prost::alloc::string::String,\n}\n/// Generated client implementations.\npub mod utcp_service_client {\n    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]\n    use tonic::codegen::*;\n    use tonic::codegen::http::Uri;\n    #[derive(Debug, Clone)]\n    pub struct UtcpServiceClient<T> {\n        inner: tonic::client::Grpc<T>,\n    }\n    impl UtcpServiceClient<tonic::transport::Channel> {\n        /// Attempt to create a new client by connecting to a given endpoint.\n        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>\n        where\n            D: TryInto<tonic::transport::Endpoint>,\n            D::Error: Into<StdError>,\n        {\n            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;\n            Ok(Self::new(conn))\n        }\n    }\n    impl<T> UtcpServiceClient<T>\n    where\n        T: tonic::client::GrpcService<tonic::body::BoxBody>,\n        T::Error: Into<StdError>,\n        T::ResponseBody: Body<Data = Bytes> + Send + 'static,\n        <T::ResponseBody as Body>::Error: Into<StdError> + Send,\n    {\n        pub fn new(inner: T) -> Self {\n            let inner = tonic::client::Grpc::new(inner);\n            Self { inner }\n        }\n        pub fn with_origin(inner: T, origin: Uri) -> Self {\n            let inner = tonic::client::Grpc::with_origin(inner, origin);\n            Self { inner }\n        }\n        pub fn with_interceptor<F>(\n            inner: T,\n            interceptor: F,\n        ) -> UtcpServiceClient<InterceptedService<T, F>>\n        where\n            F: tonic::service::Interceptor,\n            T::ResponseBody: Default,\n            T: tonic::codegen::Service<\n                http::Request<tonic::body::BoxBody>,\n                Response = http::Response<\n                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,\n                >,\n            >,\n            <T as tonic::codegen::Service<\n                http::Request<tonic::body::BoxBody>,\n            >>::Error: Into<StdError> + Send + Sync,\n        {\n            UtcpServiceClient::new(InterceptedService::new(inner, interceptor))\n        }\n        /// Compress requests with the given encoding.\n        ///\n        /// This requires the server to support it otherwise it might respond with an\n        /// error.\n        #[must_use]\n        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {\n            self.inner = self.inner.send_compressed(encoding);\n            self\n        }\n        /// Enable decompressing responses.\n        #[must_use]\n        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {\n            self.inner = self.inner.accept_compressed(encoding);\n            self\n        }\n        /// Limits the maximum size of a decoded message.\n        ///\n        /// Default: `4MB`\n        #[must_use]\n        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {\n            self.inner = self.inner.max_decoding_message_size(limit);\n            self\n        }\n        /// Limits the maximum size of an encoded message.\n        ///\n        /// Default: `usize::MAX`\n        #[must_use]\n        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {\n            self.inner = self.inner.max_encoding_message_size(limit);\n            self\n        }\n        pub async fn get_manual(\n            &mut self,\n            request: impl tonic::IntoRequest<super::Empty>,\n        ) -> std::result::Result<tonic::Response<super::Manual>, tonic::Status> {\n            self.inner\n                .ready()\n                .await\n                .map_err(|e| {\n                    tonic::Status::new(\n                        tonic::Code::Unknown,\n                        format!(\"Service was not ready: {}\", e.into()),\n                    )\n                })?;\n            let codec = tonic::codec::ProstCodec::default();\n            let path = http::uri::PathAndQuery::from_static(\n                \"/grpcpb.UTCPService/GetManual\",\n            );\n            let mut req = request.into_request();\n            req.extensions_mut()\n                .insert(GrpcMethod::new(\"grpcpb.UTCPService\", \"GetManual\"));\n            self.inner.unary(req, path, codec).await\n        }\n        pub async fn call_tool(\n            &mut self,\n            request: impl tonic::IntoRequest<super::ToolCallRequest>,\n        ) -> std::result::Result<\n            tonic::Response<super::ToolCallResponse>,\n            tonic::Status,\n        > {\n            self.inner\n                .ready()\n                .await\n                .map_err(|e| {\n                    tonic::Status::new(\n                        tonic::Code::Unknown,\n                        format!(\"Service was not ready: {}\", e.into()),\n                    )\n                })?;\n            let codec = tonic::codec::ProstCodec::default();\n            let path = http::uri::PathAndQuery::from_static(\n                \"/grpcpb.UTCPService/CallTool\",\n            );\n            let mut req = request.into_request();\n            req.extensions_mut()\n                .insert(GrpcMethod::new(\"grpcpb.UTCPService\", \"CallTool\"));\n            self.inner.unary(req, path, codec).await\n        }\n        pub async fn call_tool_stream(\n            &mut self,\n            request: impl tonic::IntoRequest<super::ToolCallRequest>,\n        ) -> std::result::Result<\n            tonic::Response<tonic::codec::Streaming<super::ToolCallResponse>>,\n            tonic::Status,\n        > {\n            self.inner\n                .ready()\n                .await\n                .map_err(|e| {\n                    tonic::Status::new(\n                        tonic::Code::Unknown,\n                        format!(\"Service was not ready: {}\", e.into()),\n                    )\n                })?;\n            let codec = tonic::codec::ProstCodec::default();\n            let path = http::uri::PathAndQuery::from_static(\n                \"/grpcpb.UTCPService/CallToolStream\",\n            );\n            let mut req = request.into_request();\n            req.extensions_mut()\n                .insert(GrpcMethod::new(\"grpcpb.UTCPService\", \"CallToolStream\"));\n            self.inner.server_streaming(req, path, codec).await\n        }\n    }\n}\n/// Generated server implementations.\npub mod utcp_service_server {\n    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]\n    use tonic::codegen::*;\n    /// Generated trait containing gRPC methods that should be implemented for use with UtcpServiceServer.\n    #[async_trait]\n    pub trait UtcpService: Send + Sync + 'static {\n        async fn get_manual(\n            &self,\n            request: tonic::Request<super::Empty>,\n        ) -> std::result::Result<tonic::Response<super::Manual>, tonic::Status>;\n        async fn call_tool(\n            &self,\n            request: tonic::Request<super::ToolCallRequest>,\n        ) -> std::result::Result<\n            tonic::Response<super::ToolCallResponse>,\n            tonic::Status,\n        >;\n        /// Server streaming response type for the CallToolStream method.\n        type CallToolStreamStream: tonic::codegen::tokio_stream::Stream<\n                Item = std::result::Result<super::ToolCallResponse, tonic::Status>,\n            >\n            + Send\n            + 'static;\n        async fn call_tool_stream(\n            &self,\n            request: tonic::Request<super::ToolCallRequest>,\n        ) -> std::result::Result<\n            tonic::Response<Self::CallToolStreamStream>,\n            tonic::Status,\n        >;\n    }\n    #[derive(Debug)]\n    pub struct UtcpServiceServer<T: UtcpService> {\n        inner: _Inner<T>,\n        accept_compression_encodings: EnabledCompressionEncodings,\n        send_compression_encodings: EnabledCompressionEncodings,\n        max_decoding_message_size: Option<usize>,\n        max_encoding_message_size: Option<usize>,\n    }\n    struct _Inner<T>(Arc<T>);\n    impl<T: UtcpService> UtcpServiceServer<T> {\n        pub fn new(inner: T) -> Self {\n            Self::from_arc(Arc::new(inner))\n        }\n        pub fn from_arc(inner: Arc<T>) -> Self {\n            let inner = _Inner(inner);\n            Self {\n                inner,\n                accept_compression_encodings: Default::default(),\n                send_compression_encodings: Default::default(),\n                max_decoding_message_size: None,\n                max_encoding_message_size: None,\n            }\n        }\n        pub fn with_interceptor<F>(\n            inner: T,\n            interceptor: F,\n        ) -> InterceptedService<Self, F>\n        where\n            F: tonic::service::Interceptor,\n        {\n            InterceptedService::new(Self::new(inner), interceptor)\n        }\n        /// Enable decompressing requests with the given encoding.\n        #[must_use]\n        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {\n            self.accept_compression_encodings.enable(encoding);\n            self\n        }\n        /// Compress responses with the given encoding, if the client supports it.\n        #[must_use]\n        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {\n            self.send_compression_encodings.enable(encoding);\n            self\n        }\n        /// Limits the maximum size of a decoded message.\n        ///\n        /// Default: `4MB`\n        #[must_use]\n        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {\n            self.max_decoding_message_size = Some(limit);\n            self\n        }\n        /// Limits the maximum size of an encoded message.\n        ///\n        /// Default: `usize::MAX`\n        #[must_use]\n        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {\n            self.max_encoding_message_size = Some(limit);\n            self\n        }\n    }\n    impl<T, B> tonic::codegen::Service<http::Request<B>> for UtcpServiceServer<T>\n    where\n        T: UtcpService,\n        B: Body + Send + 'static,\n        B::Error: Into<StdError> + Send + 'static,\n    {\n        type Response = http::Response<tonic::body::BoxBody>;\n        type Error = std::convert::Infallible;\n        type Future = BoxFuture<Self::Response, Self::Error>;\n        fn poll_ready(\n            &mut self,\n            _cx: &mut Context<'_>,\n        ) -> Poll<std::result::Result<(), Self::Error>> {\n            Poll::Ready(Ok(()))\n        }\n        fn call(&mut self, req: http::Request<B>) -> Self::Future {\n            let inner = self.inner.clone();\n            match req.uri().path() {\n                \"/grpcpb.UTCPService/GetManual\" => {\n                    #[allow(non_camel_case_types)]\n                    struct GetManualSvc<T: UtcpService>(pub Arc<T>);\n                    impl<T: UtcpService> tonic::server::UnaryService<super::Empty>\n                    for GetManualSvc<T> {\n                        type Response = super::Manual;\n                        type Future = BoxFuture<\n                            tonic::Response<Self::Response>,\n                            tonic::Status,\n                        >;\n                        fn call(\n                            &mut self,\n                            request: tonic::Request<super::Empty>,\n                        ) -> Self::Future {\n                            let inner = Arc::clone(&self.0);\n                            let fut = async move {\n                                <T as UtcpService>::get_manual(&inner, request).await\n                            };\n                            Box::pin(fut)\n                        }\n                    }\n                    let accept_compression_encodings = self.accept_compression_encodings;\n                    let send_compression_encodings = self.send_compression_encodings;\n                    let max_decoding_message_size = self.max_decoding_message_size;\n                    let max_encoding_message_size = self.max_encoding_message_size;\n                    let inner = self.inner.clone();\n                    let fut = async move {\n                        let inner = inner.0;\n                        let method = GetManualSvc(inner);\n                        let codec = tonic::codec::ProstCodec::default();\n                        let mut grpc = tonic::server::Grpc::new(codec)\n                            .apply_compression_config(\n                                accept_compression_encodings,\n                                send_compression_encodings,\n                            )\n                            .apply_max_message_size_config(\n                                max_decoding_message_size,\n                                max_encoding_message_size,\n                            );\n                        let res = grpc.unary(method, req).await;\n                        Ok(res)\n                    };\n                    Box::pin(fut)\n                }\n                \"/grpcpb.UTCPService/CallTool\" => {\n                    #[allow(non_camel_case_types)]\n                    struct CallToolSvc<T: UtcpService>(pub Arc<T>);\n                    impl<\n                        T: UtcpService,\n                    > tonic::server::UnaryService<super::ToolCallRequest>\n                    for CallToolSvc<T> {\n                        type Response = super::ToolCallResponse;\n                        type Future = BoxFuture<\n                            tonic::Response<Self::Response>,\n                            tonic::Status,\n                        >;\n                        fn call(\n                            &mut self,\n                            request: tonic::Request<super::ToolCallRequest>,\n                        ) -> Self::Future {\n                            let inner = Arc::clone(&self.0);\n                            let fut = async move {\n                                <T as UtcpService>::call_tool(&inner, request).await\n                            };\n                            Box::pin(fut)\n                        }\n                    }\n                    let accept_compression_encodings = self.accept_compression_encodings;\n                    let send_compression_encodings = self.send_compression_encodings;\n                    let max_decoding_message_size = self.max_decoding_message_size;\n                    let max_encoding_message_size = self.max_encoding_message_size;\n                    let inner = self.inner.clone();\n                    let fut = async move {\n                        let inner = inner.0;\n                        let method = CallToolSvc(inner);\n                        let codec = tonic::codec::ProstCodec::default();\n                        let mut grpc = tonic::server::Grpc::new(codec)\n                            .apply_compression_config(\n                                accept_compression_encodings,\n                                send_compression_encodings,\n                            )\n                            .apply_max_message_size_config(\n                                max_decoding_message_size,\n                                max_encoding_message_size,\n                            );\n                        let res = grpc.unary(method, req).await;\n                        Ok(res)\n                    };\n                    Box::pin(fut)\n                }\n                \"/grpcpb.UTCPService/CallToolStream\" => {\n                    #[allow(non_camel_case_types)]\n                    struct CallToolStreamSvc<T: UtcpService>(pub Arc<T>);\n                    impl<\n                        T: UtcpService,\n                    > tonic::server::ServerStreamingService<super::ToolCallRequest>\n                    for CallToolStreamSvc<T> {\n                        type Response = super::ToolCallResponse;\n                        type ResponseStream = T::CallToolStreamStream;\n                        type Future = BoxFuture<\n                            tonic::Response<Self::ResponseStream>,\n                            tonic::Status,\n                        >;\n                        fn call(\n                            &mut self,\n                            request: tonic::Request<super::ToolCallRequest>,\n                        ) -> Self::Future {\n                            let inner = Arc::clone(&self.0);\n                            let fut = async move {\n                                <T as UtcpService>::call_tool_stream(&inner, request).await\n                            };\n                            Box::pin(fut)\n                        }\n                    }\n                    let accept_compression_encodings = self.accept_compression_encodings;\n                    let send_compression_encodings = self.send_compression_encodings;\n                    let max_decoding_message_size = self.max_decoding_message_size;\n                    let max_encoding_message_size = self.max_encoding_message_size;\n                    let inner = self.inner.clone();\n                    let fut = async move {\n                        let inner = inner.0;\n                        let method = CallToolStreamSvc(inner);\n                        let codec = tonic::codec::ProstCodec::default();\n                        let mut grpc = tonic::server::Grpc::new(codec)\n                            .apply_compression_config(\n                                accept_compression_encodings,\n                                send_compression_encodings,\n                            )\n                            .apply_max_message_size_config(\n                                max_decoding_message_size,\n                                max_encoding_message_size,\n                            );\n                        let res = grpc.server_streaming(method, req).await;\n                        Ok(res)\n                    };\n                    Box::pin(fut)\n                }\n                _ => {\n                    Box::pin(async move {\n                        Ok(\n                            http::Response::builder()\n                                .status(200)\n                                .header(\"grpc-status\", \"12\")\n                                .header(\"content-type\", \"application/grpc\")\n                                .body(empty_body())\n                                .unwrap(),\n                        )\n                    })\n                }\n            }\n        }\n    }\n    impl<T: UtcpService> Clone for UtcpServiceServer<T> {\n        fn clone(&self) -> Self {\n            let inner = self.inner.clone();\n            Self {\n                inner,\n                accept_compression_encodings: self.accept_compression_encodings,\n                send_compression_encodings: self.send_compression_encodings,\n                max_decoding_message_size: self.max_decoding_message_size,\n                max_encoding_message_size: self.max_encoding_message_size,\n            }\n        }\n    }\n    impl<T: UtcpService> Clone for _Inner<T> {\n        fn clone(&self) -> Self {\n            Self(Arc::clone(&self.0))\n        }\n    }\n    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            write!(f, \"{:?}\", self.0)\n        }\n    }\n    impl<T: UtcpService> tonic::server::NamedService for UtcpServiceServer<T> {\n        const NAME: &'static str = \"grpcpb.UTCPService\";\n    }\n}\n",
      "line_count": 483,
      "word_count": 1312,
      "title": "Grpcpb.Rs",
      "summary": "// This file is @generated by prost-build. pub struct Empty {}",
      "key_terms": [
        "implementations",
        "build",
        "const",
        "Result",
        "grpc",
        "UtcpServiceClient",
        "clippy",
        "async",
        "error",
        "convert",
        "Code",
        "fmt",
        "ResponseBody",
        "Clone",
        "encoded",
        "format",
        "Utcp",
        "ToolCallRequest",
        "connect",
        "Sync"
      ],
      "timestamp": "2025-12-24T18:56:14.536790"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\openapi\\mod.rs",
      "content_type": "code",
      "content": "use anyhow::{anyhow, Result};\nuse reqwest::Url;\nuse serde_json::{Map, Value};\nuse std::collections::HashMap;\n\nuse crate::auth::{ApiKeyAuth, AuthConfig, AuthType, BasicAuth, OAuth2Auth};\nuse crate::providers::base::{BaseProvider, ProviderType};\nuse crate::providers::http::HttpProvider;\nuse crate::tools::{Tool, ToolInputOutputSchema};\n\npub const VERSION: &str = \"1.0\";\n\n/// Representation of a generated UTCP manual derived from an OpenAPI spec.\n#[derive(Debug, Clone)]\npub struct UtcpManual {\n    pub version: String,\n    pub tools: Vec<Tool>,\n}\n\n/// Converts OpenAPI v2/v3 documents into UTCP tool definitions.\npub struct OpenApiConverter {\n    spec: Value,\n    spec_url: Option<String>,\n    provider_name: String,\n}\n\nimpl OpenApiConverter {\n    /// Build a converter from an already loaded spec value.\n    pub fn new(\n        openapi_spec: Value,\n        spec_url: Option<String>,\n        provider_name: Option<String>,\n    ) -> Self {\n        let provider_name = provider_name\n            .filter(|name| !name.is_empty())\n            .unwrap_or_else(|| derive_provider_name(&openapi_spec));\n\n        Self {\n            spec: openapi_spec,\n            spec_url,\n            provider_name,\n        }\n    }\n\n    /// Fetch and parse a remote OpenAPI document, inferring a provider name when missing.\n    pub async fn new_from_url(spec_url: &str, provider_name: Option<String>) -> Result<Self> {\n        let (spec, final_url) = load_spec_from_url(spec_url).await?;\n        Ok(Self::new(spec, Some(final_url), provider_name))\n    }\n\n    /// Convert the OpenAPI document into a UTCP manual containing tools and metadata.\n    pub fn convert(&self) -> UtcpManual {\n        let mut tools = Vec::new();\n        let base_url = self.base_url();\n\n        if let Some(paths) = self.spec.get(\"paths\").and_then(|v| v.as_object()) {\n            for (raw_path, raw_item) in paths {\n                if let Some(path_item) = raw_item.as_object() {\n                    for (method, raw_op) in path_item {\n                        let lower = method.to_ascii_lowercase();\n                        if !matches!(lower.as_str(), \"get\" | \"post\" | \"put\" | \"delete\" | \"patch\") {\n                            continue;\n                        }\n\n                        if let Some(op) = raw_op.as_object() {\n                            if let Ok(Some(tool)) =\n                                self.create_tool(raw_path, &lower, op, &base_url)\n                            {\n                                tools.push(tool);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        UtcpManual {\n            version: VERSION.to_string(),\n            tools,\n        }\n    }\n\n    fn base_url(&self) -> String {\n        if let Some(servers) = self.spec.get(\"servers\").and_then(|v| v.as_array()) {\n            if let Some(first) = servers.first().and_then(|v| v.as_object()) {\n                if let Some(url) = first.get(\"url\").and_then(|v| v.as_str()) {\n                    if !url.is_empty() {\n                        return url.to_string();\n                    }\n                }\n            }\n        }\n\n        if let Some(host) = self.spec.get(\"host\").and_then(|v| v.as_str()) {\n            let scheme = self\n                .spec\n                .get(\"schemes\")\n                .and_then(|v| v.as_array())\n                .and_then(|arr| arr.first())\n                .and_then(|v| v.as_str())\n                .unwrap_or(\"https\");\n            let base_path = self\n                .spec\n                .get(\"basePath\")\n                .and_then(|v| v.as_str())\n                .unwrap_or(\"\");\n            return format!(\"{}://{}{}\", scheme, host, base_path);\n        }\n\n        if let Some(spec_url) = &self.spec_url {\n            if let Ok(parsed) = Url::parse(spec_url) {\n                if let Some(host) = parsed.host_str() {\n                    return format!(\"{}://{}\", parsed.scheme(), host);\n                }\n            }\n        }\n\n        \"/\".to_string()\n    }\n\n    fn resolve_ref(&self, reference: &str) -> Result<Value> {\n        if !reference.starts_with(\"#/\") {\n            return Err(anyhow!(\"only local refs supported, got {}\", reference));\n        }\n        let pointer = &reference[1..];\n        self.spec\n            .pointer(pointer)\n            .cloned()\n            .ok_or_else(|| anyhow!(\"ref {} not found\", reference))\n    }\n\n    fn resolve_schema(&self, schema: Value) -> Value {\n        match schema {\n            Value::Object(map) => {\n                if let Some(Value::String(reference)) = map.get(\"$ref\").cloned() {\n                    if let Ok(resolved) = self.resolve_ref(&reference) {\n                        return self.resolve_schema(resolved);\n                    }\n                    return Value::Object(map);\n                }\n\n                let mut out = Map::new();\n                for (k, v) in map {\n                    out.insert(k, self.resolve_schema(v));\n                }\n                Value::Object(out)\n            }\n            Value::Array(arr) => Value::Array(\n                arr.into_iter()\n                    .map(|item| self.resolve_schema(item))\n                    .collect(),\n            ),\n            other => other,\n        }\n    }\n\n    fn extract_auth(&self, operation: &Map<String, Value>) -> Option<AuthConfig> {\n        let mut reqs = Vec::new();\n        if let Some(op_sec) = operation.get(\"security\").and_then(|v| v.as_array()) {\n            if !op_sec.is_empty() {\n                reqs = op_sec.clone();\n            }\n        }\n        if reqs.is_empty() {\n            if let Some(global) = self.spec.get(\"security\").and_then(|v| v.as_array()) {\n                reqs = global.clone();\n            }\n        }\n        if reqs.is_empty() {\n            return None;\n        }\n\n        let schemes = self.get_security_schemes().unwrap_or_default();\n        for raw in reqs {\n            if let Some(sec_map) = raw.as_object() {\n                for name in sec_map.keys() {\n                    if let Some(Value::Object(scheme)) = schemes.get(name) {\n                        if let Some(auth) = self.create_auth_from_scheme(scheme) {\n                            return Some(auth);\n                        }\n                    }\n                }\n            }\n        }\n        None\n    }\n\n    fn get_security_schemes(&self) -> Option<Map<String, Value>> {\n        if let Some(components) = self.spec.get(\"components\").and_then(|v| v.as_object()) {\n            if let Some(security_schemes) = components\n                .get(\"securitySchemes\")\n                .and_then(|v| v.as_object())\n            {\n                return Some(security_schemes.clone());\n            }\n        }\n        if let Some(defs) = self\n            .spec\n            .get(\"securityDefinitions\")\n            .and_then(|v| v.as_object())\n        {\n            return Some(defs.clone());\n        }\n        None\n    }\n\n    fn create_auth_from_scheme(&self, scheme: &Map<String, Value>) -> Option<AuthConfig> {\n        let typ = scheme\n            .get(\"type\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"\")\n            .to_ascii_lowercase();\n\n        match typ.as_str() {\n            \"apikey\" => {\n                let location = scheme\n                    .get(\"in\")\n                    .and_then(|v| v.as_str())\n                    .unwrap_or(\"\")\n                    .to_string();\n                let name = scheme\n                    .get(\"name\")\n                    .and_then(|v| v.as_str())\n                    .unwrap_or(\"\")\n                    .to_string();\n                if location.is_empty() || name.is_empty() {\n                    return None;\n                }\n                let auth = ApiKeyAuth {\n                    auth_type: AuthType::ApiKey,\n                    api_key: format!(\"${{{}_API_KEY}}\", self.provider_name.to_uppercase()),\n                    var_name: name,\n                    location,\n                };\n                Some(AuthConfig::ApiKey(auth))\n            }\n            \"basic\" => {\n                let auth = BasicAuth {\n                    auth_type: AuthType::Basic,\n                    username: format!(\"${{{}_USERNAME}}\", self.provider_name.to_uppercase()),\n                    password: format!(\"${{{}_PASSWORD}}\", self.provider_name.to_uppercase()),\n                };\n                Some(AuthConfig::Basic(auth))\n            }\n            \"http\" => {\n                let scheme_name = scheme\n                    .get(\"scheme\")\n                    .and_then(|v| v.as_str())\n                    .unwrap_or(\"\")\n                    .to_ascii_lowercase();\n                match scheme_name.as_str() {\n                    \"basic\" => {\n                        let auth = BasicAuth {\n                            auth_type: AuthType::Basic,\n                            username: format!(\n                                \"${{{}_USERNAME}}\",\n                                self.provider_name.to_uppercase()\n                            ),\n                            password: format!(\n                                \"${{{}_PASSWORD}}\",\n                                self.provider_name.to_uppercase()\n                            ),\n                        };\n                        Some(AuthConfig::Basic(auth))\n                    }\n                    \"bearer\" => {\n                        let auth = ApiKeyAuth {\n                            auth_type: AuthType::ApiKey,\n                            api_key: format!(\n                                \"Bearer ${{{}_API_KEY}}\",\n                                self.provider_name.to_uppercase()\n                            ),\n                            var_name: \"Authorization\".to_string(),\n                            location: \"header\".to_string(),\n                        };\n                        Some(AuthConfig::ApiKey(auth))\n                    }\n                    _ => None,\n                }\n            }\n            \"oauth2\" => {\n                if let Some(flows) = scheme.get(\"flows\").and_then(|v| v.as_object()) {\n                    for raw_flow in flows.values() {\n                        if let Some(flow) = raw_flow.as_object() {\n                            if let Some(token_url) = flow.get(\"tokenUrl\").and_then(|v| v.as_str()) {\n                                let scope = flow\n                                    .get(\"scopes\")\n                                    .and_then(|v| v.as_object())\n                                    .map(|m| m.keys().cloned().collect::<Vec<_>>().join(\" \"));\n                                let auth = OAuth2Auth {\n                                    auth_type: AuthType::OAuth2,\n                                    token_url: token_url.to_string(),\n                                    client_id: format!(\n                                        \"${{{}_CLIENT_ID}}\",\n                                        self.provider_name.to_uppercase()\n                                    ),\n                                    client_secret: format!(\n                                        \"${{{}_CLIENT_SECRET}}\",\n                                        self.provider_name.to_uppercase()\n                                    ),\n                                    scope: optional_string(scope.unwrap_or_default()),\n                                };\n                                return Some(AuthConfig::OAuth2(auth));\n                            }\n                        }\n                    }\n                }\n\n                if let Some(token_url) = scheme.get(\"tokenUrl\").and_then(|v| v.as_str()) {\n                    let scope = scheme\n                        .get(\"scopes\")\n                        .and_then(|v| v.as_object())\n                        .map(|m| m.keys().cloned().collect::<Vec<_>>().join(\" \"));\n                    let auth = OAuth2Auth {\n                        auth_type: AuthType::OAuth2,\n                        token_url: token_url.to_string(),\n                        client_id: format!(\"${{{}_CLIENT_ID}}\", self.provider_name.to_uppercase()),\n                        client_secret: format!(\n                            \"${{{}_CLIENT_SECRET}}\",\n                            self.provider_name.to_uppercase()\n                        ),\n                        scope: optional_string(scope.unwrap_or_default()),\n                    };\n                    return Some(AuthConfig::OAuth2(auth));\n                }\n\n                None\n            }\n            _ => None,\n        }\n    }\n\n    fn create_tool(\n        &self,\n        path: &str,\n        method: &str,\n        op: &Map<String, Value>,\n        base_url: &str,\n    ) -> Result<Option<Tool>> {\n        let op_id = op\n            .get(\"operationId\")\n            .and_then(|v| v.as_str())\n            .map(|s| s.to_string())\n            .unwrap_or_else(|| {\n                let sanitized_path = path.trim_matches('/').replace('/', \"_\");\n                format!(\"{}_{}\", method.to_ascii_lowercase(), sanitized_path)\n            });\n\n        let description = op\n            .get(\"summary\")\n            .and_then(|v| v.as_str())\n            .filter(|s| !s.is_empty())\n            .map(|s| s.to_string())\n            .or_else(|| {\n                op.get(\"description\")\n                    .and_then(|v| v.as_str())\n                    .map(|s| s.to_string())\n            })\n            .unwrap_or_default();\n\n        let tags = op\n            .get(\"tags\")\n            .and_then(|v| v.as_array())\n            .map(|arr| {\n                arr.iter()\n                    .filter_map(|v| v.as_str().map(|s| s.to_string()))\n                    .collect::<Vec<_>>()\n            })\n            .unwrap_or_default();\n\n        let (input_schema, headers, body_field) = self.extract_inputs(op);\n        let output_schema = self.extract_outputs(op);\n        let auth = self.extract_auth(op);\n\n        let provider = HttpProvider {\n            base: BaseProvider {\n                name: self.provider_name.clone(),\n                provider_type: ProviderType::Http,\n                auth,\n                allowed_communication_protocols: None,\n            },\n            http_method: method.to_ascii_uppercase(),\n            url: join_url(base_url, path),\n            content_type: Some(\"application/json\".to_string()),\n            headers: None,\n            body_field,\n            header_fields: if headers.is_empty() {\n                None\n            } else {\n                Some(headers)\n            },\n        };\n\n        let provider_value = serde_json::to_value(provider)?;\n        Ok(Some(Tool {\n            name: op_id,\n            description,\n            inputs: input_schema,\n            outputs: output_schema,\n            tags,\n            average_response_size: None,\n            provider: Some(provider_value),\n        }))\n    }\n\n    fn extract_inputs(\n        &self,\n        op: &Map<String, Value>,\n    ) -> (ToolInputOutputSchema, Vec<String>, Option<String>) {\n        let mut props: HashMap<String, Value> = HashMap::new();\n        let mut required: Vec<String> = Vec::new();\n        let mut headers = Vec::new();\n        let mut body_field: Option<String> = None;\n\n        if let Some(parameters) = op.get(\"parameters\").and_then(|v| v.as_array()) {\n            for raw_param in parameters {\n                let param = self.resolve_schema(raw_param.clone());\n                if let Some(param_obj) = param.as_object() {\n                    let name = param_obj\n                        .get(\"name\")\n                        .and_then(|v| v.as_str())\n                        .unwrap_or(\"\")\n                        .to_string();\n                    let location = param_obj\n                        .get(\"in\")\n                        .and_then(|v| v.as_str())\n                        .unwrap_or(\"\")\n                        .to_string();\n                    if name.is_empty() {\n                        continue;\n                    }\n                    if location == \"header\" {\n                        headers.push(name.clone());\n                    }\n                    if location == \"body\" {\n                        body_field = Some(name.clone());\n                    }\n\n                    let schema_val = param_obj\n                        .get(\"schema\")\n                        .cloned()\n                        .unwrap_or_else(|| Value::Object(Map::new()));\n                    let schema_obj = self.resolve_schema(schema_val);\n                    let schema_map = schema_obj.as_object().cloned().unwrap_or_default();\n                    let mut entry = Map::new();\n\n                    if let Some(desc) = param_obj.get(\"description\") {\n                        entry.insert(\"description\".to_string(), desc.clone());\n                    }\n                    if let Some(typ) = schema_map.get(\"type\").or_else(|| param_obj.get(\"type\")) {\n                        entry.insert(\"type\".to_string(), typ.clone());\n                    }\n                    for (k, v) in schema_map {\n                        entry.insert(k, v);\n                    }\n                    if !entry.contains_key(\"type\") {\n                        entry.insert(\"type\".to_string(), Value::String(\"object\".to_string()));\n                    }\n\n                    props.insert(name.clone(), Value::Object(entry));\n                    if param_obj\n                        .get(\"required\")\n                        .and_then(|v| v.as_bool())\n                        .unwrap_or(false)\n                    {\n                        required.push(name);\n                    }\n                }\n            }\n        }\n\n        if let Some(request_body) = op.get(\"requestBody\") {\n            let rb = self.resolve_schema(request_body.clone());\n            if let Some(rb_obj) = rb.as_object() {\n                if let Some(content) = rb_obj.get(\"content\").and_then(|v| v.as_object()) {\n                    if let Some(app_json) =\n                        content.get(\"application/json\").and_then(|v| v.as_object())\n                    {\n                        if let Some(schema) = app_json.get(\"schema\") {\n                            let name = \"body\".to_string();\n                            body_field = Some(name.clone());\n                            let schema_obj = self.resolve_schema(schema.clone());\n                            let schema_map = schema_obj.as_object().cloned().unwrap_or_default();\n                            let mut entry = Map::new();\n                            if let Some(desc) = rb_obj.get(\"description\") {\n                                entry.insert(\"description\".to_string(), desc.clone());\n                            }\n                            for (k, v) in schema_map {\n                                entry.insert(k, v);\n                            }\n                            if !entry.contains_key(\"type\") {\n                                entry.insert(\n                                    \"type\".to_string(),\n                                    Value::String(\"object\".to_string()),\n                                );\n                            }\n                            props.insert(name.clone(), Value::Object(entry));\n                            if rb_obj\n                                .get(\"required\")\n                                .and_then(|v| v.as_bool())\n                                .unwrap_or(false)\n                            {\n                                required.push(name);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        let schema = ToolInputOutputSchema {\n            type_: \"object\".to_string(),\n            properties: if props.is_empty() { None } else { Some(props) },\n            required: if required.is_empty() {\n                None\n            } else {\n                Some(required)\n            },\n            description: None,\n            title: None,\n            items: None,\n            enum_: None,\n            minimum: None,\n            maximum: None,\n            format: None,\n        };\n\n        (schema, headers, body_field)\n    }\n\n    fn extract_outputs(&self, op: &Map<String, Value>) -> ToolInputOutputSchema {\n        let default_schema = ToolInputOutputSchema {\n            type_: \"object\".to_string(),\n            properties: None,\n            required: None,\n            description: None,\n            title: None,\n            items: None,\n            enum_: None,\n            minimum: None,\n            maximum: None,\n            format: None,\n        };\n\n        let responses = match op.get(\"responses\").and_then(|v| v.as_object()) {\n            Some(r) => r,\n            None => return default_schema,\n        };\n        let resp = match responses\n            .get(\"200\")\n            .or_else(|| responses.get(\"201\"))\n            .cloned()\n        {\n            Some(r) => r,\n            None => return default_schema,\n        };\n\n        let resp = self.resolve_schema(resp);\n        if let Some(resp_obj) = resp.as_object() {\n            if let Some(content) = resp_obj.get(\"content\").and_then(|v| v.as_object()) {\n                if let Some(app_json) = content.get(\"application/json\").and_then(|v| v.as_object())\n                {\n                    if let Some(schema) = app_json.get(\"schema\") {\n                        let fallback = resp_obj\n                            .get(\"description\")\n                            .and_then(|v| v.as_str())\n                            .map(|s| s.to_string());\n                        return self.build_schema_from_value(schema, fallback);\n                    }\n                }\n            }\n            if let Some(schema) = resp_obj.get(\"schema\") {\n                let fallback = resp_obj\n                    .get(\"description\")\n                    .and_then(|v| v.as_str())\n                    .map(|s| s.to_string());\n                return self.build_schema_from_value(schema, fallback);\n            }\n        }\n\n        default_schema\n    }\n\n    fn build_schema_from_value(\n        &self,\n        schema: &Value,\n        fallback_description: Option<String>,\n    ) -> ToolInputOutputSchema {\n        let resolved = self.resolve_schema(schema.clone());\n        let map = resolved.as_object().cloned().unwrap_or_default();\n\n        let mut out = ToolInputOutputSchema {\n            type_: map\n                .get(\"type\")\n                .and_then(|v| v.as_str())\n                .unwrap_or(\"object\")\n                .to_string(),\n            properties: map_from_value(map.get(\"properties\")),\n            required: string_slice(map.get(\"required\")),\n            description: match map\n                .get(\"description\")\n                .and_then(|v| v.as_str())\n                .map(|s| s.to_string())\n            {\n                Some(desc) if !desc.is_empty() => Some(desc),\n                _ => fallback_description.filter(|s| !s.is_empty()),\n            },\n            title: map\n                .get(\"title\")\n                .and_then(|v| v.as_str())\n                .map(|s| s.to_string()),\n            items: None,\n            enum_: map.get(\"enum\").and_then(|v| interface_slice(v)),\n            minimum: cast_float(map.get(\"minimum\")),\n            maximum: cast_float(map.get(\"maximum\")),\n            format: map\n                .get(\"format\")\n                .and_then(|v| v.as_str())\n                .map(|s| s.to_string()),\n        };\n\n        if out.type_ == \"array\" {\n            out.items = map_from_value(map.get(\"items\"));\n        }\n\n        out\n    }\n}\n\n/// Load an OpenAPI/Swagger document from a URL, handling JSON or YAML.\npub async fn load_spec_from_url(raw_url: &str) -> Result<(Value, String)> {\n    let resp = reqwest::get(raw_url).await?;\n    let status = resp.status();\n    if !status.is_success() {\n        return Err(anyhow!(\"unexpected HTTP status: {}\", status));\n    }\n\n    let final_url = resp.url().to_string();\n    let bytes = resp.bytes().await?;\n\n    if let Ok(json_spec) = serde_json::from_slice::<Value>(&bytes) {\n        return Ok((json_spec, final_url));\n    }\n\n    let yaml_value: serde_yaml::Value = serde_yaml::from_slice(&bytes)\n        .map_err(|err| anyhow!(\"failed to parse as JSON or YAML: {}\", err))?;\n    let json_value = serde_json::to_value(yaml_value)?;\n    Ok((json_value, final_url))\n}\n\nfn derive_provider_name(spec: &Value) -> String {\n    let title = spec\n        .get(\"info\")\n        .and_then(|v| v.as_object())\n        .and_then(|info| info.get(\"title\"))\n        .and_then(|v| v.as_str())\n        .unwrap_or(\"\")\n        .to_string();\n    let base = if title.is_empty() {\n        \"openapi_provider\".to_string()\n    } else {\n        title\n    };\n    let invalid = \" -.,!?'\\\"\\\\\\\\/()[]{}#@$%^&*+=~`|;:<>\";\n\n    let mut output = String::new();\n    for ch in base.chars() {\n        if invalid.contains(ch) {\n            output.push('_');\n        } else {\n            output.push(ch);\n        }\n    }\n    if output.is_empty() {\n        \"openapi_provider\".to_string()\n    } else {\n        output\n    }\n}\n\nfn optional_string(s: String) -> Option<String> {\n    if s.is_empty() {\n        None\n    } else {\n        Some(s)\n    }\n}\n\nfn join_url(base: &str, path: &str) -> String {\n    let trimmed_base = base.trim_end_matches('/');\n    let trimmed_path = path.trim_start_matches('/');\n    if trimmed_base.is_empty() {\n        format!(\"/{}\", trimmed_path)\n    } else if trimmed_path.is_empty() {\n        trimmed_base.to_string()\n    } else {\n        format!(\"{}/{}\", trimmed_base, trimmed_path)\n    }\n}\n\nfn map_from_value(value: Option<&Value>) -> Option<HashMap<String, Value>> {\n    value.and_then(|v| v.as_object()).map(|obj| {\n        obj.iter()\n            .map(|(k, v)| (k.clone(), v.clone()))\n            .collect::<HashMap<_, _>>()\n    })\n}\n\nfn string_slice(value: Option<&Value>) -> Option<Vec<String>> {\n    value.and_then(|v| v.as_array()).map(|arr| {\n        let collected = arr\n            .iter()\n            .filter_map(|v| v.as_str().map(|s| s.to_string()))\n            .collect::<Vec<_>>();\n        if collected.is_empty() {\n            None\n        } else {\n            Some(collected)\n        }\n    })?\n}\n\nfn interface_slice(value: &Value) -> Option<Vec<Value>> {\n    value.as_array().map(|arr| {\n        if arr.is_empty() {\n            None\n        } else {\n            Some(arr.to_vec())\n        }\n    })?\n}\n\nfn cast_float(value: Option<&Value>) -> Option<f64> {\n    value.and_then(|v| {\n        if let Some(n) = v.as_f64() {\n            Some(n)\n        } else if let Some(i) = v.as_i64() {\n            Some(i as f64)\n        } else {\n            None\n        }\n    })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    fn build_test_converter() -> OpenApiConverter {\n        let spec = json!({\n            \"info\": {\"title\": \"Test\"},\n            \"components\": {\n                \"schemas\": {\n                    \"Obj\": {\n                        \"type\": \"object\",\n                        \"properties\": { \"name\": { \"type\": \"string\" } }\n                    }\n                },\n                \"securitySchemes\": {\n                    \"apiKey\": { \"type\": \"apiKey\", \"name\": \"X-Token\", \"in\": \"header\" },\n                    \"basicAuth\": { \"type\": \"http\", \"scheme\": \"basic\" }\n                }\n            },\n            \"security\": [ { \"apiKey\": [] } ]\n        });\n\n        OpenApiConverter::new(\n            spec,\n            Some(\"https://api.example.com/spec.json\".to_string()),\n            Some(\"test\".to_string()),\n        )\n    }\n\n    #[test]\n    fn resolve_ref_and_schema() {\n        let converter = build_test_converter();\n        let obj = converter.resolve_ref(\"#/components/schemas/Obj\").unwrap();\n        assert_eq!(obj.get(\"type\").and_then(|v| v.as_str()), Some(\"object\"));\n        assert!(converter.resolve_ref(\"#/bad/ref\").is_err());\n\n        let resolved = converter.resolve_schema(json!({\"$ref\": \"#/components/schemas/Obj\"}));\n        assert_eq!(\n            resolved\n                .get(\"properties\")\n                .and_then(|v| v.get(\"name\"))\n                .and_then(|v| v.get(\"type\"))\n                .and_then(|v| v.as_str()),\n            Some(\"string\")\n        );\n    }\n\n    #[test]\n    fn create_auth_from_scheme_and_extract() {\n        let converter = build_test_converter();\n        let api_key = converter\n            .create_auth_from_scheme(\n                &json!({\"type\": \"apiKey\", \"in\": \"header\", \"name\": \"X\"})\n                    .as_object()\n                    .unwrap(),\n            )\n            .unwrap();\n        match api_key {\n            AuthConfig::ApiKey(auth) => {\n                assert_eq!(auth.var_name, \"X\");\n                assert_eq!(auth.location, \"header\");\n                assert_eq!(auth.api_key, \"${TEST_API_KEY}\");\n            }\n            _ => panic!(\"expected ApiKey auth\"),\n        }\n\n        let basic = converter\n            .create_auth_from_scheme(\n                &json!({\"type\": \"http\", \"scheme\": \"basic\"})\n                    .as_object()\n                    .unwrap(),\n            )\n            .unwrap();\n        matches!(basic, AuthConfig::Basic(_));\n\n        let bearer = converter\n            .create_auth_from_scheme(\n                &json!({\"type\": \"http\", \"scheme\": \"bearer\"})\n                    .as_object()\n                    .unwrap(),\n            )\n            .unwrap();\n        match bearer {\n            AuthConfig::ApiKey(auth) => {\n                assert_eq!(auth.var_name, \"Authorization\");\n                assert!(auth.api_key.contains(\"${TEST_API_KEY}\"));\n            }\n            _ => panic!(\"expected bearer api key auth\"),\n        }\n\n        let mut op = Map::new();\n        op.insert(\"security\".to_string(), json!([{\"basicAuth\": []}]));\n        let auth = converter.extract_auth(&op).unwrap();\n        matches!(auth, AuthConfig::Basic(_));\n    }\n\n    #[test]\n    fn inputs_outputs_and_create_tool() {\n        let converter = build_test_converter();\n        let op_value = json!({\n            \"operationId\": \"ping\",\n            \"summary\": \"Ping\",\n            \"tags\": [\"t\"],\n            \"parameters\": [\n                { \"name\": \"id\", \"in\": \"query\", \"required\": true, \"schema\": { \"type\": \"string\" }},\n                { \"name\": \"X\", \"in\": \"header\", \"schema\": { \"type\": \"string\" }}\n            ],\n            \"requestBody\": {\n                \"required\": true,\n                \"content\": {\n                    \"application/json\": {\n                        \"schema\": {\n                            \"type\": \"object\",\n                            \"properties\": { \"foo\": { \"type\": \"string\" } }\n                        }\n                    }\n                }\n            },\n            \"responses\": {\n                \"200\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"type\": \"object\",\n                                \"description\": \"desc\",\n                                \"properties\": { \"ok\": { \"type\": \"boolean\" } }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n        let op = op_value.as_object().unwrap().clone();\n\n        let (schema, headers, body) = converter.extract_inputs(&op);\n        assert_eq!(schema.properties.as_ref().map(|m| m.len()), Some(3));\n        assert_eq!(headers, vec![\"X\".to_string()]);\n        assert_eq!(body.as_deref(), Some(\"body\"));\n\n        let out = converter.extract_outputs(&op);\n        assert_eq!(out.type_, \"object\");\n        assert!(out.properties.unwrap().contains_key(\"ok\"));\n\n        let tool = converter\n            .create_tool(\"/ping\", \"get\", &op, \"https://api.example.com\")\n            .unwrap()\n            .unwrap();\n        assert_eq!(tool.name, \"ping\");\n        let prov: HttpProvider = serde_json::from_value(tool.provider.unwrap()).unwrap();\n        assert_eq!(prov.url, \"https://api.example.com/ping\");\n    }\n\n    #[test]\n    fn convert_basic() {\n        let spec = json!({\n            \"info\": {\"title\": \"Test API\"},\n            \"servers\": [{\"url\": \"https://api.example.com\"}],\n            \"paths\": {\n                \"/ping\": {\n                    \"get\": {\n                        \"operationId\": \"ping\",\n                        \"summary\": \"Ping\",\n                        \"responses\": {\n                            \"200\": {\n                                \"content\": {\n                                    \"application/json\": {\n                                        \"schema\": { \"type\": \"object\" }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n        let converter = OpenApiConverter::new(spec, None, None);\n        let manual = converter.convert();\n        assert_eq!(manual.version, VERSION);\n        assert_eq!(manual.tools.len(), 1);\n        assert_eq!(manual.tools[0].name, \"ping\");\n    }\n}\n",
      "line_count": 928,
      "word_count": 2219,
      "title": "Mod.Rs",
      "summary": "use anyhow::{anyhow, Result}; use reqwest::Url;",
      "key_terms": [
        "arr",
        "lower",
        "output",
        "const",
        "Result",
        "rb",
        "paths",
        "entry",
        "async",
        "headers",
        "chars",
        "convert",
        "id",
        "prov",
        "info",
        "VERSION",
        "Clone",
        "format",
        "Utcp",
        "only"
      ],
      "timestamp": "2025-12-24T18:56:14.600643"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\plugins\\mod.rs",
      "content_type": "code",
      "content": "pub mod codemode;\n",
      "line_count": 2,
      "word_count": 3,
      "title": "Mod.Rs",
      "summary": "pub mod codemode;",
      "key_terms": [
        "pub",
        "codemode",
        "mod"
      ],
      "timestamp": "2025-12-24T18:56:14.616591"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\plugins\\codemode\\mod.rs",
      "content_type": "code",
      "content": "use std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::Duration;\nuse tokio::sync::RwLock;\n\nuse anyhow::{anyhow, Result};\nuse rhai::{Dynamic, Engine, EvalAltResult, Map, Scope};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse tokio::runtime::{Builder, RuntimeFlavor};\n\nuse crate::security;\nuse crate::tools::{Tool, ToolInputOutputSchema};\nuse crate::UtcpClientInterface;\n\n// Security configuration constants\n/// Maximum code snippet size (100KB) to prevent DoS attacks\nconst MAX_CODE_SIZE: usize = 100_000;\n\n/// Maximum timeout for code execution (30 seconds)\nconst MAX_TIMEOUT_MS: u64 = 45_000;\n\n/// Default timeout if none specified (5 seconds)\nconst DEFAULT_TIMEOUT_MS: u64 = 5_000;\n\n/// Maximum size for script output (10MB) to prevent memory exhaustion\nconst MAX_OUTPUT_SIZE: usize = 10_000_000;\n\n/// Maximum operations per script execution\nconst MAX_OPERATIONS: u64 = 100_000;\n\n/// Maximum expression depth to prevent stack overflow\nconst MAX_EXPR_DEPTH: (usize, usize) = (64, 32);\n\n/// Maximum string size (1MB) within scripts\nconst MAX_STRING_SIZE: usize = 1_000_000;\n\n/// Maximum array/map sizes to prevent memory exhaustion\nconst MAX_ARRAY_SIZE: usize = 10_000;\nconst MAX_MAP_SIZE: usize = 10_000;\n\n/// Maximum number of modules\nconst MAX_MODULES: usize = 16;\n\n/// Dangerous code patterns that are prohibited\nconst DANGEROUS_PATTERNS: &[&str] = &[\n    \"eval(\",\n    \"import \",\n    \"fn \",        // Function definitions could be abused\n    \"while true\", // Infinite loops\n    \"loop {\",     // Infinite loops\n];\n\n/// Minimal facade exposing UTCP calls to Rhai scripts executed by CodeMode.\npub struct CodeModeUtcp {\n    client: Arc<dyn UtcpClientInterface>,\n}\n\nimpl CodeModeUtcp {\n    /// Wrap an `UtcpClientInterface` so codemode scripts can invoke tools.\n    pub fn new(client: Arc<dyn UtcpClientInterface>) -> Self {\n        Self { client }\n    }\n\n    /// Validates code for security issues before execution.\n    fn validate_code(&self, code: &str) -> Result<()> {\n        // Check code size\n        if code.len() > MAX_CODE_SIZE {\n            return Err(anyhow!(\n                \"Code size {} bytes exceeds maximum allowed {} bytes\",\n                code.len(),\n                MAX_CODE_SIZE\n            ));\n        }\n\n        // Check for dangerous patterns\n        for pattern in DANGEROUS_PATTERNS {\n            if code.contains(pattern) {\n                return Err(anyhow!(\"Code contains prohibited pattern: '{}'\", pattern));\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Execute a snippet or JSON payload, returning the resulting value and captured output.\n    pub async fn execute(&self, args: CodeModeArgs) -> Result<CodeModeResult> {\n        // Validate code before execution\n        self.validate_code(&args.code)?;\n\n        // Determine and validate timeout\n        let timeout_ms = args.timeout.unwrap_or(DEFAULT_TIMEOUT_MS);\n        security::validate_timeout(timeout_ms, MAX_TIMEOUT_MS)?;\n\n        // If it's JSON already, return it directly (no execution needed)\n        if let Ok(json) = serde_json::from_str::<Value>(&args.code) {\n            return Ok(CodeModeResult {\n                value: json,\n                stdout: String::new(),\n                stderr: String::new(),\n            });\n        }\n\n        // Execute with timeout\n        let result = tokio::time::timeout(\n            Duration::from_millis(timeout_ms),\n            self.eval_rusty_snippet(&args.code, Some(timeout_ms)),\n        )\n        .await;\n\n        let value = match result {\n            Ok(Ok(v)) => v,\n            Ok(Err(e)) => return Err(e),\n            Err(_) => {\n                return Err(anyhow!(\"Code execution timed out after {}ms\", timeout_ms));\n            }\n        };\n\n        // Validate output size to prevent memory exhaustion\n        let serialized = serde_json::to_vec(&value)?;\n        if serialized.len() > MAX_OUTPUT_SIZE {\n            return Err(anyhow!(\n                \"Output size {} bytes exceeds maximum allowed {} bytes\",\n                serialized.len(),\n                MAX_OUTPUT_SIZE\n            ));\n        }\n\n        Ok(CodeModeResult {\n            value,\n            stdout: String::new(),\n            stderr: String::new(),\n        })\n    }\n\n    fn tool_schema(&self) -> Tool {\n        Tool {\n            name: \"codemode.run_code\".to_string(),\n            description: \"Execute a Rust-like snippet with access to UTCP tools.\".to_string(),\n            inputs: ToolInputOutputSchema {\n                type_: \"object\".to_string(),\n                properties: Some(HashMap::from([\n                    (\n                        \"code\".to_string(),\n                        serde_json::json!({\"type\": \"string\", \"description\": \"Rust-like snippet\"}),\n                    ),\n                    (\n                        \"timeout\".to_string(),\n                        serde_json::json!({\"type\": \"integer\", \"description\": \"Timeout ms\"}),\n                    ),\n                ])),\n                required: Some(vec![\"code\".to_string()]),\n                description: None,\n                title: Some(\"CodeModeArgs\".to_string()),\n                items: None,\n                enum_: None,\n                minimum: None,\n                maximum: None,\n                format: None,\n            },\n            outputs: ToolInputOutputSchema {\n                type_: \"object\".to_string(),\n                properties: Some(HashMap::from([\n                    (\"value\".to_string(), serde_json::json!({\"type\": \"string\"})),\n                    (\"stdout\".to_string(), serde_json::json!({\"type\": \"string\"})),\n                    (\"stderr\".to_string(), serde_json::json!({\"type\": \"string\"})),\n                ])),\n                required: None,\n                description: None,\n                title: Some(\"CodeModeResult\".to_string()),\n                items: None,\n                enum_: None,\n                minimum: None,\n                maximum: None,\n                format: None,\n            },\n            tags: vec![\"codemode\".to_string(), \"utcp\".to_string()],\n            average_response_size: None,\n            provider: None,\n        }\n    }\n\n    fn build_engine(&self) -> Engine {\n        let mut engine = Engine::new();\n\n        // Security: Comprehensive sandboxing using centralized constants\n        engine.set_max_expr_depths(MAX_EXPR_DEPTH.0, MAX_EXPR_DEPTH.1);\n        engine.set_max_operations(MAX_OPERATIONS);\n        engine.set_max_modules(MAX_MODULES);\n        engine.set_max_string_size(MAX_STRING_SIZE);\n        engine.set_max_array_size(MAX_ARRAY_SIZE);\n        engine.set_max_map_size(MAX_MAP_SIZE);\n\n        // Note: File I/O and other dangerous operations are disabled by default in Rhai\n        // when not explicitly importing the std modules\n\n        engine.register_fn(\"sprintf\", sprintf);\n\n        let client = self.client.clone();\n        engine.register_fn(\n            \"call_tool\",\n            move |name: &str, map: Map| -> Result<Dynamic, Box<EvalAltResult>> {\n                // Security: Validate tool name format\n                if name.is_empty() || name.len() > 200 {\n                    return Err(EvalAltResult::ErrorRuntime(\n                        \"Invalid tool name length\".into(),\n                        rhai::Position::NONE,\n                    )\n                    .into());\n                }\n\n                let args_val = serde_json::to_value(map).map_err(|e| {\n                    EvalAltResult::ErrorRuntime(e.to_string().into(), rhai::Position::NONE)\n                })?;\n                let args = value_to_map(args_val)?;\n\n                let res = block_on_any_runtime(async { client.call_tool(name, args).await })\n                    .map_err(|e| {\n                        EvalAltResult::ErrorRuntime(e.to_string().into(), rhai::Position::NONE)\n                    })?;\n\n                Ok(rhai::serde::to_dynamic(res).map_err(|e| {\n                    EvalAltResult::ErrorRuntime(e.to_string().into(), rhai::Position::NONE)\n                })?)\n            },\n        );\n\n        let client = self.client.clone();\n        engine.register_fn(\n            \"call_tool_stream\",\n            move |name: &str, map: Map| -> Result<Dynamic, Box<EvalAltResult>> {\n                // Security: Validate tool name format\n                if name.is_empty() || name.len() > 200 {\n                    return Err(EvalAltResult::ErrorRuntime(\n                        \"Invalid tool name length\".into(),\n                        rhai::Position::NONE,\n                    )\n                    .into());\n                }\n\n                let args_val = serde_json::to_value(map).map_err(|e| {\n                    EvalAltResult::ErrorRuntime(e.to_string().into(), rhai::Position::NONE)\n                })?;\n                let args = value_to_map(args_val)?;\n\n                let mut stream =\n                    block_on_any_runtime(async { client.call_tool_stream(name, args).await })\n                        .map_err(|e| {\n                            EvalAltResult::ErrorRuntime(e.to_string().into(), rhai::Position::NONE)\n                        })?;\n\n                let mut items = Vec::new();\n                // Security: Limit maximum number of stream items to prevent memory exhaustion\n                const MAX_STREAM_ITEMS: usize = 10_000;\n\n                loop {\n                    if items.len() >= MAX_STREAM_ITEMS {\n                        return Err(EvalAltResult::ErrorRuntime(\n                            format!(\"Stream exceeded maximum {} items\", MAX_STREAM_ITEMS).into(),\n                            rhai::Position::NONE,\n                        )\n                        .into());\n                    }\n\n                    let next =\n                        block_on_any_runtime(async { stream.next().await }).map_err(|e| {\n                            EvalAltResult::ErrorRuntime(e.to_string().into(), rhai::Position::NONE)\n                        })?;\n                    match next {\n                        Some(value) => items.push(value),\n                        None => break,\n                    }\n                }\n\n                if let Err(e) = block_on_any_runtime(async { stream.close().await }) {\n                    return Err(EvalAltResult::ErrorRuntime(\n                        e.to_string().into(),\n                        rhai::Position::NONE,\n                    )\n                    .into());\n                }\n\n                Ok(rhai::serde::to_dynamic(items).map_err(|e| {\n                    EvalAltResult::ErrorRuntime(e.to_string().into(), rhai::Position::NONE)\n                })?)\n            },\n        );\n\n        let client = self.client.clone();\n        engine.register_fn(\n            \"search_tools\",\n            move |query: &str, limit: i64| -> Result<Dynamic, Box<EvalAltResult>> {\n                // Security: Validate query length\n                if query.len() > 1000 {\n                    return Err(EvalAltResult::ErrorRuntime(\n                        \"Search query too long (max 1000 chars)\".into(),\n                        rhai::Position::NONE,\n                    )\n                    .into());\n                }\n\n                // Security: Enforce reasonable search limit\n                const MAX_SEARCH_LIMIT: i64 = 500;\n                let safe_limit = if limit <= 0 || limit > MAX_SEARCH_LIMIT {\n                    MAX_SEARCH_LIMIT\n                } else {\n                    limit\n                };\n\n                let res = block_on_any_runtime(async {\n                    client.search_tools(query, safe_limit as usize).await\n                })\n                .map_err(|e| {\n                    EvalAltResult::ErrorRuntime(e.to_string().into(), rhai::Position::NONE)\n                })?;\n                Ok(rhai::serde::to_dynamic(res).map_err(|e| {\n                    EvalAltResult::ErrorRuntime(e.to_string().into(), rhai::Position::NONE)\n                })?)\n            },\n        );\n\n        engine\n    }\n\n    async fn eval_rusty_snippet(&self, code: &str, _timeout_ms: Option<u64>) -> Result<Value> {\n        let wrapped = format!(\"let __out = {{ {} }};\\n__out\", code);\n        let engine = self.build_engine();\n        let mut scope = Scope::new();\n\n        let dyn_result = engine.eval_with_scope::<Dynamic>(&mut scope, &wrapped);\n        let dyn_value = dyn_result.map_err(|e| anyhow!(\"codemode eval error: {}\", e))?;\n        let value: Value = rhai::serde::from_dynamic(&dyn_value)\n            .map_err(|e| anyhow!(\"Failed to convert result: {}\", e))?;\n        Ok(value)\n    }\n\n    /// Expose the codemode tool definition for registration.\n    pub fn tool(&self) -> Tool {\n        self.tool_schema()\n    }\n\n    /// Convenience helpers mirroring go-utcp codemode helper exports.\n    pub async fn call_tool(&self, name: &str, args: HashMap<String, Value>) -> Result<Value> {\n        self.client.call_tool(name, args).await\n    }\n\n    pub async fn call_tool_stream(\n        &self,\n        name: &str,\n        args: HashMap<String, Value>,\n    ) -> Result<Box<dyn crate::transports::stream::StreamResult>> {\n        self.client.call_tool_stream(name, args).await\n    }\n\n    pub async fn search_tools(&self, query: &str, limit: usize) -> Result<Vec<Tool>> {\n        self.client.search_tools(query, limit).await\n    }\n}\n\n#[async_trait::async_trait]\npub trait LlmModel: Send + Sync {\n    /// Produce a completion for the provided prompt.\n    async fn complete(&self, prompt: &str) -> Result<Value>;\n}\n\n/// High-level orchestrator that mirrors go-utcp's CodeMode flow:\n/// 1) Decide if tools are needed\n/// 2) Select tools by name\n/// 3) Ask the model to emit a Rhai snippet using call_tool helpers\n/// 4) Execute the snippet via CodeMode\npub struct CodemodeOrchestrator {\n    codemode: Arc<CodeModeUtcp>,\n    model: Arc<dyn LlmModel>,\n    tool_specs_cache: RwLock<Option<String>>,\n}\n\nimpl CodemodeOrchestrator {\n    /// Create a new orchestrator backed by a CodeMode UTCP shim and an LLM model.\n    pub fn new(codemode: Arc<CodeModeUtcp>, model: Arc<dyn LlmModel>) -> Self {\n        Self {\n            codemode,\n            model,\n            tool_specs_cache: RwLock::new(None),\n        }\n    }\n\n    /// Run the full orchestration flow. Returns Ok(None) if the model says no tools are needed\n    /// or fails to pick any tools. Otherwise returns the codemode execution result.\n    pub async fn call_prompt(&self, prompt: &str) -> Result<Option<Value>> {\n        let specs = self.render_tool_specs().await?;\n\n        if !self.decide_if_tools_needed(prompt, &specs).await? {\n            return Ok(None);\n        }\n\n        let selected = self.select_tools(prompt, &specs).await?;\n        if selected.is_empty() {\n            return Ok(None);\n        }\n\n        let snippet = self.generate_snippet(prompt, &selected, &specs).await?;\n        let raw = self\n            .codemode\n            .execute(CodeModeArgs {\n                code: snippet,\n                timeout: Some(20_000),\n            })\n            .await?;\n\n        Ok(Some(raw.value))\n    }\n\n    async fn render_tool_specs(&self) -> Result<String> {\n        {\n            let cache = self.tool_specs_cache.read().await;\n            if let Some(specs) = &*cache {\n                return Ok(specs.clone());\n            }\n        }\n\n        let tools = self\n            .codemode\n            .search_tools(\"\", 200)\n            .await\n            .unwrap_or_default();\n        let mut rendered =\n            String::from(\"UTCP TOOL REFERENCE (use exact field names and required keys):\\n\");\n        for tool in tools {\n            rendered.push_str(&format!(\"TOOL: {} - {}\\n\", tool.name, tool.description));\n\n            rendered.push_str(\"INPUTS:\\n\");\n            match tool.inputs.properties.as_ref() {\n                Some(props) if !props.is_empty() => {\n                    for (key, schema) in props {\n                        rendered.push_str(&format!(\"  - {}: {}\\n\", key, schema_type_hint(schema)));\n                    }\n                }\n                _ => rendered.push_str(\"  - none\\n\"),\n            }\n\n            if let Some(required) = tool.inputs.required.as_ref() {\n                if !required.is_empty() {\n                    rendered.push_str(\"  REQUIRED:\\n\");\n                    for field in required {\n                        rendered.push_str(&format!(\"  - {}\\n\", field));\n                    }\n                }\n            }\n\n            rendered.push_str(\"OUTPUTS:\\n\");\n            match tool.outputs.properties.as_ref() {\n                Some(props) if !props.is_empty() => {\n                    for (key, schema) in props {\n                        rendered.push_str(&format!(\"  - {}: {}\\n\", key, schema_type_hint(schema)));\n                    }\n                }\n                _ => {\n                    if !tool.outputs.type_.is_empty() {\n                        rendered.push_str(&format!(\"  - type: {}\\n\", tool.outputs.type_));\n                    } else {\n                        rendered.push_str(\"  - (shape unspecified)\\n\");\n                    }\n                }\n            }\n\n            rendered.push('\\n');\n        }\n\n        let mut cache = self.tool_specs_cache.write().await;\n        *cache = Some(rendered.clone());\n        Ok(rendered)\n    }\n\n    async fn decide_if_tools_needed(&self, prompt: &str, specs: &str) -> Result<bool> {\n        let request = format!(\n            \"You can call tools described below. Respond with only 'yes' or 'no'.\\n\\nTOOLS:\\n{}\\n\\nUSER:\\n{}\",\n            specs, prompt\n        );\n        let resp_val = self.model.complete(&request).await?;\n        Ok(resp_val\n            .as_str()\n            .unwrap_or_default()\n            .trim_start()\n            .to_ascii_lowercase()\n            .starts_with('y'))\n    }\n\n    async fn select_tools(&self, prompt: &str, specs: &str) -> Result<Vec<String>> {\n        let request = format!(\n            \"Choose relevant tool names from the list. Respond with a comma-separated list of names only.\\n\\nTOOLS:\\n{}\\n\\nUSER:\\n{}\",\n            specs, prompt\n        );\n        let resp_val = self.model.complete(&request).await?;\n        let resp = resp_val.as_str().unwrap_or_default();\n        let mut out = Vec::new();\n        for name in resp.split(',') {\n            let n = name.trim();\n            if !n.is_empty() {\n                out.push(n.to_string());\n            }\n        }\n        Ok(out)\n    }\n\n    async fn generate_snippet(\n        &self,\n        prompt: &str,\n        tools: &[String],\n        specs: &str,\n    ) -> Result<String> {\n        let tool_list = tools.join(\", \");\n        let request = format!(\n            \"Generate a Rhai snippet that chains UTCP tool calls to satisfy the user request.\\n\\\nUse ONLY these tools: {tool_list}.\\n\\\nHelpers available: call_tool(name, map), call_tool_stream(name, map) -> array of streamed chunks, search_tools(query, limit), sprintf(fmt, list).\\n\\\nUse Rhai map syntax #{{\\\"field\\\": value}} with exact input field names; include required fields and never invent new keys.\\n\\\nYou may call multiple tools, store results in variables, and pass them into subsequent tools.\\n\\\nWhen using call_tool_stream, treat the returned array as the streamed items and chain it into later calls or the final output.\\n\\\nReturn the final value as the last expression (map/list/scalar). No markdown or commentary, code only.\\n\\\n\\nUSER:\\n{prompt}\\n\\nTOOLS (use exact field names):\\n{specs}\"\n        );\n        let resp_val = self.model.complete(&request).await?;\n        Ok(resp_val.as_str().unwrap_or_default().trim().to_string())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n/// Arguments accepted by the codemode tool.\npub struct CodeModeArgs {\n    pub code: String,\n    #[serde(default)]\n    pub timeout: Option<u64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n/// Result payload returned from codemode execution.\npub struct CodeModeResult {\n    pub value: Value,\n    #[serde(default)]\n    pub stdout: String,\n    #[serde(default)]\n    pub stderr: String,\n}\n\nfn schema_type_hint(value: &Value) -> String {\n    if let Some(t) = value.get(\"type\").and_then(|v| v.as_str()) {\n        t.to_string()\n    } else if let Some(s) = value.as_str() {\n        s.to_string()\n    } else if value.is_array() {\n        \"array\".to_string()\n    } else if value.is_object() {\n        \"object\".to_string()\n    } else {\n        \"any\".to_string()\n    }\n}\n\nfn value_to_map(value: Value) -> Result<HashMap<String, Value>, Box<EvalAltResult>> {\n    match value {\n        Value::Object(obj) => Ok(obj.into_iter().collect()),\n        _ => Err(EvalAltResult::ErrorRuntime(\n            \"call_tool expects object args\".into(),\n            rhai::Position::NONE,\n        )\n        .into()),\n    }\n}\n\n/// Minimal string formatter exposed to Rhai snippets.\n/// Security: Limited to prevent DoS attacks.\npub fn sprintf(fmt: &str, args: &[Dynamic]) -> String {\n    // Security: Limit format string size\n    const MAX_FMT_SIZE: usize = 10_000;\n    const MAX_ARGS: usize = 100;\n\n    if fmt.len() > MAX_FMT_SIZE {\n        return \"[ERROR: Format string too long]\".to_string();\n    }\n\n    if args.len() > MAX_ARGS {\n        return \"[ERROR: Too many arguments]\".to_string();\n    }\n\n    let mut out = fmt.to_string();\n    for rendered in args.iter().map(|v| v.to_string()) {\n        // Security: Limit argument string length\n        let safe_rendered = if rendered.len() > 1000 {\n            format!(\"{}...[truncated]\", &rendered[..1000])\n        } else {\n            rendered\n        };\n        out = out.replacen(\"{}\", &safe_rendered, 1);\n    }\n\n    // Security: Limit total output size\n    if out.len() > MAX_FMT_SIZE * 2 {\n        out.truncate(MAX_FMT_SIZE * 2);\n        out.push_str(\"...[truncated]\");\n    }\n\n    out\n}\n\nfn block_on_any_runtime<F, T>(fut: F) -> Result<T, anyhow::Error>\nwhere\n    F: std::future::Future<Output = Result<T, anyhow::Error>>,\n    T: Send + 'static,\n{\n    match tokio::runtime::Handle::try_current() {\n        Ok(handle) => match handle.runtime_flavor() {\n            RuntimeFlavor::MultiThread => tokio::task::block_in_place(|| handle.block_on(fut)),\n            RuntimeFlavor::CurrentThread => {\n                let rt = Builder::new_current_thread().enable_all().build()?;\n                rt.block_on(fut)\n            }\n            _ => {\n                let rt = Builder::new_current_thread().enable_all().build()?;\n                rt.block_on(fut)\n            }\n        },\n        Err(_) => {\n            let rt = Builder::new_current_thread().enable_all().build()?;\n            rt.block_on(fut)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::tools::Tool;\n    use crate::transports::stream::boxed_vec_stream;\n    use tokio::sync::Mutex;\n\n    #[derive(Clone)]\n    struct MockClient {\n        called: Arc<Mutex<Vec<String>>>,\n    }\n\n    #[async_trait::async_trait]\n    impl UtcpClientInterface for MockClient {\n        async fn register_tool_provider(\n            &self,\n            _prov: Arc<dyn crate::providers::base::Provider>,\n        ) -> Result<Vec<Tool>> {\n            Ok(vec![])\n        }\n\n        async fn register_tool_provider_with_tools(\n            &self,\n            _prov: Arc<dyn crate::providers::base::Provider>,\n            tools: Vec<Tool>,\n        ) -> Result<Vec<Tool>> {\n            Ok(tools)\n        }\n\n        async fn deregister_tool_provider(&self, _provider_name: &str) -> Result<()> {\n            Ok(())\n        }\n\n        async fn call_tool(&self, tool_name: &str, _args: HashMap<String, Value>) -> Result<Value> {\n            self.called.lock().await.push(tool_name.to_string());\n            Ok(Value::Number(serde_json::Number::from(5)))\n        }\n\n        async fn search_tools(&self, query: &str, _limit: usize) -> Result<Vec<Tool>> {\n            self.called.lock().await.push(format!(\"search:{query}\"));\n            Ok(vec![])\n        }\n\n        fn get_transports(&self) -> HashMap<String, Arc<dyn crate::transports::ClientTransport>> {\n            HashMap::new()\n        }\n\n        async fn call_tool_stream(\n            &self,\n            tool_name: &str,\n            _args: HashMap<String, Value>,\n        ) -> Result<Box<dyn crate::transports::stream::StreamResult>> {\n            self.called.lock().await.push(format!(\"stream:{tool_name}\"));\n            Ok(boxed_vec_stream(vec![Value::String(\"chunk\".into())]))\n        }\n    }\n\n    #[tokio::test(flavor = \"multi_thread\")]\n    async fn codemode_helpers_forward_to_client() {\n        let client = Arc::new(MockClient {\n            called: Arc::new(Mutex::new(Vec::new())),\n        });\n        let codemode = CodeModeUtcp::new(client.clone());\n\n        codemode\n            .call_tool(\"demo.tool\", HashMap::new())\n            .await\n            .unwrap();\n        codemode.search_tools(\"demo\", 5).await.unwrap();\n        let mut stream = codemode\n            .call_tool_stream(\"demo.tool\", HashMap::new())\n            .await\n            .unwrap();\n        let _ = stream.next().await.unwrap();\n\n        let calls = client.called.lock().await.clone();\n        assert_eq!(calls, vec![\"demo.tool\", \"search:demo\", \"stream:demo.tool\"]);\n    }\n\n    #[tokio::test(flavor = \"multi_thread\")]\n    async fn execute_runs_rusty_snippet_and_call_tool() {\n        let client = Arc::new(MockClient {\n            called: Arc::new(Mutex::new(Vec::new())),\n        });\n        let codemode = CodeModeUtcp::new(client);\n\n        let code = r#\"let x = 2 + 3; let y = call_tool(\"math.add\", #{\"a\":1}); x + y\"#;\n        let args = CodeModeArgs {\n            code: code.into(),\n            timeout: Some(1000),\n        };\n        let res = codemode.execute(args).await.unwrap();\n        assert_eq!(res.value, serde_json::json!(10));\n    }\n\n    #[tokio::test(flavor = \"multi_thread\")]\n    async fn execute_collects_stream_results() {\n        let client = Arc::new(MockClient {\n            called: Arc::new(Mutex::new(Vec::new())),\n        });\n        let codemode = CodeModeUtcp::new(client.clone());\n\n        let code = r#\"let chunks = call_tool_stream(\"demo.tool\", #{}); chunks\"#;\n        let args = CodeModeArgs {\n            code: code.into(),\n            timeout: Some(1_000),\n        };\n        let res = codemode.execute(args).await.unwrap();\n        assert_eq!(res.value, serde_json::json!([\"chunk\"]));\n        let calls = client.called.lock().await.clone();\n        assert_eq!(calls, vec![\"stream:demo.tool\"]);\n    }\n\n    // Security Tests\n\n    #[tokio::test(flavor = \"multi_thread\")]\n    async fn security_rejects_oversized_code() {\n        let client = Arc::new(MockClient {\n            called: Arc::new(Mutex::new(Vec::new())),\n        });\n        let codemode = CodeModeUtcp::new(client);\n\n        // Create code larger than MAX_CODE_SIZE (100KB)\n        let large_code = \"x\".repeat(150_000);\n        let args = CodeModeArgs {\n            code: large_code,\n            timeout: Some(1000),\n        };\n\n        let result = codemode.execute(args).await;\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"exceeds maximum\"));\n    }\n\n    #[tokio::test(flavor = \"multi_thread\")]\n    async fn security_rejects_dangerous_patterns() {\n        let client = Arc::new(MockClient {\n            called: Arc::new(Mutex::new(Vec::new())),\n        });\n        let codemode = CodeModeUtcp::new(client);\n\n        // Test each dangerous pattern\n        let dangerous_codes = vec![\n            \"eval(some_code)\",\n            \"import some_module\",\n            \"fn evil() { }\",\n            \"while true { }\",\n            \"loop { break; }\",\n        ];\n\n        for code in dangerous_codes {\n            let args = CodeModeArgs {\n                code: code.to_string(),\n                timeout: Some(1000),\n            };\n\n            let result = codemode.execute(args).await;\n            assert!(result.is_err(), \"Should reject: {}\", code);\n            assert!(result\n                .unwrap_err()\n                .to_string()\n                .contains(\"prohibited pattern\"));\n        }\n    }\n\n    #[tokio::test(flavor = \"multi_thread\")]\n    async fn security_enforces_timeout() {\n        let client = Arc::new(MockClient {\n            called: Arc::new(Mutex::new(Vec::new())),\n        });\n        let codemode = CodeModeUtcp::new(client);\n\n        // Code that takes a while (but not infinite due to operation limits)\n        let code = r#\"let sum = 0; for i in 0..100000 { sum = sum + i; } sum\"#;\n        let args = CodeModeArgs {\n            code: code.to_string(),\n            timeout: Some(1), // Very short timeout - 1ms\n        };\n\n        let result = codemode.execute(args).await;\n        // This should timeout or complete very fast\n        // Either way, we're testing that timeout mechanism works\n        if result.is_err() {\n            let err = result.unwrap_err().to_string();\n            // It might timeout or hit operation limit\n            assert!(\n                err.contains(\"timeout\") || err.contains(\"operations\"),\n                \"Unexpected error: {}\",\n                err\n            );\n        }\n    }\n\n    #[tokio::test(flavor = \"multi_thread\")]\n    async fn security_rejects_excessive_timeout() {\n        let client = Arc::new(MockClient {\n            called: Arc::new(Mutex::new(Vec::new())),\n        });\n        let codemode = CodeModeUtcp::new(client);\n\n        let args = CodeModeArgs {\n            code: \"42\".to_string(),\n            timeout: Some(60_000), // 60 seconds - over MAX_TIMEOUT_MS\n        };\n\n        let result = codemode.execute(args).await;\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"exceeds maximum\"));\n    }\n\n    #[tokio::test(flavor = \"multi_thread\")]\n    async fn security_limits_output_size() {\n        let client = Arc::new(MockClient {\n            called: Arc::new(Mutex::new(Vec::new())),\n        });\n        let codemode = CodeModeUtcp::new(client);\n\n        // Create code that would produce large output through array limits\n        // This will hit the array size limit (10,000 items)\n        let code = r#\"let arr = []; for i in 0..15000 { arr.push(i); } arr\"#;\n        let args = CodeModeArgs {\n            code: code.to_string(),\n            timeout: Some(10_000),\n        };\n\n        let result = codemode.execute(args).await;\n        // Should fail due to array size limit or operations limit\n        assert!(result.is_err(), \"Should fail due to limits\");\n        let err = result.unwrap_err().to_string();\n        assert!(\n            err.contains(\"array\") || err.contains(\"operations\") || err.contains(\"eval error\"),\n            \"Unexpected error: {}\",\n            err\n        );\n    }\n\n    #[test]\n    fn security_sprintf_limits_format_size() {\n        let fmt = \"x\".repeat(20_000); // Over MAX_FMT_SIZE\n        let result = sprintf(&fmt, &[]);\n        assert_eq!(result, \"[ERROR: Format string too long]\");\n    }\n\n    #[test]\n    fn security_sprintf_limits_args_count() {\n        let args: Vec<Dynamic> = (0..200).map(|i| Dynamic::from(i)).collect();\n        let result = sprintf(\"{}\", &args);\n        assert_eq!(result, \"[ERROR: Too many arguments]\");\n    }\n\n    #[test]\n    fn security_sprintf_truncates_long_args() {\n        let long_arg = Dynamic::from(\"x\".repeat(2000));\n        let result = sprintf(\"Value: {}\", &[long_arg]);\n        assert!(result.contains(\"...[truncated]\"));\n    }\n\n    #[test]\n    fn security_sprintf_limits_output_size() {\n        let fmt = \"{}\".repeat(10_000);\n        let args: Vec<Dynamic> = (0..10_000)\n            .map(|i| Dynamic::from(format!(\"arg{}\", i)))\n            .collect();\n        let result = sprintf(&fmt, &args[..100]); // Use fewer args to stay under MAX_ARGS\n                                                  // Output should be truncated if it gets too large\n        if result.len() > 20_000 {\n            assert!(result.contains(\"...[truncated]\"));\n        }\n    }\n}\n",
      "line_count": 899,
      "word_count": 2705,
      "title": "Mod.Rs",
      "summary": "use std::collections::HashMap; use std::sync::Arc;",
      "key_terms": [
        "REFERENCE",
        "close",
        "const",
        "chars",
        "convert",
        "Code",
        "Either",
        "list",
        "fmt",
        "importing",
        "selected",
        "Clone",
        "helper",
        "Scope",
        "providers",
        "reject",
        "Self",
        "multiple",
        "satisfy",
        "MultiThread"
      ],
      "timestamp": "2025-12-24T18:56:14.683366"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\providers\\mod.rs",
      "content_type": "code",
      "content": "pub mod base;\npub mod cli;\npub mod graphql;\npub mod grpc;\npub mod http;\npub mod http_stream;\npub mod mcp;\npub mod sse;\npub mod tcp;\npub mod text;\npub mod udp;\npub mod webrtc;\npub mod websocket;\n",
      "line_count": 14,
      "word_count": 39,
      "title": "Mod.Rs",
      "summary": "pub mod base; pub mod cli;",
      "key_terms": [
        "mcp",
        "tcp",
        "webrtc",
        "grpc",
        "sse",
        "pub",
        "cli",
        "text",
        "http",
        "base",
        "graphql",
        "udp",
        "websocket",
        "mod"
      ],
      "timestamp": "2025-12-24T18:56:14.712379"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\providers\\base\\mod.rs",
      "content_type": "code",
      "content": "use serde::{Deserialize, Serialize};\n\nuse crate::auth::AuthConfig;\n\n/// Provider categories supported by UTCP transports.\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum ProviderType {\n    Http,\n    Sse,\n    HttpStream,\n    Cli,\n    Websocket,\n    Grpc,\n    Graphql,\n    Tcp,\n    Udp,\n    Webrtc,\n    Mcp,\n    Text,\n    #[serde(other)]\n    Unknown,\n}\n\nimpl ProviderType {\n    /// Transport registry key used to look up the matching communication protocol.\n    pub fn as_key(&self) -> &'static str {\n        match self {\n            ProviderType::Http => \"http\",\n            ProviderType::Sse => \"sse\",\n            ProviderType::HttpStream => \"http_stream\",\n            ProviderType::Cli => \"cli\",\n            ProviderType::Websocket => \"websocket\",\n            ProviderType::Grpc => \"grpc\",\n            ProviderType::Graphql => \"graphql\",\n            ProviderType::Tcp => \"tcp\",\n            ProviderType::Udp => \"udp\",\n            ProviderType::Webrtc => \"webrtc\",\n            ProviderType::Mcp => \"mcp\",\n            ProviderType::Text => \"text\",\n            ProviderType::Unknown => \"unknown\",\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::ProviderType;\n\n    #[test]\n    fn provider_type_keys_match_transport_names() {\n        assert_eq!(ProviderType::Http.as_key(), \"http\");\n        assert_eq!(ProviderType::Sse.as_key(), \"sse\");\n        assert_eq!(ProviderType::HttpStream.as_key(), \"http_stream\");\n        assert_eq!(ProviderType::Cli.as_key(), \"cli\");\n        assert_eq!(ProviderType::Websocket.as_key(), \"websocket\");\n        assert_eq!(ProviderType::Grpc.as_key(), \"grpc\");\n        assert_eq!(ProviderType::Graphql.as_key(), \"graphql\");\n        assert_eq!(ProviderType::Tcp.as_key(), \"tcp\");\n        assert_eq!(ProviderType::Udp.as_key(), \"udp\");\n        assert_eq!(ProviderType::Webrtc.as_key(), \"webrtc\");\n        assert_eq!(ProviderType::Mcp.as_key(), \"mcp\");\n        assert_eq!(ProviderType::Text.as_key(), \"text\");\n        assert_eq!(ProviderType::Unknown.as_key(), \"unknown\");\n    }\n}\n\n/// Common interface each provider implementation must expose.\npub trait Provider: Send + Sync + std::fmt::Debug + std::any::Any {\n    /// Return the provider type used to pick the right transport.\n    fn type_(&self) -> ProviderType;\n    /// Human readable provider name used for discovery and namespacing tools.\n    fn name(&self) -> String;\n\n    /// Downcast helper for transports that need the concrete provider type.\n    fn as_any(&self) -> &dyn std::any::Any;\n\n    /// Returns the list of allowed communication protocols for this provider.\n    /// If not configured (None or empty), defaults to only the provider's own protocol type.\n    fn allowed_protocols(&self) -> Vec<String> {\n        // Default implementation - providers can override this\n        vec![self.type_().as_key().to_string()]\n    }\n}\n\n/// Minimal provider shape shared by most transport-specific provider structs.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BaseProvider {\n    pub name: String,\n    pub provider_type: ProviderType,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub auth: Option<AuthConfig>,\n    /// List of allowed communication protocol types (e.g., [\"http\", \"cli\"]).\n    /// If undefined, null, or empty, defaults to only allowing this provider's own protocol type.\n    /// This provides secure-by-default behavior where a provider can only register/call tools\n    /// that use its own protocol unless explicitly configured otherwise.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    #[serde(default)]\n    pub allowed_communication_protocols: Option<Vec<String>>,\n}\n\nimpl Provider for BaseProvider {\n    fn type_(&self) -> ProviderType {\n        self.provider_type.clone()\n    }\n    fn name(&self) -> String {\n        self.name.clone()\n    }\n    fn as_any(&self) -> &dyn std::any::Any {\n        self\n    }\n    fn allowed_protocols(&self) -> Vec<String> {\n        if let Some(ref protocols) = self.allowed_communication_protocols {\n            if !protocols.is_empty() {\n                return protocols.clone();\n            }\n        }\n        // Default to only allowing this provider's own protocol\n        vec![self.provider_type.as_key().to_string()]\n    }\n}\n",
      "line_count": 122,
      "word_count": 394,
      "title": "Mod.Rs",
      "summary": "use serde::{Deserialize, Serialize}; use crate::auth::AuthConfig;",
      "key_terms": [
        "null",
        "grpc",
        "up",
        "each",
        "If",
        "list",
        "fmt",
        "Clone",
        "Udp",
        "websocket",
        "helper",
        "unknown",
        "only",
        "providers",
        "Sync",
        "must",
        "other",
        "namespacing",
        "Sse",
        "shared"
      ],
      "timestamp": "2025-12-24T18:56:14.744578"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\providers\\cli\\mod.rs",
      "content_type": "code",
      "content": "use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\nuse crate::auth::AuthConfig;\nuse crate::providers::base::{BaseProvider, Provider, ProviderType};\n\n/// Provider definition for CLI-based tool execution.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CliProvider {\n    #[serde(flatten)]\n    pub base: BaseProvider,\n    pub command_name: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub working_dir: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub env_vars: Option<HashMap<String, String>>,\n}\n\nimpl Provider for CliProvider {\n    fn type_(&self) -> ProviderType {\n        ProviderType::Cli\n    }\n\n    fn name(&self) -> String {\n        self.base.name.clone()\n    }\n\n    fn as_any(&self) -> &dyn std::any::Any {\n        self\n    }\n}\n\nimpl CliProvider {\n    /// Construct a CLI provider with a base command and optional authentication metadata.\n    pub fn new(name: String, command_name: String, auth: Option<AuthConfig>) -> Self {\n        Self {\n            base: BaseProvider {\n                name,\n                provider_type: ProviderType::Cli,\n                auth,\n                allowed_communication_protocols: None,\n            },\n            command_name,\n            working_dir: None,\n            env_vars: None,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn deserializes_cli_provider_with_minimal_config() {\n        let json = json!({\n            \"name\": \"test-cli\",\n            \"provider_type\": \"cli\",\n            \"command_name\": \"echo\"\n        });\n\n        let provider: CliProvider = serde_json::from_value(json).unwrap();\n        assert_eq!(provider.base.name, \"test-cli\");\n        assert_eq!(provider.command_name, \"echo\");\n        assert!(provider.working_dir.is_none());\n        assert!(provider.env_vars.is_none());\n        assert_eq!(provider.type_(), ProviderType::Cli);\n    }\n\n    #[test]\n    fn cli_provider_new_sets_defaults() {\n        let provider = CliProvider::new(\"builder\".to_string(), \"make\".to_string(), None);\n\n        assert_eq!(provider.base.name, \"builder\");\n        assert_eq!(provider.base.provider_type, ProviderType::Cli);\n        assert_eq!(provider.command_name, \"make\");\n        assert!(provider.working_dir.is_none());\n        assert!(provider.env_vars.is_none());\n    }\n}\n",
      "line_count": 82,
      "word_count": 179,
      "title": "Mod.Rs",
      "summary": "use serde::{Deserialize, Serialize}; use std::collections::HashMap;",
      "key_terms": [
        "CliProvider",
        "any",
        "pub",
        "Deserialize",
        "None",
        "make",
        "dyn",
        "flatten",
        "based",
        "CLI-based",
        "Cli",
        "test-cli",
        "auth",
        "Clone",
        "with",
        "tool",
        "test",
        "ProviderType",
        "and",
        "providers"
      ],
      "timestamp": "2025-12-24T18:56:14.800891"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\providers\\graphql\\mod.rs",
      "content_type": "code",
      "content": "use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\nuse crate::auth::AuthConfig;\nuse crate::providers::base::{BaseProvider, Provider, ProviderType};\n\n/// Provider configuration for GraphQL endpoints.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GraphqlProvider {\n    #[serde(flatten)]\n    pub base: BaseProvider,\n    pub url: String,\n    #[serde(default = \"GraphqlProvider::default_operation\")]\n    pub operation_type: String, // query | mutation | subscription\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub operation_name: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub headers: Option<HashMap<String, String>>,\n}\n\nimpl Provider for GraphqlProvider {\n    fn type_(&self) -> ProviderType {\n        ProviderType::Graphql\n    }\n\n    fn name(&self) -> String {\n        self.base.name.clone()\n    }\n\n    fn as_any(&self) -> &dyn std::any::Any {\n        self\n    }\n}\n\nimpl GraphqlProvider {\n    /// Create a GraphQL provider with sensible defaults.\n    pub fn new(name: String, url: String, auth: Option<AuthConfig>) -> Self {\n        Self {\n            base: BaseProvider {\n                name,\n                provider_type: ProviderType::Graphql,\n                auth,\n                allowed_communication_protocols: None,\n            },\n            url,\n            operation_type: Self::default_operation(),\n            operation_name: None,\n            headers: None,\n        }\n    }\n\n    fn default_operation() -> String {\n        \"query\".to_string()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn graphql_provider_defaults_to_query() {\n        let json = json!({\n            \"name\": \"test-graphql\",\n            \"provider_type\": \"graphql\",\n            \"url\": \"http://localhost:4000/graphql\"\n        });\n\n        let provider: GraphqlProvider = serde_json::from_value(json).unwrap();\n        assert_eq!(provider.base.name, \"test-graphql\");\n        assert_eq!(provider.operation_type, \"query\");\n        assert!(provider.operation_name.is_none());\n        assert!(provider.headers.is_none());\n    }\n\n    #[test]\n    fn graphql_provider_accepts_custom_operation_and_headers() {\n        let json = json!({\n            \"name\": \"test-graphql-full\",\n            \"provider_type\": \"graphql\",\n            \"url\": \"https://example.com/graphql\",\n            \"operation_type\": \"mutation\",\n            \"operation_name\": \"CreateUser\",\n            \"headers\": {\n                \"Authorization\": \"Bearer token\"\n            }\n        });\n\n        let provider: GraphqlProvider = serde_json::from_value(json).unwrap();\n        assert_eq!(provider.operation_type, \"mutation\");\n        assert_eq!(provider.operation_name.as_deref(), Some(\"CreateUser\"));\n        assert_eq!(\n            provider\n                .headers\n                .unwrap()\n                .get(\"Authorization\")\n                .map(|s| s.as_str()),\n            Some(\"Bearer token\")\n        );\n    }\n\n    #[test]\n    fn graphql_provider_new_sets_defaults() {\n        let provider = GraphqlProvider::new(\n            \"new-graphql\".to_string(),\n            \"https://example.com/graphql\".to_string(),\n            None,\n        );\n\n        assert_eq!(provider.base.provider_type, ProviderType::Graphql);\n        assert_eq!(provider.operation_type, \"query\");\n        assert!(provider.operation_name.is_none());\n    }\n}\n",
      "line_count": 116,
      "word_count": 236,
      "title": "Mod.Rs",
      "summary": "use serde::{Deserialize, Serialize}; use std::collections::HashMap;",
      "key_terms": [
        "localhost",
        "headers",
        "token",
        "Clone",
        "providers",
        "Self",
        "AuthConfig",
        "https",
        "let",
        "super",
        "struct",
        "collections",
        "GraphqlProvider",
        "any",
        "url",
        "default",
        "std",
        "derive",
        "tests",
        "clone"
      ],
      "timestamp": "2025-12-24T18:56:14.845427"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\providers\\grpc\\mod.rs",
      "content_type": "code",
      "content": "use serde::{Deserialize, Serialize};\n\nuse crate::auth::AuthConfig;\nuse crate::providers::base::{BaseProvider, Provider, ProviderType};\n\n/// Provider definition for gRPC services.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GrpcProvider {\n    #[serde(flatten)]\n    pub base: BaseProvider,\n    pub host: String,\n    pub port: u16,\n    #[serde(default)]\n    pub use_ssl: bool,\n}\n\nimpl Provider for GrpcProvider {\n    fn type_(&self) -> ProviderType {\n        ProviderType::Grpc\n    }\n\n    fn name(&self) -> String {\n        self.base.name.clone()\n    }\n\n    fn as_any(&self) -> &dyn std::any::Any {\n        self\n    }\n}\n\nimpl GrpcProvider {\n    /// Construct a gRPC provider with host/port and optional auth.\n    pub fn new(name: String, host: String, port: u16, auth: Option<AuthConfig>) -> Self {\n        Self {\n            base: BaseProvider {\n                name,\n                provider_type: ProviderType::Grpc,\n                auth,\n                allowed_communication_protocols: None,\n            },\n            host,\n            port,\n            use_ssl: false,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn grpc_provider_defaults_use_ssl_to_false() {\n        let json = json!({\n            \"name\": \"test-grpc\",\n            \"provider_type\": \"grpc\",\n            \"host\": \"localhost\",\n            \"port\": 50051\n        });\n\n        let provider: GrpcProvider = serde_json::from_value(json).unwrap();\n        assert_eq!(provider.base.name, \"test-grpc\");\n        assert_eq!(provider.host, \"localhost\");\n        assert_eq!(provider.port, 50051);\n        assert!(!provider.use_ssl);\n    }\n\n    #[test]\n    fn grpc_provider_allows_ssl_flag() {\n        let json = json!({\n            \"name\": \"secure-grpc\",\n            \"provider_type\": \"grpc\",\n            \"host\": \"example.com\",\n            \"port\": 443,\n            \"use_ssl\": true\n        });\n\n        let provider: GrpcProvider = serde_json::from_value(json).unwrap();\n        assert!(provider.use_ssl);\n        assert_eq!(provider.host, \"example.com\");\n        assert_eq!(provider.port, 443);\n    }\n\n    #[test]\n    fn grpc_provider_new_sets_defaults() {\n        let provider =\n            GrpcProvider::new(\"new-grpc\".to_string(), \"localhost\".to_string(), 1234, None);\n\n        assert_eq!(provider.base.provider_type, ProviderType::Grpc);\n        assert_eq!(provider.host, \"localhost\");\n        assert_eq!(provider.port, 1234);\n        assert!(!provider.use_ssl);\n    }\n}\n",
      "line_count": 96,
      "word_count": 199,
      "title": "Mod.Rs",
      "summary": "use serde::{Deserialize, Serialize}; use crate::auth::AuthConfig;",
      "key_terms": [
        "grpc",
        "any",
        "pub",
        "Deserialize",
        "None",
        "localhost",
        "dyn",
        "flatten",
        "auth",
        "Clone",
        "with",
        "bool",
        "test",
        "ProviderType",
        "and",
        "providers",
        "protocol",
        "for",
        "gRPC",
        "services"
      ],
      "timestamp": "2025-12-24T18:56:14.877439"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\providers\\http\\mod.rs",
      "content_type": "code",
      "content": "use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\nuse crate::auth::AuthConfig;\nuse crate::providers::base::{BaseProvider, Provider, ProviderType};\n\n/// Provider configuration for HTTP-based tools.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct HttpProvider {\n    #[serde(flatten)]\n    pub base: BaseProvider,\n    pub http_method: String,\n    pub url: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub content_type: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub headers: Option<HashMap<String, String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub body_field: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub header_fields: Option<Vec<String>>,\n}\n\nimpl Provider for HttpProvider {\n    fn type_(&self) -> ProviderType {\n        ProviderType::Http\n    }\n\n    fn name(&self) -> String {\n        self.base.name.clone()\n    }\n\n    fn as_any(&self) -> &dyn std::any::Any {\n        self\n    }\n}\n\nimpl HttpProvider {\n    /// Create an HTTP provider with common defaults (JSON content type and GET/POST URLs).\n    pub fn new(name: String, url: String, http_method: String, auth: Option<AuthConfig>) -> Self {\n        Self {\n            base: BaseProvider {\n                name,\n                provider_type: ProviderType::Http,\n                auth,\n                allowed_communication_protocols: None,\n            },\n            http_method,\n            url,\n            content_type: Some(\"application/json\".to_string()),\n            headers: None,\n            body_field: None,\n            header_fields: None,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn test_http_provider_deserialization() {\n        let json = json!({\n            \"name\": \"test-http\",\n            \"provider_type\": \"http\",\n            \"url\": \"http://example.com\",\n            \"http_method\": \"POST\"\n        });\n\n        let provider: HttpProvider = serde_json::from_value(json).unwrap();\n        assert_eq!(provider.base.name, \"test-http\");\n        assert_eq!(provider.url, \"http://example.com\");\n        assert_eq!(provider.http_method, \"POST\");\n        assert!(provider.content_type.is_none()); // Defaults are handled in new(), but serde doesn't use new() unless default impl exists\n    }\n\n    #[test]\n    fn test_http_provider_full_config() {\n        let json = json!({\n            \"name\": \"test-http-full\",\n            \"provider_type\": \"http\",\n            \"url\": \"http://example.com/api\",\n            \"http_method\": \"GET\",\n            \"content_type\": \"application/xml\",\n            \"headers\": {\n                \"X-Custom\": \"value\"\n            }\n        });\n\n        let provider: HttpProvider = serde_json::from_value(json).unwrap();\n        assert_eq!(provider.content_type.as_deref(), Some(\"application/xml\"));\n        assert_eq!(\n            provider\n                .headers\n                .unwrap()\n                .get(\"X-Custom\")\n                .map(|s| s.as_str()),\n            Some(\"value\")\n        );\n    }\n}\n",
      "line_count": 104,
      "word_count": 239,
      "title": "Mod.Rs",
      "summary": "use serde::{Deserialize, Serialize}; use std::collections::HashMap;",
      "key_terms": [
        "headers",
        "based",
        "Clone",
        "providers",
        "Self",
        "application",
        "AuthConfig",
        "let",
        "super",
        "struct",
        "test-http",
        "collections",
        "Vec",
        "any",
        "HTTP-based",
        "type",
        "url",
        "default",
        "X-Custom",
        "std"
      ],
      "timestamp": "2025-12-24T18:56:14.926364"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\providers\\http_stream\\mod.rs",
      "content_type": "code",
      "content": "use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\nuse crate::auth::AuthConfig;\nuse crate::providers::base::{BaseProvider, Provider, ProviderType};\n\n/// Provider definition for streaming HTTP endpoints that emit chunked JSON.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct StreamableHttpProvider {\n    #[serde(flatten)]\n    pub base: BaseProvider,\n    pub url: String,\n    #[serde(default = \"StreamableHttpProvider::default_method\")]\n    pub http_method: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub headers: Option<HashMap<String, String>>,\n}\n\nimpl Provider for StreamableHttpProvider {\n    fn type_(&self) -> ProviderType {\n        ProviderType::HttpStream\n    }\n\n    fn name(&self) -> String {\n        self.base.name.clone()\n    }\n\n    fn as_any(&self) -> &dyn std::any::Any {\n        self\n    }\n}\n\nimpl StreamableHttpProvider {\n    /// Construct a streaming HTTP provider pointing at a base URL.\n    pub fn new(name: String, url: String, auth: Option<AuthConfig>) -> Self {\n        Self {\n            base: BaseProvider {\n                name,\n                provider_type: ProviderType::HttpStream,\n                auth,\n                allowed_communication_protocols: None,\n            },\n            url,\n            http_method: Self::default_method(),\n            headers: None,\n        }\n    }\n\n    fn default_method() -> String {\n        \"POST\".to_string()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn streamable_http_provider_defaults_to_post() {\n        let json = json!({\n            \"name\": \"test-http-stream\",\n            \"provider_type\": \"http_stream\",\n            \"url\": \"https://example.com/stream\"\n        });\n\n        let provider: StreamableHttpProvider = serde_json::from_value(json).unwrap();\n        assert_eq!(provider.base.name, \"test-http-stream\");\n        assert_eq!(provider.http_method, \"POST\");\n        assert!(provider.headers.is_none());\n    }\n\n    #[test]\n    fn streamable_http_provider_accepts_method_and_headers() {\n        let json = json!({\n            \"name\": \"test-http-stream-full\",\n            \"provider_type\": \"http_stream\",\n            \"url\": \"https://example.com/stream\",\n            \"http_method\": \"PUT\",\n            \"headers\": {\n                \"Authorization\": \"Bearer token\"\n            }\n        });\n\n        let provider: StreamableHttpProvider = serde_json::from_value(json).unwrap();\n        assert_eq!(provider.http_method, \"PUT\");\n        assert_eq!(\n            provider\n                .headers\n                .unwrap()\n                .get(\"Authorization\")\n                .map(|s| s.as_str()),\n            Some(\"Bearer token\")\n        );\n    }\n\n    #[test]\n    fn streamable_http_provider_new_sets_defaults() {\n        let provider = StreamableHttpProvider::new(\n            \"new-http-stream\".to_string(),\n            \"https://example.com\".to_string(),\n            None,\n        );\n\n        assert_eq!(provider.base.provider_type, ProviderType::HttpStream);\n        assert_eq!(provider.http_method, \"POST\");\n        assert!(provider.headers.is_none());\n    }\n}\n",
      "line_count": 110,
      "word_count": 225,
      "title": "Mod.Rs",
      "summary": "use serde::{Deserialize, Serialize}; use std::collections::HashMap;",
      "key_terms": [
        "headers",
        "token",
        "Clone",
        "providers",
        "pointing",
        "Self",
        "AuthConfig",
        "https",
        "let",
        "that",
        "super",
        "streaming",
        "struct",
        "test-http",
        "StreamableHttpProvider",
        "collections",
        "any",
        "url",
        "HttpStream",
        "default"
      ],
      "timestamp": "2025-12-24T18:56:14.968604"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\providers\\mcp\\mod.rs",
      "content_type": "code",
      "content": "use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\nuse crate::auth::AuthConfig;\nuse crate::providers::base::{BaseProvider, Provider, ProviderType};\n\n/// Provider definition for MCP servers reachable over HTTP or stdio.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct McpProvider {\n    #[serde(flatten)]\n    pub base: BaseProvider,\n    // HTTP transport fields\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub url: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub headers: Option<HashMap<String, String>>,\n    // Stdio transport fields\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub command: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub args: Option<Vec<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub env_vars: Option<HashMap<String, String>>,\n}\n\nimpl Provider for McpProvider {\n    fn type_(&self) -> ProviderType {\n        ProviderType::Mcp\n    }\n\n    fn name(&self) -> String {\n        self.base.name.clone()\n    }\n\n    fn as_any(&self) -> &dyn std::any::Any {\n        self\n    }\n}\n\nimpl McpProvider {\n    /// Create an HTTP-based MCP provider.\n    pub fn new(name: String, url: String, auth: Option<AuthConfig>) -> Self {\n        Self {\n            base: BaseProvider {\n                name,\n                provider_type: ProviderType::Mcp,\n                auth,\n                allowed_communication_protocols: None,\n            },\n            url: Some(url),\n            headers: None,\n            command: None,\n            args: None,\n            env_vars: None,\n        }\n    }\n\n    /// Create a stdio-based MCP provider that spawns a local process.\n    pub fn new_stdio(\n        name: String,\n        command: String,\n        args: Option<Vec<String>>,\n        env_vars: Option<HashMap<String, String>>,\n    ) -> Self {\n        Self {\n            base: BaseProvider {\n                name,\n                provider_type: ProviderType::Mcp,\n                auth: None,\n                allowed_communication_protocols: None,\n            },\n            url: None,\n            headers: None,\n            command: Some(command),\n            args,\n            env_vars,\n        }\n    }\n\n    /// True if the provider should be reached via stdio.\n    pub fn is_stdio(&self) -> bool {\n        self.command.is_some()\n    }\n\n    /// True if the provider should be reached via HTTP.\n    pub fn is_http(&self) -> bool {\n        self.url.is_some()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn test_mcp_provider_http_deserialization() {\n        let json = json!({\n            \"name\": \"test-mcp-http\",\n            \"provider_type\": \"mcp\",\n            \"url\": \"http://localhost:3000/mcp\"\n        });\n\n        let provider: McpProvider = serde_json::from_value(json).unwrap();\n        assert_eq!(provider.base.name, \"test-mcp-http\");\n        assert_eq!(provider.url.as_deref(), Some(\"http://localhost:3000/mcp\"));\n        assert!(provider.is_http());\n        assert!(!provider.is_stdio());\n    }\n\n    #[test]\n    fn test_mcp_provider_stdio_deserialization() {\n        let json = json!({\n            \"name\": \"test-mcp-stdio\",\n            \"provider_type\": \"mcp\",\n            \"command\": \"python\",\n            \"args\": [\"server.py\"],\n            \"env_vars\": {\n                \"DEBUG\": \"1\"\n            }\n        });\n\n        let provider: McpProvider = serde_json::from_value(json).unwrap();\n        assert_eq!(provider.base.name, \"test-mcp-stdio\");\n        assert_eq!(provider.command.as_deref(), Some(\"python\"));\n        assert_eq!(provider.args.as_ref().unwrap()[0], \"server.py\");\n        assert_eq!(\n            provider\n                .env_vars\n                .as_ref()\n                .unwrap()\n                .get(\"DEBUG\")\n                .map(|s| s.as_str()),\n            Some(\"1\")\n        );\n        assert!(provider.is_stdio());\n        assert!(!provider.is_http());\n    }\n}\n",
      "line_count": 140,
      "word_count": 316,
      "title": "Mod.Rs",
      "summary": "use serde::{Deserialize, Serialize}; use std::collections::HashMap;",
      "key_terms": [
        "localhost",
        "headers",
        "based",
        "Clone",
        "providers",
        "Self",
        "AuthConfig",
        "if",
        "let",
        "that",
        "reached",
        "super",
        "struct",
        "fields",
        "test-mcp",
        "collections",
        "Vec",
        "any",
        "HTTP-based",
        "or"
      ],
      "timestamp": "2025-12-24T18:56:15.036870"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\providers\\sse\\mod.rs",
      "content_type": "code",
      "content": "use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\nuse crate::auth::AuthConfig;\nuse crate::providers::base::{BaseProvider, Provider, ProviderType};\n\n/// Provider definition for Server-Sent Events endpoints.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SseProvider {\n    #[serde(flatten)]\n    pub base: BaseProvider,\n    pub url: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub headers: Option<HashMap<String, String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub body_field: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub header_fields: Option<Vec<String>>,\n}\n\nimpl Provider for SseProvider {\n    fn type_(&self) -> ProviderType {\n        ProviderType::Sse\n    }\n\n    fn name(&self) -> String {\n        self.base.name.clone()\n    }\n\n    fn as_any(&self) -> &dyn std::any::Any {\n        self\n    }\n}\n\nimpl SseProvider {\n    /// Construct an SSE provider pointing at a streaming endpoint.\n    pub fn new(name: String, url: String, auth: Option<AuthConfig>) -> Self {\n        Self {\n            base: BaseProvider {\n                name,\n                provider_type: ProviderType::Sse,\n                auth,\n                allowed_communication_protocols: None,\n            },\n            url,\n            headers: None,\n            body_field: None,\n            header_fields: None,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn sse_provider_deserializes_minimal_config() {\n        let json = json!({\n            \"name\": \"test-sse\",\n            \"provider_type\": \"sse\",\n            \"url\": \"https://example.com/sse\"\n        });\n\n        let provider: SseProvider = serde_json::from_value(json).unwrap();\n        assert_eq!(provider.base.name, \"test-sse\");\n        assert_eq!(provider.url, \"https://example.com/sse\");\n        assert!(provider.headers.is_none());\n        assert!(provider.body_field.is_none());\n        assert!(provider.header_fields.is_none());\n    }\n\n    #[test]\n    fn sse_provider_accepts_headers_and_fields() {\n        let json = json!({\n            \"name\": \"test-sse-full\",\n            \"provider_type\": \"sse\",\n            \"url\": \"https://example.com/stream\",\n            \"headers\": {\n                \"Authorization\": \"Bearer token\"\n            },\n            \"body_field\": \"data\",\n            \"header_fields\": [\"Content-Type\", \"X-Trace-Id\"]\n        });\n\n        let provider: SseProvider = serde_json::from_value(json).unwrap();\n        assert_eq!(\n            provider\n                .headers\n                .unwrap()\n                .get(\"Authorization\")\n                .map(|s| s.as_str()),\n            Some(\"Bearer token\")\n        );\n        assert_eq!(provider.body_field.as_deref(), Some(\"data\"));\n        assert_eq!(\n            provider.header_fields.as_ref().unwrap(),\n            &vec![\"Content-Type\".to_string(), \"X-Trace-Id\".to_string()]\n        );\n    }\n\n    #[test]\n    fn sse_provider_new_sets_defaults() {\n        let provider = SseProvider::new(\n            \"new-sse\".to_string(),\n            \"http://localhost:8080/sse\".to_string(),\n            None,\n        );\n\n        assert_eq!(provider.base.provider_type, ProviderType::Sse);\n        assert!(provider.headers.is_none());\n        assert!(provider.body_field.is_none());\n        assert!(provider.header_fields.is_none());\n    }\n}\n",
      "line_count": 117,
      "word_count": 231,
      "title": "Mod.Rs",
      "summary": "use serde::{Deserialize, Serialize}; use std::collections::HashMap;",
      "key_terms": [
        "localhost",
        "headers",
        "Type",
        "token",
        "Clone",
        "Trace",
        "providers",
        "pointing",
        "Self",
        "Sse",
        "AuthConfig",
        "https",
        "let",
        "sse",
        "super",
        "streaming",
        "struct",
        "collections",
        "Vec",
        "any"
      ],
      "timestamp": "2025-12-24T18:56:15.079560"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\providers\\tcp\\mod.rs",
      "content_type": "code",
      "content": "use serde::{Deserialize, Serialize};\n\nuse crate::auth::AuthConfig;\nuse crate::providers::base::{BaseProvider, Provider, ProviderType};\n\n/// Provider definition for plain TCP endpoints.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TcpProvider {\n    #[serde(flatten)]\n    pub base: BaseProvider,\n    pub host: String,\n    pub port: u16,\n    #[serde(default)]\n    pub timeout_ms: Option<u64>,\n}\n\nimpl Provider for TcpProvider {\n    fn type_(&self) -> ProviderType {\n        ProviderType::Tcp\n    }\n\n    fn name(&self) -> String {\n        self.base.name.clone()\n    }\n\n    fn as_any(&self) -> &dyn std::any::Any {\n        self\n    }\n}\n\nimpl TcpProvider {\n    /// Create a TCP provider with host/port and optional timeout.\n    pub fn new(name: String, host: String, port: u16, auth: Option<AuthConfig>) -> Self {\n        Self {\n            base: BaseProvider {\n                name,\n                provider_type: ProviderType::Tcp,\n                auth,\n                allowed_communication_protocols: None,\n            },\n            host,\n            port,\n            timeout_ms: Some(30_000),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn tcp_provider_defaults_timeout_to_none_when_not_provided() {\n        let json = json!({\n            \"name\": \"test-tcp\",\n            \"provider_type\": \"tcp\",\n            \"host\": \"127.0.0.1\",\n            \"port\": 8080\n        });\n\n        let provider: TcpProvider = serde_json::from_value(json).unwrap();\n        assert_eq!(provider.base.name, \"test-tcp\");\n        assert_eq!(provider.host, \"127.0.0.1\");\n        assert_eq!(provider.port, 8080);\n        assert_eq!(provider.timeout_ms, None);\n    }\n\n    #[test]\n    fn tcp_provider_respects_configured_timeout() {\n        let json = json!({\n            \"name\": \"test-tcp-timeout\",\n            \"provider_type\": \"tcp\",\n            \"host\": \"localhost\",\n            \"port\": 9000,\n            \"timeout_ms\": 5000\n        });\n\n        let provider: TcpProvider = serde_json::from_value(json).unwrap();\n        assert_eq!(provider.timeout_ms, Some(5000));\n    }\n\n    #[test]\n    fn tcp_provider_new_sets_default_timeout() {\n        let provider = TcpProvider::new(\"new-tcp\".to_string(), \"localhost\".to_string(), 80, None);\n\n        assert_eq!(provider.base.provider_type, ProviderType::Tcp);\n        assert_eq!(provider.timeout_ms, Some(30_000));\n    }\n}\n",
      "line_count": 91,
      "word_count": 195,
      "title": "Mod.Rs",
      "summary": "use serde::{Deserialize, Serialize}; use crate::auth::AuthConfig;",
      "key_terms": [
        "any",
        "pub",
        "Deserialize",
        "None",
        "localhost",
        "Some",
        "dyn",
        "flatten",
        "test-tcp",
        "auth",
        "Clone",
        "with",
        "test",
        "ProviderType",
        "TCP",
        "and",
        "providers",
        "tcp",
        "for",
        "protocol"
      ],
      "timestamp": "2025-12-24T18:56:15.111430"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\providers\\text\\mod.rs",
      "content_type": "code",
      "content": "use serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\n\nuse crate::auth::AuthConfig;\nuse crate::providers::base::{BaseProvider, Provider, ProviderType};\n\n/// Provider definition for file-backed text tools.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TextProvider {\n    #[serde(flatten)]\n    pub base: BaseProvider,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub base_path: Option<PathBuf>,\n}\n\nimpl Provider for TextProvider {\n    fn type_(&self) -> ProviderType {\n        ProviderType::Text\n    }\n\n    fn name(&self) -> String {\n        self.base.name.clone()\n    }\n\n    fn as_any(&self) -> &dyn std::any::Any {\n        self\n    }\n}\n\nimpl TextProvider {\n    /// Create a text provider with an optional base directory for scripts and manifests.\n    pub fn new(name: String, base_path: Option<PathBuf>, auth: Option<AuthConfig>) -> Self {\n        Self {\n            base: BaseProvider {\n                name,\n                provider_type: ProviderType::Text,\n                auth,\n                allowed_communication_protocols: None,\n            },\n            base_path,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n    use std::path::Path;\n\n    #[test]\n    fn text_provider_deserializes_without_base_path() {\n        let json = json!({\n            \"name\": \"test-text\",\n            \"provider_type\": \"text\"\n        });\n\n        let provider: TextProvider = serde_json::from_value(json).unwrap();\n        assert_eq!(provider.base.name, \"test-text\");\n        assert!(provider.base_path.is_none());\n        assert_eq!(provider.base.provider_type, ProviderType::Text);\n    }\n\n    #[test]\n    fn text_provider_deserializes_with_base_path() {\n        let json = json!({\n            \"name\": \"test-text-path\",\n            \"provider_type\": \"text\",\n            \"base_path\": \"/tmp/tools\"\n        });\n\n        let provider: TextProvider = serde_json::from_value(json).unwrap();\n        assert_eq!(provider.base_path.as_deref(), Some(Path::new(\"/tmp/tools\")));\n    }\n\n    #[test]\n    fn text_provider_new_sets_fields() {\n        let provider = TextProvider::new(\"new-text\".to_string(), Some(\"/opt/text\".into()), None);\n\n        assert_eq!(provider.base.name, \"new-text\");\n        assert_eq!(provider.base.provider_type, ProviderType::Text);\n        assert_eq!(provider.base_path.as_deref(), Some(Path::new(\"/opt/text\")));\n    }\n}\n",
      "line_count": 85,
      "word_count": 184,
      "title": "Mod.Rs",
      "summary": "use serde::{Deserialize, Serialize}; use std::path::PathBuf;",
      "key_terms": [
        "Text",
        "any",
        "pub",
        "Deserialize",
        "None",
        "scripts",
        "tmp",
        "Path",
        "Some",
        "dyn",
        "flatten",
        "auth",
        "Clone",
        "file",
        "with",
        "test",
        "ProviderType",
        "and",
        "providers",
        "PathBuf"
      ],
      "timestamp": "2025-12-24T18:56:15.143862"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\providers\\udp\\mod.rs",
      "content_type": "code",
      "content": "use serde::{Deserialize, Serialize};\n\nuse crate::auth::AuthConfig;\nuse crate::providers::base::{BaseProvider, Provider, ProviderType};\n\n/// Provider definition for UDP datagram endpoints.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct UdpProvider {\n    #[serde(flatten)]\n    pub base: BaseProvider,\n    pub host: String,\n    pub port: u16,\n    #[serde(default)]\n    pub timeout_ms: Option<u64>,\n}\n\nimpl Provider for UdpProvider {\n    fn type_(&self) -> ProviderType {\n        ProviderType::Udp\n    }\n\n    fn name(&self) -> String {\n        self.base.name.clone()\n    }\n\n    fn as_any(&self) -> &dyn std::any::Any {\n        self\n    }\n}\n\nimpl UdpProvider {\n    /// Create a UDP provider with host/port and optional timeout.\n    pub fn new(name: String, host: String, port: u16, auth: Option<AuthConfig>) -> Self {\n        Self {\n            base: BaseProvider {\n                name,\n                provider_type: ProviderType::Udp,\n                auth,\n                allowed_communication_protocols: None,\n            },\n            host,\n            port,\n            timeout_ms: Some(30_000),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn udp_provider_defaults_timeout_to_none_when_not_provided() {\n        let json = json!({\n            \"name\": \"test-udp\",\n            \"provider_type\": \"udp\",\n            \"host\": \"127.0.0.1\",\n            \"port\": 8081\n        });\n\n        let provider: UdpProvider = serde_json::from_value(json).unwrap();\n        assert_eq!(provider.base.name, \"test-udp\");\n        assert_eq!(provider.host, \"127.0.0.1\");\n        assert_eq!(provider.port, 8081);\n        assert_eq!(provider.timeout_ms, None);\n    }\n\n    #[test]\n    fn udp_provider_respects_configured_timeout() {\n        let json = json!({\n            \"name\": \"test-udp-timeout\",\n            \"provider_type\": \"udp\",\n            \"host\": \"localhost\",\n            \"port\": 9001,\n            \"timeout_ms\": 7000\n        });\n\n        let provider: UdpProvider = serde_json::from_value(json).unwrap();\n        assert_eq!(provider.timeout_ms, Some(7000));\n    }\n\n    #[test]\n    fn udp_provider_new_sets_default_timeout() {\n        let provider = UdpProvider::new(\"new-udp\".to_string(), \"localhost\".to_string(), 53, None);\n\n        assert_eq!(provider.base.provider_type, ProviderType::Udp);\n        assert_eq!(provider.timeout_ms, Some(30_000));\n    }\n}\n",
      "line_count": 91,
      "word_count": 195,
      "title": "Mod.Rs",
      "summary": "use serde::{Deserialize, Serialize}; use crate::auth::AuthConfig;",
      "key_terms": [
        "any",
        "pub",
        "Deserialize",
        "None",
        "localhost",
        "Some",
        "UdpProvider",
        "dyn",
        "flatten",
        "auth",
        "Clone",
        "Udp",
        "with",
        "test",
        "ProviderType",
        "and",
        "providers",
        "protocol",
        "for",
        "default"
      ],
      "timestamp": "2025-12-24T18:56:15.168628"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\providers\\webrtc\\mod.rs",
      "content_type": "code",
      "content": "use serde::{Deserialize, Serialize};\n\nuse crate::auth::AuthConfig;\nuse crate::providers::base::{BaseProvider, Provider, ProviderType};\n\n/// STUN/TURN server configuration passed to the WebRTC stack.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct IceServer {\n    pub urls: Vec<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub username: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub credential: Option<String>,\n}\n\n/// Provider definition for peer-to-peer WebRTC transports.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct WebRtcProvider {\n    #[serde(flatten)]\n    pub base: BaseProvider,\n\n    /// Signaling server URL (WebSocket or HTTP)\n    pub signaling_server: String,\n\n    /// ICE servers (STUN/TURN)\n    #[serde(default = \"default_ice_servers\")]\n    pub ice_servers: Vec<IceServer>,\n\n    /// Data channel label\n    #[serde(default = \"default_channel_label\")]\n    pub channel_label: String,\n\n    /// Whether to use ordered delivery\n    #[serde(default = \"default_true\")]\n    pub ordered: bool,\n\n    /// Max packet lifetime in milliseconds (for unordered channels)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub max_packet_life_time: Option<u16>,\n\n    /// Max retransmits (for unordered channels)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub max_retransmits: Option<u16>,\n}\n\nfn default_ice_servers() -> Vec<IceServer> {\n    vec![IceServer {\n        urls: vec![\"stun:stun.l.google.com:19302\".to_string()],\n        username: None,\n        credential: None,\n    }]\n}\n\nfn default_channel_label() -> String {\n    \"utcp-data\".to_string()\n}\n\nfn default_true() -> bool {\n    true\n}\n\nimpl Provider for WebRtcProvider {\n    fn type_(&self) -> ProviderType {\n        ProviderType::Webrtc\n    }\n\n    fn name(&self) -> String {\n        self.base.name.clone()\n    }\n\n    fn as_any(&self) -> &dyn std::any::Any {\n        self\n    }\n}\n\nimpl WebRtcProvider {\n    /// Construct a WebRTC provider backed by a signaling server URL.\n    pub fn new(name: String, signaling_server: String, auth: Option<AuthConfig>) -> Self {\n        Self {\n            base: BaseProvider {\n                name,\n                provider_type: ProviderType::Webrtc,\n                auth,\n                allowed_communication_protocols: None,\n            },\n            signaling_server,\n            ice_servers: default_ice_servers(),\n            channel_label: default_channel_label(),\n            ordered: true,\n            max_packet_life_time: None,\n            max_retransmits: None,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn test_webrtc_provider_defaults() {\n        let json = json!({\n            \"name\": \"test-webrtc\",\n            \"provider_type\": \"webrtc\",\n            \"signaling_server\": \"http://localhost:8080\"\n        });\n\n        let provider: WebRtcProvider = serde_json::from_value(json).unwrap();\n\n        assert_eq!(provider.base.name, \"test-webrtc\");\n        assert_eq!(provider.signaling_server, \"http://localhost:8080\");\n        assert_eq!(provider.channel_label, \"utcp-data\");\n        assert!(provider.ordered);\n        assert_eq!(provider.ice_servers.len(), 1);\n        assert_eq!(\n            provider.ice_servers[0].urls[0],\n            \"stun:stun.l.google.com:19302\"\n        );\n    }\n\n    #[test]\n    fn test_webrtc_provider_full_config() {\n        let json = json!({\n            \"name\": \"test-webrtc-full\",\n            \"provider_type\": \"webrtc\",\n            \"signaling_server\": \"wss://signal.example.com\",\n            \"ice_servers\": [\n                {\n                    \"urls\": [\"turn:turn.example.com\"],\n                    \"username\": \"user\",\n                    \"credential\": \"pass\"\n                }\n            ],\n            \"channel_label\": \"custom-label\",\n            \"ordered\": false,\n            \"max_packet_life_time\": 100,\n            \"max_retransmits\": 5\n        });\n\n        let provider: WebRtcProvider = serde_json::from_value(json).unwrap();\n\n        assert_eq!(provider.signaling_server, \"wss://signal.example.com\");\n        assert_eq!(provider.ice_servers.len(), 1);\n        assert_eq!(provider.ice_servers[0].username.as_deref(), Some(\"user\"));\n        assert_eq!(provider.channel_label, \"custom-label\");\n        assert!(!provider.ordered);\n        assert_eq!(provider.max_packet_life_time, Some(100));\n        assert_eq!(provider.max_retransmits, Some(5));\n    }\n}\n",
      "line_count": 152,
      "word_count": 335,
      "title": "Mod.Rs",
      "summary": "use serde::{Deserialize, Serialize}; use crate::auth::AuthConfig;",
      "key_terms": [
        "localhost",
        "WebSocket",
        "Clone",
        "packet",
        "providers",
        "Self",
        "AuthConfig",
        "let",
        "lifetime",
        "Webrtc",
        "backed",
        "super",
        "true",
        "struct",
        "google",
        "pass",
        "signal",
        "WebRTC",
        "Vec",
        "any"
      ],
      "timestamp": "2025-12-24T18:56:15.207548"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\providers\\websocket\\mod.rs",
      "content_type": "code",
      "content": "use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\nuse crate::auth::AuthConfig;\nuse crate::providers::base::{BaseProvider, Provider, ProviderType};\n\n/// Provider configuration for WebSocket endpoints.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct WebSocketProvider {\n    #[serde(flatten)]\n    pub base: BaseProvider,\n    pub url: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub protocol: Option<String>,\n    #[serde(default)]\n    pub keep_alive: bool,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub headers: Option<HashMap<String, String>>,\n}\n\nimpl Provider for WebSocketProvider {\n    fn type_(&self) -> ProviderType {\n        ProviderType::Websocket\n    }\n\n    fn name(&self) -> String {\n        self.base.name.clone()\n    }\n\n    fn as_any(&self) -> &dyn std::any::Any {\n        self\n    }\n}\n\nimpl WebSocketProvider {\n    /// Create a WebSocket provider pointing at a URL.\n    pub fn new(name: String, url: String, auth: Option<AuthConfig>) -> Self {\n        Self {\n            base: BaseProvider {\n                name,\n                provider_type: ProviderType::Websocket,\n                auth,\n                allowed_communication_protocols: None,\n            },\n            url,\n            protocol: None,\n            keep_alive: false,\n            headers: None,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn test_websocket_provider_deserialization() {\n        let json = json!({\n            \"name\": \"test-ws\",\n            \"provider_type\": \"websocket\",\n            \"url\": \"ws://localhost:8080\"\n        });\n\n        let provider: WebSocketProvider = serde_json::from_value(json).unwrap();\n        assert_eq!(provider.base.name, \"test-ws\");\n        assert_eq!(provider.url, \"ws://localhost:8080\");\n        assert!(!provider.keep_alive);\n        assert!(provider.protocol.is_none());\n    }\n\n    #[test]\n    fn test_websocket_provider_full_config() {\n        let json = json!({\n            \"name\": \"test-ws-full\",\n            \"provider_type\": \"websocket\",\n            \"url\": \"wss://example.com/ws\",\n            \"protocol\": \"json-rpc\",\n            \"keep_alive\": true,\n            \"headers\": {\n                \"Authorization\": \"Bearer token\"\n            }\n        });\n\n        let provider: WebSocketProvider = serde_json::from_value(json).unwrap();\n        assert_eq!(provider.url, \"wss://example.com/ws\");\n        assert_eq!(provider.protocol.as_deref(), Some(\"json-rpc\"));\n        assert!(provider.keep_alive);\n        assert_eq!(\n            provider\n                .headers\n                .unwrap()\n                .get(\"Authorization\")\n                .map(|s| s.as_str()),\n            Some(\"Bearer token\")\n        );\n    }\n}\n",
      "line_count": 100,
      "word_count": 205,
      "title": "Mod.Rs",
      "summary": "use serde::{Deserialize, Serialize}; use std::collections::HashMap;",
      "key_terms": [
        "localhost",
        "headers",
        "token",
        "WebSocket",
        "Clone",
        "websocket",
        "rpc",
        "providers",
        "pointing",
        "Self",
        "AuthConfig",
        "let",
        "super",
        "true",
        "struct",
        "json-rpc",
        "ws",
        "collections",
        "any",
        "url"
      ],
      "timestamp": "2025-12-24T18:56:15.223413"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\repository\\in_memory.rs",
      "content_type": "code",
      "content": "use crate::providers::base::Provider;\nuse crate::repository::ToolRepository;\nuse crate::tools::Tool;\nuse anyhow::{anyhow, Result};\nuse async_trait::async_trait;\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n/// Simple in-memory repository for tests and local usage.\npub struct InMemoryToolRepository {\n    tools: RwLock<HashMap<String, Vec<Tool>>>, // provider_name -> tools\n    providers: RwLock<HashMap<String, Arc<dyn Provider>>>, // provider_name -> Provider\n}\n\nimpl InMemoryToolRepository {\n    /// Create an empty repository instance.\n    pub fn new() -> Self {\n        Self {\n            tools: RwLock::new(HashMap::new()),\n            providers: RwLock::new(HashMap::new()),\n        }\n    }\n}\n\n#[async_trait]\nimpl ToolRepository for InMemoryToolRepository {\n    async fn save_provider_with_tools(\n        &self,\n        provider: Arc<dyn Provider>,\n        tools: Vec<Tool>,\n    ) -> Result<()> {\n        let provider_name = provider.name();\n\n        let mut providers_lock = self.providers.write().await;\n        providers_lock.insert(provider_name.clone(), provider);\n\n        let mut tools_lock = self.tools.write().await;\n        tools_lock.insert(provider_name, tools);\n\n        Ok(())\n    }\n\n    async fn get_provider(&self, name: &str) -> Result<Option<Arc<dyn Provider>>> {\n        let providers = self.providers.read().await;\n        Ok(providers.get(name).cloned())\n    }\n\n    async fn remove_provider(&self, name: &str) -> Result<()> {\n        let mut providers = self.providers.write().await;\n        if providers.remove(name).is_none() {\n            return Err(anyhow!(\"provider not found: {}\", name));\n        }\n        let mut tools = self.tools.write().await;\n        tools.remove(name);\n        Ok(())\n    }\n\n    async fn get_tools(&self) -> Result<Vec<Tool>> {\n        let tools_map = self.tools.read().await;\n        let total_len: usize = tools_map.values().map(|tools| tools.len()).sum();\n        let mut all_tools = Vec::with_capacity(total_len);\n        for tools in tools_map.values() {\n            all_tools.extend(tools.clone());\n        }\n        Ok(all_tools)\n    }\n\n    async fn get_tools_by_provider(&self, provider_name: &str) -> Result<Vec<Tool>> {\n        let tools_map = self.tools.read().await;\n        match tools_map.get(provider_name) {\n            Some(tools) => Ok(tools.clone()),\n            None => Err(anyhow!(\"no tools found for provider {}\", provider_name)),\n        }\n    }\n}\n",
      "line_count": 77,
      "word_count": 215,
      "title": "In Memory.Rs",
      "summary": "use crate::providers::base::Provider; use crate::repository::ToolRepository;",
      "key_terms": [
        "memory",
        "write",
        "remove",
        "Vec",
        "Result",
        "pub",
        "extend",
        "async",
        "None",
        "Some",
        "dyn",
        "match",
        "Simple",
        "Tool",
        "no",
        "cloned",
        "and",
        "providers",
        "map",
        "for"
      ],
      "timestamp": "2025-12-24T18:56:15.260603"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\repository\\mod.rs",
      "content_type": "code",
      "content": "pub mod in_memory;\n\nuse crate::providers::base::Provider;\nuse crate::tools::Tool;\nuse anyhow::Result;\nuse async_trait::async_trait;\nuse std::sync::Arc;\n\n/// Persistence abstraction for storing providers and their tools.\n#[async_trait]\npub trait ToolRepository: Send + Sync {\n    /// Save a provider along with the full list of tools it offers.\n    async fn save_provider_with_tools(\n        &self,\n        prov: Arc<dyn Provider>,\n        tools: Vec<Tool>,\n    ) -> Result<()>;\n    /// Retrieve a provider by name if it exists.\n    async fn get_provider(&self, name: &str) -> Result<Option<Arc<dyn Provider>>>;\n    /// Remove a provider and its tools.\n    async fn remove_provider(&self, name: &str) -> Result<()>;\n    /// Return all registered tools across all providers.\n    async fn get_tools(&self) -> Result<Vec<Tool>>;\n    /// Return tools offered by a specific provider.\n    async fn get_tools_by_provider(&self, provider_name: &str) -> Result<Vec<Tool>>;\n}\n",
      "line_count": 27,
      "word_count": 115,
      "title": "Mod.Rs",
      "summary": "pub mod in_memory; use crate::providers::base::Provider;",
      "key_terms": [
        "Vec",
        "Result",
        "pub",
        "specific",
        "async",
        "dyn",
        "list",
        "prov",
        "with",
        "Tool",
        "it",
        "and",
        "providers",
        "Sync",
        "for",
        "registered",
        "abstraction",
        "their",
        "along",
        "base"
      ],
      "timestamp": "2025-12-24T18:56:15.286506"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\tag\\mod.rs",
      "content_type": "code",
      "content": "pub mod tag_search;\n",
      "line_count": 2,
      "word_count": 3,
      "title": "Mod.Rs",
      "summary": "pub mod tag_search;",
      "key_terms": [
        "pub",
        "mod"
      ],
      "timestamp": "2025-12-24T18:56:15.302011"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\tag\\tag_search.rs",
      "content_type": "code",
      "content": "use crate::repository::ToolRepository;\nuse crate::tools::{Tool, ToolSearchStrategy};\nuse anyhow::Result;\nuse async_trait::async_trait;\nuse regex::Regex;\nuse std::cmp::Ordering;\nuse std::collections::HashSet;\nuse std::sync::Arc;\n\n/// Simple tag/description based search that rewards tag matches and keyword overlap.\npub struct TagSearchStrategy {\n    tool_repository: Arc<dyn ToolRepository>,\n    description_weight: f64,\n    word_regex: Regex,\n}\n\nimpl TagSearchStrategy {\n    /// Build a new tag search strategy with configurable description weight.\n    pub fn new(repo: Arc<dyn ToolRepository>, description_weight: f64) -> Self {\n        Self {\n            tool_repository: repo,\n            description_weight,\n            word_regex: Regex::new(r\"\\w+\").unwrap(),\n        }\n    }\n}\n\n#[derive(Clone)]\nstruct ScoredTool {\n    tool: Tool,\n    score: f64,\n}\n\n#[async_trait]\nimpl ToolSearchStrategy for TagSearchStrategy {\n    /// Score tools by tags and description keywords and return the best matches.\n    async fn search_tools(&self, query: &str, limit: usize) -> Result<Vec<Tool>> {\n        let query_lower = query.trim().to_lowercase();\n        let query_word_set: HashSet<String> = self\n            .word_regex\n            .find_iter(&query_lower)\n            .map(|m| m.as_str().to_string())\n            .collect();\n\n        let tools = self.tool_repository.get_tools().await?;\n        if tools.is_empty() {\n            return Ok(Vec::new());\n        }\n\n        let mut positives = Vec::new();\n        let mut nonpositives = Vec::new();\n\n        for tool in tools {\n            let score = self.score_tool(&tool, &query_lower, &query_word_set);\n            let entry = ScoredTool { tool, score };\n            if score > 0.0 {\n                positives.push(entry);\n            } else {\n                nonpositives.push(entry);\n            }\n        }\n\n        // Unbounded result set keeps full sort for correctness but skips zero-score tools unless necessary.\n        if limit == 0 {\n            if !positives.is_empty() {\n                positives.sort_unstable_by(compare_scored);\n                return Ok(positives.into_iter().map(|st| st.tool).collect());\n            }\n\n            nonpositives.sort_unstable_by(compare_scored);\n            return Ok(nonpositives.into_iter().map(|st| st.tool).collect());\n        }\n\n        if !positives.is_empty() {\n            take_top_n(&mut positives, limit);\n            return Ok(positives.into_iter().map(|st| st.tool).collect());\n        }\n\n        if nonpositives.is_empty() {\n            return Ok(Vec::new());\n        }\n\n        take_top_n(&mut nonpositives, limit);\n        Ok(nonpositives.into_iter().map(|st| st.tool).collect())\n    }\n}\n\nimpl TagSearchStrategy {\n    fn score_tool(&self, tool: &Tool, query_lower: &str, query_word_set: &HashSet<String>) -> f64 {\n        let mut score = 0.0;\n\n        for tag in &tool.tags {\n            let tag_lower = tag.to_ascii_lowercase();\n\n            if query_lower.contains(&tag_lower) {\n                score += 1.0;\n            }\n\n            for m in self.word_regex.find_iter(&tag_lower) {\n                if query_word_set.contains(m.as_str()) {\n                    score += self.description_weight;\n                }\n            }\n        }\n\n        for m in self.word_regex.find_iter(&tool.description) {\n            let word = m.as_str().to_ascii_lowercase();\n            if word.len() > 2 && query_word_set.contains(&word) {\n                score += self.description_weight;\n            }\n        }\n\n        score\n    }\n}\n\nfn compare_scored(a: &ScoredTool, b: &ScoredTool) -> Ordering {\n    b.score\n        .total_cmp(&a.score)\n        .then_with(|| a.tool.name.cmp(&b.tool.name))\n}\n\nfn take_top_n(scored: &mut Vec<ScoredTool>, limit: usize) {\n    if limit == 0 {\n        scored.sort_unstable_by(compare_scored);\n        return;\n    }\n\n    if scored.len() > limit {\n        let pivot = limit - 1;\n        scored.select_nth_unstable_by(pivot, compare_scored);\n        scored.truncate(limit);\n    }\n\n    scored.sort_unstable_by(compare_scored);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::providers::base::{BaseProvider, ProviderType};\n    use crate::repository::in_memory::InMemoryToolRepository;\n    use crate::tools::ToolInputOutputSchema;\n    use std::sync::Arc;\n\n    fn schema() -> ToolInputOutputSchema {\n        ToolInputOutputSchema {\n            type_: \"object\".to_string(),\n            properties: None,\n            required: None,\n            description: None,\n            title: None,\n            items: None,\n            enum_: None,\n            minimum: None,\n            maximum: None,\n            format: None,\n        }\n    }\n\n    fn make_tool(name: &str, description: &str, tags: &[&str]) -> Tool {\n        Tool {\n            name: name.to_string(),\n            description: description.to_string(),\n            inputs: schema(),\n            outputs: schema(),\n            tags: tags.iter().map(|t| t.to_string()).collect(),\n            average_response_size: None,\n            provider: None,\n        }\n    }\n\n    async fn setup_repo(tools: Vec<Tool>) -> Arc<InMemoryToolRepository> {\n        let repo = Arc::new(InMemoryToolRepository::new());\n        let provider = Arc::new(BaseProvider {\n            name: \"test\".to_string(),\n            provider_type: ProviderType::Http,\n            auth: None,\n            allowed_communication_protocols: None,\n        });\n        repo.save_provider_with_tools(provider, tools)\n            .await\n            .unwrap();\n        repo\n    }\n\n    #[tokio::test]\n    async fn returns_top_scoring_tools_with_limit() {\n        let repo = setup_repo(vec![\n            make_tool(\n                \"p1.weather_primary\",\n                \"Weather forecast endpoint\",\n                &[\"weather\"],\n            ),\n            make_tool(\"p1.weather_backup\", \"Weather data service\", &[\"climate\"]),\n            make_tool(\"p1.finance\", \"Stock price lookup\", &[\"stocks\"]),\n        ])\n        .await;\n\n        let strategy = TagSearchStrategy::new(repo, 0.5);\n        let results = strategy.search_tools(\"weather forecast\", 2).await.unwrap();\n\n        assert_eq!(results.len(), 2);\n        assert_eq!(results[0].name, \"p1.weather_primary\");\n        assert_eq!(results[1].name, \"p1.weather_backup\");\n    }\n\n    #[tokio::test]\n    async fn falls_back_when_no_positive_scores() {\n        let repo = setup_repo(vec![\n            make_tool(\"p1.alpha\", \"No overlap here\", &[\"alpha\"]),\n            make_tool(\"p1.beta\", \"Still nothing useful\", &[\"beta\"]),\n            make_tool(\"p1.gamma\", \"More unrelated content\", &[\"gamma\"]),\n        ])\n        .await;\n\n        let strategy = TagSearchStrategy::new(repo, 1.0);\n        let results = strategy.search_tools(\"nonsense\", 2).await.unwrap();\n\n        assert_eq!(results.len(), 2);\n        assert_eq!(results[0].name, \"p1.alpha\");\n        assert_eq!(results[1].name, \"p1.beta\");\n    }\n\n    #[tokio::test]\n    async fn ties_are_sorted_by_name_within_limit() {\n        let repo = setup_repo(vec![\n            make_tool(\"p1.alpha\", \"Math helper\", &[\"math\"]),\n            make_tool(\"p1.beta\", \"Math helper\", &[\"math\"]),\n            make_tool(\"p1.gamma\", \"Math helper\", &[\"math\"]),\n        ])\n        .await;\n\n        let strategy = TagSearchStrategy::new(repo, 1.0);\n        let results = strategy.search_tools(\"math\", 2).await.unwrap();\n\n        assert_eq!(results.len(), 2);\n        assert_eq!(results[0].name, \"p1.alpha\");\n        assert_eq!(results[1].name, \"p1.beta\");\n    }\n}\n",
      "line_count": 242,
      "word_count": 586,
      "title": "Tag Search.Rs",
      "summary": "use crate::repository::ToolRepository; use crate::tools::{Tool, ToolSearchStrategy};",
      "key_terms": [
        "Result",
        "entry",
        "search",
        "ScoredTool",
        "async",
        "gamma",
        "based",
        "cmp",
        "truncate",
        "Clone",
        "format",
        "helper",
        "trim",
        "providers",
        "repo",
        "HashSet",
        "Self",
        "keyword",
        "InMemoryToolRepository",
        "let"
      ],
      "timestamp": "2025-12-24T18:56:15.317832"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\tools\\mod.rs",
      "content_type": "code",
      "content": "use anyhow::Result;\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n/// Minimal JSON Schema-like description for tool inputs/outputs.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ToolInputOutputSchema {\n    #[serde(rename = \"type\")]\n    pub type_: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub properties: Option<HashMap<String, serde_json::Value>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub required: Option<Vec<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub title: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub items: Option<HashMap<String, serde_json::Value>>,\n    #[serde(rename = \"enum\", skip_serializing_if = \"Option::is_none\")]\n    pub enum_: Option<Vec<serde_json::Value>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub minimum: Option<f64>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub maximum: Option<f64>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub format: Option<String>,\n}\n\n/// Canonical tool definition used by UTCP transports and repositories.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Tool {\n    pub name: String,\n    pub description: String,\n    pub inputs: ToolInputOutputSchema,\n    pub outputs: ToolInputOutputSchema,\n    pub tags: Vec<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub average_response_size: Option<i64>,\n    #[serde(rename = \"tool_provider\", skip_serializing_if = \"Option::is_none\")]\n    pub provider: Option<serde_json::Value>,\n}\n\n/// Strategy abstraction used to search tools by query string.\n#[async_trait]\npub trait ToolSearchStrategy: Send + Sync {\n    /// Return tools matching the query string, limited to `limit` results when non-zero.\n    async fn search_tools(&self, query: &str, limit: usize) -> Result<Vec<Tool>>;\n}\n",
      "line_count": 51,
      "word_count": 181,
      "title": "Mod.Rs",
      "summary": "use anyhow::Result; use async_trait::async_trait;",
      "key_terms": [
        "Result",
        "search",
        "async",
        "Clone",
        "format",
        "Sync",
        "string",
        "limited",
        "struct",
        "description",
        "title",
        "non",
        "collections",
        "Value",
        "non-zero",
        "rename",
        "Vec",
        "items",
        "Tool",
        "tool"
      ],
      "timestamp": "2025-12-24T18:56:15.349722"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\transports\\mod.rs",
      "content_type": "code",
      "content": "pub mod cli;\npub mod graphql;\npub mod grpc;\npub mod http;\npub mod http_stream;\npub mod mcp;\npub mod registry;\npub mod sse;\npub mod stream;\npub mod tcp;\npub mod text;\npub mod udp;\npub mod webrtc;\npub mod websocket;\n\nuse crate::providers::base::Provider;\nuse crate::tools::Tool;\nuse crate::transports::stream::StreamResult;\nuse anyhow::Result;\nuse async_trait::async_trait;\nuse serde_json::Value;\nuse std::collections::HashMap;\n\n/// Core transport abstraction all communication protocols implement.\n#[async_trait]\npub trait ClientTransport: Send + Sync {\n    /// Register a tool provider with the underlying transport, returning discovered tools.\n    async fn register_tool_provider(&self, prov: &dyn Provider) -> Result<Vec<Tool>>;\n    /// Deregister a tool provider and release any associated resources.\n    async fn deregister_tool_provider(&self, prov: &dyn Provider) -> Result<()>;\n    /// Invoke a tool over the transport and return the result payload.\n    async fn call_tool(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, Value>,\n        prov: &dyn Provider,\n    ) -> Result<Value>;\n    /// Invoke a tool and stream incremental responses back to the caller.\n    async fn call_tool_stream(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, Value>,\n        prov: &dyn Provider,\n    ) -> Result<Box<dyn StreamResult>>;\n}\n\n// CommunicationProtocol is the new name for transports; kept as a re-export for backwards\n// compatibility so plugins can implement the updated terminology without breaking old code.\npub use ClientTransport as CommunicationProtocol;\n\npub use registry::{\n    communication_protocols_snapshot, register_communication_protocol,\n    CommunicationProtocolRegistry,\n};\n",
      "line_count": 55,
      "word_count": 205,
      "title": "Mod.Rs",
      "summary": "pub mod cli; pub mod graphql;",
      "key_terms": [
        "grpc",
        "ClientTransport",
        "Result",
        "async",
        "prov",
        "websocket",
        "providers",
        "Sync",
        "associated",
        "backwards",
        "sse",
        "returning",
        "underlying",
        "payload",
        "collections",
        "Value",
        "compatibility",
        "Vec",
        "any",
        "implement"
      ],
      "timestamp": "2025-12-24T18:56:15.381504"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\transports\\registry.rs",
      "content_type": "code",
      "content": "use std::collections::HashMap;\nuse std::sync::{Arc, RwLock};\n\nuse once_cell::sync::Lazy;\n\nuse crate::transports::CommunicationProtocol;\n\n/// Plugin-style registry for communication protocols (formerly transports) keyed by call_template_type/provider_type.\n#[derive(Clone, Default)]\npub struct CommunicationProtocolRegistry {\n    map: Arc<RwLock<HashMap<String, Arc<dyn CommunicationProtocol>>>>,\n}\n\nimpl CommunicationProtocolRegistry {\n    /// Create an empty registry without any transports.\n    pub fn new() -> Self {\n        Self {\n            map: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    /// Build a registry pre-populated with the built-in communication protocols.\n    pub fn with_default_protocols() -> Self {\n        let reg = Self::new();\n        reg.register_default_protocols();\n        reg\n    }\n\n    /// Backwards-compatible helper matching the old transport terminology.\n    pub fn with_default_transports() -> Self {\n        Self::with_default_protocols()\n    }\n\n    /// Register all built-in transports into this registry instance.\n    pub fn register_default_protocols(&self) {\n        self.register(\n            \"http\",\n            Arc::new(crate::transports::http::HttpClientTransport::new()),\n        );\n        self.register(\"cli\", Arc::new(crate::transports::cli::CliTransport::new()));\n        self.register(\n            \"websocket\",\n            Arc::new(crate::transports::websocket::WebSocketTransport::new()),\n        );\n        self.register(\n            \"grpc\",\n            Arc::new(crate::transports::grpc::GrpcTransport::new()),\n        );\n        self.register(\n            \"graphql\",\n            Arc::new(crate::transports::graphql::GraphQLTransport::new()),\n        );\n        self.register(\"tcp\", Arc::new(crate::transports::tcp::TcpTransport::new()));\n        self.register(\"udp\", Arc::new(crate::transports::udp::UdpTransport::new()));\n        self.register(\"sse\", Arc::new(crate::transports::sse::SseTransport::new()));\n        self.register(\"mcp\", Arc::new(crate::transports::mcp::McpTransport::new()));\n        self.register(\n            \"webrtc\",\n            Arc::new(crate::transports::webrtc::WebRtcTransport::new()),\n        );\n        self.register(\n            \"http_stream\",\n            Arc::new(crate::transports::http_stream::StreamableHttpTransport::new()),\n        );\n        self.register(\n            \"text\",\n            Arc::new(crate::transports::text::TextTransport::new()),\n        );\n    }\n\n    /// Add a protocol implementation under the provided key.\n    pub fn register(&self, key: &str, protocol: Arc<dyn CommunicationProtocol>) {\n        let mut guard = self\n            .map\n            .write()\n            .expect(\"communication protocol registry poisoned\");\n        guard.insert(key.to_string(), protocol);\n    }\n\n    /// Look up a protocol by key.\n    pub fn get(&self, key: &str) -> Option<Arc<dyn CommunicationProtocol>> {\n        let guard = self\n            .map\n            .read()\n            .expect(\"communication protocol registry poisoned\");\n        guard.get(key).cloned()\n    }\n\n    /// Return a copy of the current map for inspection or iteration.\n    pub fn as_map(&self) -> HashMap<String, Arc<dyn CommunicationProtocol>> {\n        let guard = self\n            .map\n            .read()\n            .expect(\"communication protocol registry poisoned\");\n        guard.clone()\n    }\n}\n\n/// Backwards-compatible alias for the previous registry name.\npub type TransportRegistry = CommunicationProtocolRegistry;\n\n/// Global, plugin-extensible registry that holds every registered communication protocol.\npub static GLOBAL_COMMUNICATION_PROTOCOLS: Lazy<RwLock<CommunicationProtocolRegistry>> =\n    Lazy::new(|| {\n        let reg = CommunicationProtocolRegistry::new();\n        reg.register_default_protocols();\n        RwLock::new(reg)\n    });\n\n/// Register a new communication protocol (transport) implementation globally so all clients can use it.\npub fn register_communication_protocol(key: &str, protocol: Arc<dyn CommunicationProtocol>) {\n    let reg = GLOBAL_COMMUNICATION_PROTOCOLS\n        .write()\n        .expect(\"communication protocol registry poisoned\");\n    reg.register(key, protocol);\n}\n\n/// Snapshot the current set of registered communication protocols.\npub fn communication_protocols_snapshot() -> CommunicationProtocolRegistry {\n    GLOBAL_COMMUNICATION_PROTOCOLS\n        .read()\n        .expect(\"communication protocol registry poisoned\")\n        .clone()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::providers::base::ProviderType;\n    use crate::transports::stream::boxed_vec_stream;\n    use crate::transports::CommunicationProtocol;\n    use async_trait::async_trait;\n    use serde_json::Value;\n\n    #[derive(Debug)]\n    struct DummyProtocol;\n\n    #[async_trait]\n    impl CommunicationProtocol for DummyProtocol {\n        async fn register_tool_provider(\n            &self,\n            _prov: &dyn crate::providers::base::Provider,\n        ) -> anyhow::Result<Vec<crate::tools::Tool>> {\n            Ok(vec![])\n        }\n\n        async fn deregister_tool_provider(\n            &self,\n            _prov: &dyn crate::providers::base::Provider,\n        ) -> anyhow::Result<()> {\n            Ok(())\n        }\n\n        async fn call_tool(\n            &self,\n            _tool_name: &str,\n            _args: HashMap<String, Value>,\n            _prov: &dyn crate::providers::base::Provider,\n        ) -> anyhow::Result<Value> {\n            Ok(Value::Null)\n        }\n\n        async fn call_tool_stream(\n            &self,\n            _tool_name: &str,\n            _args: HashMap<String, Value>,\n            _prov: &dyn crate::providers::base::Provider,\n        ) -> anyhow::Result<Box<dyn crate::transports::stream::StreamResult>> {\n            Ok(boxed_vec_stream(vec![Value::Null]))\n        }\n    }\n\n    #[test]\n    fn default_protocol_registry_contains_all_builtins() {\n        let reg = CommunicationProtocolRegistry::with_default_protocols();\n        let expected = vec![\n            \"http\",\n            \"cli\",\n            \"websocket\",\n            \"grpc\",\n            \"graphql\",\n            \"tcp\",\n            \"udp\",\n            \"sse\",\n            \"mcp\",\n            \"webrtc\",\n            \"http_stream\",\n            \"text\",\n        ];\n        for key in &expected {\n            assert!(reg.get(key).is_some(), \"missing built-in protocol {key}\");\n        }\n        assert_eq!(reg.as_map().len(), expected.len());\n    }\n\n    #[test]\n    fn transport_alias_builds_default_protocols() {\n        let reg = TransportRegistry::with_default_transports();\n        // Reuse provider type keys to ensure mapping doesn't drift.\n        let provider_keys = vec![\n            ProviderType::Http,\n            ProviderType::Cli,\n            ProviderType::Websocket,\n            ProviderType::Grpc,\n            ProviderType::Graphql,\n            ProviderType::Tcp,\n            ProviderType::Udp,\n            ProviderType::Sse,\n            ProviderType::Mcp,\n            ProviderType::Webrtc,\n            ProviderType::HttpStream,\n            ProviderType::Text,\n        ]\n        .into_iter()\n        .map(|p| p.as_key().to_string())\n        .collect::<Vec<_>>();\n\n        for key in provider_keys {\n            assert!(reg.get(&key).is_some(), \"missing protocol for {key}\");\n        }\n    }\n\n    #[test]\n    fn register_global_protocol_exposes_it_in_snapshot() {\n        let key = \"dummy_protocol_test\";\n        register_communication_protocol(key, Arc::new(DummyProtocol));\n\n        let snapshot = communication_protocols_snapshot();\n        assert!(snapshot.get(key).is_some(), \"global registry missing {key}\");\n\n        // Clean up to avoid leaking state between tests.\n        if let Ok(guard) = GLOBAL_COMMUNICATION_PROTOCOLS.write() {\n            if let Ok(mut map) = guard.map.write() {\n                map.remove(key);\n            }\n        }\n    }\n}\n",
      "line_count": 239,
      "word_count": 558,
      "title": "Registry.Rs",
      "summary": "use std::collections::HashMap; use std::sync::{Arc, RwLock};",
      "key_terms": [
        "grpc",
        "populated",
        "Result",
        "up",
        "async",
        "compatible",
        "Clone",
        "Udp",
        "helper",
        "websocket",
        "cloned",
        "providers",
        "global",
        "Self",
        "Sse",
        "pre-populated",
        "TextTransport",
        "snapshot",
        "let",
        "if"
      ],
      "timestamp": "2025-12-24T18:56:15.419250"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\transports\\stream.rs",
      "content_type": "code",
      "content": "use anyhow::Result;\nuse async_trait::async_trait;\nuse serde_json::Value;\nuse tokio::sync::mpsc;\n\n/// A minimal streaming abstraction that mirrors go-utcp's StreamResult (Next/Close).\n#[async_trait]\npub trait StreamResult: Send {\n    /// Pull the next value from the stream. Returns Ok(None) on EOF.\n    async fn next(&mut self) -> Result<Option<Value>>;\n    /// Close the stream and release any underlying resources.\n    async fn close(&mut self) -> Result<()>;\n}\n\n/// StreamResult backed by a channel of `Result<Value>`.\npub struct ChannelStreamResult {\n    rx: mpsc::Receiver<Result<Value>>,\n    close_fn: Option<Box<dyn FnOnce() -> Result<()> + Send>>,\n}\n\nimpl ChannelStreamResult {\n    /// Create a new channel-backed stream with an optional close callback.\n    pub fn new(\n        rx: mpsc::Receiver<Result<Value>>,\n        close_fn: Option<Box<dyn FnOnce() -> Result<()> + Send>>,\n    ) -> Self {\n        Self { rx, close_fn }\n    }\n}\n\n#[async_trait]\nimpl StreamResult for ChannelStreamResult {\n    async fn next(&mut self) -> Result<Option<Value>> {\n        match self.rx.recv().await {\n            Some(Ok(v)) => Ok(Some(v)),\n            Some(Err(e)) => Err(e),\n            None => Ok(None),\n        }\n    }\n\n    async fn close(&mut self) -> Result<()> {\n        if let Some(close_fn) = self.close_fn.take() {\n            close_fn()?;\n        }\n        Ok(())\n    }\n}\n\n/// StreamResult backed by an in-memory vector (useful for adapting eager responses).\npub struct VecStreamResult {\n    items: Vec<Value>,\n    index: usize,\n    close_fn: Option<Box<dyn FnOnce() -> Result<()> + Send>>,\n}\n\nimpl VecStreamResult {\n    /// Wrap an eager collection of values as a stream result.\n    pub fn new(\n        items: Vec<Value>,\n        close_fn: Option<Box<dyn FnOnce() -> Result<()> + Send>>,\n    ) -> Self {\n        Self {\n            items,\n            index: 0,\n            close_fn,\n        }\n    }\n}\n\n#[async_trait]\nimpl StreamResult for VecStreamResult {\n    async fn next(&mut self) -> Result<Option<Value>> {\n        if self.index >= self.items.len() {\n            return Ok(None);\n        }\n        let item = self.items[self.index].clone();\n        self.index += 1;\n        Ok(Some(item))\n    }\n\n    async fn close(&mut self) -> Result<()> {\n        if let Some(close_fn) = self.close_fn.take() {\n            close_fn()?;\n        }\n        Ok(())\n    }\n}\n\n/// Helper to box a channel-backed stream result.\npub fn boxed_channel_stream(\n    rx: mpsc::Receiver<Result<Value>>,\n    close_fn: Option<Box<dyn FnOnce() -> Result<()> + Send>>,\n) -> Box<dyn StreamResult> {\n    Box::new(ChannelStreamResult::new(rx, close_fn))\n}\n\n/// Helper to box a vector-backed stream result.\npub fn boxed_vec_stream(items: Vec<Value>) -> Box<dyn StreamResult> {\n    Box::new(VecStreamResult::new(items, None))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n    use std::sync::{\n        atomic::{AtomicBool, Ordering},\n        Arc,\n    };\n    use tokio::sync::mpsc;\n\n    #[tokio::test]\n    async fn vec_stream_iterates_and_closes() {\n        let closed = Arc::new(AtomicBool::new(false));\n        let closed_clone = closed.clone();\n        let mut stream = VecStreamResult::new(\n            vec![json!(1), json!({\"two\": 2})],\n            Some(Box::new(move || {\n                closed_clone.store(true, Ordering::SeqCst);\n                Ok(())\n            })),\n        );\n\n        assert_eq!(stream.next().await.unwrap(), Some(json!(1)));\n        assert_eq!(stream.next().await.unwrap(), Some(json!({\"two\": 2})));\n        assert_eq!(stream.next().await.unwrap(), None);\n        stream.close().await.unwrap();\n        assert!(closed.load(Ordering::SeqCst));\n    }\n\n    #[tokio::test]\n    async fn channel_stream_propagates_error() {\n        let (tx, rx) = mpsc::channel(2);\n        tx.send(Ok(json!(\"ok\"))).await.unwrap();\n        tx.send(Err(anyhow::anyhow!(\"boom\"))).await.unwrap();\n        drop(tx);\n\n        let mut stream = ChannelStreamResult::new(rx, None);\n        assert_eq!(stream.next().await.unwrap(), Some(json!(\"ok\")));\n        let err = stream.next().await.unwrap_err();\n        assert!(format!(\"{err}\").contains(\"boom\"));\n        assert_eq!(stream.next().await.unwrap(), None);\n    }\n}\n",
      "line_count": 145,
      "word_count": 409,
      "title": "Stream.Rs",
      "summary": "use anyhow::Result; use async_trait::async_trait;",
      "key_terms": [
        "close",
        "Result",
        "async",
        "tx",
        "index",
        "format",
        "minimal",
        "Self",
        "if",
        "let",
        "that",
        "load",
        "mpsc",
        "channel-backed",
        "backed",
        "ChannelStreamResult",
        "streaming",
        "struct",
        "super",
        "true"
      ],
      "timestamp": "2025-12-24T18:56:15.455999"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\transports\\cli\\mod.rs",
      "content_type": "code",
      "content": "// CLI Transport - executes command-line tools\nuse anyhow::{anyhow, Result};\nuse async_trait::async_trait;\nuse serde_json::Value;\nuse std::collections::HashMap;\nuse std::time::Duration;\nuse tokio::io::AsyncWriteExt;\nuse tokio::process::Command;\n\nuse crate::providers::base::Provider;\nuse crate::providers::cli::CliProvider;\nuse crate::tools::Tool;\nuse crate::transports::{stream::StreamResult, ClientTransport};\n\n/// Transport that shells out to a CLI binary which exposes UTCP-compatible commands.\npub struct CliTransport;\n\nimpl CliTransport {\n    /// Create a CLI transport.\n    pub fn new() -> Self {\n        Self\n    }\n\n    fn parse_command(&self, command_name: &str) -> Result<(String, Vec<String>)> {\n        let parts: Vec<String> = command_name\n            .split_whitespace()\n            .map(|s| s.to_string())\n            .collect();\n\n        if parts.is_empty() {\n            return Err(anyhow!(\"Empty command name\"));\n        }\n\n        Ok((parts[0].clone(), parts[1..].to_vec()))\n    }\n\n    async fn execute_command(\n        &self,\n        cmd_path: &str,\n        args: &[String],\n        env_vars: &Option<HashMap<String, String>>,\n        working_dir: &Option<String>,\n        stdin_input: Option<&str>,\n    ) -> Result<(String, String, i32)> {\n        let mut cmd = Command::new(cmd_path);\n        cmd.args(args);\n\n        // Set environment variables\n        if let Some(env) = env_vars {\n            for (k, v) in env {\n                cmd.env(k, v);\n            }\n        }\n\n        // Set working directory\n        if let Some(dir) = working_dir {\n            cmd.current_dir(dir);\n        }\n\n        // Configure stdin/stdout/stderr\n        cmd.stdin(if stdin_input.is_some() {\n            std::process::Stdio::piped()\n        } else {\n            std::process::Stdio::null()\n        });\n        cmd.stdout(std::process::Stdio::piped());\n        cmd.stderr(std::process::Stdio::piped());\n\n        let mut child = cmd.spawn()?;\n\n        // Write stdin if provided\n        if let Some(input) = stdin_input {\n            if let Some(mut stdin) = child.stdin.take() {\n                stdin.write_all(input.as_bytes()).await?;\n                drop(stdin); // Close stdin\n            }\n        }\n\n        // Wait for completion with timeout\n        let output =\n            tokio::time::timeout(Duration::from_secs(30), child.wait_with_output()).await??;\n\n        let stdout = String::from_utf8_lossy(&output.stdout).to_string();\n        let stderr = String::from_utf8_lossy(&output.stderr).to_string();\n        let exit_code = output.status.code().unwrap_or(1);\n\n        Ok((stdout, stderr, exit_code))\n    }\n\n    fn format_arguments(&self, args: &HashMap<String, Value>) -> Vec<String> {\n        let mut result = Vec::new();\n        let mut keys: Vec<_> = args.keys().collect();\n        keys.sort(); // Deterministic ordering\n\n        for key in keys {\n            if let Some(value) = args.get(key) {\n                match value {\n                    Value::Bool(true) => {\n                        result.push(format!(\"--{}\", key));\n                    }\n                    Value::Bool(false) => {\n                        // Skip false booleans\n                    }\n                    Value::Array(arr) => {\n                        for item in arr {\n                            result.push(format!(\"--{}\", key));\n                            result.push(item.to_string());\n                        }\n                    }\n                    _ => {\n                        result.push(format!(\"--{}\", key));\n                        result.push(value.to_string().trim_matches('\"').to_string());\n                    }\n                }\n            }\n        }\n\n        result\n    }\n\n    fn extract_tools_from_output(&self, output: &str) -> Vec<Tool> {\n        // Try to parse as UTCP manifest\n        if let Ok(manifest) = serde_json::from_str::<Value>(output) {\n            if let Some(tools_array) = manifest.get(\"tools\").and_then(|v| v.as_array()) {\n                let mut tools = Vec::new();\n                for tool_value in tools_array {\n                    if let Ok(tool) = serde_json::from_value::<Tool>(tool_value.clone()) {\n                        tools.push(tool);\n                    }\n                }\n                return tools;\n            }\n        }\n\n        // Try line-by-line parsing\n        let mut tools = Vec::new();\n        for line in output.lines() {\n            let line = line.trim();\n            if line.starts_with('{') && line.ends_with('}') {\n                if let Ok(tool) = serde_json::from_str::<Tool>(line) {\n                    tools.push(tool);\n                }\n            }\n        }\n\n        tools\n    }\n}\n\n#[async_trait]\nimpl ClientTransport for CliTransport {\n    async fn register_tool_provider(&self, prov: &dyn Provider) -> Result<Vec<Tool>> {\n        let cli_prov = prov\n            .as_any()\n            .downcast_ref::<CliProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not a CliProvider\"))?;\n\n        // Parse command name into command and args\n        let (cmd_path, cmd_args) = self.parse_command(&cli_prov.command_name)?;\n\n        // Execute discovery command\n        let (stdout, stderr, exit_code) = self\n            .execute_command(\n                &cmd_path,\n                &cmd_args,\n                &cli_prov.env_vars,\n                &cli_prov.working_dir,\n                None,\n            )\n            .await?;\n\n        let output = if exit_code == 0 { stdout } else { stderr };\n\n        if output.trim().is_empty() {\n            return Ok(vec![]);\n        }\n\n        Ok(self.extract_tools_from_output(&output))\n    }\n\n    async fn deregister_tool_provider(&self, _prov: &dyn Provider) -> Result<()> {\n        // CLI transport is stateless\n        Ok(())\n    }\n\n    async fn call_tool(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, Value>,\n        prov: &dyn Provider,\n    ) -> Result<Value> {\n        let cli_prov = prov\n            .as_any()\n            .downcast_ref::<CliProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not a CliProvider\"))?;\n\n        // Parse command name\n        let (cmd_path, mut cmd_args) = self.parse_command(&cli_prov.command_name)?;\n\n        // Build command: <cmd> call <provider> <tool> [--flags]\n        cmd_args.extend([\n            \"call\".to_string(),\n            cli_prov.base.name.clone(),\n            tool_name.to_string(),\n        ]);\n        cmd_args.extend(self.format_arguments(&args));\n\n        // Prepare JSON input\n        let input_json = serde_json::to_string(&args)?;\n\n        // Execute command\n        let (stdout, stderr, exit_code) = self\n            .execute_command(\n                &cmd_path,\n                &cmd_args,\n                &cli_prov.env_vars,\n                &cli_prov.working_dir,\n                Some(&input_json),\n            )\n            .await?;\n\n        let output = if exit_code == 0 { stdout } else { stderr };\n\n        if output.trim().is_empty() {\n            return Ok(Value::String(String::new()));\n        }\n\n        // Try to parse as JSON\n        if let Ok(result) = serde_json::from_str::<Value>(&output) {\n            Ok(result)\n        } else {\n            // Return as string if not JSON\n            Ok(Value::String(output.trim().to_string()))\n        }\n    }\n\n    async fn call_tool_stream(\n        &self,\n        _tool_name: &str,\n        _args: HashMap<String, Value>,\n        _prov: &dyn Provider,\n    ) -> Result<Box<dyn StreamResult>> {\n        Err(anyhow!(\"Streaming not supported by CliTransport\"))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::providers::base::{BaseProvider, ProviderType};\n    use crate::providers::cli::CliProvider;\n    use serde_json::json;\n    use std::fs;\n    use tempfile::tempdir;\n\n    #[test]\n    fn format_arguments_handles_types_and_ordering() {\n        let transport = CliTransport::new();\n        let mut args = HashMap::new();\n        args.insert(\"message\".to_string(), Value::String(\"hello\".to_string()));\n        args.insert(\"count\".to_string(), Value::Number(2.into()));\n        args.insert(\"enabled\".to_string(), Value::Bool(true));\n        args.insert(\"skip\".to_string(), Value::Bool(false));\n        args.insert(\n            \"ids\".to_string(),\n            Value::Array(vec![Value::Number(1.into()), Value::Number(2.into())]),\n        );\n\n        let formatted = transport.format_arguments(&args);\n        assert_eq!(\n            formatted,\n            vec![\n                \"--count\",\n                \"2\",\n                \"--enabled\",\n                \"--ids\",\n                \"1\",\n                \"--ids\",\n                \"2\",\n                \"--message\",\n                \"hello\"\n            ]\n        );\n    }\n\n    #[test]\n    fn extract_tools_from_output_parses_manifest() {\n        let transport = CliTransport::new();\n        let output = json!({\n            \"tools\": [{\n                \"name\": \"example\",\n                \"description\": \"example tool\",\n                \"inputs\": { \"type\": \"object\" },\n                \"outputs\": { \"type\": \"object\" },\n                \"tags\": []\n            }]\n        })\n        .to_string();\n\n        let tools = transport.extract_tools_from_output(&output);\n        assert_eq!(tools.len(), 1);\n        assert_eq!(tools[0].name, \"example\");\n        assert_eq!(tools[0].description, \"example tool\");\n    }\n\n    fn write_mock_cli(dir: &std::path::Path) -> std::path::PathBuf {\n        let script_path = dir.join(\"mock_cli.js\");\n        let script = r#\"#!/usr/bin/env node\nconst [,, mode, provider, tool, ...flags] = process.argv;\nif (!mode) {\n  console.log(JSON.stringify({\n    tools: [{\n      name: \"echo\",\n      description: \"echo tool\",\n      inputs: { \"type\": \"object\" },\n      outputs: { \"type\": \"object\" },\n      tags: []\n    }]\n  }));\n  process.exit(0);\n}\n\nif (mode === \"call\") {\n  let body = \"\";\n  process.stdin.on(\"data\", chunk => body += chunk.toString());\n  process.stdin.on(\"end\", () => {\n    const args = body ? JSON.parse(body) : {};\n    console.log(JSON.stringify({ provider, tool, args, flags }));\n  });\n}\n\"#;\n        fs::write(&script_path, script).unwrap();\n        #[cfg(unix)]\n        {\n            use std::os::unix::fs::PermissionsExt;\n            let mut perms = fs::metadata(&script_path).unwrap().permissions();\n            perms.set_mode(0o755);\n            fs::set_permissions(&script_path, perms).unwrap();\n        }\n        script_path\n    }\n\n    fn write_cli_requiring_mode_flag(dir: &std::path::Path) -> std::path::PathBuf {\n        let script_path = dir.join(\"mock_cli_mode_flag.js\");\n        let script = r#\"#!/usr/bin/env node\nconst argv = process.argv.slice(2);\nconst hasFlag = argv.shift() === \"--cli-mode\";\nif (!hasFlag) {\n  console.error(\"missing --cli-mode\");\n  process.exit(2);\n}\n\nconst [mode, provider, tool, ...flags] = argv;\nif (!mode) {\n  console.log(JSON.stringify({\n    tools: [{\n      name: \"echo\",\n      description: \"echo tool\",\n      inputs: { \"type\": \"object\" },\n      outputs: { \"type\": \"object\" },\n      tags: []\n    }]\n  }));\n  process.exit(0);\n}\n\nif (mode === \"call\") {\n  let body = \"\";\n  process.stdin.on(\"data\", chunk => body += chunk.toString());\n  process.stdin.on(\"end\", () => {\n    const args = body ? JSON.parse(body) : {};\n    console.log(JSON.stringify({ provider, tool, args, flags, hadFlag: hasFlag }));\n  });\n}\n\"#;\n        fs::write(&script_path, script).unwrap();\n        #[cfg(unix)]\n        {\n            use std::os::unix::fs::PermissionsExt;\n            let mut perms = fs::metadata(&script_path).unwrap().permissions();\n            perms.set_mode(0o755);\n            fs::set_permissions(&script_path, perms).unwrap();\n        }\n        script_path\n    }\n\n    fn cli_provider(command: &str) -> CliProvider {\n        CliProvider {\n            base: BaseProvider {\n                name: \"cli\".to_string(),\n                provider_type: ProviderType::Cli,\n                auth: None,\n                allowed_communication_protocols: None,\n            },\n            command_name: command.to_string(),\n            working_dir: None,\n            env_vars: None,\n        }\n    }\n\n    #[tokio::test]\n    async fn register_and_call_tool_via_cli_transport() {\n        let dir = tempdir().unwrap();\n        let script_path = write_mock_cli(dir.path());\n        let command = script_path.display().to_string();\n\n        let transport = CliTransport::new();\n        let provider = cli_provider(&command);\n\n        let tools = transport\n            .register_tool_provider(&provider)\n            .await\n            .expect(\"register tools\");\n        assert_eq!(tools.len(), 1);\n        assert_eq!(tools[0].name, \"echo\");\n\n        let mut args = HashMap::new();\n        args.insert(\"name\".into(), Value::String(\"world\".into()));\n        let result = transport\n            .call_tool(\"echo\", args.clone(), &provider)\n            .await\n            .expect(\"call tool\");\n\n        assert!(\n            result.get(\"provider\").is_some(),\n            \"result missing provider: {}\",\n            result\n        );\n        assert_eq!(result[\"provider\"], \"cli\");\n        assert_eq!(result[\"tool\"], \"echo\");\n        assert_eq!(result[\"args\"], json!(args));\n    }\n\n    #[tokio::test]\n    async fn call_tool_respects_base_command_args() {\n        let dir = tempdir().unwrap();\n        let script_path = write_cli_requiring_mode_flag(dir.path());\n        let command = format!(\"{} --cli-mode\", script_path.display());\n\n        let transport = CliTransport::new();\n        let provider = cli_provider(&command);\n\n        let tools = transport\n            .register_tool_provider(&provider)\n            .await\n            .expect(\"register tools\");\n        assert_eq!(tools.len(), 1);\n\n        let result = transport\n            .call_tool(\"echo\", HashMap::new(), &provider)\n            .await\n            .expect(\"call tool\");\n\n        assert_eq!(result[\"hadFlag\"], json!(true));\n    }\n\n    #[tokio::test]\n    async fn call_tool_stream_not_supported() {\n        let dir = tempdir().unwrap();\n        let script_path = write_mock_cli(dir.path());\n        let command = format!(\"node {}\", script_path.display());\n        let transport = CliTransport::new();\n        let provider = cli_provider(&command);\n\n        let err = transport\n            .call_tool_stream(\"echo\", HashMap::new(), &provider)\n            .await\n            .err()\n            .expect(\"expected streaming error\");\n        assert!(err.to_string().contains(\"Streaming not supported\"));\n    }\n}\n",
      "line_count": 473,
      "word_count": 1149,
      "title": "Mod.Rs",
      "summary": "// CLI Transport - executes command-line tools use anyhow::{anyhow, Result};",
      "key_terms": [
        "toString",
        "Bool",
        "output",
        "null",
        "ClientTransport",
        "Result",
        "const",
        "arr",
        "async",
        "completion",
        "error",
        "display",
        "flags",
        "perms",
        "prov",
        "Prepare",
        "compatible",
        "Duration",
        "format",
        "mode"
      ],
      "timestamp": "2025-12-24T18:56:15.491329"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\transports\\graphql\\mod.rs",
      "content_type": "code",
      "content": "// GraphQL Transport - queries, mutations, and subscriptions\nuse anyhow::{anyhow, Result};\nuse async_trait::async_trait;\nuse base64::Engine;\nuse futures::{SinkExt, StreamExt};\nuse reqwest::Client;\nuse serde_json::{json, Value};\nuse std::collections::HashMap;\nuse tokio::sync::mpsc;\nuse tokio_tungstenite::{connect_async, tungstenite::Message};\n\nuse crate::auth::AuthConfig;\nuse crate::providers::base::Provider;\nuse crate::providers::graphql::GraphqlProvider;\nuse crate::tools::{Tool, ToolInputOutputSchema};\nuse crate::transports::{\n    stream::{boxed_channel_stream, StreamResult},\n    ClientTransport,\n};\n\n/// Transport that maps GraphQL operations to UTCP tools.\npub struct GraphQLTransport {\n    client: Client,\n}\n\nimpl GraphQLTransport {\n    /// Create a GraphQL transport using a default reqwest client.\n    pub fn new() -> Self {\n        Self {\n            client: Client::new(),\n        }\n    }\n\n    fn default_schema() -> ToolInputOutputSchema {\n        ToolInputOutputSchema {\n            type_: \"object\".to_string(),\n            properties: None,\n            required: None,\n            description: None,\n            title: None,\n            items: None,\n            enum_: None,\n            minimum: None,\n            maximum: None,\n            format: None,\n        }\n    }\n\n    fn infer_operation(operation_type: &str, tool_name: &str) -> String {\n        let op = operation_type.trim().to_lowercase();\n        match op.as_str() {\n            \"query\" | \"mutation\" | \"subscription\" => return op,\n            _ => {}\n        }\n\n        let tool = tool_name.to_lowercase();\n        if tool.starts_with(\"subscription\")\n            || tool.starts_with(\"subscribe\")\n            || tool.starts_with(\"on_\")\n        {\n            return \"subscription\".to_string();\n        }\n        if tool.starts_with(\"mutation\")\n            || tool.starts_with(\"create\")\n            || tool.starts_with(\"update\")\n            || tool.starts_with(\"delete\")\n        {\n            return \"mutation\".to_string();\n        }\n\n        \"query\".to_string()\n    }\n\n    fn normalize_arg_value(key: &str, value: Value) -> (String, Value) {\n        match value {\n            Value::Bool(_) => (\"Boolean!\".to_string(), value),\n            Value::Number(num) => {\n                if let Some(int_val) = num.as_i64() {\n                    if int_val >= i64::from(i32::MIN) && int_val <= i64::from(i32::MAX) {\n                        return (\"Int!\".to_string(), Value::Number(num));\n                    }\n                }\n                (\"Float!\".to_string(), Value::Number(num))\n            }\n            Value::String(s) => {\n                let maybe_id = key.to_ascii_lowercase().ends_with(\"_id\");\n                let type_name = if maybe_id { \"ID!\" } else { \"String!\" };\n                (type_name.to_string(), Value::String(s))\n            }\n            Value::Array(_) | Value::Object(_) => {\n                // Serialize complex values as JSON strings for portability.\n                let serialized = value.to_string();\n                (\"String!\".to_string(), Value::String(serialized))\n            }\n            Value::Null => (\"String\".to_string(), Value::Null),\n        }\n    }\n\n    fn apply_auth(\n        &self,\n        builder: reqwest::RequestBuilder,\n        auth: &AuthConfig,\n    ) -> Result<reqwest::RequestBuilder> {\n        match auth {\n            AuthConfig::ApiKey(api_key) => {\n                let location = api_key.location.to_ascii_lowercase();\n                match location.as_str() {\n                    \"header\" => Ok(builder.header(&api_key.var_name, &api_key.api_key)),\n                    \"query\" => {\n                        Ok(builder.query(&[(api_key.var_name.clone(), api_key.api_key.clone())]))\n                    }\n                    \"cookie\" => Ok(builder.header(\n                        \"cookie\",\n                        format!(\"{}={}\", api_key.var_name, api_key.api_key),\n                    )),\n                    other => Err(anyhow!(\"Unsupported API key location: {}\", other)),\n                }\n            }\n            AuthConfig::Basic(basic) => {\n                Ok(builder.basic_auth(&basic.username, Some(&basic.password)))\n            }\n            AuthConfig::OAuth2(_) => Err(anyhow!(\n                \"OAuth2 auth is not yet supported by the GraphQL transport\"\n            )),\n        }\n    }\n\n    async fn execute_query(\n        &self,\n        prov: &GraphqlProvider,\n        query: &str,\n        variables: HashMap<String, Value>,\n    ) -> Result<Value> {\n        let mut req = self\n            .client\n            .post(&prov.url)\n            .json(&json!({ \"query\": query, \"variables\": variables }));\n        if let Some(headers) = &prov.headers {\n            for (k, v) in headers {\n                req = req.header(k, v);\n            }\n        }\n        if let Some(auth) = &prov.base.auth {\n            req = self.apply_auth(req, auth)?;\n        }\n\n        let response = req.send().await?;\n        if !response.status().is_success() {\n            return Err(anyhow!(\"GraphQL request failed: {}\", response.status()));\n        }\n\n        let result: Value = response.json().await?;\n        if let Some(errors) = result.get(\"errors\") {\n            return Err(anyhow!(\"GraphQL errors: {}\", errors));\n        }\n\n        result\n            .get(\"data\")\n            .cloned()\n            .ok_or_else(|| anyhow!(\"No data in GraphQL response\"))\n    }\n}\n\n#[async_trait]\nimpl ClientTransport for GraphQLTransport {\n    async fn register_tool_provider(&self, prov: &dyn Provider) -> Result<Vec<Tool>> {\n        let gql_prov = prov\n            .as_any()\n            .downcast_ref::<GraphqlProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not a GraphqlProvider\"))?;\n\n        // Basic introspection to list available operations.\n        let introspection = r#\"\n        query IntrospectionQuery {\n          __schema {\n            queryType { fields { name description } }\n            mutationType { fields { name description } }\n            subscriptionType { fields { name description } }\n          }\n        }\"#;\n\n        let response = self\n            .execute_query(gql_prov, introspection, HashMap::new())\n            .await;\n\n        if response.is_err() {\n            return Ok(vec![]);\n        }\n        let response = response.unwrap_or_default();\n\n        let mut tools = Vec::new();\n        let default_schema = Self::default_schema();\n\n        if let Some(schema) = response.get(\"__schema\") {\n            for (op_type, key) in [\n                (\"query\", \"queryType\"),\n                (\"mutation\", \"mutationType\"),\n                (\"subscription\", \"subscriptionType\"),\n            ] {\n                if let Some(fields) = schema\n                    .get(key)\n                    .and_then(|v| v.get(\"fields\"))\n                    .and_then(|v| v.as_array())\n                {\n                    for field in fields {\n                        if let Some(name) = field.get(\"name\").and_then(|v| v.as_str()) {\n                            let description = field\n                                .get(\"description\")\n                                .and_then(|v| v.as_str())\n                                .unwrap_or_default()\n                                .to_string();\n                            tools.push(Tool {\n                                name: name.to_string(),\n                                description,\n                                inputs: default_schema.clone(),\n                                outputs: default_schema.clone(),\n                                tags: vec![op_type.to_string()],\n                                average_response_size: None,\n                                provider: None,\n                            });\n                        }\n                    }\n                }\n            }\n        }\n\n        Ok(tools)\n    }\n\n    async fn deregister_tool_provider(&self, _prov: &dyn Provider) -> Result<()> {\n        Ok(())\n    }\n\n    async fn call_tool(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, Value>,\n        prov: &dyn Provider,\n    ) -> Result<Value> {\n        let gql_prov = prov\n            .as_any()\n            .downcast_ref::<GraphqlProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not a GraphqlProvider\"))?;\n\n        let call_name = tool_name\n            .strip_prefix(&format!(\"{}.\", gql_prov.base.name))\n            .unwrap_or(tool_name);\n\n        let operation_type = Self::infer_operation(&gql_prov.operation_type, call_name);\n        let operation_name = gql_prov\n            .operation_name\n            .clone()\n            .unwrap_or_else(|| call_name.to_string());\n\n        // Use simple variable typing (String) for portability.\n        let mut arg_defs = Vec::new();\n        let mut arg_uses = Vec::new();\n        let mut variables = HashMap::new();\n\n        for (key, value) in args {\n            let (type_name, normalized_value) = Self::normalize_arg_value(&key, value);\n            arg_defs.push(format!(\"${}: {}\", key, type_name));\n            arg_uses.push(format!(\"{}: ${}\", key, key));\n            variables.insert(key, normalized_value);\n        }\n\n        let query = if !arg_defs.is_empty() {\n            format!(\n                \"{} {}({}) {{ {}({}) }}\",\n                operation_type,\n                operation_name,\n                arg_defs.join(\", \"),\n                call_name,\n                arg_uses.join(\", \")\n            )\n        } else {\n            format!(\"{} {{ {} }}\", operation_type, call_name)\n        };\n\n        self.execute_query(gql_prov, &query, variables).await\n    }\n\n    async fn call_tool_stream(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, Value>,\n        prov: &dyn Provider,\n    ) -> Result<Box<dyn StreamResult>> {\n        let gql_prov = prov\n            .as_any()\n            .downcast_ref::<GraphqlProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not a GraphqlProvider\"))?;\n\n        let call_name = tool_name\n            .strip_prefix(&format!(\"{}.\", gql_prov.base.name))\n            .unwrap_or(tool_name);\n\n        let operation_type = Self::infer_operation(&gql_prov.operation_type, call_name);\n\n        // GraphQL subscriptions must be sent over WebSocket\n        if operation_type != \"subscription\" {\n            return Err(anyhow!(\n                \"call_tool_stream is only for GraphQL subscriptions; '{}' is a {}\",\n                call_name,\n                operation_type\n            ));\n        }\n\n        let operation_name = gql_prov\n            .operation_name\n            .clone()\n            .unwrap_or_else(|| call_name.to_string());\n\n        // Build the subscription query with variables\n        let mut arg_defs = Vec::new();\n        let mut arg_uses = Vec::new();\n        let mut variables = HashMap::new();\n\n        for (key, value) in args {\n            let (type_name, normalized_value) = Self::normalize_arg_value(&key, value);\n            arg_defs.push(format!(\"${}: {}\", key, type_name));\n            arg_uses.push(format!(\"{}: ${}\", key, key));\n            variables.insert(key, normalized_value);\n        }\n\n        let subscription_query = if !arg_defs.is_empty() {\n            format!(\n                \"{} {}({}) {{ {}({}) }}\",\n                operation_type,\n                operation_name,\n                arg_defs.join(\", \"),\n                call_name,\n                arg_uses.join(\", \")\n            )\n        } else {\n            format!(\"{} {{ {} }}\", operation_type, call_name)\n        };\n\n        // Convert HTTP URL to WebSocket URL\n        let mut ws_url = gql_prov\n            .url\n            .replace(\"http://\", \"ws://\")\n            .replace(\"https://\", \"wss://\");\n\n        // Handle query-based authentication\n        if let Some(AuthConfig::ApiKey(api_key)) = &gql_prov.base.auth {\n            if api_key.location.to_ascii_lowercase() == \"query\" {\n                let separator = if ws_url.contains('?') { \"&\" } else { \"?\" };\n                ws_url = format!(\n                    \"{}{}{}={}\",\n                    ws_url, separator, api_key.var_name, api_key.api_key\n                );\n            }\n        }\n\n        // Build the WebSocket request with proper headers\n        let mut req = tokio_tungstenite::tungstenite::http::Request::builder()\n            .uri(&ws_url)\n            .header(\"Host\", ws_url.split('/').nth(2).unwrap_or(\"localhost\"))\n            .header(\"Connection\", \"Upgrade\")\n            .header(\"Upgrade\", \"websocket\")\n            .header(\"Sec-WebSocket-Version\", \"13\")\n            .header(\n                \"Sec-WebSocket-Key\",\n                tokio_tungstenite::tungstenite::handshake::client::generate_key(),\n            )\n            .header(\"Sec-WebSocket-Protocol\", \"graphql-transport-ws\")\n            .body(())?;\n\n        // Apply authentication to WebSocket request (except query which was handled above)\n        if let Some(auth) = &gql_prov.base.auth {\n            match auth {\n                AuthConfig::ApiKey(api_key) => {\n                    let location = api_key.location.to_ascii_lowercase();\n                    match location.as_str() {\n                        \"header\" => {\n                            use tokio_tungstenite::tungstenite::http::{HeaderName, HeaderValue};\n                            let name = HeaderName::from_bytes(api_key.var_name.as_bytes())\n                                .map_err(|_| anyhow!(\"Invalid header name\"))?;\n                            let value = HeaderValue::from_str(&api_key.api_key)\n                                .map_err(|_| anyhow!(\"Invalid header value\"))?;\n                            req.headers_mut().insert(name, value);\n                        }\n                        \"cookie\" => {\n                            use tokio_tungstenite::tungstenite::http::HeaderValue;\n                            let cookie_value = format!(\"{}={}\", api_key.var_name, api_key.api_key);\n                            let value = HeaderValue::from_str(&cookie_value)\n                                .map_err(|_| anyhow!(\"Invalid cookie value\"))?;\n                            req.headers_mut().insert(\"cookie\", value);\n                        }\n                        \"query\" => {\n                            // Already handled above\n                        }\n                        other => {\n                            return Err(anyhow!(\n                                \"Unsupported API key location for WebSocket: {}\",\n                                other\n                            ))\n                        }\n                    }\n                }\n                AuthConfig::Basic(basic) => {\n                    use tokio_tungstenite::tungstenite::http::HeaderValue;\n                    let credentials = format!(\"{}:{}\", basic.username, basic.password);\n                    let encoded =\n                        base64::engine::general_purpose::STANDARD.encode(credentials.as_bytes());\n                    let value = HeaderValue::from_str(&format!(\"Basic {}\", encoded))\n                        .map_err(|_| anyhow!(\"Invalid auth header\"))?;\n                    req.headers_mut().insert(\"authorization\", value);\n                }\n                AuthConfig::OAuth2(_) => {\n                    return Err(anyhow!(\n                        \"OAuth2 is not supported for GraphQL WebSocket subscriptions\"\n                    ));\n                }\n            }\n        }\n\n        // Apply custom headers if any\n        if let Some(headers) = &gql_prov.headers {\n            use tokio_tungstenite::tungstenite::http::{HeaderName, HeaderValue};\n            for (k, v) in headers {\n                let name = HeaderName::from_bytes(k.as_bytes())\n                    .map_err(|_| anyhow!(\"Invalid header name: {}\", k))?;\n                let value =\n                    HeaderValue::from_str(v).map_err(|_| anyhow!(\"Invalid header value: {}\", v))?;\n                req.headers_mut().insert(name, value);\n            }\n        }\n\n        let (mut ws_stream, _) = connect_async(req).await?;\n\n        // Send connection_init message (graphql-transport-ws protocol)\n        ws_stream\n            .send(Message::Text(\n                json!({\n                    \"type\": \"connection_init\"\n                })\n                .to_string(),\n            ))\n            .await?;\n\n        // Wait for connection_ack\n        if let Some(msg) = ws_stream.next().await {\n            match msg? {\n                Message::Text(text) => {\n                    let ack: Value = serde_json::from_str(&text)?;\n                    if ack.get(\"type\").and_then(|v| v.as_str()) != Some(\"connection_ack\") {\n                        return Err(anyhow!(\"Expected connection_ack, got: {}\", text));\n                    }\n                }\n                _ => return Err(anyhow!(\"Expected text message for connection_ack\")),\n            }\n        }\n\n        // Send subscription message\n        let subscription_id = \"1\"; // Simple ID for single subscription\n        let subscribe_msg = json!({\n            \"id\": subscription_id,\n            \"type\": \"subscribe\",\n            \"payload\": {\n                \"query\": subscription_query,\n                \"variables\": variables,\n            }\n        });\n\n        ws_stream\n            .send(Message::Text(subscribe_msg.to_string()))\n            .await?;\n\n        // Create channel for streaming results\n        let (tx, rx) = mpsc::channel(256);\n\n        // Spawn task to handle incoming subscription messages\n        tokio::spawn(async move {\n            while let Some(msg) = ws_stream.next().await {\n                match msg {\n                    Ok(Message::Text(text)) => {\n                        let parsed = match serde_json::from_str::<Value>(&text) {\n                            Ok(v) => v,\n                            Err(e) => {\n                                let _ = tx\n                                    .send(Err(anyhow!(\"Failed to parse WebSocket message: {}\", e)))\n                                    .await;\n                                break;\n                            }\n                        };\n\n                        let msg_type = parsed.get(\"type\").and_then(|v| v.as_str());\n                        match msg_type {\n                            Some(\"next\") => {\n                                // Extract data from payload\n                                if let Some(payload) = parsed.get(\"payload\") {\n                                    if let Some(data) = payload.get(\"data\") {\n                                        if tx.send(Ok(data.clone())).await.is_err() {\n                                            break;\n                                        }\n                                    }\n                                    // Check for errors in payload\n                                    if let Some(errors) = payload.get(\"errors\") {\n                                        let _ = tx\n                                            .send(Err(anyhow!(\n                                                \"GraphQL subscription error: {}\",\n                                                errors\n                                            )))\n                                            .await;\n                                        break;\n                                    }\n                                }\n                            }\n                            Some(\"error\") => {\n                                let error_msg = parsed\n                                    .get(\"payload\")\n                                    .map(|p| p.to_string())\n                                    .unwrap_or_else(|| \"Unknown error\".to_string());\n                                let _ = tx\n                                    .send(Err(anyhow!(\"GraphQL subscription error: {}\", error_msg)))\n                                    .await;\n                                break;\n                            }\n                            Some(\"complete\") => {\n                                // Subscription completed normally\n                                break;\n                            }\n                            _ => {\n                                // Ignore other message types (ping, pong, etc.)\n                            }\n                        }\n                    }\n                    Ok(Message::Close(_)) => break,\n                    Ok(_) => {} // Ignore binary, ping, pong\n                    Err(err) => {\n                        let _ = tx.send(Err(anyhow!(\"WebSocket error: {}\", err))).await;\n                        break;\n                    }\n                }\n            }\n        });\n\n        Ok(boxed_channel_stream(rx, None))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use axum::{extract::Json, routing::post, Router};\n    use serde_json::json;\n    use std::net::TcpListener;\n\n    #[test]\n    fn infer_operation_prefers_explicit_value() {\n        assert_eq!(\n            GraphQLTransport::infer_operation(\"Mutation\", \"getUser\"),\n            \"mutation\"\n        );\n        assert_eq!(\n            GraphQLTransport::infer_operation(\"subscription\", \"createUser\"),\n            \"subscription\"\n        );\n        assert_eq!(\n            GraphQLTransport::infer_operation(\"QUERY\", \"deleteUser\"),\n            \"query\"\n        );\n    }\n\n    #[test]\n    fn infer_operation_derives_from_tool_name_when_unspecified() {\n        assert_eq!(\n            GraphQLTransport::infer_operation(\"\", \"subscription_changes\"),\n            \"subscription\"\n        );\n        assert_eq!(\n            GraphQLTransport::infer_operation(\"unknown\", \"createItem\"),\n            \"mutation\"\n        );\n        assert_eq!(\n            GraphQLTransport::infer_operation(\"  \", \"listItems\"),\n            \"query\"\n        );\n    }\n\n    #[test]\n    fn normalize_arg_value_maps_rust_types_to_graphql_scalars() {\n        let (ty, value) =\n            GraphQLTransport::normalize_arg_value(\"user_id\", Value::String(\"abc\".into()));\n        assert_eq!(ty, \"ID!\");\n        assert_eq!(value, Value::String(\"abc\".into()));\n\n        let (ty, value) = GraphQLTransport::normalize_arg_value(\"count\", Value::Number(3.into()));\n        assert_eq!(ty, \"Int!\");\n        assert_eq!(value, Value::Number(3.into()));\n\n        let (ty, value) = GraphQLTransport::normalize_arg_value(\n            \"price\",\n            Value::Number(serde_json::Number::from_f64(1.5).unwrap()),\n        );\n        assert_eq!(ty, \"Float!\");\n        assert_eq!(\n            value,\n            Value::Number(serde_json::Number::from_f64(1.5).unwrap())\n        );\n\n        let (ty, value) =\n            GraphQLTransport::normalize_arg_value(\"flags\", serde_json::json!({\"a\": 1}));\n        assert_eq!(ty, \"String!\");\n        assert_eq!(value, Value::String(\"{\\\"a\\\":1}\".into()));\n    }\n\n    #[tokio::test]\n    async fn register_and_call_graphql_transport() {\n        async fn handler(Json(body): Json<Value>) -> Json<Value> {\n            let query_str = body.get(\"query\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            if query_str.contains(\"__schema\") {\n                return Json(json!({\n                    \"data\": {\n                        \"__schema\": {\n                            \"queryType\": { \"fields\": [{ \"name\": \"hello\", \"description\": \"hi\" }] },\n                            \"mutationType\": null,\n                            \"subscriptionType\": null\n                        }\n                    }\n                }));\n            }\n\n            Json(json!({\n                \"data\": {\n                    \"hello\": {\n                        \"msg\": \"hi\"\n                    }\n                }\n            }))\n        }\n\n        let app = Router::new().route(\"/\", post(handler));\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n        tokio::spawn(async move {\n            axum::Server::from_tcp(listener)\n                .unwrap()\n                .serve(app.into_make_service())\n                .await\n                .unwrap();\n        });\n\n        let prov = GraphqlProvider {\n            base: crate::providers::base::BaseProvider {\n                name: \"gql\".to_string(),\n                provider_type: crate::providers::base::ProviderType::Graphql,\n                auth: None,\n                allowed_communication_protocols: None,\n            },\n            url: format!(\"http://{}\", addr),\n            operation_type: \"query\".to_string(),\n            operation_name: None,\n            headers: None,\n        };\n\n        let transport = GraphQLTransport::new();\n        let tools = transport\n            .register_tool_provider(&prov)\n            .await\n            .expect(\"register\");\n        assert_eq!(tools.len(), 1);\n        assert_eq!(tools[0].name, \"hello\");\n\n        let result = transport\n            .call_tool(\"hello\", HashMap::new(), &prov)\n            .await\n            .expect(\"call\");\n        assert_eq!(result[\"hello\"][\"msg\"], \"hi\");\n\n        // call_tool_stream should fail for queries (non-subscriptions)\n        let err = transport\n            .call_tool_stream(\"hello\", HashMap::new(), &prov)\n            .await\n            .err()\n            .expect(\"stream error\");\n        assert!(err.to_string().contains(\"only for GraphQL subscriptions\"));\n    }\n\n    #[tokio::test]\n    async fn graphql_call_strips_provider_prefix() {\n        async fn handler(Json(body): Json<Value>) -> Json<Value> {\n            let query = body\n                .get(\"query\")\n                .and_then(|v| v.as_str())\n                .unwrap_or_default()\n                .to_string();\n            assert!(query.contains(\"echo\"));\n            assert!(\n                !query.contains(\"gql.echo\"),\n                \"provider prefix should be stripped before building query\"\n            );\n            let vars = body\n                .get(\"variables\")\n                .cloned()\n                .unwrap_or_else(|| json!({ \"missing\": true }));\n            Json(json!({ \"data\": { \"echo\": vars } }))\n        }\n\n        let app = Router::new().route(\"/graphql\", post(handler));\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n        tokio::spawn(async move {\n            axum::Server::from_tcp(listener)\n                .unwrap()\n                .serve(app.into_make_service())\n                .await\n                .unwrap();\n        });\n\n        let prov = GraphqlProvider {\n            base: crate::providers::base::BaseProvider {\n                name: \"gql\".to_string(),\n                provider_type: crate::providers::base::ProviderType::Graphql,\n                auth: None,\n                allowed_communication_protocols: None,\n            },\n            url: format!(\"http://{}/graphql\", addr),\n            operation_type: \"query\".to_string(),\n            operation_name: None,\n            headers: None,\n        };\n\n        let mut args = HashMap::new();\n        args.insert(\"msg\".into(), json!(\"hi\"));\n\n        let transport = GraphQLTransport::new();\n        let result = transport\n            .call_tool(\"gql.echo\", args.clone(), &prov)\n            .await\n            .expect(\"call tool\");\n\n        assert_eq!(result, json!({ \"echo\": json!({ \"msg\": \"hi\" }) }));\n    }\n\n    #[tokio::test]\n    async fn graphql_subscription_streams_data() {\n        use futures_util::{SinkExt, StreamExt};\n        use tokio::net::TcpListener;\n        use tokio_tungstenite::accept_async;\n\n        // Create a mock GraphQL subscription server\n        let listener = TcpListener::bind(\"127.0.0.1:0\").await.unwrap();\n        let addr = listener.local_addr().unwrap();\n\n        tokio::spawn(async move {\n            if let Ok((stream, _)) = listener.accept().await {\n                // Accept any WebSocket connection\n                if let Ok(mut ws) = accept_async(stream).await {\n                    // Receive connection_init\n                    if let Some(Ok(Message::Text(text))) = ws.next().await {\n                        let init: Value = serde_json::from_str(&text).unwrap();\n                        if init.get(\"type\").and_then(|v| v.as_str()) == Some(\"connection_init\") {\n                            // Send connection_ack\n                            let _ = ws\n                                .send(Message::Text(\n                                    json!({ \"type\": \"connection_ack\" }).to_string(),\n                                ))\n                                .await;\n\n                            // Receive subscription message\n                            if let Some(Ok(Message::Text(text))) = ws.next().await {\n                                let sub: Value = serde_json::from_str(&text).unwrap();\n                                if sub.get(\"type\").and_then(|v| v.as_str()) == Some(\"subscribe\") {\n                                    // Send multiple streaming events\n                                    for i in 1..=3 {\n                                        let _ = ws\n                                            .send(Message::Text(\n                                                json!({\n                                                    \"id\": \"1\",\n                                                    \"type\": \"next\",\n                                                    \"payload\": {\n                                                        \"data\": {\n                                                            \"messageAdded\": {\n                                                                \"id\": i,\n                                                                \"content\": format!(\"Message {}\", i)\n                                                            }\n                                                        }\n                                                    }\n                                                })\n                                                .to_string(),\n                                            ))\n                                            .await;\n                                        tokio::time::sleep(tokio::time::Duration::from_millis(10))\n                                            .await;\n                                    }\n\n                                    // Send complete message\n                                    let _ = ws\n                                        .send(Message::Text(\n                                            json!({\n                                                \"id\": \"1\",\n                                                \"type\": \"complete\"\n                                            })\n                                            .to_string(),\n                                        ))\n                                        .await;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n\n        // Give server time to start\n        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n\n        let prov = GraphqlProvider {\n            base: crate::providers::base::BaseProvider {\n                name: \"gql\".to_string(),\n                provider_type: crate::providers::base::ProviderType::Graphql,\n                auth: None,\n                allowed_communication_protocols: None,\n            },\n            url: format!(\"http://{}\", addr),\n            operation_type: \"subscription\".to_string(),\n            operation_name: Some(\"MessageAdded\".to_string()),\n            headers: None,\n        };\n\n        let transport = GraphQLTransport::new();\n        let mut stream = transport\n            .call_tool_stream(\"messageAdded\", HashMap::new(), &prov)\n            .await\n            .expect(\"stream created\");\n\n        // Collect streaming results\n        let mut results = Vec::new();\n        while let Ok(Some(value)) = stream.next().await {\n            results.push(value);\n            if results.len() >= 3 {\n                break;\n            }\n        }\n\n        assert_eq!(results.len(), 3);\n        for (i, result) in results.iter().enumerate() {\n            let expected_id = i + 1;\n            assert_eq!(\n                result[\"messageAdded\"][\"id\"], expected_id,\n                \"Expected message {} to have id {}\",\n                i, expected_id\n            );\n            assert_eq!(\n                result[\"messageAdded\"][\"content\"],\n                format!(\"Message {}\", expected_id)\n            );\n        }\n    }\n}\n",
      "line_count": 854,
      "word_count": 2141,
      "title": "Mod.Rs",
      "summary": "// GraphQL Transport - queries, mutations, and subscriptions use anyhow::{anyhow, Result};",
      "key_terms": [
        "MIN",
        "localhost",
        "etc",
        "list",
        "cookie",
        "encoded",
        "providers",
        "subscribe",
        "Self",
        "multiple",
        "if",
        "that",
        "supported",
        "basic",
        "Version",
        "ty",
        "price",
        "completed",
        "title",
        "await"
      ],
      "timestamp": "2025-12-24T18:56:15.524084"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\transports\\grpc\\mod.rs",
      "content_type": "code",
      "content": "// gRPC Transport - Protocol Buffers RPC\nuse anyhow::{anyhow, Result};\nuse async_trait::async_trait;\nuse base64::Engine;\nuse serde_json::Value;\nuse std::collections::HashMap;\nuse std::str::FromStr;\nuse tokio::sync::mpsc;\nuse tonic::metadata::{MetadataKey, MetadataValue};\nuse tonic::transport::{Channel, ClientTlsConfig, Endpoint};\nuse tonic::Request;\n\nuse crate::auth::AuthConfig;\nuse crate::providers::base::Provider;\nuse crate::providers::grpc::GrpcProvider;\nuse crate::tools::{Tool, ToolInputOutputSchema};\nuse crate::transports::{\n    stream::{boxed_channel_stream, StreamResult},\n    ClientTransport,\n};\n\nuse crate::grpcpb::generated::utcp_service_client::UtcpServiceClient;\nuse crate::grpcpb::generated::{Empty, ToolCallRequest};\n\n/// Transport implementation that communicates with UTCP servers over gRPC.\npub struct GrpcTransport;\n\nimpl GrpcTransport {\n    /// Create a gRPC transport instance.\n    pub fn new() -> Self {\n        Self\n    }\n\n    fn default_schema() -> ToolInputOutputSchema {\n        ToolInputOutputSchema {\n            type_: \"object\".to_string(),\n            properties: None,\n            required: None,\n            description: None,\n            title: None,\n            items: None,\n            enum_: None,\n            minimum: None,\n            maximum: None,\n            format: None,\n        }\n    }\n\n    async fn connect(&self, prov: &GrpcProvider) -> Result<UtcpServiceClient<Channel>> {\n        let scheme = if prov.use_ssl { \"https\" } else { \"http\" };\n        let endpoint = format!(\"{}://{}:{}\", scheme, prov.host, prov.port);\n\n        let mut endpoint = Endpoint::from_shared(endpoint)?;\n        if prov.use_ssl {\n            endpoint = endpoint.tls_config(ClientTlsConfig::new())?;\n        }\n\n        let channel = endpoint.connect().await?;\n        Ok(UtcpServiceClient::new(channel))\n    }\n\n    fn apply_auth<T>(&self, prov: &GrpcProvider, req: &mut Request<T>) -> Result<()> {\n        if let Some(auth) = &prov.base.auth {\n            match auth {\n                AuthConfig::Basic(auth) => {\n                    let basic = base64::engine::general_purpose::STANDARD\n                        .encode(format!(\"{}:{}\", auth.username, auth.password));\n                    let value = MetadataValue::from_str(&format!(\"Basic {}\", basic))?;\n                    req.metadata_mut().insert(\"authorization\", value);\n                }\n                AuthConfig::ApiKey(api_key) => {\n                    if api_key.location.to_ascii_lowercase() != \"header\" {\n                        return Err(anyhow!(\n                            \"gRPC API key auth only supports the 'header' location\"\n                        ));\n                    }\n                    let key = MetadataKey::from_str(&api_key.var_name.to_ascii_lowercase())?;\n                    let value = MetadataValue::from_str(&api_key.api_key)?;\n                    req.metadata_mut().insert(key, value);\n                }\n                _ => {\n                    return Err(anyhow!(\n                        \"Only basic and api key auth are supported for gRPC providers\"\n                    ));\n                }\n            }\n        }\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl ClientTransport for GrpcTransport {\n    async fn register_tool_provider(&self, prov: &dyn Provider) -> Result<Vec<Tool>> {\n        let grpc_prov = prov\n            .as_any()\n            .downcast_ref::<GrpcProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not a GrpcProvider\"))?;\n\n        let mut client = self.connect(grpc_prov).await?;\n        let mut request = Request::new(Empty {});\n        self.apply_auth(grpc_prov, &mut request)?;\n\n        let manual = client.get_manual(request).await?.into_inner();\n        let default_schema = Self::default_schema();\n\n        let tools = manual\n            .tools\n            .into_iter()\n            .map(|t| Tool {\n                name: t.name,\n                description: t.description,\n                inputs: default_schema.clone(),\n                outputs: default_schema.clone(),\n                tags: vec![\"grpc\".to_string()],\n                average_response_size: None,\n                provider: None,\n            })\n            .collect();\n\n        Ok(tools)\n    }\n\n    async fn deregister_tool_provider(&self, _prov: &dyn Provider) -> Result<()> {\n        Ok(())\n    }\n\n    async fn call_tool(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, Value>,\n        prov: &dyn Provider,\n    ) -> Result<Value> {\n        let grpc_prov = prov\n            .as_any()\n            .downcast_ref::<GrpcProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not a GrpcProvider\"))?;\n\n        let mut client = self.connect(grpc_prov).await?;\n        let args_json = serde_json::to_string(&args)?;\n\n        let mut request = Request::new(ToolCallRequest {\n            tool: tool_name.to_string(),\n            args_json,\n        });\n        self.apply_auth(grpc_prov, &mut request)?;\n\n        let response = client.call_tool(request).await?.into_inner();\n        if response.result_json.is_empty() {\n            return Ok(Value::Null);\n        }\n\n        Ok(serde_json::from_str(&response.result_json)\n            .unwrap_or_else(|_| Value::String(response.result_json.clone())))\n    }\n\n    async fn call_tool_stream(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, Value>,\n        prov: &dyn Provider,\n    ) -> Result<Box<dyn StreamResult>> {\n        let grpc_prov = prov\n            .as_any()\n            .downcast_ref::<GrpcProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not a GrpcProvider\"))?;\n\n        let mut client = self.connect(grpc_prov).await?;\n        let args_json = serde_json::to_string(&args)?;\n\n        let mut request = Request::new(ToolCallRequest {\n            tool: tool_name.to_string(),\n            args_json,\n        });\n        self.apply_auth(grpc_prov, &mut request)?;\n\n        let mut stream = client.call_tool_stream(request).await?.into_inner();\n        let (tx, rx) = mpsc::channel(16);\n        tokio::spawn(async move {\n            while let Some(item) = stream.message().await.transpose() {\n                match item {\n                    Ok(resp) => {\n                        let parsed = if resp.result_json.is_empty() {\n                            Ok(Value::Null)\n                        } else {\n                            serde_json::from_str::<Value>(&resp.result_json)\n                                .map_err(|e| anyhow!(\"Failed to parse stream item: {}\", e))\n                        };\n                        if tx.send(parsed).await.is_err() {\n                            return;\n                        }\n                    }\n                    Err(status) => {\n                        let _ = tx.send(Err(anyhow!(\"gRPC stream error: {}\", status))).await;\n                        return;\n                    }\n                }\n            }\n        });\n\n        Ok(boxed_channel_stream(rx, None))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::auth::{ApiKeyAuth, AuthType, BasicAuth, OAuth2Auth};\n    use crate::providers::base::{BaseProvider, ProviderType};\n    use serde_json::json;\n    use tokio::net::TcpListener;\n    use tokio_stream::wrappers::{ReceiverStream, TcpListenerStream};\n    use tonic::transport::Server;\n\n    use crate::grpcpb::generated::utcp_service_server::{UtcpService, UtcpServiceServer};\n    use crate::grpcpb::generated::{Manual, Tool as GrpcTool, ToolCallResponse};\n\n    #[test]\n    fn apply_auth_sets_basic_header() {\n        let transport = GrpcTransport::new();\n        let prov = GrpcProvider::new(\n            \"grpc\".to_string(),\n            \"localhost\".to_string(),\n            50051,\n            Some(AuthConfig::Basic(BasicAuth {\n                auth_type: AuthType::Basic,\n                username: \"user\".to_string(),\n                password: \"pass\".to_string(),\n            })),\n        );\n\n        let mut request: Request<()> = Request::new(());\n        transport.apply_auth(&prov, &mut request).unwrap();\n\n        let header = request.metadata().get(\"authorization\").unwrap();\n        assert_eq!(header.to_str().unwrap(), \"Basic dXNlcjpwYXNz\");\n    }\n\n    #[test]\n    fn apply_auth_rejects_non_basic() {\n        let transport = GrpcTransport::new();\n        let prov = GrpcProvider::new(\n            \"grpc\".to_string(),\n            \"localhost\".to_string(),\n            50051,\n            Some(AuthConfig::OAuth2(OAuth2Auth {\n                auth_type: AuthType::OAuth2,\n                token_url: \"https://example.com\".to_string(),\n                client_id: \"id\".to_string(),\n                client_secret: \"secret\".to_string(),\n                scope: None,\n            })),\n        );\n\n        let mut request: Request<()> = Request::new(());\n        let err = transport.apply_auth(&prov, &mut request).unwrap_err();\n        assert!(err\n            .to_string()\n            .contains(\"Only basic and api key auth are supported\"));\n    }\n\n    #[test]\n    fn apply_auth_sets_api_key_header() {\n        let transport = GrpcTransport::new();\n        let prov = GrpcProvider::new(\n            \"grpc\".to_string(),\n            \"localhost\".to_string(),\n            50051,\n            Some(AuthConfig::ApiKey(ApiKeyAuth {\n                auth_type: AuthType::ApiKey,\n                api_key: \"token\".to_string(),\n                var_name: \"x-api-key\".to_string(),\n                location: \"header\".to_string(),\n            })),\n        );\n\n        let mut request: Request<()> = Request::new(());\n        transport.apply_auth(&prov, &mut request).unwrap();\n        let header = request.metadata().get(\"x-api-key\").unwrap();\n        assert_eq!(header.to_str().unwrap(), \"token\");\n    }\n\n    #[derive(Default)]\n    struct MockGrpc;\n\n    #[tonic::async_trait]\n    impl UtcpService for MockGrpc {\n        async fn get_manual(\n            &self,\n            _request: Request<Empty>,\n        ) -> Result<tonic::Response<Manual>, tonic::Status> {\n            Ok(tonic::Response::new(Manual {\n                version: \"1.0\".to_string(),\n                tools: vec![GrpcTool {\n                    name: \"echo\".to_string(),\n                    description: \"echo tool\".to_string(),\n                }],\n            }))\n        }\n\n        async fn call_tool(\n            &self,\n            request: Request<ToolCallRequest>,\n        ) -> Result<tonic::Response<ToolCallResponse>, tonic::Status> {\n            let inner = request.into_inner();\n            let args_value: Value =\n                serde_json::from_str(&inner.args_json).unwrap_or_else(|_| Value::Null);\n            Ok(tonic::Response::new(ToolCallResponse {\n                result_json: json!({\n                    \"tool\": inner.tool,\n                    \"args\": args_value\n                })\n                .to_string(),\n            }))\n        }\n\n        type CallToolStreamStream = ReceiverStream<Result<ToolCallResponse, tonic::Status>>;\n\n        async fn call_tool_stream(\n            &self,\n            _request: Request<ToolCallRequest>,\n        ) -> Result<tonic::Response<Self::CallToolStreamStream>, tonic::Status> {\n            let (tx, rx) = tokio::sync::mpsc::channel(4);\n            tx.send(Ok(ToolCallResponse {\n                result_json: json!({ \"idx\": 1 }).to_string(),\n            }))\n            .await\n            .unwrap();\n            tx.send(Ok(ToolCallResponse {\n                result_json: json!({ \"idx\": 2 }).to_string(),\n            }))\n            .await\n            .unwrap();\n            Ok(tonic::Response::new(ReceiverStream::new(rx)))\n        }\n    }\n\n    #[tokio::test]\n    async fn register_call_and_stream_over_grpc() {\n        let listener = TcpListener::bind(\"127.0.0.1:0\").await.unwrap();\n        let addr = listener.local_addr().unwrap();\n        let incoming = TcpListenerStream::new(listener);\n        let (shutdown_tx, shutdown_rx) = tokio::sync::oneshot::channel();\n\n        tokio::spawn(async move {\n            Server::builder()\n                .add_service(UtcpServiceServer::new(MockGrpc::default()))\n                .serve_with_incoming_shutdown(incoming, async {\n                    let _ = shutdown_rx.await;\n                })\n                .await\n                .unwrap();\n        });\n\n        let prov = GrpcProvider {\n            base: BaseProvider {\n                name: \"grpc\".to_string(),\n                provider_type: ProviderType::Grpc,\n                auth: None,\n                allowed_communication_protocols: None,\n            },\n            host: addr.ip().to_string(),\n            port: addr.port(),\n            use_ssl: false,\n        };\n\n        let transport = GrpcTransport::new();\n\n        let tools = transport\n            .register_tool_provider(&prov)\n            .await\n            .expect(\"register\");\n        assert_eq!(tools.len(), 1);\n        assert_eq!(tools[0].name, \"echo\");\n\n        let mut args = HashMap::new();\n        args.insert(\"msg\".into(), Value::String(\"hi\".into()));\n        let call_value = transport\n            .call_tool(\"echo\", args.clone(), &prov)\n            .await\n            .expect(\"call\");\n        assert_eq!(call_value, json!({ \"tool\": \"echo\", \"args\": json!(args) }));\n\n        let mut stream = transport\n            .call_tool_stream(\"echo\", args, &prov)\n            .await\n            .expect(\"call stream\");\n        assert_eq!(stream.next().await.unwrap().unwrap(), json!({ \"idx\": 1 }));\n        assert_eq!(stream.next().await.unwrap().unwrap(), json!({ \"idx\": 2 }));\n        stream.close().await.unwrap();\n\n        let _ = shutdown_tx.send(());\n    }\n}\n",
      "line_count": 395,
      "word_count": 930,
      "title": "Mod.Rs",
      "summary": "// gRPC Transport - Protocol Buffers RPC use anyhow::{anyhow, Result};",
      "key_terms": [
        "close",
        "ClientTransport",
        "Result",
        "grpc",
        "UtcpServiceClient",
        "async",
        "localhost",
        "error",
        "token",
        "prov",
        "tx",
        "id",
        "ip",
        "format",
        "Utcp",
        "MockGrpc",
        "only",
        "idx",
        "ToolCallRequest",
        "providers"
      ],
      "timestamp": "2025-12-24T18:56:15.566684"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\transports\\http\\mod.rs",
      "content_type": "code",
      "content": "use anyhow::{anyhow, Result};\nuse async_trait::async_trait;\nuse reqwest::{header, Client};\nuse serde_json::Value;\nuse std::collections::HashMap;\nuse std::time::Duration;\n\nuse crate::auth::AuthConfig;\nuse crate::providers::base::Provider;\nuse crate::providers::http::HttpProvider;\nuse crate::security::{validate_size_limit, validate_url_security};\nuse crate::tools::Tool;\nuse crate::transports::{stream::StreamResult, ClientTransport};\n\nconst MAX_RESPONSE_SIZE: usize = 10 * 1024 * 1024; // 10 MB\n\n/// Transport for synchronous HTTP providers that expose JSON APIs.\npub struct HttpClientTransport {\n    pub client: Client,\n}\n\nimpl HttpClientTransport {\n    /// Build a new HTTP client transport with tuned defaults.\n    pub fn new() -> Self {\n        // Optimized HTTP client with connection pooling and compression\n        let client = Client::builder()\n            .timeout(Duration::from_secs(60)) // Increased timeout for better reliability\n            .pool_max_idle_per_host(100) // Connection pool optimization\n            .pool_idle_timeout(Some(Duration::from_secs(90))) // Keep connections alive longer\n            .tcp_keepalive(Some(Duration::from_secs(30))) // TCP keep-alive\n            .gzip(true) // Enable gzip compression\n            .http2_adaptive_window(true) // HTTP/2 flow control optimization\n            .http2_keep_alive_interval(Some(Duration::from_secs(10))) // HTTP/2 keep-alive\n            .http2_keep_alive_timeout(Duration::from_secs(20))\n            .http2_keep_alive_while_idle(true)\n            .build()\n            .expect(\"Failed to build HTTP client\");\n\n        Self { client }\n    }\n\n    /// Attach authentication headers or query params to the request builder.\n    fn apply_auth(\n        &self,\n        builder: reqwest::RequestBuilder,\n        auth: &AuthConfig,\n    ) -> Result<reqwest::RequestBuilder> {\n        match auth {\n            AuthConfig::ApiKey(api_key) => {\n                let location = api_key.location.to_ascii_lowercase();\n                match location.as_str() {\n                    \"header\" => Ok(builder.header(&api_key.var_name, &api_key.api_key)),\n                    \"query\" => {\n                        Ok(builder.query(&[(api_key.var_name.clone(), api_key.api_key.clone())]))\n                    }\n                    \"cookie\" => {\n                        let cookie_value = format!(\"{}={}\", api_key.var_name, api_key.api_key);\n                        Ok(builder.header(header::COOKIE, cookie_value))\n                    }\n                    other => Err(anyhow!(\"Unsupported API key location: {}\", other)),\n                }\n            }\n            AuthConfig::Basic(basic) => {\n                Ok(builder.basic_auth(&basic.username, Some(&basic.password)))\n            }\n            AuthConfig::OAuth2(_) => Err(anyhow!(\n                \"OAuth2 auth is not yet supported by the HTTP transport\"\n            )),\n        }\n    }\n}\n\n#[async_trait]\nimpl ClientTransport for HttpClientTransport {\n    async fn register_tool_provider(&self, prov: &dyn Provider) -> Result<Vec<Tool>> {\n        // Downcast to HttpProvider using as_any\n        let http_prov = prov\n            .as_any()\n            .downcast_ref::<HttpProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not an HttpProvider\"))?;\n\n        // Fetch tool definitions from the HTTP endpoint\n        // The endpoint should return a UTCP manifest or OpenAPI spec\n        validate_url_security(&http_prov.url, false)?;\n        let mut request_builder = self.client.get(&http_prov.url);\n\n        if let Some(headers) = &http_prov.headers {\n            for (key, value) in headers {\n                request_builder = request_builder.header(key, value);\n            }\n        }\n\n        if let Some(auth) = &http_prov.base.auth {\n            request_builder = self.apply_auth(request_builder, auth)?;\n        }\n\n        let response = request_builder.send().await?;\n\n        if !response.status().is_success() {\n            return Err(anyhow!(\n                \"Failed to fetch tools from {}: {}\",\n                http_prov.url,\n                response.status()\n            ));\n        }\n\n        // Try to parse as UTCP manifest first\n        let body_bytes = response.bytes().await?;\n        validate_size_limit(&body_bytes, MAX_RESPONSE_SIZE)?;\n\n        // Try parsing as JSON\n        if let Ok(manifest) = serde_json::from_slice::<Value>(&body_bytes) {\n            // Check if it's a UTCP manifest (has \"tools\" array)\n            if let Some(tools_array) = manifest.get(\"tools\").and_then(|v| v.as_array()) {\n                let mut tools = Vec::new();\n                for tool_value in tools_array {\n                    if let Ok(tool) = serde_json::from_value::<Tool>(tool_value.clone()) {\n                        tools.push(tool);\n                    }\n                }\n                return Ok(tools);\n            }\n        }\n\n        // If no tools found, return empty vec\n        // In a full implementation, we would also parse OpenAPI specs here\n        Ok(vec![])\n    }\n\n    async fn deregister_tool_provider(&self, _prov: &dyn Provider) -> Result<()> {\n        // HTTP transport is stateless, so nothing to do\n        Ok(())\n    }\n\n    async fn call_tool(\n        &self,\n        _tool_name: &str,\n        args: HashMap<String, Value>,\n        prov: &dyn Provider,\n    ) -> Result<Value> {\n        // Downcast to HttpProvider using as_any\n        let http_prov = prov\n            .as_any()\n            .downcast_ref::<HttpProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not an HttpProvider\"))?;\n\n        // Handle URL path parameters (e.g., {id} in URL)\n        let mut url = http_prov.url.clone();\n        for (key, value) in &args {\n            let placeholder = format!(\"{{{}}}\", key);\n            if url.contains(&placeholder) {\n                url = url.replace(&placeholder, &value.to_string());\n            }\n        }\n\n        validate_url_security(&url, false)?;\n\n        let method_upper = http_prov.http_method.to_uppercase();\n        let mut request_builder = match method_upper.as_str() {\n            \"GET\" => self.client.get(&url),\n            \"POST\" => self.client.post(&url),\n            \"PUT\" => self.client.put(&url),\n            \"DELETE\" => self.client.delete(&url),\n            \"PATCH\" => self.client.patch(&url),\n            method => return Err(anyhow!(\"Unsupported HTTP method: {}\", method)),\n        };\n\n        // Add headers\n        if let Some(headers) = &http_prov.headers {\n            for (key, value) in headers {\n                request_builder = request_builder.header(key, value);\n            }\n        }\n\n        if let Some(auth) = &http_prov.base.auth {\n            request_builder = self.apply_auth(request_builder, auth)?;\n        }\n\n        // Determine how to send remaining args\n        if method_upper == \"POST\" || method_upper == \"PUT\" || method_upper == \"PATCH\" {\n            // Send as JSON body\n            request_builder = request_builder.json(&args);\n        } else {\n            // Send as query parameters\n            for (key, value) in &args {\n                request_builder = request_builder.query(&[(key, value.to_string())]);\n            }\n        }\n\n        // Send request\n        let response = request_builder.send().await?;\n\n        if !response.status().is_success() {\n            return Err(anyhow!(\n                \"HTTP request failed with status: {}\",\n                response.status()\n            ));\n        }\n\n        let body_bytes = response.bytes().await?;\n        validate_size_limit(&body_bytes, MAX_RESPONSE_SIZE)?;\n        let result: Value = serde_json::from_slice(&body_bytes)?;\n        Ok(result)\n    }\n\n    async fn call_tool_stream(\n        &self,\n        _tool_name: &str,\n        _args: HashMap<String, Value>,\n        _prov: &dyn Provider,\n    ) -> Result<Box<dyn StreamResult>> {\n        Err(anyhow!(\"Streaming not supported by HttpClientTransport\"))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::auth::{ApiKeyAuth, AuthType, BasicAuth, OAuth2Auth};\n    use crate::providers::base::{BaseProvider, ProviderType};\n    use crate::providers::http::HttpProvider;\n    use axum::{extract::Json, routing::get, routing::post, Router};\n    use serde_json::json;\n    use std::net::TcpListener;\n\n    #[test]\n    fn apply_auth_handles_api_key_locations() {\n        let transport = HttpClientTransport::new();\n\n        // Header location\n        let header_auth = AuthConfig::ApiKey(ApiKeyAuth {\n            auth_type: AuthType::ApiKey,\n            api_key: \"secret\".to_string(),\n            var_name: \"X-Key\".to_string(),\n            location: \"header\".to_string(),\n        });\n        let request = transport\n            .apply_auth(\n                reqwest::Client::new().get(\"http://example.com\"),\n                &header_auth,\n            )\n            .unwrap()\n            .build()\n            .unwrap();\n        assert_eq!(request.headers().get(\"X-Key\").unwrap(), \"secret\");\n\n        // Query location\n        let query_auth = AuthConfig::ApiKey(ApiKeyAuth {\n            auth_type: AuthType::ApiKey,\n            api_key: \"secret\".to_string(),\n            var_name: \"key\".to_string(),\n            location: \"query\".to_string(),\n        });\n        let request = transport\n            .apply_auth(\n                reqwest::Client::new().get(\"http://example.com\"),\n                &query_auth,\n            )\n            .unwrap()\n            .build()\n            .unwrap();\n        assert_eq!(request.url().query(), Some(\"key=secret\"));\n\n        // Cookie location\n        let cookie_auth = AuthConfig::ApiKey(ApiKeyAuth {\n            auth_type: AuthType::ApiKey,\n            api_key: \"cookie-secret\".to_string(),\n            var_name: \"session\".to_string(),\n            location: \"cookie\".to_string(),\n        });\n        let request = transport\n            .apply_auth(\n                reqwest::Client::new().get(\"http://example.com\"),\n                &cookie_auth,\n            )\n            .unwrap()\n            .build()\n            .unwrap();\n        assert_eq!(\n            request.headers().get(header::COOKIE).unwrap(),\n            \"session=cookie-secret\"\n        );\n    }\n\n    #[test]\n    fn apply_auth_sets_basic_auth_header() {\n        let transport = HttpClientTransport::new();\n        let auth = AuthConfig::Basic(BasicAuth {\n            auth_type: AuthType::Basic,\n            username: \"user\".to_string(),\n            password: \"pass\".to_string(),\n        });\n\n        let request = transport\n            .apply_auth(reqwest::Client::new().get(\"http://example.com\"), &auth)\n            .unwrap()\n            .build()\n            .unwrap();\n\n        assert_eq!(\n            request.headers().get(header::AUTHORIZATION).unwrap(),\n            \"Basic dXNlcjpwYXNz\"\n        );\n    }\n\n    #[test]\n    fn apply_auth_rejects_unsupported_oauth2() {\n        let transport = HttpClientTransport::new();\n        let auth = AuthConfig::OAuth2(OAuth2Auth {\n            auth_type: AuthType::OAuth2,\n            token_url: \"https://auth.example.com/token\".to_string(),\n            client_id: \"client\".to_string(),\n            client_secret: \"secret\".to_string(),\n            scope: None,\n        });\n\n        let err = transport\n            .apply_auth(reqwest::Client::new().get(\"http://example.com\"), &auth)\n            .unwrap_err();\n        assert!(err.to_string().contains(\"OAuth2 auth is not yet supported\"));\n    }\n\n    #[tokio::test]\n    async fn register_call_and_stream_error_http_transport() {\n        async fn manifest_handler() -> Json<Value> {\n            Json(json!({\n                \"tools\": [{\n                    \"name\": \"greet\",\n                    \"description\": \"says hello\",\n                    \"inputs\": { \"type\": \"object\" },\n                    \"outputs\": { \"type\": \"object\" },\n                    \"tags\": []\n                }]\n            }))\n        }\n\n        async fn call_handler(Json(payload): Json<Value>) -> Json<Value> {\n            Json(json!({ \"echo\": payload }))\n        }\n\n        let app = Router::new()\n            .route(\"/\", get(manifest_handler))\n            .route(\"/\", post(call_handler));\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n        tokio::spawn(async move {\n            axum::Server::from_tcp(listener)\n                .unwrap()\n                .serve(app.into_make_service())\n                .await\n                .unwrap();\n        });\n\n        let base_url = format!(\"http://{}\", addr);\n        let provider = HttpProvider {\n            base: BaseProvider {\n                name: \"http\".to_string(),\n                provider_type: ProviderType::Http,\n                auth: None,\n                allowed_communication_protocols: None,\n            },\n            http_method: \"POST\".to_string(),\n            url: base_url.clone(),\n            content_type: None,\n            headers: None,\n            body_field: None,\n            header_fields: None,\n        };\n\n        let transport = HttpClientTransport::new();\n        let tools = transport\n            .register_tool_provider(&provider)\n            .await\n            .expect(\"register tools\");\n        assert_eq!(tools.len(), 1);\n        assert_eq!(tools[0].name, \"greet\");\n\n        let mut args = HashMap::new();\n        args.insert(\"name\".into(), Value::String(\"http\".into()));\n        let result = transport\n            .call_tool(\"ignored\", args.clone(), &provider)\n            .await\n            .expect(\"call tool\");\n        assert_eq!(result, json!({ \"echo\": json!(args) }));\n\n        let err = transport\n            .call_tool_stream(\"greet\", args, &provider)\n            .await\n            .err()\n            .expect(\"expected streaming error\");\n        assert!(err.to_string().contains(\"Streaming not supported\"));\n    }\n}\n",
      "line_count": 394,
      "word_count": 1048,
      "title": "Mod.Rs",
      "summary": "use anyhow::{anyhow, Result}; use async_trait::async_trait;",
      "key_terms": [
        "build",
        "ClientTransport",
        "Result",
        "const",
        "we",
        "extract",
        "async",
        "headers",
        "error",
        "If",
        "Optimized",
        "Cookie",
        "token",
        "prov",
        "id",
        "Duration",
        "cookie",
        "format",
        "Json",
        "Unsupported"
      ],
      "timestamp": "2025-12-24T18:56:15.603216"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\transports\\http_stream\\mod.rs",
      "content_type": "code",
      "content": "// Streamable HTTP Transport (for chunked/streaming HTTP responses)\nuse anyhow::{anyhow, Result};\nuse async_trait::async_trait;\nuse futures::StreamExt;\nuse reqwest::{header, Client};\nuse serde_json::{de::Deserializer, Value};\nuse std::collections::HashMap;\nuse tokio::sync::mpsc;\n\nuse crate::auth::AuthConfig;\nuse crate::providers::base::Provider;\nuse crate::providers::http_stream::StreamableHttpProvider;\nuse crate::tools::Tool;\nuse crate::transports::{\n    stream::{boxed_channel_stream, StreamResult},\n    ClientTransport,\n};\n\n/// Transport for HTTP endpoints that stream newline-delimited JSON or chunked bodies.\npub struct StreamableHttpTransport {\n    client: Client,\n}\n\nimpl StreamableHttpTransport {\n    /// Create a streaming HTTP transport with a default client.\n    pub fn new() -> Self {\n        Self {\n            client: Client::new(),\n        }\n    }\n\n    /// Attach authentication headers or query params to the request builder.\n    fn apply_auth(\n        &self,\n        builder: reqwest::RequestBuilder,\n        auth: &AuthConfig,\n    ) -> Result<reqwest::RequestBuilder> {\n        match auth {\n            AuthConfig::ApiKey(api_key) => {\n                let location = api_key.location.to_ascii_lowercase();\n                match location.as_str() {\n                    \"header\" => Ok(builder.header(&api_key.var_name, &api_key.api_key)),\n                    \"query\" => {\n                        Ok(builder.query(&[(api_key.var_name.clone(), api_key.api_key.clone())]))\n                    }\n                    \"cookie\" => {\n                        let cookie_value = format!(\"{}={}\", api_key.var_name, api_key.api_key);\n                        Ok(builder.header(header::COOKIE, cookie_value))\n                    }\n                    other => Err(anyhow!(\"Unsupported API key location: {}\", other)),\n                }\n            }\n            AuthConfig::Basic(basic) => {\n                Ok(builder.basic_auth(&basic.username, Some(&basic.password)))\n            }\n            AuthConfig::OAuth2(_) => Err(anyhow!(\n                \"OAuth2 auth is not yet supported by the HTTP stream transport\"\n            )),\n        }\n    }\n}\n\n#[async_trait]\nimpl ClientTransport for StreamableHttpTransport {\n    async fn register_tool_provider(&self, _prov: &dyn Provider) -> Result<Vec<Tool>> {\n        // Streamable HTTP often shares the same discovery endpoint as HTTP providers.\n        Ok(vec![])\n    }\n\n    async fn deregister_tool_provider(&self, _prov: &dyn Provider) -> Result<()> {\n        Ok(())\n    }\n\n    async fn call_tool(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, Value>,\n        prov: &dyn Provider,\n    ) -> Result<Value> {\n        // Fallback: perform a standard request and aggregate the full response.\n        let http_prov = prov\n            .as_any()\n            .downcast_ref::<StreamableHttpProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not a StreamableHttpProvider\"))?;\n\n        let call_name = tool_name\n            .strip_prefix(&format!(\"{}.\", http_prov.base.name))\n            .unwrap_or(tool_name);\n        let url = format!(\"{}/{}\", http_prov.url.trim_end_matches('/'), call_name);\n        let method_upper = http_prov.http_method.to_uppercase();\n        let mut request_builder = match method_upper.as_str() {\n            \"GET\" => self.client.get(&url).query(&args),\n            \"POST\" => self.client.post(&url).json(&args),\n            \"PUT\" => self.client.put(&url).json(&args),\n            \"DELETE\" => self.client.delete(&url).json(&args),\n            \"PATCH\" => self.client.patch(&url).json(&args),\n            other => return Err(anyhow!(\"Unsupported HTTP method: {}\", other)),\n        };\n\n        if let Some(headers) = &http_prov.headers {\n            for (k, v) in headers {\n                request_builder = request_builder.header(k, v);\n            }\n        }\n\n        if let Some(auth) = &http_prov.base.auth {\n            request_builder = self.apply_auth(request_builder, auth)?;\n        }\n\n        let response = request_builder.send().await?;\n\n        if !response.status().is_success() {\n            return Err(anyhow!(\n                \"HTTP request failed with status: {}\",\n                response.status()\n            ));\n        }\n\n        let value: Value = response.json().await?;\n        Ok(value)\n    }\n\n    async fn call_tool_stream(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, Value>,\n        prov: &dyn Provider,\n    ) -> Result<Box<dyn StreamResult>> {\n        let http_prov = prov\n            .as_any()\n            .downcast_ref::<StreamableHttpProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not a StreamableHttpProvider\"))?;\n\n        let call_name = tool_name\n            .strip_prefix(&format!(\"{}.\", http_prov.base.name))\n            .unwrap_or(tool_name);\n        let url = format!(\"{}/{}\", http_prov.url.trim_end_matches('/'), call_name);\n        let method_upper = http_prov.http_method.to_uppercase();\n        let mut req = match method_upper.as_str() {\n            \"GET\" => self.client.get(url).query(&args),\n            \"POST\" => self.client.post(url).json(&args),\n            \"PUT\" => self.client.put(url).json(&args),\n            \"DELETE\" => self.client.delete(url).json(&args),\n            \"PATCH\" => self.client.patch(url).json(&args),\n            other => return Err(anyhow!(\"Unsupported HTTP method: {}\", other)),\n        };\n\n        if let Some(headers) = &http_prov.headers {\n            for (k, v) in headers {\n                req = req.header(k, v);\n            }\n        }\n\n        if let Some(auth) = &http_prov.base.auth {\n            req = self.apply_auth(req, auth)?;\n        }\n\n        let response = req.send().await?;\n\n        if !response.status().is_success() {\n            return Err(anyhow!(\n                \"HTTP request failed with status: {}\",\n                response.status()\n            ));\n        }\n\n        // Stream response chunks and parse them as JSON values.\n        let mut byte_stream = response.bytes_stream();\n        let (tx, rx) = mpsc::channel(16);\n\n        tokio::spawn(async move {\n            let mut buffer: Vec<u8> = Vec::new();\n            while let Some(chunk_result) = byte_stream.next().await {\n                match chunk_result {\n                    Ok(bytes) => {\n                        buffer.extend_from_slice(&bytes);\n                        let deserializer = Deserializer::from_slice(&buffer);\n                        let mut stream = deserializer.into_iter::<Value>();\n                        let mut offset = 0usize;\n\n                        loop {\n                            match stream.next() {\n                                Some(Ok(value)) => {\n                                    offset = stream.byte_offset();\n                                    if tx.send(Ok(value)).await.is_err() {\n                                        return;\n                                    }\n                                }\n                                Some(Err(e)) => {\n                                    if e.is_eof() {\n                                        break;\n                                    }\n                                    let _ = tx\n                                        .send(Err(anyhow!(\n                                            \"Failed to parse JSON from stream: {}\",\n                                            e\n                                        )))\n                                        .await;\n                                    return;\n                                }\n                                None => break,\n                            }\n                        }\n\n                        if offset > 0 && offset <= buffer.len() {\n                            buffer.drain(0..offset);\n                        }\n                    }\n                    Err(err) => {\n                        let _ = tx\n                            .send(Err(anyhow!(\"Error reading bytes from stream: {}\", err)))\n                            .await;\n                        return;\n                    }\n                }\n            }\n\n            if !buffer.is_empty() {\n                let _ = tx\n                    .send(Err(anyhow!(\"Stream ended with incomplete JSON frame\")))\n                    .await;\n            }\n        });\n\n        Ok(boxed_channel_stream(rx, None))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::auth::{ApiKeyAuth, AuthType, BasicAuth, OAuth2Auth};\n    use crate::providers::base::{BaseProvider, ProviderType};\n    use crate::providers::http_stream::StreamableHttpProvider;\n    use axum::{body::Body, extract::Json, http::Response, routing::post, Router};\n    use bytes::Bytes;\n    use serde_json::json;\n    use std::net::TcpListener;\n\n    #[test]\n    fn apply_auth_sets_expected_headers_and_query() {\n        let transport = StreamableHttpTransport::new();\n\n        let header_auth = AuthConfig::ApiKey(ApiKeyAuth {\n            auth_type: AuthType::ApiKey,\n            api_key: \"secret\".to_string(),\n            var_name: \"X-Stream-Key\".to_string(),\n            location: \"header\".to_string(),\n        });\n        let request = transport\n            .apply_auth(\n                reqwest::Client::new().get(\"http://example.com\"),\n                &header_auth,\n            )\n            .unwrap()\n            .build()\n            .unwrap();\n        assert_eq!(request.headers().get(\"X-Stream-Key\").unwrap(), \"secret\");\n\n        let query_auth = AuthConfig::ApiKey(ApiKeyAuth {\n            auth_type: AuthType::ApiKey,\n            api_key: \"abc\".to_string(),\n            var_name: \"token\".to_string(),\n            location: \"query\".to_string(),\n        });\n        let request = transport\n            .apply_auth(\n                reqwest::Client::new().get(\"http://example.com\"),\n                &query_auth,\n            )\n            .unwrap()\n            .build()\n            .unwrap();\n        assert_eq!(request.url().query(), Some(\"token=abc\"));\n\n        let basic_auth = AuthConfig::Basic(BasicAuth {\n            auth_type: AuthType::Basic,\n            username: \"user\".to_string(),\n            password: \"pass\".to_string(),\n        });\n        let request = transport\n            .apply_auth(\n                reqwest::Client::new().get(\"http://example.com\"),\n                &basic_auth,\n            )\n            .unwrap()\n            .build()\n            .unwrap();\n        assert_eq!(\n            request.headers().get(header::AUTHORIZATION).unwrap(),\n            \"Basic dXNlcjpwYXNz\"\n        );\n    }\n\n    #[test]\n    fn apply_auth_rejects_oauth2() {\n        let transport = StreamableHttpTransport::new();\n        let auth = AuthConfig::OAuth2(OAuth2Auth {\n            auth_type: AuthType::OAuth2,\n            token_url: \"https://auth.example.com/token\".to_string(),\n            client_id: \"client\".to_string(),\n            client_secret: \"secret\".to_string(),\n            scope: None,\n        });\n\n        let err = transport\n            .apply_auth(reqwest::Client::new().get(\"http://example.com\"), &auth)\n            .unwrap_err();\n        assert!(err.to_string().contains(\"OAuth2 auth is not yet supported\"));\n    }\n\n    #[tokio::test]\n    async fn register_call_and_stream_http_stream_transport() {\n        async fn aggregate(Json(payload): Json<Value>) -> Json<Value> {\n            Json(json!({ \"received\": payload }))\n        }\n\n        async fn stream(Json(_payload): Json<Value>) -> Response<Body> {\n            let chunks: Vec<Result<Bytes, std::convert::Infallible>> = vec![\n                Ok(Bytes::from_static(br#\"{\"chunk\":\"#)),\n                Ok(Bytes::from_static(br#\"1}\"#)),\n                Ok(Bytes::from_static(b\"\\n{\\\"chunk\\\":2}\")),\n            ];\n            Response::builder()\n                .header(\"content-type\", \"application/json\")\n                .body(Body::wrap_stream(tokio_stream::iter(chunks)))\n                .unwrap()\n        }\n\n        let app = Router::new()\n            .route(\"/aggregate\", post(aggregate))\n            .route(\"/stream\", post(stream));\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n        tokio::spawn(async move {\n            axum::Server::from_tcp(listener)\n                .unwrap()\n                .serve(app.into_make_service())\n                .await\n                .unwrap();\n        });\n\n        let base_url = format!(\"http://{}\", addr);\n        let provider = StreamableHttpProvider {\n            base: BaseProvider {\n                name: \"http-stream\".to_string(),\n                provider_type: ProviderType::HttpStream,\n                auth: None,\n                allowed_communication_protocols: None,\n            },\n            url: base_url.clone(),\n            http_method: \"POST\".to_string(),\n            headers: None,\n        };\n\n        let transport = StreamableHttpTransport::new();\n        let tools = transport\n            .register_tool_provider(&provider)\n            .await\n            .expect(\"register\");\n        assert!(tools.is_empty());\n\n        let mut args = HashMap::new();\n        args.insert(\"payload\".into(), Value::String(\"data\".into()));\n\n        let aggregate_value = transport\n            .call_tool(\"aggregate\", args.clone(), &provider)\n            .await\n            .expect(\"call tool\");\n        assert_eq!(aggregate_value, json!({ \"received\": json!(args) }));\n\n        let mut stream = transport\n            .call_tool_stream(\"stream\", args, &provider)\n            .await\n            .expect(\"call tool stream\");\n        let mut items = Vec::new();\n        while let Some(item) = stream.next().await.unwrap() {\n            items.push(item);\n            if items.len() == 2 {\n                break;\n            }\n        }\n        stream.close().await.unwrap();\n\n        assert_eq!(items, vec![json!({\"chunk\": 1}), json!({\"chunk\": 2})]);\n    }\n\n    #[tokio::test]\n    async fn http_stream_strips_provider_prefix() {\n        async fn echo(Json(_payload): Json<Value>) -> Json<Value> {\n            Json(json!({\"ok\": true}))\n        }\n\n        let app = Router::new().route(\"/echo\", post(echo));\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n        tokio::spawn(async move {\n            axum::Server::from_tcp(listener)\n                .unwrap()\n                .serve(app.into_make_service())\n                .await\n                .unwrap();\n        });\n\n        let base_url = format!(\"http://{}\", addr);\n        let provider = StreamableHttpProvider {\n            base: BaseProvider {\n                name: \"http-stream\".to_string(),\n                provider_type: ProviderType::HttpStream,\n                auth: None,\n                allowed_communication_protocols: None,\n            },\n            url: base_url.clone(),\n            http_method: \"POST\".to_string(),\n            headers: None,\n        };\n\n        let transport = StreamableHttpTransport::new();\n        let value = transport\n            .call_tool(\"http-stream.echo\", HashMap::new(), &provider)\n            .await\n            .expect(\"call tool\");\n        assert_eq!(value, json!({\"ok\": true}));\n    }\n}\n",
      "line_count": 426,
      "word_count": 1042,
      "title": "Mod.Rs",
      "summary": "// Streamable HTTP Transport (for chunked/streaming HTTP responses) use anyhow::{anyhow, Result};",
      "key_terms": [
        "reading",
        "build",
        "ClientTransport",
        "Result",
        "Fallback",
        "futures",
        "extract",
        "async",
        "close",
        "headers",
        "convert",
        "abc",
        "token",
        "prov",
        "tx",
        "Json",
        "cookie",
        "format",
        "same",
        "Unsupported"
      ],
      "timestamp": "2025-12-24T18:56:15.669804"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\transports\\mcp\\mod.rs",
      "content_type": "code",
      "content": "// MCP (Model Context Protocol) Transport\nuse anyhow::{anyhow, Result};\nuse async_trait::async_trait;\nuse reqwest::{header, Client};\nuse serde_json::Value;\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};\nuse tokio::process::{Child, ChildStdin, ChildStdout, Command};\nuse tokio::sync::Mutex;\n\nuse crate::auth::AuthConfig;\nuse crate::providers::base::Provider;\nuse crate::providers::mcp::McpProvider;\nuse crate::security::{validate_size_limit, validate_url_security};\nuse crate::tools::Tool;\nuse crate::transports::{stream::StreamResult, ClientTransport};\n\nconst MAX_RESPONSE_SIZE: usize = 10 * 1024 * 1024; // 10 MB\n\n// Stdio process wrapper for MCP transport\nstruct McpStdioProcess {\n    #[allow(dead_code)] // Needed to keep the process alive\n    child: Child,\n    stdin: Arc<Mutex<ChildStdin>>,\n    stdout: Arc<Mutex<BufReader<ChildStdout>>>,\n    request_id: Arc<Mutex<u64>>,\n}\n\nimpl McpStdioProcess {\n    async fn new(\n        command: &str,\n        args: &Option<Vec<String>>,\n        env_vars: &Option<HashMap<String, String>>,\n    ) -> Result<Self> {\n        // Security: Validate command to prevent injection attacks\n        // Allow empty allowlist for flexibility (allows all commands), but validation still checks for dangerous chars.\n        // TODO: Make allowlist configurable via McpProvider or global config.\n        crate::security::validate_command(command, &[])?;\n\n        // Security: Validate arguments\n        if let Some(args_vec) = args {\n            crate::security::validate_command_args(args_vec)?;\n        }\n\n        let mut cmd = Command::new(command);\n\n        if let Some(args_vec) = args {\n            cmd.args(args_vec);\n        }\n\n        if let Some(env) = env_vars {\n            for (k, v) in env {\n                cmd.env(k, v);\n            }\n        }\n\n        cmd.stdin(std::process::Stdio::piped());\n        cmd.stdout(std::process::Stdio::piped());\n        cmd.stderr(std::process::Stdio::piped());\n\n        let mut child = cmd.spawn()?;\n\n        let stdin = child\n            .stdin\n            .take()\n            .ok_or_else(|| anyhow!(\"Failed to get stdin\"))?;\n        let stdout = child\n            .stdout\n            .take()\n            .ok_or_else(|| anyhow!(\"Failed to get stdout\"))?;\n\n        // Use larger buffers for better I/O performance (64KB)\n        let buf_reader = BufReader::with_capacity(65536, stdout);\n\n        Ok(Self {\n            child,\n            stdin: Arc::new(Mutex::new(stdin)),\n            stdout: Arc::new(Mutex::new(buf_reader)),\n            request_id: Arc::new(Mutex::new(1)),\n        })\n    }\n\n    async fn send_request(&self, method: &str, params: Value) -> Result<Value> {\n        let mut id_guard = self.request_id.lock().await;\n        let id = *id_guard;\n        *id_guard += 1;\n        drop(id_guard);\n\n        let request = serde_json::json!({\n            \"jsonrpc\": \"2.0\",\n            \"method\": method,\n            \"params\": params,\n            \"id\": id,\n        });\n\n        let request_str = serde_json::to_string(&request)?;\n\n        // Write request to stdin\n        let mut stdin = self.stdin.lock().await;\n        stdin.write_all(request_str.as_bytes()).await?;\n        stdin.write_all(b\"\\n\").await?;\n        stdin.flush().await?;\n        drop(stdin);\n\n        // Read response from stdout\n        let mut stdout = self.stdout.lock().await;\n        let mut line = String::new();\n        stdout.read_line(&mut line).await?;\n        drop(stdout);\n\n        if line.is_empty() {\n            return Err(anyhow!(\"MCP process closed connection\"));\n        }\n\n        validate_size_limit(line.as_bytes(), MAX_RESPONSE_SIZE)?;\n\n        let response: Value = serde_json::from_str(&line)?;\n\n        // Check for JSON-RPC error\n        if let Some(error) = response.get(\"error\") {\n            return Err(anyhow!(\"MCP error: {}\", error));\n        }\n\n        response\n            .get(\"result\")\n            .cloned()\n            .ok_or_else(|| anyhow!(\"No result in MCP response\"))\n    }\n}\n\n/// Transport for MCP providers over HTTP or stdio.\npub struct McpTransport {\n    client: Client,\n    // Map of provider name to stdio process\n    stdio_processes: Arc<Mutex<HashMap<String, Arc<McpStdioProcess>>>>,\n}\n\nimpl McpTransport {\n    /// Create an MCP transport with a tuned reqwest client.\n    pub fn new() -> Self {\n        // Optimized HTTP client for MCP transport\n        let client = Client::builder()\n            .timeout(std::time::Duration::from_secs(120)) // Longer timeout for MCP operations\n            .pool_max_idle_per_host(50) // Connection pool for MCP servers\n            .pool_idle_timeout(Some(std::time::Duration::from_secs(90)))\n            .tcp_keepalive(Some(std::time::Duration::from_secs(30)))\n            .gzip(true) // Enable compression\n            .http2_adaptive_window(true)\n            .build()\n            .expect(\"Failed to build MCP HTTP client\");\n\n        Self {\n            client,\n            stdio_processes: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n\n    fn apply_auth(\n        &self,\n        builder: reqwest::RequestBuilder,\n        auth: &AuthConfig,\n    ) -> Result<reqwest::RequestBuilder> {\n        match auth {\n            AuthConfig::ApiKey(api_key) => {\n                let location = api_key.location.to_ascii_lowercase();\n                match location.as_str() {\n                    \"header\" => Ok(builder.header(&api_key.var_name, &api_key.api_key)),\n                    \"query\" => {\n                        Ok(builder.query(&[(api_key.var_name.clone(), api_key.api_key.clone())]))\n                    }\n                    \"cookie\" => {\n                        let cookie_value = format!(\"{}={}\", api_key.var_name, api_key.api_key);\n                        Ok(builder.header(header::COOKIE, cookie_value))\n                    }\n                    other => Err(anyhow!(\"Unsupported API key location: {}\", other)),\n                }\n            }\n            AuthConfig::Basic(basic) => {\n                Ok(builder.basic_auth(&basic.username, Some(&basic.password)))\n            }\n            AuthConfig::OAuth2(_) => Err(anyhow!(\n                \"OAuth2 auth is not yet supported by the MCP transport\"\n            )),\n        }\n    }\n\n    async fn mcp_http_request(\n        &self,\n        prov: &McpProvider,\n        method: &str,\n        params: Value,\n    ) -> Result<Value> {\n        let url = prov\n            .url\n            .as_ref()\n            .ok_or_else(|| anyhow!(\"No URL provided for HTTP MCP provider\"))?;\n\n        validate_url_security(url, false)?;\n\n        let request = serde_json::json!({\n            \"jsonrpc\": \"2.0\",\n            \"method\": method,\n            \"params\": params,\n            \"id\": 1,\n        });\n\n        let mut req = self.client.post(url).json(&request);\n        if let Some(headers) = &prov.headers {\n            for (k, v) in headers {\n                req = req.header(k, v);\n            }\n        }\n        if let Some(auth) = &prov.base.auth {\n            req = self.apply_auth(req, auth)?;\n        }\n\n        let response = req.send().await?;\n\n        if !response.status().is_success() {\n            return Err(anyhow!(\"MCP request failed: {}\", response.status()));\n        }\n\n        let body_bytes = response.bytes().await?;\n        validate_size_limit(&body_bytes, MAX_RESPONSE_SIZE)?;\n        let result: Value = serde_json::from_slice(&body_bytes)?;\n\n        // Check for JSON-RPC error\n        if let Some(error) = result.get(\"error\") {\n            return Err(anyhow!(\"MCP error: {}\", error));\n        }\n\n        result\n            .get(\"result\")\n            .cloned()\n            .ok_or_else(|| anyhow!(\"No result in MCP response\"))\n    }\n\n    async fn get_or_create_stdio_process(\n        &self,\n        prov: &McpProvider,\n    ) -> Result<Arc<McpStdioProcess>> {\n        let mut processes = self.stdio_processes.lock().await;\n\n        if let Some(process) = processes.get(&prov.base.name) {\n            return Ok(Arc::clone(process));\n        }\n\n        let command = prov\n            .command\n            .as_ref()\n            .ok_or_else(|| anyhow!(\"No command provided for stdio MCP provider\"))?;\n\n        let process = Arc::new(McpStdioProcess::new(command, &prov.args, &prov.env_vars).await?);\n        processes.insert(prov.base.name.clone(), Arc::clone(&process));\n\n        Ok(process)\n    }\n\n    async fn mcp_request(&self, prov: &McpProvider, method: &str, params: Value) -> Result<Value> {\n        if prov.is_http() {\n            self.mcp_http_request(prov, method, params).await\n        } else if prov.is_stdio() {\n            let process = self.get_or_create_stdio_process(prov).await?;\n            process.send_request(method, params).await\n        } else {\n            Err(anyhow!(\n                \"MCP provider must have either 'url' (HTTP) or 'command' (stdio)\"\n            ))\n        }\n    }\n\n    async fn mcp_http_stream(\n        &self,\n        prov: &McpProvider,\n        params: Value,\n    ) -> Result<Box<dyn StreamResult>> {\n        use eventsource_stream::Eventsource;\n        use futures::StreamExt;\n\n        let url = prov\n            .url\n            .as_ref()\n            .ok_or_else(|| anyhow!(\"No URL provided for HTTP MCP provider\"))?;\n\n        validate_url_security(url, false)?;\n\n        let request = serde_json::json!({\n            \"jsonrpc\": \"2.0\",\n            \"method\": \"tools/call\",\n            \"params\": params,\n            \"id\": 1,\n        });\n\n        let mut req = self.client.post(url).json(&request);\n\n        // Add headers\n        if let Some(headers) = &prov.headers {\n            for (k, v) in headers {\n                req = req.header(k, v);\n            }\n        }\n\n        // Add authentication\n        if let Some(auth) = &prov.base.auth {\n            req = self.apply_auth(req, auth)?;\n        }\n\n        // Set Accept header for SSE\n        req = req.header(\"Accept\", \"text/event-stream\");\n\n        let response = req.send().await?;\n\n        if !response.status().is_success() {\n            return Err(anyhow!(\"MCP stream request failed: {}\", response.status()));\n        }\n\n        // Create a channel to stream results\n        // Create a channel to stream results with larger buffer\n        let (tx, rx) = tokio::sync::mpsc::channel(256);\n\n        // Spawn a task to read SSE events\n        tokio::spawn(async move {\n            let byte_stream = response.bytes_stream();\n            let mut event_stream = byte_stream.eventsource();\n\n            while let Some(event_result) = event_stream.next().await {\n                match event_result {\n                    Ok(event) => {\n                        // Parse the event data as JSON\n                        match serde_json::from_str::<Value>(&event.data) {\n                            Ok(value) => {\n                                if tx.send(Ok(value)).await.is_err() {\n                                    break; // Receiver dropped\n                                }\n                            }\n                            Err(e) => {\n                                let _ = tx\n                                    .send(Err(anyhow!(\"Failed to parse SSE event: {}\", e)))\n                                    .await;\n                                break;\n                            }\n                        }\n                    }\n                    Err(e) => {\n                        let _ = tx.send(Err(anyhow!(\"SSE stream error: {}\", e))).await;\n                        break;\n                    }\n                }\n            }\n        });\n\n        Ok(crate::transports::stream::boxed_channel_stream(rx, None))\n    }\n\n    async fn mcp_stdio_stream(\n        &self,\n        prov: &McpProvider,\n        params: Value,\n    ) -> Result<Box<dyn StreamResult>> {\n        let process = self.get_or_create_stdio_process(prov).await?;\n\n        // Generate request ID\n        let mut id_guard = process.request_id.lock().await;\n        let id = *id_guard;\n        *id_guard += 1;\n        drop(id_guard);\n\n        let request = serde_json::json!({\n            \"jsonrpc\": \"2.0\",\n            \"method\": \"tools/call\",\n            \"params\": params,\n            \"id\": id,\n        });\n\n        let request_str = serde_json::to_string(&request)?;\n\n        // Write request to stdin\n        let mut stdin = process.stdin.lock().await;\n        stdin.write_all(request_str.as_bytes()).await?;\n        stdin.write_all(b\"\\n\").await?;\n        stdin.flush().await?;\n        drop(stdin);\n\n        // Create a channel to stream results\n        // Create a channel to stream results with larger buffer\n        let (tx, rx) = tokio::sync::mpsc::channel(256);\n\n        // Clone Arc for the task\n        let stdout = Arc::clone(&process.stdout);\n\n        // Spawn a task to read streaming responses\n        tokio::spawn(async move {\n            let mut stdout_guard = stdout.lock().await;\n\n            loop {\n                let mut line = String::new();\n                match stdout_guard.read_line(&mut line).await {\n                    Ok(0) => break, // EOF\n                    Ok(_) => {\n                        if line.trim().is_empty() {\n                            continue;\n                        }\n\n                        // Parse the JSON-RPC response\n                        match serde_json::from_str::<Value>(&line) {\n                            Ok(response) => {\n                                // Check if this is an error response\n                                if let Some(error) = response.get(\"error\") {\n                                    let _ = tx.send(Err(anyhow!(\"MCP error: {}\", error))).await;\n                                    break;\n                                }\n\n                                // Check if this is the final result or a stream chunk\n                                if let Some(result) = response.get(\"result\") {\n                                    // Send the result\n                                    if tx.send(Ok(result.clone())).await.is_err() {\n                                        break; // Receiver dropped\n                                    }\n\n                                    // Check if this is marked as the final response\n                                    if response\n                                        .get(\"final\")\n                                        .and_then(|v| v.as_bool())\n                                        .unwrap_or(false)\n                                    {\n                                        break;\n                                    }\n                                }\n                            }\n                            Err(e) => {\n                                let _ = tx\n                                    .send(Err(anyhow!(\"Failed to parse response: {}\", e)))\n                                    .await;\n                                break;\n                            }\n                        }\n                    }\n                    Err(e) => {\n                        let _ = tx\n                            .send(Err(anyhow!(\"Failed to read from stdout: {}\", e)))\n                            .await;\n                        break;\n                    }\n                }\n            }\n        });\n\n        Ok(crate::transports::stream::boxed_channel_stream(rx, None))\n    }\n}\n\n#[async_trait]\nimpl ClientTransport for McpTransport {\n    async fn register_tool_provider(&self, _prov: &dyn Provider) -> Result<Vec<Tool>> {\n        let mcp_prov = _prov\n            .as_any()\n            .downcast_ref::<McpProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not an McpProvider\"))?;\n\n        let params = serde_json::json!({ \"cursor\": null });\n        let result = self.mcp_request(mcp_prov, \"tools/list\", params).await?;\n\n        if let Some(tools) = result.get(\"tools\").and_then(|v| v.as_array()) {\n            let mut parsed = Vec::new();\n            for tool in tools {\n                if let Ok(t) = serde_json::from_value::<Tool>(tool.clone()) {\n                    parsed.push(t);\n                }\n            }\n            return Ok(parsed);\n        }\n\n        Ok(vec![])\n    }\n\n    async fn deregister_tool_provider(&self, _prov: &dyn Provider) -> Result<()> {\n        let mcp_prov = _prov\n            .as_any()\n            .downcast_ref::<McpProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not an McpProvider\"))?;\n\n        // For stdio processes, terminate the process\n        if mcp_prov.is_stdio() {\n            let mut processes = self.stdio_processes.lock().await;\n            if let Some(process) = processes.remove(&mcp_prov.base.name) {\n                // Process will be dropped and killed when Arc count reaches 0\n                drop(process);\n            }\n        }\n\n        Ok(())\n    }\n\n    async fn call_tool(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, Value>,\n        prov: &dyn Provider,\n    ) -> Result<Value> {\n        let mcp_prov = prov\n            .as_any()\n            .downcast_ref::<McpProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not an McpProvider\"))?;\n\n        // MCP tool call format\n        let params = serde_json::json!({\n            \"name\": tool_name,\n            \"arguments\": args,\n        });\n\n        // Call the tool via MCP request\n        self.mcp_request(mcp_prov, \"tools/call\", params).await\n    }\n\n    async fn call_tool_stream(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, Value>,\n        prov: &dyn Provider,\n    ) -> Result<Box<dyn StreamResult>> {\n        let mcp_prov = prov\n            .as_any()\n            .downcast_ref::<McpProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not an McpProvider\"))?;\n\n        // MCP tool call format\n        let params = serde_json::json!({\n            \"name\": tool_name,\n            \"arguments\": args,\n        });\n\n        if mcp_prov.is_http() {\n            self.mcp_http_stream(mcp_prov, params).await\n        } else if mcp_prov.is_stdio() {\n            self.mcp_stdio_stream(mcp_prov, params).await\n        } else {\n            Err(anyhow!(\n                \"MCP provider must have either 'url' (HTTP) or 'command' (stdio)\"\n            ))\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::auth::{ApiKeyAuth, AuthType};\n    use crate::providers::base::{BaseProvider, ProviderType};\n    use axum::{extract::Json, http::HeaderValue, routing::post, Router};\n    use bytes::Bytes;\n    use serde_json::json;\n    use std::net::TcpListener;\n\n    #[test]\n    fn apply_auth_adds_expected_headers() {\n        let transport = McpTransport::new();\n        let auth = AuthConfig::ApiKey(ApiKeyAuth {\n            auth_type: AuthType::ApiKey,\n            api_key: \"secret\".to_string(),\n            var_name: \"X-MCP\".to_string(),\n            location: \"header\".to_string(),\n        });\n\n        let request = transport\n            .apply_auth(reqwest::Client::new().post(\"http://example.com\"), &auth)\n            .unwrap()\n            .build()\n            .unwrap();\n\n        assert_eq!(request.headers().get(\"X-MCP\").unwrap(), \"secret\");\n    }\n\n    #[tokio::test]\n    async fn mcp_request_requires_transport_configuration() {\n        let transport = McpTransport::new();\n        let prov = McpProvider {\n            base: BaseProvider {\n                name: \"invalid\".to_string(),\n                provider_type: ProviderType::Mcp,\n                auth: None,\n                allowed_communication_protocols: None,\n            },\n            url: None,\n            headers: None,\n            command: None,\n            args: None,\n            env_vars: None,\n        };\n\n        let err = transport\n            .mcp_request(&prov, \"ping\", Value::Null)\n            .await\n            .unwrap_err();\n        assert!(err\n            .to_string()\n            .contains(\"MCP provider must have either 'url' (HTTP) or 'command' (stdio)\"));\n    }\n\n    #[tokio::test]\n    async fn register_call_and_stream_mcp_http_transport() {\n        async fn handler(\n            headers: axum::http::HeaderMap,\n            Json(payload): Json<Value>,\n        ) -> Json<Value> {\n            if headers\n                .get(axum::http::header::ACCEPT)\n                .and_then(|v| v.to_str().ok())\n                == Some(\"text/event-stream\")\n            {\n                // Should never hit JSON handler for stream; placeholder\n                return Json(json!({ \"error\": \"wrong handler\" }));\n            }\n\n            let method = payload.get(\"method\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            match method {\n                \"tools/list\" => Json(json!({\n                    \"jsonrpc\": \"2.0\",\n                    \"result\": {\n                        \"tools\": [{\n                            \"name\": \"echo\",\n                            \"description\": \"echo tool\",\n                            \"inputs\": { \"type\": \"object\" },\n                            \"outputs\": { \"type\": \"object\" },\n                            \"tags\": []\n                        }]\n                    },\n                    \"id\": 1\n                })),\n                \"tools/call\" => {\n                    let params = payload.get(\"params\").cloned().unwrap_or_default();\n                    Json(json!({\n                        \"jsonrpc\": \"2.0\",\n                        \"result\": { \"called\": params },\n                        \"id\": 1\n                    }))\n                }\n                _ => Json(json!({ \"jsonrpc\": \"2.0\", \"result\": {}, \"id\": 1 })),\n            }\n        }\n\n        async fn stream_handler(\n            headers: axum::http::HeaderMap,\n            Json(_payload): Json<Value>,\n        ) -> impl axum::response::IntoResponse {\n            assert_eq!(\n                headers.get(axum::http::header::ACCEPT),\n                Some(&HeaderValue::from_static(\"text/event-stream\"))\n            );\n\n            let stream = tokio_stream::iter(vec![\n                Ok::<_, std::convert::Infallible>(Bytes::from_static(b\"data: {\\\"idx\\\":1}\\n\\n\")),\n                Ok(Bytes::from_static(b\"data: {\\\"idx\\\":2}\\n\\n\")),\n            ]);\n            (\n                [(axum::http::header::CONTENT_TYPE, \"text/event-stream\")],\n                axum::body::boxed(axum::body::Body::wrap_stream(stream)),\n            )\n        }\n\n        let app = Router::new()\n            .route(\"/\", post(handler))\n            .route(\"/stream\", post(stream_handler));\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n        tokio::spawn(async move {\n            axum::Server::from_tcp(listener)\n                .unwrap()\n                .serve(app.into_make_service())\n                .await\n                .unwrap();\n        });\n\n        let prov = McpProvider {\n            base: BaseProvider {\n                name: \"mcp\".to_string(),\n                provider_type: ProviderType::Mcp,\n                auth: None,\n                allowed_communication_protocols: None,\n            },\n            url: Some(format!(\"http://{}\", addr)),\n            headers: None,\n            command: None,\n            args: None,\n            env_vars: None,\n        };\n\n        let transport = McpTransport::new();\n        let tools = transport\n            .register_tool_provider(&prov)\n            .await\n            .expect(\"register\");\n        assert_eq!(tools.len(), 1);\n        assert_eq!(tools[0].name, \"echo\");\n\n        let mut args = HashMap::new();\n        args.insert(\"msg\".into(), Value::String(\"hi\".into()));\n        let call_value = transport\n            .call_tool(\"echo\", args.clone(), &prov)\n            .await\n            .expect(\"call\");\n        assert_eq!(\n            call_value,\n            json!({ \"called\": { \"name\": \"echo\", \"arguments\": json!(args) } })\n        );\n\n        // Stream uses /stream endpoint\n        let stream_prov = McpProvider {\n            url: Some(format!(\"http://{}/stream\", addr)),\n            ..prov.clone()\n        };\n        let mut stream = transport\n            .call_tool_stream(\"echo\", args, &stream_prov)\n            .await\n            .expect(\"stream\");\n        assert_eq!(stream.next().await.unwrap().unwrap(), json!({\"idx\":1}));\n        assert_eq!(stream.next().await.unwrap().unwrap(), json!({\"idx\":2}));\n        stream.close().await.unwrap();\n    }\n}\n",
      "line_count": 721,
      "word_count": 1874,
      "title": "Mod.Rs",
      "summary": "// MCP (Model Context Protocol) Transport use anyhow::{anyhow, Result};",
      "key_terms": [
        "close",
        "const",
        "Model",
        "chars",
        "convert",
        "Optimized",
        "either",
        "list",
        "cookie",
        "Clone",
        "providers",
        "global",
        "wrong",
        "Self",
        "if",
        "supported",
        "basic",
        "dangerous",
        "ApiKeyAuth",
        "await"
      ],
      "timestamp": "2025-12-24T18:56:15.714704"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\transports\\sse\\mod.rs",
      "content_type": "code",
      "content": "// SSE (Server-Sent Events) Transport\nuse anyhow::{anyhow, Result};\nuse async_trait::async_trait;\nuse bytes::Bytes;\nuse futures::StreamExt;\nuse reqwest::{header, Client};\nuse serde_json::{json, Value};\nuse std::collections::HashMap;\nuse tokio::sync::mpsc;\n\nuse crate::auth::AuthConfig;\nuse crate::providers::base::Provider;\nuse crate::providers::sse::SseProvider;\nuse crate::tools::Tool;\nuse crate::transports::{\n    stream::{boxed_channel_stream, StreamResult},\n    ClientTransport,\n};\n\n/// Transport for Server-Sent Events endpoints that return event streams per tool call.\npub struct SseTransport {\n    client: Client,\n}\n\nimpl SseTransport {\n    /// Create an SSE transport backed by a reqwest client.\n    pub fn new() -> Self {\n        Self {\n            client: Client::new(),\n        }\n    }\n\n    fn build_payload(&self, prov: &SseProvider, args: HashMap<String, Value>) -> Value {\n        if let Some(body_field) = &prov.body_field {\n            json!({ body_field: args })\n        } else {\n            json!(args)\n        }\n    }\n\n    fn value_to_header(value: &Value) -> Option<String> {\n        match value {\n            Value::String(s) => Some(s.clone()),\n            Value::Number(n) => Some(n.to_string()),\n            Value::Bool(b) => Some(b.to_string()),\n            _ => None,\n        }\n    }\n\n    fn split_headers_from_args(\n        &self,\n        prov: &SseProvider,\n        mut args: HashMap<String, Value>,\n    ) -> (HashMap<String, String>, HashMap<String, Value>) {\n        let mut headers = HashMap::new();\n        if let Some(header_fields) = &prov.header_fields {\n            for field in header_fields {\n                if let Some(value) = args.remove(field) {\n                    if let Some(header_value) = Self::value_to_header(&value) {\n                        headers.insert(field.clone(), header_value);\n                    }\n                }\n            }\n        }\n        (headers, args)\n    }\n\n    fn apply_headers(\n        &self,\n        request: reqwest::RequestBuilder,\n        prov: &SseProvider,\n        extra_accept: Option<&str>,\n        dynamic_headers: &HashMap<String, String>,\n    ) -> reqwest::RequestBuilder {\n        let mut builder = request;\n        builder = builder.header(\"Accept\", extra_accept.unwrap_or(\"application/json\"));\n        if let Some(headers) = &prov.headers {\n            for (k, v) in headers {\n                builder = builder.header(k, v);\n            }\n        }\n        for (k, v) in dynamic_headers {\n            builder = builder.header(k, v);\n        }\n        builder\n    }\n\n    fn apply_auth(\n        &self,\n        builder: reqwest::RequestBuilder,\n        auth: &AuthConfig,\n    ) -> Result<reqwest::RequestBuilder> {\n        match auth {\n            AuthConfig::ApiKey(api_key) => {\n                let location = api_key.location.to_ascii_lowercase();\n                match location.as_str() {\n                    \"header\" => Ok(builder.header(&api_key.var_name, &api_key.api_key)),\n                    \"query\" => {\n                        Ok(builder.query(&[(api_key.var_name.clone(), api_key.api_key.clone())]))\n                    }\n                    \"cookie\" => {\n                        let cookie_value = format!(\"{}={}\", api_key.var_name, api_key.api_key);\n                        Ok(builder.header(header::COOKIE, cookie_value))\n                    }\n                    other => Err(anyhow!(\"Unsupported API key location: {}\", other)),\n                }\n            }\n            AuthConfig::Basic(basic) => {\n                Ok(builder.basic_auth(&basic.username, Some(&basic.password)))\n            }\n            AuthConfig::OAuth2(_) => Err(anyhow!(\n                \"OAuth2 auth is not yet supported by the SSE transport\"\n            )),\n        }\n    }\n\n    fn parse_tools_from_body(&self, body: &str) -> Vec<Tool> {\n        if let Ok(manifest) = serde_json::from_str::<Value>(body) {\n            if let Some(tools) = manifest.get(\"tools\").and_then(|v| v.as_array()) {\n                let mut parsed = Vec::new();\n                for t in tools {\n                    if let Ok(tool) = serde_json::from_value::<Tool>(t.clone()) {\n                        parsed.push(tool);\n                    }\n                }\n                return parsed;\n            }\n        }\n        vec![]\n    }\n\n    fn spawn_sse_reader(\n        &self,\n        mut stream: impl futures::Stream<Item = Result<Bytes, reqwest::Error>> + Send + Unpin + 'static,\n    ) -> mpsc::Receiver<Result<Value>> {\n        let (tx, rx) = mpsc::channel(16);\n        tokio::spawn(async move {\n            let mut buffer = String::new();\n            let mut data_buf = String::new();\n\n            while let Some(chunk_res) = stream.next().await {\n                match chunk_res {\n                    Ok(bytes) => {\n                        buffer.push_str(&String::from_utf8_lossy(&bytes));\n                        loop {\n                            if let Some(pos) = buffer.find('\\n') {\n                                let mut line = buffer[..pos].to_string();\n                                buffer.drain(..=pos);\n                                line = line.trim_end_matches('\\r').to_string();\n\n                                if line.starts_with(\"data: \") {\n                                    if !data_buf.is_empty() {\n                                        data_buf.push('\\n');\n                                    }\n                                    data_buf.push_str(&line[6..]);\n                                } else if line.is_empty() {\n                                    if !data_buf.is_empty() {\n                                        let parsed = serde_json::from_str::<Value>(&data_buf)\n                                            .map_err(|e| {\n                                                anyhow!(\"Failed to parse SSE data: {}\", e)\n                                            });\n                                        if tx.send(parsed).await.is_err() {\n                                            return;\n                                        }\n                                        data_buf.clear();\n                                    }\n                                }\n                            } else {\n                                break;\n                            }\n                        }\n                    }\n                    Err(err) => {\n                        let _ = tx\n                            .send(Err(anyhow!(\"Error reading SSE stream: {}\", err)))\n                            .await;\n                        return;\n                    }\n                }\n            }\n\n            // Flush trailing data if present\n            if !data_buf.is_empty() {\n                let _ = tx\n                    .send(\n                        serde_json::from_str::<Value>(&data_buf)\n                            .map_err(|e| anyhow!(\"Failed to parse SSE data: {}\", e)),\n                    )\n                    .await;\n            }\n        });\n        rx\n    }\n}\n\n#[async_trait]\nimpl ClientTransport for SseTransport {\n    async fn register_tool_provider(&self, prov: &dyn Provider) -> Result<Vec<Tool>> {\n        let sse_prov = prov\n            .as_any()\n            .downcast_ref::<SseProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not an SseProvider\"))?;\n\n        let mut request = self\n            .client\n            .get(&sse_prov.url)\n            .header(\"Accept\", \"application/json\");\n        request = self.apply_headers(request, sse_prov, None, &HashMap::new());\n        if let Some(auth) = &sse_prov.base.auth {\n            request = self.apply_auth(request, auth)?;\n        }\n\n        let response = request.send().await?;\n        if !response.status().is_success() {\n            return Err(anyhow!(\n                \"Failed to fetch tools from {}: {}\",\n                sse_prov.url,\n                response.status()\n            ));\n        }\n\n        let body = response.text().await?;\n        Ok(self.parse_tools_from_body(&body))\n    }\n\n    async fn deregister_tool_provider(&self, _prov: &dyn Provider) -> Result<()> {\n        Ok(())\n    }\n\n    async fn call_tool(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, Value>,\n        prov: &dyn Provider,\n    ) -> Result<Value> {\n        // Use streaming parser and eagerly collect values.\n        let mut stream = self.call_tool_stream(tool_name, args, prov).await?;\n        let mut items = Vec::new();\n        while let Some(item) = stream.next().await? {\n            items.push(item);\n        }\n        stream.close().await?;\n        Ok(Value::Array(items))\n    }\n\n    async fn call_tool_stream(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, Value>,\n        prov: &dyn Provider,\n    ) -> Result<Box<dyn StreamResult>> {\n        let sse_prov = prov\n            .as_any()\n            .downcast_ref::<SseProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not an SseProvider\"))?;\n\n        let call_name = tool_name\n            .strip_prefix(&format!(\"{}.\", sse_prov.base.name))\n            .unwrap_or(tool_name);\n        let url = format!(\"{}/{}\", sse_prov.url.trim_end_matches('/'), call_name);\n        let (header_args, payload_args) = self.split_headers_from_args(sse_prov, args);\n        let payload = self.build_payload(sse_prov, payload_args);\n\n        let mut request = self\n            .client\n            .post(url)\n            .header(\"Content-Type\", \"application/json\");\n        request = self.apply_headers(request, sse_prov, Some(\"text/event-stream\"), &header_args);\n        if let Some(auth) = &sse_prov.base.auth {\n            request = self.apply_auth(request, auth)?;\n        }\n        let response = request.json(&payload).send().await?;\n\n        if !response.status().is_success() {\n            return Err(anyhow!(\"SSE request failed: {}\", response.status()));\n        }\n\n        let rx = self.spawn_sse_reader(response.bytes_stream());\n        Ok(boxed_channel_stream(rx, None))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::providers::base::{BaseProvider, ProviderType};\n    use axum::{body::Body, extract::Json, http::Response, routing::get, routing::post, Router};\n    use bytes::Bytes;\n    use serde_json::json;\n    use std::net::TcpListener;\n\n    #[test]\n    fn build_payload_respects_body_field() {\n        let transport = SseTransport::new();\n        let mut args = HashMap::new();\n        args.insert(\"message\".to_string(), json!(\"hi\"));\n\n        let prov = SseProvider {\n            base: BaseProvider {\n                name: \"sse\".to_string(),\n                provider_type: ProviderType::Sse,\n                auth: None,\n                allowed_communication_protocols: None,\n            },\n            url: \"http://example.com\".to_string(),\n            headers: None,\n            body_field: Some(\"data\".to_string()),\n            header_fields: None,\n        };\n\n        let payload = transport.build_payload(&prov, args.clone());\n        assert_eq!(payload, json!({ \"data\": args }));\n\n        let prov_no_field =\n            SseProvider::new(\"sse\".to_string(), \"http://example.com\".to_string(), None);\n        let payload = transport.build_payload(&prov_no_field, args.clone());\n        assert_eq!(payload, json!(args));\n    }\n\n    #[test]\n    fn apply_headers_adds_accept_and_custom_headers() {\n        let transport = SseTransport::new();\n        let prov = SseProvider {\n            base: BaseProvider {\n                name: \"sse\".to_string(),\n                provider_type: ProviderType::Sse,\n                auth: None,\n                allowed_communication_protocols: None,\n            },\n            url: \"http://example.com\".to_string(),\n            headers: Some(HashMap::from([(\"X-Test\".to_string(), \"123\".to_string())])),\n            body_field: None,\n            header_fields: None,\n        };\n\n        let request = transport\n            .apply_headers(\n                reqwest::Client::new().get(\"http://example.com\"),\n                &prov,\n                Some(\"text/event-stream\"),\n                &HashMap::new(),\n            )\n            .build()\n            .unwrap();\n\n        assert_eq!(\n            request.headers().get(\"accept\").unwrap(),\n            \"text/event-stream\"\n        );\n        assert_eq!(request.headers().get(\"x-test\").unwrap(), \"123\");\n    }\n\n    #[test]\n    fn parse_tools_from_body_reads_manifest() {\n        let transport = SseTransport::new();\n        let body = json!({\n            \"tools\": [{\n                \"name\": \"stream-tool\",\n                \"description\": \"streams\",\n                \"inputs\": { \"type\": \"object\" },\n                \"outputs\": { \"type\": \"object\" },\n                \"tags\": []\n            }]\n        })\n        .to_string();\n\n        let tools = transport.parse_tools_from_body(&body);\n        assert_eq!(tools.len(), 1);\n        assert_eq!(tools[0].name, \"stream-tool\");\n    }\n\n    #[test]\n    fn header_fields_move_args_into_headers() {\n        let transport = SseTransport::new();\n        let prov = SseProvider {\n            base: BaseProvider {\n                name: \"sse\".to_string(),\n                provider_type: ProviderType::Sse,\n                auth: None,\n                allowed_communication_protocols: None,\n            },\n            url: \"http://example.com\".to_string(),\n            headers: None,\n            body_field: None,\n            header_fields: Some(vec![\"X-Token\".into(), \"trace\".into()]),\n        };\n\n        let mut args = HashMap::new();\n        args.insert(\"X-Token\".into(), json!(\"abc\"));\n        args.insert(\"trace\".into(), json!(123));\n        args.insert(\"message\".into(), json!(\"hi\"));\n\n        let (headers, remaining) = transport.split_headers_from_args(&prov, args);\n        assert_eq!(headers.get(\"X-Token\").map(|s| s.as_str()), Some(\"abc\"));\n        assert_eq!(headers.get(\"trace\").map(|s| s.as_str()), Some(\"123\"));\n        assert!(remaining.contains_key(\"message\"));\n        assert!(!remaining.contains_key(\"trace\"));\n    }\n\n    #[tokio::test]\n    async fn register_call_and_stream_sse_transport() {\n        async fn manifest() -> Json<Value> {\n            Json(json!({\n                \"tools\": [{\n                    \"name\": \"tool1\",\n                    \"description\": \"sse tool\",\n                    \"inputs\": { \"type\": \"object\" },\n                    \"outputs\": { \"type\": \"object\" },\n                    \"tags\": []\n                }]\n            }))\n        }\n\n        async fn sse_handler(\n            headers: axum::http::HeaderMap,\n            Json(payload): Json<Value>,\n        ) -> Response<Body> {\n            assert_eq!(payload.get(\"msg\").and_then(|v| v.as_str()), Some(\"hello\"));\n            assert!(\n                payload.get(\"X-Trace\").is_none(),\n                \"header field should be stripped from payload\"\n            );\n            assert!(\n                headers.get(\"x-trace\").is_some(),\n                \"trace header should be present\"\n            );\n            let stream = tokio_stream::iter(vec![\n                Ok::<Bytes, std::convert::Infallible>(Bytes::from_static(b\"data: {\\\"idx\\\":1}\\n\\n\")),\n                Ok(Bytes::from_static(b\"data: {\\\"idx\\\":2}\\n\\n\")),\n            ]);\n\n            Response::builder()\n                .header(\"content-type\", \"text/event-stream\")\n                .body(Body::wrap_stream(stream))\n                .unwrap()\n        }\n\n        let app = Router::new()\n            .route(\"/\", get(manifest))\n            .route(\"/tool1\", post(sse_handler));\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n        tokio::spawn(async move {\n            axum::Server::from_tcp(listener)\n                .unwrap()\n                .serve(app.into_make_service())\n                .await\n                .unwrap();\n        });\n\n        let prov = SseProvider {\n            base: BaseProvider {\n                name: \"sse\".to_string(),\n                provider_type: ProviderType::Sse,\n                auth: None,\n                allowed_communication_protocols: None,\n            },\n            url: format!(\"http://{}\", addr),\n            headers: None,\n            body_field: None,\n            header_fields: Some(vec![\"X-Trace\".into()]),\n        };\n\n        let transport = SseTransport::new();\n        let tools = transport\n            .register_tool_provider(&prov)\n            .await\n            .expect(\"register\");\n        assert_eq!(tools.len(), 1);\n        assert_eq!(tools[0].name, \"tool1\");\n\n        let mut args = HashMap::new();\n        args.insert(\"msg\".into(), Value::String(\"hello\".into()));\n        args.insert(\"X-Trace\".into(), Value::String(\"trace-1\".into()));\n\n        let value = transport\n            .call_tool(\"tool1\", args.clone(), &prov)\n            .await\n            .expect(\"call\");\n        assert_eq!(value, json!([json!({\"idx\":1}), json!({\"idx\":2})]));\n\n        let mut stream = transport\n            .call_tool_stream(\"tool1\", args, &prov)\n            .await\n            .expect(\"stream\");\n        assert_eq!(stream.next().await.unwrap().unwrap(), json!({\"idx\":1}));\n        assert_eq!(stream.next().await.unwrap().unwrap(), json!({\"idx\":2}));\n        stream.close().await.unwrap();\n\n        // Provider-prefixed names should still resolve to the same endpoint.\n        let mut args = HashMap::new();\n        args.insert(\"msg\".into(), Value::String(\"hello\".into()));\n        args.insert(\"X-Trace\".into(), Value::String(\"trace-2\".into()));\n        let mut prefixed_stream = transport\n            .call_tool_stream(\"sse.tool1\", args, &prov)\n            .await\n            .expect(\"prefixed stream\");\n        assert_eq!(\n            prefixed_stream.next().await.unwrap().unwrap(),\n            json!({\"idx\":1})\n        );\n        let _ = prefixed_stream.close().await;\n    }\n}\n",
      "line_count": 505,
      "word_count": 1234,
      "title": "Mod.Rs",
      "summary": "// SSE (Server-Sent Events) Transport use anyhow::{anyhow, Result};",
      "key_terms": [
        "Bool",
        "reading",
        "close",
        "ClientTransport",
        "Result",
        "build",
        "futures",
        "clear",
        "async",
        "extract",
        "headers",
        "convert",
        "Type",
        "abc",
        "tx",
        "prov",
        "x-test",
        "Json",
        "cookie",
        "format"
      ],
      "timestamp": "2025-12-24T18:56:15.762691"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\transports\\tcp\\mod.rs",
      "content_type": "code",
      "content": "// TCP Transport\nuse anyhow::{anyhow, Result};\nuse async_trait::async_trait;\nuse serde_json::{json, Value};\nuse std::collections::HashMap;\nuse std::time::Duration;\nuse tokio::io::{AsyncBufReadExt, AsyncReadExt, AsyncWriteExt, BufReader};\nuse tokio::net::TcpStream;\nuse tokio::sync::mpsc;\n\nuse crate::providers::base::Provider;\nuse crate::providers::tcp::TcpProvider;\nuse crate::tools::Tool;\nuse crate::transports::{\n    stream::{boxed_channel_stream, StreamResult},\n    ClientTransport,\n};\n\n/// TCP transport used for simple length-delimited or line-delimited JSON exchanges.\npub struct TcpTransport;\n\nimpl TcpTransport {\n    /// Create a TCP transport instance.\n    pub fn new() -> Self {\n        Self\n    }\n\n    async fn send_and_receive(&self, address: &str, data: &[u8]) -> Result<Vec<u8>> {\n        let mut stream = TcpStream::connect(address).await?;\n\n        // Send data\n        stream.write_all(data).await?;\n        stream.flush().await?;\n\n        // Shutdown write half to signal we're done sending\n        stream.shutdown().await?;\n\n        // Read response\n        let mut buffer = Vec::new();\n        stream.read_to_end(&mut buffer).await?;\n\n        Ok(buffer)\n    }\n}\n\n#[async_trait]\nimpl ClientTransport for TcpTransport {\n    async fn register_tool_provider(&self, _prov: &dyn Provider) -> Result<Vec<Tool>> {\n        // TCP providers would define tools statically or via initial handshake\n        Ok(vec![])\n    }\n\n    async fn deregister_tool_provider(&self, _prov: &dyn Provider) -> Result<()> {\n        Ok(())\n    }\n\n    async fn call_tool(\n        &self,\n        _tool_name: &str,\n        args: HashMap<String, Value>,\n        prov: &dyn Provider,\n    ) -> Result<Value> {\n        let tcp_prov = prov\n            .as_any()\n            .downcast_ref::<TcpProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not a TcpProvider\"))?;\n\n        let request = serde_json::to_vec(&json!({\n            \"tool\": _tool_name,\n            \"args\": args\n        }))?;\n        let address = format!(\"{}:{}\", tcp_prov.host, tcp_prov.port);\n\n        // Optional timeout\n        let response = if let Some(timeout) = tcp_prov.timeout_ms {\n            tokio::time::timeout(\n                std::time::Duration::from_millis(timeout),\n                self.send_and_receive(&address, &request),\n            )\n            .await??\n        } else {\n            self.send_and_receive(&address, &request).await?\n        };\n\n        let result: Value = serde_json::from_slice(&response)?;\n        Ok(result)\n    }\n\n    async fn call_tool_stream(\n        &self,\n        _tool_name: &str,\n        args: HashMap<String, Value>,\n        prov: &dyn Provider,\n    ) -> Result<Box<dyn StreamResult>> {\n        let tcp_prov = prov\n            .as_any()\n            .downcast_ref::<TcpProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not a TcpProvider\"))?;\n\n        let request = serde_json::to_vec(&json!({\n            \"tool\": _tool_name,\n            \"args\": args\n        }))?;\n        let address = format!(\"{}:{}\", tcp_prov.host, tcp_prov.port);\n        let mut stream = TcpStream::connect(address).await?;\n        stream.write_all(&request).await?;\n        stream.write_all(b\"\\n\").await?;\n        stream.flush().await?;\n        stream.shutdown().await?;\n\n        let timeout = tcp_prov.timeout_ms.map(Duration::from_millis);\n        let mut reader = BufReader::new(stream);\n        let (tx, rx) = mpsc::channel(32);\n\n        tokio::spawn(async move {\n            loop {\n                let mut line = String::new();\n                let read_future = reader.read_line(&mut line);\n\n                let read_result = if let Some(duration) = timeout {\n                    match tokio::time::timeout(duration, read_future).await {\n                        Ok(res) => res,\n                        Err(_) => {\n                            let _ = tx.send(Err(anyhow!(\"TCP stream timed out\"))).await;\n                            return;\n                        }\n                    }\n                } else {\n                    read_future.await\n                };\n\n                match read_result {\n                    Ok(0) => return,\n                    Ok(_) => {\n                        let trimmed = line.trim();\n                        if trimmed.is_empty() {\n                            continue;\n                        }\n\n                        match serde_json::from_str::<Value>(trimmed) {\n                            Ok(value) => {\n                                if tx.send(Ok(value)).await.is_err() {\n                                    return;\n                                }\n                            }\n                            Err(err) => {\n                                let _ = tx\n                                    .send(Err(anyhow!(\"Failed to parse TCP stream JSON: {}\", err)))\n                                    .await;\n                                return;\n                            }\n                        }\n                    }\n                    Err(err) => {\n                        let _ = tx.send(Err(anyhow!(\"TCP stream error: {}\", err))).await;\n                        return;\n                    }\n                }\n            }\n        });\n\n        Ok(boxed_channel_stream(rx, None))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::providers::base::{BaseProvider, ProviderType};\n    use serde_json::json;\n    use tokio::net::TcpListener;\n\n    #[tokio::test]\n    async fn call_tool_round_trips_over_tcp() {\n        let listener = TcpListener::bind(\"127.0.0.1:0\").await.unwrap();\n        let addr = listener.local_addr().unwrap();\n\n        tokio::spawn(async move {\n            let (mut socket, _) = listener.accept().await.unwrap();\n            let mut buf = Vec::new();\n            socket.read_to_end(&mut buf).await.unwrap();\n            let incoming: Value = serde_json::from_slice(&buf).unwrap();\n            let response = serde_json::to_vec(&json!({\n                \"tool\": incoming.get(\"tool\").cloned().unwrap(),\n                \"args\": incoming.get(\"args\").cloned().unwrap()\n            }))\n            .unwrap();\n            socket.write_all(&response).await.unwrap();\n        });\n\n        let prov = TcpProvider {\n            base: BaseProvider {\n                name: \"tcp\".to_string(),\n                provider_type: ProviderType::Tcp,\n                auth: None,\n                allowed_communication_protocols: None,\n            },\n            host: addr.ip().to_string(),\n            port: addr.port(),\n            timeout_ms: None,\n        };\n\n        let mut args = HashMap::new();\n        args.insert(\"msg\".to_string(), Value::String(\"hello\".to_string()));\n\n        let result = TcpTransport::new()\n            .call_tool(\"echo\", args.clone(), &prov)\n            .await\n            .unwrap();\n\n        assert_eq!(result.get(\"tool\"), Some(&json!(\"echo\")));\n        assert_eq!(result.get(\"args\"), Some(&json!(args)));\n    }\n\n    #[tokio::test]\n    async fn call_tool_stream_reads_newline_delimited_messages() {\n        let listener = TcpListener::bind(\"127.0.0.1:0\").await.unwrap();\n        let addr = listener.local_addr().unwrap();\n\n        tokio::spawn(async move {\n            let (mut socket, _) = listener.accept().await.unwrap();\n            let mut buf = Vec::new();\n            socket.read_to_end(&mut buf).await.unwrap();\n\n            let messages = vec![json!({\"idx\": 1}), json!({\"idx\": 2})];\n            for message in messages {\n                let line = serde_json::to_vec(&message).unwrap();\n                socket.write_all(&line).await.unwrap();\n                socket.write_all(b\"\\n\").await.unwrap();\n            }\n        });\n\n        let prov = TcpProvider {\n            base: BaseProvider {\n                name: \"tcp\".to_string(),\n                provider_type: ProviderType::Tcp,\n                auth: None,\n                allowed_communication_protocols: None,\n            },\n            host: addr.ip().to_string(),\n            port: addr.port(),\n            timeout_ms: None,\n        };\n\n        let mut args = HashMap::new();\n        args.insert(\"value\".to_string(), Value::String(\"v\".to_string()));\n\n        let transport = TcpTransport::new();\n        let mut stream = transport\n            .call_tool_stream(\"sample\", args, &prov)\n            .await\n            .expect(\"stream\");\n\n        assert_eq!(stream.next().await.unwrap().unwrap(), json!({\"idx\": 1}));\n        assert_eq!(stream.next().await.unwrap().unwrap(), json!({\"idx\": 2}));\n        assert_eq!(stream.next().await.unwrap(), None);\n        stream.close().await.unwrap();\n    }\n}\n",
      "line_count": 260,
      "word_count": 618,
      "title": "Mod.Rs",
      "summary": "// TCP Transport use anyhow::{anyhow, Result};",
      "key_terms": [
        "close",
        "ClientTransport",
        "Result",
        "we",
        "async",
        "error",
        "Read",
        "tx",
        "prov",
        "buf",
        "ip",
        "Duration",
        "format",
        "line-delimited",
        "trim",
        "cloned",
        "idx",
        "connect",
        "providers",
        "Self"
      ],
      "timestamp": "2025-12-24T18:56:15.794461"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\transports\\text\\mod.rs",
      "content_type": "code",
      "content": "// Text Transport (for file-based tool definitions and execution)\nuse crate::providers::base::Provider;\nuse crate::providers::text::TextProvider;\nuse crate::security::validate_file_path;\nuse crate::tools::Tool;\nuse crate::transports::{stream::StreamResult, ClientTransport};\nuse anyhow::{anyhow, Result};\nuse async_trait::async_trait;\nuse serde_json::Value;\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\nuse tokio::fs;\nuse tokio::process::Command;\n\n/// Transport that loads tools from a directory and executes scripts locally.\npub struct TextTransport {\n    base_path: Option<PathBuf>,\n}\n\nenum ScriptKind {\n    Executable,\n    Node,\n    Bash,\n    Python,\n}\n\nimpl TextTransport {\n    /// Create a text transport without a default base path.\n    pub fn new() -> Self {\n        Self { base_path: None }\n    }\n\n    /// Configure a base directory that holds tool scripts and manifests.\n    pub fn with_base_path(mut self, path: PathBuf) -> Self {\n        self.base_path = Some(path);\n        self\n    }\n\n    async fn load_tools_from_file(&self, path: &PathBuf) -> Result<Vec<Tool>> {\n        // Validate path is safe\n        let path_str = path\n            .to_str()\n            .ok_or_else(|| anyhow!(\"Invalid path encoding\"))?;\n        let base_str = self.base_path.as_ref().and_then(|p| p.to_str());\n        validate_file_path(path_str, base_str)?;\n\n        let contents = fs::read_to_string(path).await?;\n\n        // Try to parse as JSON array of tools\n        if let Ok(tools) = serde_json::from_str::<Vec<Tool>>(&contents) {\n            return Ok(tools);\n        }\n\n        // Try to parse as UTCP manifest\n        if let Ok(manifest) = serde_json::from_str::<Value>(&contents) {\n            if let Some(tools_array) = manifest.get(\"tools\").and_then(|v| v.as_array()) {\n                let mut tools = Vec::new();\n                for tool_value in tools_array {\n                    if let Ok(tool) = serde_json::from_value::<Tool>(tool_value.clone()) {\n                        tools.push(tool);\n                    }\n                }\n                return Ok(tools);\n            }\n        }\n\n        Ok(vec![])\n    }\n\n    fn resolve_script(&self, base_path: &Path, tool_name: &str) -> Option<(ScriptKind, PathBuf)> {\n        let candidates = [\n            (ScriptKind::Executable, base_path.join(tool_name)),\n            (\n                ScriptKind::Node,\n                base_path.join(format!(\"{}.js\", tool_name)),\n            ),\n            (\n                ScriptKind::Bash,\n                base_path.join(format!(\"{}.sh\", tool_name)),\n            ),\n            (\n                ScriptKind::Python,\n                base_path.join(format!(\"{}.py\", tool_name)),\n            ),\n        ];\n\n        for (kind, path) in candidates {\n            if path.exists() {\n                return Some((kind, path));\n            }\n        }\n        None\n    }\n\n    fn build_command(&self, kind: ScriptKind, script_path: &Path, args_json: &str) -> Command {\n        let mut cmd = match kind {\n            ScriptKind::Node => {\n                let mut c = Command::new(\"node\");\n                c.arg(script_path);\n                c\n            }\n            ScriptKind::Bash => {\n                let mut c = Command::new(\"bash\");\n                c.arg(script_path);\n                c\n            }\n            ScriptKind::Python => {\n                let mut c = Command::new(\"python3\");\n                c.arg(script_path);\n                c\n            }\n            ScriptKind::Executable => Command::new(script_path),\n        };\n        cmd.arg(args_json);\n        cmd\n    }\n}\n\n#[async_trait]\nimpl ClientTransport for TextTransport {\n    async fn register_tool_provider(&self, _prov: &dyn Provider) -> Result<Vec<Tool>> {\n        // Load tools from text file\n        let base_path = _prov\n            .as_any()\n            .downcast_ref::<TextProvider>()\n            .and_then(|p| p.base_path.clone())\n            .or_else(|| self.base_path.clone());\n\n        if let Some(base_path) = base_path {\n            let tools_file = base_path.join(\"tools.json\");\n            if tools_file.exists() {\n                return self.load_tools_from_file(&tools_file).await;\n            }\n        }\n        Ok(vec![])\n    }\n\n    async fn deregister_tool_provider(&self, _prov: &dyn Provider) -> Result<()> {\n        Ok(())\n    }\n\n    async fn call_tool(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, Value>,\n        _prov: &dyn Provider,\n    ) -> Result<Value> {\n        let base_path = _prov\n            .as_any()\n            .downcast_ref::<TextProvider>()\n            .and_then(|p| p.base_path.clone())\n            .or_else(|| self.base_path.clone());\n\n        let base_path = base_path.ok_or_else(|| {\n            anyhow!(\"Text transport requires base_path configuration to execute tools\")\n        })?;\n\n        let (kind, script_path) = self\n            .resolve_script(&base_path, tool_name)\n            .ok_or_else(|| anyhow!(\"Tool script not found for '{}'\", tool_name))?;\n\n        // Validate script path is within base path\n        let script_path_str = script_path\n            .to_str()\n            .ok_or_else(|| anyhow!(\"Invalid path encoding\"))?;\n        let base_path_str = base_path.to_str();\n        validate_file_path(script_path_str, base_path_str)?;\n\n        let args_json = serde_json::to_string(&args)?;\n        let mut command = self.build_command(kind, &script_path, &args_json);\n        let output = command\n            .stdin(std::process::Stdio::null())\n            .stdout(std::process::Stdio::piped())\n            .stderr(std::process::Stdio::piped())\n            .spawn()?\n            .wait_with_output()\n            .await?;\n\n        if output.status.success() {\n            let result_str = String::from_utf8_lossy(&output.stdout);\n            if let Ok(result) = serde_json::from_str::<Value>(&result_str) {\n                return Ok(result);\n            }\n            return Ok(Value::String(result_str.to_string()));\n        }\n\n        let error = String::from_utf8_lossy(&output.stderr);\n        Err(anyhow!(\n            \"Tool execution failed ({}): {}\",\n            script_path.display(),\n            error\n        ))\n    }\n\n    async fn call_tool_stream(\n        &self,\n        _tool_name: &str,\n        _args: HashMap<String, Value>,\n        _prov: &dyn Provider,\n    ) -> Result<Box<dyn StreamResult>> {\n        Err(anyhow!(\"Streaming not supported by Text transport\"))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n    use std::fs as stdfs;\n    use std::fs::File;\n    use std::io::Write;\n    use tempfile::tempdir;\n\n    #[tokio::test]\n    async fn test_text_transport_call_tool() {\n        // Create a temporary directory\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path().to_path_buf();\n\n        // Create a tool script\n        let tool_script_path = base_path.join(\"test_tool.js\");\n        let mut tool_script_file = File::create(&tool_script_path).unwrap();\n        writeln!(\n            tool_script_file,\n            \"{}\",\n            r#\"\n            const args = JSON.parse(process.argv[2]);\n            const result = { message: `Hello, ${args.name}!` };\n            console.log(JSON.stringify(result));\n            \"#\n        )\n        .unwrap();\n\n        // Make the script executable (on Unix-like systems)\n        #[cfg(unix)]\n        {\n            use std::os::unix::fs::PermissionsExt;\n            let mut permissions = std::fs::metadata(&tool_script_path).unwrap().permissions();\n            permissions.set_mode(0o755); // rwxr-xr-x\n            std::fs::set_permissions(&tool_script_path, permissions).unwrap();\n        }\n\n        // Create a TextTransport with the base path\n        let transport = TextTransport::new().with_base_path(base_path.clone());\n\n        // Define tool arguments\n        let mut args = HashMap::new();\n        args.insert(\"name\".to_string(), Value::String(\"World\".to_string()));\n\n        // Call the tool\n        let result = transport\n            .call_tool(\"test_tool\", args, &MockProvider)\n            .await\n            .unwrap();\n\n        // Assert the result\n        assert_eq!(result[\"message\"], \"Hello, World!\");\n\n        // Clean up the temporary directory\n        temp_dir.close().unwrap();\n    }\n\n    // Mock Provider for testing\n    #[derive(Debug)]\n    struct MockProvider;\n\n    impl Provider for MockProvider {\n        fn type_(&self) -> crate::providers::base::ProviderType {\n            crate::providers::base::ProviderType::Http\n        }\n\n        fn name(&self) -> String {\n            \"mock\".to_string()\n        }\n\n        fn as_any(&self) -> &dyn std::any::Any {\n            self\n        }\n    }\n\n    #[tokio::test]\n    async fn register_and_call_stream_errors() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path().to_path_buf();\n\n        // Write tools.json\n        let tools_manifest = json!({\n            \"tools\": [{\n                \"name\": \"sample\",\n                \"description\": \"sample tool\",\n                \"inputs\": { \"type\": \"object\" },\n                \"outputs\": { \"type\": \"object\" },\n                \"tags\": []\n            }]\n        });\n        stdfs::write(base_path.join(\"tools.json\"), tools_manifest.to_string()).unwrap();\n\n        // Write script\n        let script_path = base_path.join(\"sample.js\");\n        stdfs::write(\n            &script_path,\n            r#\"const args = JSON.parse(process.argv[2]); console.log(JSON.stringify({ ok: args.value }));\"#,\n        )\n        .unwrap();\n\n        let transport = TextTransport::new().with_base_path(base_path.clone());\n        let tools = transport\n            .register_tool_provider(&MockProvider)\n            .await\n            .expect(\"register\");\n        assert_eq!(tools.len(), 1);\n        assert_eq!(tools[0].name, \"sample\");\n\n        let mut args = HashMap::new();\n        args.insert(\"value\".to_string(), Value::String(\"v\".to_string()));\n        let result = transport\n            .call_tool(\"sample\", args.clone(), &MockProvider)\n            .await\n            .expect(\"call\");\n        assert_eq!(result, json!({ \"ok\": \"v\" }));\n\n        let err = transport\n            .call_tool_stream(\"sample\", args, &MockProvider)\n            .await\n            .err()\n            .expect(\"stream error\");\n        assert!(err.to_string().contains(\"Streaming not supported\"));\n    }\n}\n",
      "line_count": 330,
      "word_count": 828,
      "title": "Mod.Rs",
      "summary": "// Text Transport (for file-based tool definitions and execution) use crate::providers::base::Provider;",
      "key_terms": [
        "output",
        "close",
        "ClientTransport",
        "Result",
        "Python",
        "const",
        "null",
        "async",
        "File",
        "up",
        "error",
        "display",
        "based",
        "World",
        "format",
        "providers",
        "found",
        "piped",
        "Self",
        "path"
      ],
      "timestamp": "2025-12-24T18:56:15.825925"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\transports\\udp\\mod.rs",
      "content_type": "code",
      "content": "// UDP Transport - connectionless datagram communication\nuse anyhow::{anyhow, Result};\nuse async_trait::async_trait;\nuse serde_json::Value;\nuse std::collections::HashMap;\nuse std::time::Duration;\nuse tokio::net::UdpSocket;\n\nuse crate::providers::base::Provider;\nuse crate::providers::udp::UdpProvider;\nuse crate::tools::Tool;\nuse crate::transports::{stream::StreamResult, ClientTransport};\n\n/// Datagram-based transport for lightweight request/response tools.\npub struct UdpTransport;\n\nimpl UdpTransport {\n    /// Create a UDP transport instance.\n    pub fn new() -> Self {\n        Self\n    }\n\n    async fn send_and_receive(&self, server_addr: &str, data: &[u8]) -> Result<Vec<u8>> {\n        // Bind to a random local port\n        let socket = UdpSocket::bind(\"0.0.0.0:0\").await?;\n\n        // Send data\n        socket.send_to(data, server_addr).await?;\n\n        // Receive response\n        let mut buf = vec![0u8; 65535]; // Max UDP packet size\n        let (len, _) = socket.recv_from(&mut buf).await?;\n\n        buf.truncate(len);\n        Ok(buf)\n    }\n}\n\n#[async_trait]\nimpl ClientTransport for UdpTransport {\n    async fn register_tool_provider(&self, _prov: &dyn Provider) -> Result<Vec<Tool>> {\n        // UDP providers define tools statically\n        Ok(vec![])\n    }\n\n    async fn deregister_tool_provider(&self, _prov: &dyn Provider) -> Result<()> {\n        Ok(())\n    }\n\n    async fn call_tool(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, Value>,\n        prov: &dyn Provider,\n    ) -> Result<Value> {\n        let udp_prov = prov\n            .as_any()\n            .downcast_ref::<UdpProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not a UdpProvider\"))?;\n\n        // Build request\n        let request = serde_json::json!({\n            \"tool\": tool_name,\n            \"args\": args,\n        });\n\n        let request_bytes = serde_json::to_vec(&request)?;\n\n        // Send request and receive response\n        let address = format!(\"{}:{}\", udp_prov.host, udp_prov.port);\n        let response_bytes = if let Some(timeout) = udp_prov.timeout_ms {\n            tokio::time::timeout(\n                Duration::from_millis(timeout),\n                self.send_and_receive(&address, &request_bytes),\n            )\n            .await??\n        } else {\n            self.send_and_receive(&address, &request_bytes).await?\n        };\n\n        // Parse response\n        let result: Value = serde_json::from_slice(&response_bytes)?;\n        Ok(result)\n    }\n\n    async fn call_tool_stream(\n        &self,\n        _tool_name: &str,\n        _args: HashMap<String, Value>,\n        _prov: &dyn Provider,\n    ) -> Result<Box<dyn StreamResult>> {\n        Err(anyhow!(\n            \"Streaming not suitable for UDP - use TCP or WebSocket\"\n        ))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::providers::base::{BaseProvider, ProviderType};\n    use serde_json::json;\n    use tokio::net::UdpSocket;\n\n    #[tokio::test]\n    async fn call_tool_sends_and_receives_datagram() {\n        let socket = UdpSocket::bind(\"127.0.0.1:0\").await.unwrap();\n        let addr = socket.local_addr().unwrap();\n\n        tokio::spawn(async move {\n            let mut buf = vec![0u8; 1024];\n            let (len, peer) = socket.recv_from(&mut buf).await.unwrap();\n            let incoming: Value = serde_json::from_slice(&buf[..len]).unwrap();\n            let response = serde_json::to_vec(&json!({\n                \"received_tool\": incoming.get(\"tool\").cloned().unwrap(),\n                \"args\": incoming.get(\"args\").cloned().unwrap()\n            }))\n            .unwrap();\n            UdpSocket::bind(\"0.0.0.0:0\")\n                .await\n                .unwrap()\n                .send_to(&response, peer)\n                .await\n                .unwrap();\n        });\n\n        let prov = UdpProvider {\n            base: BaseProvider {\n                name: \"udp\".to_string(),\n                provider_type: ProviderType::Udp,\n                auth: None,\n                allowed_communication_protocols: None,\n            },\n            host: addr.ip().to_string(),\n            port: addr.port(),\n            timeout_ms: None,\n        };\n\n        let mut args = HashMap::new();\n        args.insert(\"value\".to_string(), Value::String(\"ping\".to_string()));\n\n        let result = UdpTransport::new()\n            .call_tool(\"echo\", args.clone(), &prov)\n            .await\n            .unwrap();\n\n        assert_eq!(result.get(\"received_tool\"), Some(&json!(\"echo\")));\n        assert_eq!(result.get(\"args\"), Some(&json!(args)));\n    }\n\n    #[tokio::test]\n    async fn register_returns_empty_and_stream_error() {\n        let prov = UdpProvider {\n            base: BaseProvider {\n                name: \"udp\".to_string(),\n                provider_type: ProviderType::Udp,\n                auth: None,\n                allowed_communication_protocols: None,\n            },\n            host: \"127.0.0.1\".to_string(),\n            port: 0,\n            timeout_ms: None,\n        };\n\n        let transport = UdpTransport::new();\n        assert!(transport\n            .register_tool_provider(&prov)\n            .await\n            .unwrap()\n            .is_empty());\n\n        let err = transport\n            .call_tool_stream(\"tool\", HashMap::new(), &prov)\n            .await\n            .err()\n            .expect(\"stream error\");\n        assert!(err.to_string().contains(\"Streaming not suitable for UDP\"));\n    }\n\n    #[tokio::test]\n    async fn call_tool_respects_timeout_when_no_response() {\n        let prov = UdpProvider {\n            base: BaseProvider {\n                name: \"udp-timeout\".to_string(),\n                provider_type: ProviderType::Udp,\n                auth: None,\n                allowed_communication_protocols: None,\n            },\n            host: \"127.0.0.1\".to_string(),\n            port: 9, // discard port - we won't listen\n            timeout_ms: Some(30),\n        };\n\n        let err = UdpTransport::new()\n            .call_tool(\"noop\", HashMap::new(), &prov)\n            .await\n            .expect_err(\"expected timeout\");\n        assert!(\n            err.to_string().to_lowercase().contains(\"elapsed\")\n                || err.to_string().to_lowercase().contains(\"timeout\")\n        );\n    }\n}\n",
      "line_count": 204,
      "word_count": 475,
      "title": "Mod.Rs",
      "summary": "// UDP Transport - connectionless datagram communication use anyhow::{anyhow, Result};",
      "key_terms": [
        "we",
        "ClientTransport",
        "Result",
        "async",
        "error",
        "UdpProvider",
        "based",
        "truncate",
        "WebSocket",
        "buf",
        "prov",
        "Duration",
        "receive",
        "format",
        "Udp",
        "packet",
        "ip",
        "cloned",
        "providers",
        "Self"
      ],
      "timestamp": "2025-12-24T18:56:15.869063"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\transports\\webrtc\\mod.rs",
      "content_type": "code",
      "content": "// WebRTC Transport - peer-to-peer data channels\nuse anyhow::{anyhow, Result};\nuse async_trait::async_trait;\nuse serde_json::Value;\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::{mpsc, Mutex};\nuse webrtc::api::APIBuilder;\nuse webrtc::data_channel::data_channel_message::DataChannelMessage;\nuse webrtc::data_channel::RTCDataChannel;\nuse webrtc::ice_transport::ice_server::RTCIceServer;\nuse webrtc::peer_connection::configuration::RTCConfiguration;\nuse webrtc::peer_connection::peer_connection_state::RTCPeerConnectionState;\nuse webrtc::peer_connection::sdp::session_description::RTCSessionDescription;\nuse webrtc::peer_connection::RTCPeerConnection;\n\nuse crate::auth::AuthConfig;\nuse crate::providers::base::Provider;\nuse crate::providers::webrtc::WebRtcProvider;\nuse crate::security::{validate_size_limit, validate_url_security};\nuse crate::tools::{Tool, ToolInputOutputSchema};\nuse crate::transports::{\n    stream::{boxed_channel_stream, StreamResult},\n    ClientTransport,\n};\n\n/// Peer-to-peer transport that relays tool calls over WebRTC data channels.\npub struct WebRtcTransport {\n    // Cache of active peer connections\n    connections: Arc<Mutex<HashMap<String, Arc<RTCPeerConnection>>>>,\n}\n\nimpl WebRtcTransport {\n    /// Create an empty transport with no cached connections.\n    pub fn new() -> Self {\n        Self {\n            connections: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n\n    fn default_schema() -> ToolInputOutputSchema {\n        ToolInputOutputSchema {\n            type_: \"object\".to_string(),\n            properties: None,\n            required: None,\n            description: None,\n            title: None,\n            items: None,\n            enum_: None,\n            minimum: None,\n            maximum: None,\n            format: None,\n        }\n    }\n\n    async fn create_peer_connection(\n        &self,\n        prov: &WebRtcProvider,\n    ) -> Result<Arc<RTCPeerConnection>> {\n        // Configure ICE servers (credential_type field removed in WebRTC 0.14)\n        let ice_servers: Vec<RTCIceServer> = prov\n            .ice_servers\n            .iter()\n            .map(|server| RTCIceServer {\n                urls: server.urls.clone(),\n                username: server.username.clone().unwrap_or_default(),\n                credential: server.credential.clone().unwrap_or_default(),\n            })\n            .collect();\n\n        // Use the default API to create peer connection\n        let api = APIBuilder::new().build();\n\n        // Create peer connection configuration\n        let config = RTCConfiguration {\n            ice_servers,\n            ..Default::default()\n        };\n\n        // Create the peer connection\n        let peer_connection = Arc::new(api.new_peer_connection(config).await?);\n\n        Ok(peer_connection)\n    }\n\n    async fn exchange_sdp(\n        &self,\n        prov: &WebRtcProvider,\n        offer: RTCSessionDescription,\n    ) -> Result<RTCSessionDescription> {\n        // Send offer to signaling server and get answer\n        validate_url_security(&prov.signaling_server, false)?;\n        let client = reqwest::Client::new();\n\n        let mut request = client\n            .post(&prov.signaling_server)\n            .json(&serde_json::json!({\n                \"type\": \"offer\",\n                \"sdp\": offer.sdp,\n            }));\n\n        // Apply authentication if configured\n        if let Some(auth) = &prov.base.auth {\n            request = self.apply_auth(request, auth)?;\n        }\n\n        let response = request.send().await?;\n\n        if !response.status().is_success() {\n            return Err(anyhow!(\n                \"Signaling server returned error: {}\",\n                response.status()\n            ));\n        }\n\n        let answer_json: Value = response.json().await?;\n\n        let answer_sdp = answer_json\n            .get(\"sdp\")\n            .and_then(|v| v.as_str())\n            .ok_or_else(|| anyhow!(\"Invalid answer from signaling server\"))?;\n\n        Ok(RTCSessionDescription::answer(answer_sdp.to_string())?)\n    }\n\n    fn apply_auth(\n        &self,\n        builder: reqwest::RequestBuilder,\n        auth: &AuthConfig,\n    ) -> Result<reqwest::RequestBuilder> {\n        match auth {\n            AuthConfig::ApiKey(api_key) => {\n                let location = api_key.location.to_ascii_lowercase();\n                match location.as_str() {\n                    \"header\" => Ok(builder.header(&api_key.var_name, &api_key.api_key)),\n                    \"query\" => {\n                        Ok(builder.query(&[(api_key.var_name.clone(), api_key.api_key.clone())]))\n                    }\n                    other => Err(anyhow!(\"Unsupported API key location: {}\", other)),\n                }\n            }\n            AuthConfig::Basic(basic) => {\n                Ok(builder.basic_auth(&basic.username, Some(&basic.password)))\n            }\n            AuthConfig::OAuth2(_) => {\n                Err(anyhow!(\"OAuth2 auth not yet supported by WebRTC transport\"))\n            }\n        }\n    }\n\n    async fn create_data_channel(\n        &self,\n        prov: &WebRtcProvider,\n    ) -> Result<(Arc<RTCPeerConnection>, Arc<RTCDataChannel>)> {\n        let peer_connection = self.create_peer_connection(prov).await?;\n\n        // Create data channel configuration\n        let mut init = webrtc::data_channel::data_channel_init::RTCDataChannelInit {\n            ordered: Some(prov.ordered),\n            ..Default::default()\n        };\n\n        if let Some(max_retransmits) = prov.max_retransmits {\n            init.max_retransmits = Some(max_retransmits);\n        }\n\n        if let Some(max_packet_life_time) = prov.max_packet_life_time {\n            init.max_packet_life_time = Some(max_packet_life_time);\n        }\n\n        // Create data channel\n        let data_channel = peer_connection\n            .create_data_channel(&prov.channel_label, Some(init))\n            .await?;\n\n        // Create offer\n        let offer = peer_connection.create_offer(None).await?;\n        peer_connection.set_local_description(offer.clone()).await?;\n\n        // Exchange SDP with signaling server\n        let answer = self.exchange_sdp(prov, offer).await?;\n        peer_connection.set_remote_description(answer).await?;\n\n        // Wait for data channel to open\n        let (open_tx, mut open_rx) = mpsc::channel::<()>(1);\n        let open_tx = Arc::new(Mutex::new(Some(open_tx)));\n\n        data_channel.on_open(Box::new(move || {\n            let open_tx = open_tx.clone();\n            Box::pin(async move {\n                if let Some(tx) = open_tx.lock().await.take() {\n                    let _ = tx.send(()).await;\n                }\n            })\n        }));\n\n        // Wait for channel to open with timeout\n        tokio::time::timeout(std::time::Duration::from_secs(10), open_rx.recv())\n            .await\n            .map_err(|_| anyhow!(\"Timeout waiting for data channel to open\"))?;\n\n        Ok((peer_connection, data_channel))\n    }\n\n    async fn send_and_receive(\n        &self,\n        data_channel: &Arc<RTCDataChannel>,\n        request: Value,\n    ) -> Result<Value> {\n        let request_bytes = serde_json::to_vec(&request)?;\n\n        // Set up receiver before sending\n        let (response_tx, mut response_rx) = mpsc::channel::<Result<Value>>(1);\n        let response_tx = Arc::new(Mutex::new(Some(response_tx)));\n\n        data_channel.on_message(Box::new(move |msg: DataChannelMessage| {\n            let response_tx = response_tx.clone();\n            Box::pin(async move {\n                if let Some(tx) = response_tx.lock().await.take() {\n                    // Validate size\n                    if let Err(e) = validate_size_limit(&msg.data, 10 * 1024 * 1024) {\n                        let _ = tx.send(Err(e)).await;\n                        return;\n                    }\n\n                    let result = serde_json::from_slice::<Value>(&msg.data)\n                        .map_err(|e| anyhow!(\"Failed to parse response: {}\", e));\n                    let _ = tx.send(result).await;\n                }\n            })\n        }));\n\n        // Send request\n        data_channel.send(&request_bytes.into()).await?;\n\n        // Wait for response with timeout\n        let response_result =\n            tokio::time::timeout(std::time::Duration::from_secs(30), response_rx.recv())\n                .await\n                .map_err(|_| anyhow!(\"Timeout waiting for response\"))?;\n\n        let response = match response_result {\n            Some(Ok(value)) => value,\n            Some(Err(e)) => return Err(e),\n            None => return Err(anyhow!(\"No response received\")),\n        };\n\n        Ok(response)\n    }\n}\n\n#[async_trait]\nimpl ClientTransport for WebRtcTransport {\n    async fn register_tool_provider(&self, prov: &dyn Provider) -> Result<Vec<Tool>> {\n        let webrtc_prov = prov\n            .as_any()\n            .downcast_ref::<WebRtcProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not a WebRtcProvider\"))?;\n\n        // Establish connection and request tool list\n        let (_peer_connection, data_channel) = self.create_data_channel(webrtc_prov).await?;\n\n        let request = serde_json::json!({\n            \"method\": \"list_tools\",\n            \"params\": {}\n        });\n\n        let response = self.send_and_receive(&data_channel, request).await?;\n\n        // Parse tools from response\n        let tools_array = response\n            .get(\"tools\")\n            .and_then(|v| v.as_array())\n            .ok_or_else(|| anyhow!(\"Invalid tools response\"))?;\n\n        let default_schema = Self::default_schema();\n        let mut tools = Vec::new();\n\n        for tool_value in tools_array {\n            if let Ok(mut tool) = serde_json::from_value::<Tool>(tool_value.clone()) {\n                // Set defaults if not present\n                if tool.inputs.type_.is_empty() {\n                    tool.inputs = default_schema.clone();\n                }\n                if tool.outputs.type_.is_empty() {\n                    tool.outputs = default_schema.clone();\n                }\n                tools.push(tool);\n            }\n        }\n\n        Ok(tools)\n    }\n\n    async fn deregister_tool_provider(&self, prov: &dyn Provider) -> Result<()> {\n        let webrtc_prov = prov\n            .as_any()\n            .downcast_ref::<WebRtcProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not a WebRtcProvider\"))?;\n\n        // Remove cached connection\n        let mut connections = self.connections.lock().await;\n        if let Some(pc) = connections.remove(&webrtc_prov.base.name) {\n            pc.close().await?;\n        }\n\n        Ok(())\n    }\n\n    async fn call_tool(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, Value>,\n        prov: &dyn Provider,\n    ) -> Result<Value> {\n        let webrtc_prov = prov\n            .as_any()\n            .downcast_ref::<WebRtcProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not a WebRtcProvider\"))?;\n\n        // Get or create connection\n        let connections = self.connections.lock().await;\n        let connection_key = webrtc_prov.base.name.clone();\n\n        let (_peer_connection, data_channel) = if let Some(pc) = connections.get(&connection_key) {\n            // Check if connection is still alive\n            if pc.connection_state() == RTCPeerConnectionState::Connected {\n                // Try to get existing data channel\n                // Note: In practice, you'd store the data channel ref as well\n                // For now, we'll create a new connection\n                drop(connections);\n                self.create_data_channel(webrtc_prov).await?\n            } else {\n                drop(connections);\n                self.create_data_channel(webrtc_prov).await?\n            }\n        } else {\n            drop(connections);\n            let (pc, dc) = self.create_data_channel(webrtc_prov).await?;\n            // Cache the connection\n            let mut connections = self.connections.lock().await;\n            connections.insert(connection_key.clone(), pc.clone());\n            (pc, dc)\n        };\n\n        // Send tool call request\n        let request = serde_json::json!({\n            \"method\": \"call_tool\",\n            \"params\": {\n                \"tool\": tool_name,\n                \"args\": args,\n            }\n        });\n\n        let response = self.send_and_receive(&data_channel, request).await?;\n\n        // Extract result\n        if let Some(error) = response.get(\"error\") {\n            return Err(anyhow!(\"Tool execution error: {}\", error));\n        }\n\n        response\n            .get(\"result\")\n            .cloned()\n            .ok_or_else(|| anyhow!(\"No result in response\"))\n    }\n\n    async fn call_tool_stream(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, Value>,\n        prov: &dyn Provider,\n    ) -> Result<Box<dyn StreamResult>> {\n        let webrtc_prov = prov\n            .as_any()\n            .downcast_ref::<WebRtcProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not a WebRtcProvider\"))?;\n\n        let (_peer_connection, data_channel) = self.create_data_channel(webrtc_prov).await?;\n\n        // Send streaming request\n        let request = serde_json::json!({\n            \"method\": \"call_tool_stream\",\n            \"params\": {\n                \"tool\": tool_name,\n                \"args\": args,\n            }\n        });\n\n        let request_bytes = serde_json::to_vec(&request)?;\n        data_channel.send(&request_bytes.into()).await?;\n\n        // Set up streaming receiver\n        let (tx, rx) = mpsc::channel(16);\n\n        data_channel.on_message(Box::new(move |msg: DataChannelMessage| {\n            let tx = tx.clone();\n            Box::pin(async move {\n                let parsed = serde_json::from_slice::<Value>(&msg.data)\n                    .map_err(|e| anyhow!(\"Failed to parse stream item: {}\", e));\n                let _ = tx.send(parsed).await;\n            })\n        }));\n\n        Ok(boxed_channel_stream(rx, None))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::auth::{ApiKeyAuth, AuthType, BasicAuth};\n\n    #[test]\n    fn test_default_schema() {\n        let schema = WebRtcTransport::default_schema();\n        assert_eq!(schema.type_, \"object\");\n        assert!(schema.properties.is_none());\n    }\n\n    #[test]\n    fn test_apply_auth_api_key_header() {\n        let transport = WebRtcTransport::new();\n        let auth = AuthConfig::ApiKey(ApiKeyAuth {\n            auth_type: AuthType::ApiKey,\n            api_key: \"secret\".to_string(),\n            var_name: \"X-API-Key\".to_string(),\n            location: \"header\".to_string(),\n        });\n\n        let builder = reqwest::Client::new().get(\"http://example.com\");\n        let builder = transport.apply_auth(builder, &auth).unwrap();\n        let request = builder.build().unwrap();\n\n        assert_eq!(\n            request\n                .headers()\n                .get(\"X-API-Key\")\n                .unwrap()\n                .to_str()\n                .unwrap(),\n            \"secret\"\n        );\n    }\n\n    #[test]\n    fn test_apply_auth_api_key_query() {\n        let transport = WebRtcTransport::new();\n        let auth = AuthConfig::ApiKey(ApiKeyAuth {\n            auth_type: AuthType::ApiKey,\n            api_key: \"secret\".to_string(),\n            var_name: \"key\".to_string(),\n            location: \"query\".to_string(),\n        });\n\n        let builder = reqwest::Client::new().get(\"http://example.com\");\n        let builder = transport.apply_auth(builder, &auth).unwrap();\n        let request = builder.build().unwrap();\n\n        assert_eq!(request.url().query(), Some(\"key=secret\"));\n    }\n\n    #[test]\n    fn test_apply_auth_basic() {\n        let transport = WebRtcTransport::new();\n        let auth = AuthConfig::Basic(BasicAuth {\n            auth_type: AuthType::Basic,\n            username: \"user\".to_string(),\n            password: \"pass\".to_string(),\n        });\n\n        let builder = reqwest::Client::new().get(\"http://example.com\");\n        let builder = transport.apply_auth(builder, &auth).unwrap();\n        let request = builder.build().unwrap();\n\n        // Basic auth header is \"Basic <base64(user:pass)>\"\n        // user:pass -> dXNlcjpwYXNz\n        assert_eq!(\n            request\n                .headers()\n                .get(\"Authorization\")\n                .unwrap()\n                .to_str()\n                .unwrap(),\n            \"Basic dXNlcjpwYXNz\"\n        );\n    }\n\n    #[test]\n    fn test_transport_implements_trait() {\n        fn assert_client_transport<T: ClientTransport>() {}\n        assert_client_transport::<WebRtcTransport>();\n    }\n}\n",
      "line_count": 495,
      "word_count": 1234,
      "title": "Mod.Rs",
      "summary": "// WebRTC Transport - peer-to-peer data channels use anyhow::{anyhow, Result};",
      "key_terms": [
        "Timeout",
        "open",
        "build",
        "ClientTransport",
        "Result",
        "close",
        "up",
        "we",
        "async",
        "error",
        "Exchange",
        "headers",
        "list",
        "tx",
        "prov",
        "Duration",
        "format",
        "Apply",
        "Unsupported",
        "cloned"
      ],
      "timestamp": "2025-12-24T18:56:15.894351"
    },
    {
      "file_path": "UPSTREAM\\rs-utcp\\src\\transports\\websocket\\mod.rs",
      "content_type": "code",
      "content": "// WebSocket Transport - bidirectional communication\nuse anyhow::{anyhow, Result};\nuse async_trait::async_trait;\nuse base64::Engine;\nuse futures::{SinkExt, StreamExt};\nuse reqwest::Url;\nuse serde_json::Value;\nuse std::collections::HashMap;\nuse std::str::FromStr;\nuse tokio::sync::mpsc;\nuse tokio_tungstenite::{\n    connect_async,\n    tungstenite::{\n        client::IntoClientRequest,\n        http::{HeaderName, HeaderValue, Request},\n        protocol::Message,\n    },\n};\n\nuse crate::auth::AuthConfig;\nuse crate::providers::base::Provider;\nuse crate::providers::websocket::WebSocketProvider;\nuse crate::tools::{Tool, ToolInputOutputSchema};\nuse crate::transports::{\n    stream::{boxed_channel_stream, StreamResult},\n    ClientTransport,\n};\n\n/// Transport that communicates with tools over WebSocket connections.\npub struct WebSocketTransport;\n\nimpl WebSocketTransport {\n    /// Create a WebSocket transport.\n    pub fn new() -> Self {\n        Self\n    }\n\n    fn default_schema() -> ToolInputOutputSchema {\n        ToolInputOutputSchema {\n            type_: \"object\".to_string(),\n            properties: None,\n            required: None,\n            description: None,\n            title: None,\n            items: None,\n            enum_: None,\n            minimum: None,\n            maximum: None,\n            format: None,\n        }\n    }\n\n    fn apply_auth_to_url(&self, url: &str, auth: &AuthConfig) -> Result<String> {\n        match auth {\n            AuthConfig::ApiKey(api_key) => {\n                let location = api_key.location.to_ascii_lowercase();\n                if location == \"query\" {\n                    let mut parsed = Url::parse(url)?;\n                    parsed\n                        .query_pairs_mut()\n                        .append_pair(&api_key.var_name, &api_key.api_key);\n                    Ok(parsed.to_string())\n                } else {\n                    Ok(url.to_string())\n                }\n            }\n            _ => Ok(url.to_string()),\n        }\n    }\n\n    fn apply_auth_headers(&self, req: &mut Request<()>, auth: &AuthConfig) -> Result<()> {\n        match auth {\n            AuthConfig::ApiKey(api_key) => {\n                if api_key.location.to_ascii_lowercase() == \"header\" {\n                    let name = HeaderName::from_str(&api_key.var_name)?;\n                    req.headers_mut()\n                        .insert(name, HeaderValue::from_str(&api_key.api_key)?);\n                } else if api_key.location.to_ascii_lowercase() == \"cookie\" {\n                    let cookie_val = format!(\"{}={}\", api_key.var_name, api_key.api_key);\n                    req.headers_mut()\n                        .insert(\"cookie\", HeaderValue::from_str(&cookie_val)?);\n                }\n                Ok(())\n            }\n            AuthConfig::Basic(basic) => {\n                let encoded = base64::engine::general_purpose::STANDARD\n                    .encode(format!(\"{}:{}\", basic.username, basic.password));\n                req.headers_mut().insert(\n                    \"authorization\",\n                    HeaderValue::from_str(&format!(\"Basic {}\", encoded))?,\n                );\n                Ok(())\n            }\n            AuthConfig::OAuth2(_) => Err(anyhow!(\n                \"OAuth2 auth is not yet supported by the WebSocket transport\"\n            )),\n        }\n    }\n\n    fn build_request(&self, prov: &WebSocketProvider, url: &str) -> Result<Request<()>> {\n        let mut url = url.to_string();\n        if let Some(auth) = &prov.base.auth {\n            url = self.apply_auth_to_url(&url, auth)?;\n        }\n\n        let mut req = url.into_client_request()?;\n        if let Some(headers) = &prov.headers {\n            for (k, v) in headers {\n                let name = HeaderName::from_str(k)?;\n                req.headers_mut().insert(name, HeaderValue::from_str(v)?);\n            }\n        }\n        if let Some(proto) = &prov.protocol {\n            req.headers_mut()\n                .insert(\"Sec-WebSocket-Protocol\", HeaderValue::from_str(proto)?);\n        }\n        if let Some(auth) = &prov.base.auth {\n            self.apply_auth_headers(&mut req, auth)?;\n        }\n        Ok(req)\n    }\n}\n\n#[async_trait]\nimpl ClientTransport for WebSocketTransport {\n    async fn register_tool_provider(&self, prov: &dyn Provider) -> Result<Vec<Tool>> {\n        let ws_prov = prov\n            .as_any()\n            .downcast_ref::<WebSocketProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not a WebSocketProvider\"))?;\n\n        let req = self.build_request(ws_prov, &ws_prov.url)?;\n        let (mut ws_stream, _) = connect_async(req).await?;\n\n        // Request manual/tool list\n        ws_stream.send(Message::Text(\"manual\".to_string())).await?;\n        if let Some(msg) = ws_stream.next().await {\n            if let Ok(Message::Text(text)) = msg {\n                if let Ok(manifest) = serde_json::from_str::<Value>(&text) {\n                    if let Some(tools) = manifest.get(\"tools\").and_then(|v| v.as_array()) {\n                        let mut parsed = Vec::new();\n                        for t in tools {\n                            if let Ok(tool) = serde_json::from_value::<Tool>(t.clone()) {\n                                parsed.push(tool);\n                            } else if let Some(name) = t.get(\"name\").and_then(|v| v.as_str()) {\n                                let schema = Self::default_schema();\n                                parsed.push(Tool {\n                                    name: name.to_string(),\n                                    description: t\n                                        .get(\"description\")\n                                        .and_then(|v| v.as_str())\n                                        .unwrap_or_default()\n                                        .to_string(),\n                                    inputs: schema.clone(),\n                                    outputs: schema,\n                                    tags: vec![],\n                                    average_response_size: None,\n                                    provider: None,\n                                });\n                            }\n                        }\n                        return Ok(parsed);\n                    }\n                }\n            }\n        }\n\n        Ok(vec![])\n    }\n\n    async fn deregister_tool_provider(&self, _prov: &dyn Provider) -> Result<()> {\n        Ok(())\n    }\n\n    async fn call_tool(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, Value>,\n        prov: &dyn Provider,\n    ) -> Result<Value> {\n        let ws_prov = prov\n            .as_any()\n            .downcast_ref::<WebSocketProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not a WebSocketProvider\"))?;\n\n        let call_name = tool_name\n            .strip_prefix(&format!(\"{}.\", ws_prov.base.name))\n            .unwrap_or(tool_name);\n\n        let mut base_url = ws_prov.url.trim_end_matches('/').to_string();\n        if base_url.ends_with(\"/tools\") {\n            base_url = base_url.trim_end_matches(\"/tools\").to_string();\n        }\n        let url = format!(\"{}/{}\", base_url, call_name);\n\n        let req = self.build_request(ws_prov, &url)?;\n        let (mut ws_stream, _) = connect_async(req).await?;\n\n        let payload = serde_json::to_string(&args)?;\n        ws_stream.send(Message::Text(payload)).await?;\n\n        let mut results = Vec::new();\n        while let Some(msg) = ws_stream.next().await {\n            match msg {\n                Ok(Message::Text(text)) => {\n                    let value = serde_json::from_str::<Value>(&text)\n                        .unwrap_or_else(|_| Value::String(text));\n                    results.push(value);\n                }\n                Ok(Message::Binary(bin)) => {\n                    if let Ok(text) = String::from_utf8(bin) {\n                        let value = serde_json::from_str::<Value>(&text)\n                            .unwrap_or_else(|_| Value::String(text));\n                        results.push(value);\n                    }\n                }\n                Ok(Message::Close(_)) | Err(_) => break,\n                _ => {}\n            }\n        }\n\n        Ok(Value::Array(results))\n    }\n\n    async fn call_tool_stream(\n        &self,\n        tool_name: &str,\n        args: HashMap<String, Value>,\n        prov: &dyn Provider,\n    ) -> Result<Box<dyn StreamResult>> {\n        let ws_prov = prov\n            .as_any()\n            .downcast_ref::<WebSocketProvider>()\n            .ok_or_else(|| anyhow!(\"Provider is not a WebSocketProvider\"))?;\n\n        let call_name = tool_name\n            .strip_prefix(&format!(\"{}.\", ws_prov.base.name))\n            .unwrap_or(tool_name);\n\n        let mut base_url = ws_prov.url.trim_end_matches('/').to_string();\n        if base_url.ends_with(\"/tools\") {\n            base_url = base_url.trim_end_matches(\"/tools\").to_string();\n        }\n        let url = format!(\"{}/{}\", base_url, call_name);\n\n        let req = self.build_request(ws_prov, &url)?;\n        let (mut ws_stream, _) = connect_async(req).await?;\n\n        ws_stream\n            .send(Message::Text(serde_json::to_string(&args)?))\n            .await?;\n\n        let (tx, rx) = mpsc::channel(256);\n        tokio::spawn(async move {\n            while let Some(msg) = ws_stream.next().await {\n                match msg {\n                    Ok(Message::Text(text)) => {\n                        let parsed = serde_json::from_str::<Value>(&text)\n                            .map_err(|e| anyhow!(\"Failed to parse WebSocket message: {}\", e));\n                        if tx.send(parsed).await.is_err() {\n                            return;\n                        }\n                    }\n                    Ok(Message::Binary(bin)) => {\n                        if let Ok(text) = String::from_utf8(bin) {\n                            let parsed = serde_json::from_str::<Value>(&text)\n                                .map_err(|e| anyhow!(\"Failed to parse WebSocket message: {}\", e));\n                            if tx.send(parsed).await.is_err() {\n                                return;\n                            }\n                        }\n                    }\n                    Ok(Message::Close(_)) => break,\n                    Ok(_) => {}\n                    Err(err) => {\n                        let _ = tx\n                            .send(Err(anyhow!(\"WebSocket receive error: {}\", err)))\n                            .await;\n                        break;\n                    }\n                }\n            }\n        });\n\n        Ok(boxed_channel_stream(rx, None))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::auth::{ApiKeyAuth, AuthType, BasicAuth};\n    use crate::providers::base::{BaseProvider, ProviderType};\n    use serde_json::json;\n    use std::sync::{\n        atomic::{AtomicUsize, Ordering},\n        Arc, Mutex,\n    };\n    use tokio::net::TcpListener;\n    use tokio_tungstenite::tungstenite::Message;\n\n    #[test]\n    fn apply_auth_to_url_appends_query_param() {\n        let transport = WebSocketTransport::new();\n        let auth = AuthConfig::ApiKey(ApiKeyAuth {\n            auth_type: AuthType::ApiKey,\n            api_key: \"token\".to_string(),\n            var_name: \"auth\".to_string(),\n            location: \"query\".to_string(),\n        });\n\n        let url = transport\n            .apply_auth_to_url(\"ws://example.com/socket\", &auth)\n            .unwrap();\n        assert!(url.contains(\"auth=token\"));\n    }\n\n    #[test]\n    fn apply_auth_headers_supports_basic_and_cookie() {\n        let transport = WebSocketTransport::new();\n\n        let basic_auth = AuthConfig::Basic(BasicAuth {\n            auth_type: AuthType::Basic,\n            username: \"user\".to_string(),\n            password: \"pass\".to_string(),\n        });\n        let mut req = \"ws://example.com\".into_client_request().unwrap();\n        transport\n            .apply_auth_headers(&mut req, &basic_auth)\n            .expect(\"basic auth applied\");\n        assert_eq!(\n            req.headers().get(\"authorization\").unwrap(),\n            \"Basic dXNlcjpwYXNz\"\n        );\n\n        let cookie_auth = AuthConfig::ApiKey(ApiKeyAuth {\n            auth_type: AuthType::ApiKey,\n            api_key: \"secret\".to_string(),\n            var_name: \"session\".to_string(),\n            location: \"cookie\".to_string(),\n        });\n        let mut req = \"ws://example.com\".into_client_request().unwrap();\n        transport\n            .apply_auth_headers(&mut req, &cookie_auth)\n            .expect(\"cookie auth applied\");\n        assert_eq!(req.headers().get(\"cookie\").unwrap(), \"session=secret\");\n    }\n\n    #[test]\n    fn build_request_includes_provider_headers_and_protocol() {\n        let transport = WebSocketTransport::new();\n        let prov = WebSocketProvider {\n            base: BaseProvider {\n                name: \"ws\".to_string(),\n                provider_type: ProviderType::Websocket,\n                auth: Some(AuthConfig::ApiKey(ApiKeyAuth {\n                    auth_type: AuthType::ApiKey,\n                    api_key: \"abc\".to_string(),\n                    var_name: \"X-Key\".to_string(),\n                    location: \"header\".to_string(),\n                })),\n                allowed_communication_protocols: None,\n            },\n            url: \"ws://example.com/socket\".to_string(),\n            protocol: Some(\"json\".to_string()),\n            keep_alive: false,\n            headers: Some(HashMap::from([(\"X-Custom\".to_string(), \"1\".to_string())])),\n        };\n\n        let req = transport.build_request(&prov, &prov.url).unwrap();\n        assert_eq!(req.uri().to_string(), prov.url);\n        assert_eq!(req.headers().get(\"X-Custom\").unwrap(), \"1\");\n        assert_eq!(req.headers().get(\"Sec-WebSocket-Protocol\").unwrap(), \"json\");\n        assert_eq!(req.headers().get(\"X-Key\").unwrap(), \"abc\");\n    }\n\n    #[tokio::test]\n    async fn register_call_and_stream_over_websocket() {\n        let listener = TcpListener::bind(\"127.0.0.1:0\").await.unwrap();\n        let addr = listener.local_addr().unwrap();\n        let counter = Arc::new(AtomicUsize::new(0));\n        let counter_clone = counter.clone();\n\n        tokio::spawn(async move {\n            for _ in 0..3 {\n                let (stream, _) = listener.accept().await.unwrap();\n                let idx = counter_clone.fetch_add(1, Ordering::SeqCst);\n                tokio::spawn(async move {\n                    let mut ws = tokio_tungstenite::accept_async(stream).await.unwrap();\n                    match idx {\n                        0 => {\n                            // Manual lookup\n                            let _ = ws.next().await;\n                            let manifest = json!({\n                                \"tools\": [{\n                                    \"name\": \"echo\",\n                                    \"description\": \"echo tool\",\n                                    \"inputs\": { \"type\": \"object\" },\n                                    \"outputs\": { \"type\": \"object\" },\n                                    \"tags\": []\n                                }]\n                            });\n                            let _ = ws.send(Message::Text(manifest.to_string())).await;\n                        }\n                        1 => {\n                            if let Some(Ok(Message::Text(text))) = ws.next().await {\n                                let parsed: Value =\n                                    serde_json::from_str(&text).unwrap_or_else(|_| Value::Null);\n                                let reply = json!({ \"echo\": parsed });\n                                let _ = ws.send(Message::Text(reply.to_string())).await;\n                                let _ = ws.close(None).await;\n                            }\n                        }\n                        _ => {\n                            let _ = ws.next().await;\n                            let _ = ws\n                                .send(Message::Text(json!({ \"idx\": 1 }).to_string()))\n                                .await;\n                            let _ = ws\n                                .send(Message::Text(json!({ \"idx\": 2 }).to_string()))\n                                .await;\n                            let _ = ws.close(None).await;\n                        }\n                    }\n                });\n            }\n        });\n\n        let prov = WebSocketProvider {\n            base: BaseProvider {\n                name: \"ws\".to_string(),\n                provider_type: ProviderType::Websocket,\n                auth: None,\n                allowed_communication_protocols: None,\n            },\n            url: format!(\"ws://{}/tools\", addr),\n            protocol: None,\n            keep_alive: false,\n            headers: None,\n        };\n\n        let transport = WebSocketTransport::new();\n\n        let tools = transport\n            .register_tool_provider(&prov)\n            .await\n            .expect(\"register tools\");\n        assert_eq!(tools.len(), 1);\n        assert_eq!(tools[0].name, \"echo\");\n\n        let mut args = HashMap::new();\n        args.insert(\"msg\".into(), Value::String(\"hello\".into()));\n\n        let call_value = transport\n            .call_tool(\"echo\", args.clone(), &prov)\n            .await\n            .expect(\"call tool\");\n        assert_eq!(call_value, json!([json!({ \"echo\": json!(args) })]));\n\n        let mut stream = transport\n            .call_tool_stream(\"stream\", args, &prov)\n            .await\n            .expect(\"call tool stream\");\n        assert_eq!(stream.next().await.unwrap().unwrap(), json!({ \"idx\": 1 }));\n        assert_eq!(stream.next().await.unwrap().unwrap(), json!({ \"idx\": 2 }));\n        stream.close().await.unwrap();\n    }\n\n    #[tokio::test]\n    async fn websocket_strips_provider_prefix() {\n        use tokio_tungstenite::tungstenite::handshake::server::{Request, Response};\n\n        let listener = TcpListener::bind(\"127.0.0.1:0\").await.unwrap();\n        let addr = listener.local_addr().unwrap();\n        let seen_paths = Arc::new(Mutex::new(Vec::new()));\n        let seen_paths_clone = seen_paths.clone();\n\n        tokio::spawn(async move {\n            for idx in 0..2 {\n                let (stream, _) = listener.accept().await.unwrap();\n                let seen_paths = seen_paths_clone.clone();\n                tokio::spawn(async move {\n                    let cb = |req: &Request, resp: Response| {\n                        if let Ok(mut guard) = seen_paths.lock() {\n                            guard.push(req.uri().path().to_string());\n                        }\n                        Ok(resp)\n                    };\n                    let mut ws = tokio_tungstenite::accept_hdr_async(stream, cb)\n                        .await\n                        .unwrap();\n\n                    if idx == 0 {\n                        if let Some(Ok(Message::Text(msg))) = ws.next().await {\n                            if msg == \"manual\" {\n                                let manifest = json!({\n                                    \"tools\": [{\n                                        \"name\": \"echo\",\n                                        \"description\": \"echo tool\",\n                                        \"inputs\": { \"type\": \"object\" },\n                                        \"outputs\": { \"type\": \"object\" },\n                                        \"tags\": []\n                                    }]\n                                });\n                                let _ = ws.send(Message::Text(manifest.to_string())).await;\n                            }\n                        }\n                    } else {\n                        if let Some(Ok(Message::Text(text))) = ws.next().await {\n                            let val: Value =\n                                serde_json::from_str(&text).unwrap_or_else(|_| Value::Null);\n                            let _ = ws\n                                .send(Message::Text(json!({ \"echo\": val }).to_string()))\n                                .await;\n                            let _ = ws.close(None).await;\n                        }\n                    }\n                });\n            }\n        });\n\n        let prov = WebSocketProvider {\n            base: BaseProvider {\n                name: \"wsdemo\".to_string(),\n                provider_type: ProviderType::Websocket,\n                auth: None,\n                allowed_communication_protocols: None,\n            },\n            url: format!(\"ws://{}/tools\", addr),\n            protocol: None,\n            keep_alive: false,\n            headers: None,\n        };\n\n        let transport = WebSocketTransport::new();\n        let tools = transport\n            .register_tool_provider(&prov)\n            .await\n            .expect(\"register tools\");\n        assert_eq!(tools.len(), 1);\n        assert_eq!(tools[0].name, \"echo\");\n\n        let mut args = HashMap::new();\n        args.insert(\"msg\".into(), Value::String(\"hi\".into()));\n        let value = transport\n            .call_tool(\"wsdemo.echo\", args.clone(), &prov)\n            .await\n            .expect(\"prefixed call\");\n        assert_eq!(value, json!([json!({ \"echo\": json!(args) })]));\n\n        let paths = seen_paths.lock().unwrap().clone();\n        assert_eq!(paths, vec![\"/tools\".to_string(), \"/echo\".to_string()]);\n    }\n}\n",
      "line_count": 555,
      "word_count": 1387,
      "title": "Mod.Rs",
      "summary": "// WebSocket Transport - bidirectional communication use anyhow::{anyhow, Result};",
      "key_terms": [
        "close",
        "ClientTransport",
        "Result",
        "futures",
        "paths",
        "async",
        "bidirectional",
        "headers",
        "error",
        "abc",
        "list",
        "token",
        "WebSocket",
        "prov",
        "tx",
        "receive",
        "format",
        "cookie",
        "websocket",
        "encoded"
      ],
      "timestamp": "2025-12-24T18:56:15.944779"
    }
  ],
  "timestamp": "2025-12-24T18:56:15.944779"
}