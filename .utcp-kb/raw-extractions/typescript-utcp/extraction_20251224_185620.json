{
  "repository": "typescript-utcp",
  "commit_hash": "18dbc5f4ae2e646e86cd567bc743c03a802ce9e5",
  "commit_timestamp": "1765356895",
  "file_count": 120,
  "extractions": [
    {
      "file_path": "UPSTREAM\\typescript-utcp\\IMPORTS-GUIDE.md",
      "content_type": "documentation",
      "content": "# How to Import UTCP Packages\n\n## ✅ Fixed Export Configuration\n\nYour packages now use the **standard library pattern** - all exports go through the main entry point.\n\n## Correct Import Usage\n\n### ✅ Import from Main Entry Point\n\n```typescript\n// ✅ CORRECT - Import from package root\nimport { UtcpClient, ToolDefinition, CallTemplate } from '@utcp/sdk';\nimport { McpCommunicationProtocol } from '@utcp/mcp';\nimport { TextCallTemplate } from '@utcp/text';\nimport { HttpCommunicationProtocol } from '@utcp/http';\nimport { CliCallTemplate } from '@utcp/cli';\n```\n\n### ❌ Don't Import from Subpaths\n\n```typescript\n// ❌ WRONG - Don't import from dist or subpaths\nimport { ToolDefinition } from '@utcp/sdk';\nimport { ToolDefinition } from '@utcp/sdk/data';\n```\n\n## Why This Is Better\n\n### 1. **Standard Library Pattern**\nThis is how all major libraries work:\n- `import { z } from 'zod'` (not `'zod/types'`)\n- `import { format } from 'date-fns'` (not `'date-fns/format'`)\n- `import React from 'react'` (not `'react/components'`)\n\n### 2. **Simpler API**\nUsers only need to remember one import path per package.\n\n### 3. **Better Tree-Shaking**\nModern bundlers can tree-shake unused exports from the main entry point automatically.\n\n### 4. **Prevents Breaking Changes**\nInternal file structure can change without breaking user code.\n\n## Package Exports Summary\n\n### @utcp/sdk (Core Package)\n```typescript\nimport {\n  // Client\n  UtcpClient,\n  UtcpClientConfig,\n  \n  // Data Models\n  Auth,\n  CallTemplate,\n  Tool,\n  ToolDefinition,\n  UtcpManual,\n  RegisterManualResult,\n  \n  // Interfaces\n  CommunicationProtocol,\n  ConcurrentToolRepository,\n  Serializer,\n  ToolSearchStrategy,\n  VariableSubstitutor,\n  \n  // Implementations\n  InMemConcurrentToolRepository,\n  TagSearchStrategy,\n  \n  // Plugins\n  PluginLoader\n} from '@utcp/sdk';\n```\n\n### @utcp/mcp\n```typescript\nimport {\n  McpCommunicationProtocol,\n  McpCallTemplate\n} from '@utcp/mcp';\n```\n\n### @utcp/text\n```typescript\nimport {\n  TextCommunicationProtocol,\n  TextCallTemplate,\n  TextCallTemplateSerializer\n} from '@utcp/text';\n```\n\n### @utcp/http\n```typescript\nimport {\n  HttpCommunicationProtocol,\n  HttpCallTemplate,\n  OpenApiConverter,\n  SseCommunicationProtocol,\n  SseCallTemplate,\n  StreamableHttpCommunicationProtocol,\n  StreamableHttpCallTemplate\n} from '@utcp/http';\n```\n\n### @utcp/cli\n```typescript\nimport {\n  CliCommunicationProtocol,\n  CliCallTemplate\n} from '@utcp/cli';\n```\n\n## TypeScript IntelliSense\n\nYour IDE will show all available exports when you start typing:\n\n```typescript\nimport { /* Ctrl+Space to see all exports */ } from '@utcp/sdk';\n```\n\n## Configuration Changes Made\n\n### Before (Problematic)\n```json\n{\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/index.js\"\n    },\n    \"./*\": {\n      \"import\": \"./dist/*.js\"  // ❌ This caused @utcp/sdk/dist/ imports\n    }\n  }\n}\n```\n\n### After (Fixed)\n```json\n{\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/index.js\",\n      \"types\": \"./dist/index.d.ts\"\n    }\n  }\n}\n```\n\n## Re-Publishing\n\nAfter these changes, you should publish new patch versions:\n\n```bash\n# Update version in each package.json (1.0.1 -> 1.0.2)\nbun run rebuild\nbun run publish:all\n```\n\n## Migration Guide for Existing Users\n\nIf users were importing from subpaths, they need to update:\n\n```typescript\n// Before\nimport { ToolDefinition } from '@utcp/sdk';\n\n// After\nimport { ToolDefinition } from '@utcp/sdk';\n```\n\nThis is a one-line change and follows standard npm package conventions.\n",
      "line_count": 175,
      "word_count": 437,
      "title": "How to Import UTCP Packages",
      "summary": "Your packages now use the **standard library pattern** - all exports go through the main entry point. // ✅ CORRECT - Import from package root",
      "key_terms": [
        "packages",
        "entry",
        "Interfaces",
        "After",
        "each",
        "If",
        "pattern",
        "through",
        "importing",
        "major",
        "index",
        "format",
        "Utcp",
        "available",
        "fns",
        "only",
        "ConcurrentToolRepository",
        "Migration",
        "VariableSubstitutor",
        "RegisterManualResult"
      ],
      "timestamp": "2025-12-24T18:56:16.319784"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\package-lock.json",
      "content_type": "configuration",
      "content": "{\n  \"name\": \"typescript-utcp\",\n  \"lockfileVersion\": 3,\n  \"requires\": true,\n  \"packages\": {\n    \"\": {\n      \"name\": \"typescript-utcp\",\n      \"workspaces\": [\n        \"packages/*\"\n      ],\n      \"devDependencies\": {\n        \"@types/js-yaml\": \"^4.0.9\",\n        \"bun-types\": \"^1.2.22\",\n        \"nock\": \"^14.0.10\",\n        \"tsup\": \"^8.5.0\",\n        \"zod\": \"^3.25.76\"\n      },\n      \"peerDependencies\": {\n        \"typescript\": \"^5.9.2\",\n        \"zod\": \"^3.23.8\"\n      }\n    },\n    \"node_modules/@apidevtools/json-schema-ref-parser\": {\n      \"version\": \"15.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/@apidevtools/json-schema-ref-parser/-/json-schema-ref-parser-15.1.2.tgz\",\n      \"integrity\": \"sha512-54vnqDyGsDAVM0LOIdGMnfVyCN1NlqoGnHEGpMfaDBLMvClfT4j2XbJgvfuF0Ca0kxT6Gb7xUgS5W1I14QqjiQ==\",\n      \"dependencies\": {\n        \"js-yaml\": \"^4.1.1\"\n      },\n      \"engines\": {\n        \"node\": \">=20\"\n      },\n      \"peerDependencies\": {\n        \"@types/json-schema\": \"^7.0.15\"\n      }\n    },\n    \"node_modules/@esbuild/aix-ppc64\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.25.11.tgz\",\n      \"integrity\": \"sha512-Xt1dOL13m8u0WE8iplx9Ibbm+hFAO0GsU2P34UNoDGvZYkY8ifSiy6Zuc1lYxfG7svWE2fzqCUmFp5HCn51gJg==\",\n      \"cpu\": [\n        \"ppc64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"aix\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/android-arm\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.25.11.tgz\",\n      \"integrity\": \"sha512-uoa7dU+Dt3HYsethkJ1k6Z9YdcHjTrSb5NUy66ZfZaSV8hEYGD5ZHbEMXnqLFlbBflLsl89Zke7CAdDJ4JI+Gg==\",\n      \"cpu\": [\n        \"arm\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"android\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/android-arm64\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.25.11.tgz\",\n      \"integrity\": \"sha512-9slpyFBc4FPPz48+f6jyiXOx/Y4v34TUeDDXJpZqAWQn/08lKGeD8aDp9TMn9jDz2CiEuHwfhRmGBvpnd/PWIQ==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"android\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/android-x64\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.25.11.tgz\",\n      \"integrity\": \"sha512-Sgiab4xBjPU1QoPEIqS3Xx+R2lezu0LKIEcYe6pftr56PqPygbB7+szVnzoShbx64MUupqoE0KyRlN7gezbl8g==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"android\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/darwin-arm64\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.25.11.tgz\",\n      \"integrity\": \"sha512-VekY0PBCukppoQrycFxUqkCojnTQhdec0vevUL/EDOCnXd9LKWqD/bHwMPzigIJXPhC59Vd1WFIL57SKs2mg4w==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"darwin\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/darwin-x64\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.25.11.tgz\",\n      \"integrity\": \"sha512-+hfp3yfBalNEpTGp9loYgbknjR695HkqtY3d3/JjSRUyPg/xd6q+mQqIb5qdywnDxRZykIHs3axEqU6l1+oWEQ==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"darwin\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/freebsd-arm64\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.25.11.tgz\",\n      \"integrity\": \"sha512-CmKjrnayyTJF2eVuO//uSjl/K3KsMIeYeyN7FyDBjsR3lnSJHaXlVoAK8DZa7lXWChbuOk7NjAc7ygAwrnPBhA==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"freebsd\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/freebsd-x64\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.25.11.tgz\",\n      \"integrity\": \"sha512-Dyq+5oscTJvMaYPvW3x3FLpi2+gSZTCE/1ffdwuM6G1ARang/mb3jvjxs0mw6n3Lsw84ocfo9CrNMqc5lTfGOw==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"freebsd\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/linux-arm\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.25.11.tgz\",\n      \"integrity\": \"sha512-TBMv6B4kCfrGJ8cUPo7vd6NECZH/8hPpBHHlYI3qzoYFvWu2AdTvZNuU/7hsbKWqu/COU7NIK12dHAAqBLLXgw==\",\n      \"cpu\": [\n        \"arm\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/linux-arm64\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.25.11.tgz\",\n      \"integrity\": \"sha512-Qr8AzcplUhGvdyUF08A1kHU3Vr2O88xxP0Tm8GcdVOUm25XYcMPp2YqSVHbLuXzYQMf9Bh/iKx7YPqECs6ffLA==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/linux-ia32\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.25.11.tgz\",\n      \"integrity\": \"sha512-TmnJg8BMGPehs5JKrCLqyWTVAvielc615jbkOirATQvWWB1NMXY77oLMzsUjRLa0+ngecEmDGqt5jiDC6bfvOw==\",\n      \"cpu\": [\n        \"ia32\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/linux-loong64\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.25.11.tgz\",\n      \"integrity\": \"sha512-DIGXL2+gvDaXlaq8xruNXUJdT5tF+SBbJQKbWy/0J7OhU8gOHOzKmGIlfTTl6nHaCOoipxQbuJi7O++ldrxgMw==\",\n      \"cpu\": [\n        \"loong64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/linux-mips64el\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.25.11.tgz\",\n      \"integrity\": \"sha512-Osx1nALUJu4pU43o9OyjSCXokFkFbyzjXb6VhGIJZQ5JZi8ylCQ9/LFagolPsHtgw6himDSyb5ETSfmp4rpiKQ==\",\n      \"cpu\": [\n        \"mips64el\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/linux-ppc64\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.25.11.tgz\",\n      \"integrity\": \"sha512-nbLFgsQQEsBa8XSgSTSlrnBSrpoWh7ioFDUmwo158gIm5NNP+17IYmNWzaIzWmgCxq56vfr34xGkOcZ7jX6CPw==\",\n      \"cpu\": [\n        \"ppc64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/linux-riscv64\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.25.11.tgz\",\n      \"integrity\": \"sha512-HfyAmqZi9uBAbgKYP1yGuI7tSREXwIb438q0nqvlpxAOs3XnZ8RsisRfmVsgV486NdjD7Mw2UrFSw51lzUk1ww==\",\n      \"cpu\": [\n        \"riscv64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/linux-s390x\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.25.11.tgz\",\n      \"integrity\": \"sha512-HjLqVgSSYnVXRisyfmzsH6mXqyvj0SA7pG5g+9W7ESgwA70AXYNpfKBqh1KbTxmQVaYxpzA/SvlB9oclGPbApw==\",\n      \"cpu\": [\n        \"s390x\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/linux-x64\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.25.11.tgz\",\n      \"integrity\": \"sha512-HSFAT4+WYjIhrHxKBwGmOOSpphjYkcswF449j6EjsjbinTZbp8PJtjsVK1XFJStdzXdy/jaddAep2FGY+wyFAQ==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/netbsd-arm64\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/netbsd-arm64/-/netbsd-arm64-0.25.11.tgz\",\n      \"integrity\": \"sha512-hr9Oxj1Fa4r04dNpWr3P8QKVVsjQhqrMSUzZzf+LZcYjZNqhA3IAfPQdEh1FLVUJSiu6sgAwp3OmwBfbFgG2Xg==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"netbsd\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/netbsd-x64\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.25.11.tgz\",\n      \"integrity\": \"sha512-u7tKA+qbzBydyj0vgpu+5h5AeudxOAGncb8N6C9Kh1N4n7wU1Xw1JDApsRjpShRpXRQlJLb9wY28ELpwdPcZ7A==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"netbsd\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/openbsd-arm64\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/openbsd-arm64/-/openbsd-arm64-0.25.11.tgz\",\n      \"integrity\": \"sha512-Qq6YHhayieor3DxFOoYM1q0q1uMFYb7cSpLD2qzDSvK1NAvqFi8Xgivv0cFC6J+hWVw2teCYltyy9/m/14ryHg==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"openbsd\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/openbsd-x64\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.25.11.tgz\",\n      \"integrity\": \"sha512-CN+7c++kkbrckTOz5hrehxWN7uIhFFlmS/hqziSFVWpAzpWrQoAG4chH+nN3Be+Kzv/uuo7zhX716x3Sn2Jduw==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"openbsd\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/openharmony-arm64\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/openharmony-arm64/-/openharmony-arm64-0.25.11.tgz\",\n      \"integrity\": \"sha512-rOREuNIQgaiR+9QuNkbkxubbp8MSO9rONmwP5nKncnWJ9v5jQ4JxFnLu4zDSRPf3x4u+2VN4pM4RdyIzDty/wQ==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"openharmony\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/sunos-x64\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.25.11.tgz\",\n      \"integrity\": \"sha512-nq2xdYaWxyg9DcIyXkZhcYulC6pQ2FuCgem3LI92IwMgIZ69KHeY8T4Y88pcwoLIjbed8n36CyKoYRDygNSGhA==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"sunos\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/win32-arm64\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.25.11.tgz\",\n      \"integrity\": \"sha512-3XxECOWJq1qMZ3MN8srCJ/QfoLpL+VaxD/WfNRm1O3B4+AZ/BnLVgFbUV3eiRYDMXetciH16dwPbbHqwe1uU0Q==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"win32\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/win32-ia32\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.25.11.tgz\",\n      \"integrity\": \"sha512-3ukss6gb9XZ8TlRyJlgLn17ecsK4NSQTmdIXRASVsiS2sQ6zPPZklNJT5GR5tE/MUarymmy8kCEf5xPCNCqVOA==\",\n      \"cpu\": [\n        \"ia32\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"win32\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@esbuild/win32-x64\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.25.11.tgz\",\n      \"integrity\": \"sha512-D7Hpz6A2L4hzsRpPaCYkQnGOotdUpDzSGRIv9I+1ITdHROSFUWW95ZPZWQmGka1Fg7W3zFJowyn9WGwMJ0+KPA==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"win32\"\n      ],\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@isaacs/cliui\": {\n      \"version\": \"8.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz\",\n      \"integrity\": \"sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==\",\n      \"dev\": true,\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"string-width\": \"^5.1.2\",\n        \"string-width-cjs\": \"npm:string-width@^4.2.0\",\n        \"strip-ansi\": \"^7.0.1\",\n        \"strip-ansi-cjs\": \"npm:strip-ansi@^6.0.1\",\n        \"wrap-ansi\": \"^8.1.0\",\n        \"wrap-ansi-cjs\": \"npm:wrap-ansi@^7.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@jridgewell/gen-mapping\": {\n      \"version\": \"0.3.13\",\n      \"resolved\": \"https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz\",\n      \"integrity\": \"sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@jridgewell/sourcemap-codec\": \"^1.5.0\",\n        \"@jridgewell/trace-mapping\": \"^0.3.24\"\n      }\n    },\n    \"node_modules/@jridgewell/resolve-uri\": {\n      \"version\": \"3.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz\",\n      \"integrity\": \"sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=6.0.0\"\n      }\n    },\n    \"node_modules/@jridgewell/sourcemap-codec\": {\n      \"version\": \"1.5.5\",\n      \"resolved\": \"https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz\",\n      \"integrity\": \"sha512-cYQ9310grqxueWbl+WuIUIaiUaDcj7WOq5fVhEljNVgRfOUhY9fy2zTvfoqWsnebh8Sl70VScFbICvJnLKB0Og==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/@jridgewell/trace-mapping\": {\n      \"version\": \"0.3.31\",\n      \"resolved\": \"https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz\",\n      \"integrity\": \"sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@jridgewell/resolve-uri\": \"^3.1.0\",\n        \"@jridgewell/sourcemap-codec\": \"^1.4.14\"\n      }\n    },\n    \"node_modules/@modelcontextprotocol/sdk\": {\n      \"version\": \"1.17.4\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ajv\": \"^6.12.6\",\n        \"content-type\": \"^1.0.5\",\n        \"cors\": \"^2.8.5\",\n        \"cross-spawn\": \"^7.0.5\",\n        \"eventsource\": \"^3.0.2\",\n        \"eventsource-parser\": \"^3.0.0\",\n        \"express\": \"^5.0.1\",\n        \"express-rate-limit\": \"^7.5.0\",\n        \"pkce-challenge\": \"^5.0.0\",\n        \"raw-body\": \"^3.0.0\",\n        \"zod\": \"^3.23.8\",\n        \"zod-to-json-schema\": \"^3.24.1\"\n      },\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@mswjs/interceptors\": {\n      \"version\": \"0.39.6\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@open-draft/deferred-promise\": \"^2.2.0\",\n        \"@open-draft/logger\": \"^0.3.0\",\n        \"@open-draft/until\": \"^2.0.0\",\n        \"is-node-process\": \"^1.2.0\",\n        \"outvariant\": \"^1.4.3\",\n        \"strict-event-emitter\": \"^0.5.1\"\n      },\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/@open-draft/deferred-promise\": {\n      \"version\": \"2.2.0\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/@open-draft/logger\": {\n      \"version\": \"0.3.0\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"is-node-process\": \"^1.2.0\",\n        \"outvariant\": \"^1.4.0\"\n      }\n    },\n    \"node_modules/@open-draft/until\": {\n      \"version\": \"2.1.0\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/@pkgjs/parseargs\": {\n      \"version\": \"0.11.0\",\n      \"resolved\": \"https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz\",\n      \"integrity\": \"sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"engines\": {\n        \"node\": \">=14\"\n      }\n    },\n    \"node_modules/@rollup/rollup-android-arm-eabi\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.52.5.tgz\",\n      \"integrity\": \"sha512-8c1vW4ocv3UOMp9K+gToY5zL2XiiVw3k7f1ksf4yO1FlDFQ1C2u72iACFnSOceJFsWskc2WZNqeRhFRPzv+wtQ==\",\n      \"cpu\": [\n        \"arm\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"android\"\n      ]\n    },\n    \"node_modules/@rollup/rollup-android-arm64\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.52.5.tgz\",\n      \"integrity\": \"sha512-mQGfsIEFcu21mvqkEKKu2dYmtuSZOBMmAl5CFlPGLY94Vlcm+zWApK7F/eocsNzp8tKmbeBP8yXyAbx0XHsFNA==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"android\"\n      ]\n    },\n    \"node_modules/@rollup/rollup-darwin-arm64\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.52.5.tgz\",\n      \"integrity\": \"sha512-takF3CR71mCAGA+v794QUZ0b6ZSrgJkArC+gUiG6LB6TQty9T0Mqh3m2ImRBOxS2IeYBo4lKWIieSvnEk2OQWA==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"darwin\"\n      ]\n    },\n    \"node_modules/@rollup/rollup-darwin-x64\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.52.5.tgz\",\n      \"integrity\": \"sha512-W901Pla8Ya95WpxDn//VF9K9u2JbocwV/v75TE0YIHNTbhqUTv9w4VuQ9MaWlNOkkEfFwkdNhXgcLqPSmHy0fA==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"darwin\"\n      ]\n    },\n    \"node_modules/@rollup/rollup-freebsd-arm64\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.52.5.tgz\",\n      \"integrity\": \"sha512-QofO7i7JycsYOWxe0GFqhLmF6l1TqBswJMvICnRUjqCx8b47MTo46W8AoeQwiokAx3zVryVnxtBMcGcnX12LvA==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"freebsd\"\n      ]\n    },\n    \"node_modules/@rollup/rollup-freebsd-x64\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.52.5.tgz\",\n      \"integrity\": \"sha512-jr21b/99ew8ujZubPo9skbrItHEIE50WdV86cdSoRkKtmWa+DDr6fu2c/xyRT0F/WazZpam6kk7IHBerSL7LDQ==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"freebsd\"\n      ]\n    },\n    \"node_modules/@rollup/rollup-linux-arm-gnueabihf\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.52.5.tgz\",\n      \"integrity\": \"sha512-PsNAbcyv9CcecAUagQefwX8fQn9LQ4nZkpDboBOttmyffnInRy8R8dSg6hxxl2Re5QhHBf6FYIDhIj5v982ATQ==\",\n      \"cpu\": [\n        \"arm\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ]\n    },\n    \"node_modules/@rollup/rollup-linux-arm-musleabihf\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.52.5.tgz\",\n      \"integrity\": \"sha512-Fw4tysRutyQc/wwkmcyoqFtJhh0u31K+Q6jYjeicsGJJ7bbEq8LwPWV/w0cnzOqR2m694/Af6hpFayLJZkG2VQ==\",\n      \"cpu\": [\n        \"arm\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ]\n    },\n    \"node_modules/@rollup/rollup-linux-arm64-gnu\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.52.5.tgz\",\n      \"integrity\": \"sha512-a+3wVnAYdQClOTlyapKmyI6BLPAFYs0JM8HRpgYZQO02rMR09ZcV9LbQB+NL6sljzG38869YqThrRnfPMCDtZg==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ]\n    },\n    \"node_modules/@rollup/rollup-linux-arm64-musl\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.52.5.tgz\",\n      \"integrity\": \"sha512-AvttBOMwO9Pcuuf7m9PkC1PUIKsfaAJ4AYhy944qeTJgQOqJYJ9oVl2nYgY7Rk0mkbsuOpCAYSs6wLYB2Xiw0Q==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ]\n    },\n    \"node_modules/@rollup/rollup-linux-loong64-gnu\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/@rollup/rollup-linux-loong64-gnu/-/rollup-linux-loong64-gnu-4.52.5.tgz\",\n      \"integrity\": \"sha512-DkDk8pmXQV2wVrF6oq5tONK6UHLz/XcEVow4JTTerdeV1uqPeHxwcg7aFsfnSm9L+OO8WJsWotKM2JJPMWrQtA==\",\n      \"cpu\": [\n        \"loong64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ]\n    },\n    \"node_modules/@rollup/rollup-linux-ppc64-gnu\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/@rollup/rollup-linux-ppc64-gnu/-/rollup-linux-ppc64-gnu-4.52.5.tgz\",\n      \"integrity\": \"sha512-W/b9ZN/U9+hPQVvlGwjzi+Wy4xdoH2I8EjaCkMvzpI7wJUs8sWJ03Rq96jRnHkSrcHTpQe8h5Tg3ZzUPGauvAw==\",\n      \"cpu\": [\n        \"ppc64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ]\n    },\n    \"node_modules/@rollup/rollup-linux-riscv64-gnu\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.52.5.tgz\",\n      \"integrity\": \"sha512-sjQLr9BW7R/ZiXnQiWPkErNfLMkkWIoCz7YMn27HldKsADEKa5WYdobaa1hmN6slu9oWQbB6/jFpJ+P2IkVrmw==\",\n      \"cpu\": [\n        \"riscv64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ]\n    },\n    \"node_modules/@rollup/rollup-linux-riscv64-musl\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/@rollup/rollup-linux-riscv64-musl/-/rollup-linux-riscv64-musl-4.52.5.tgz\",\n      \"integrity\": \"sha512-hq3jU/kGyjXWTvAh2awn8oHroCbrPm8JqM7RUpKjalIRWWXE01CQOf/tUNWNHjmbMHg/hmNCwc/Pz3k1T/j/Lg==\",\n      \"cpu\": [\n        \"riscv64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ]\n    },\n    \"node_modules/@rollup/rollup-linux-s390x-gnu\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.52.5.tgz\",\n      \"integrity\": \"sha512-gn8kHOrku8D4NGHMK1Y7NA7INQTRdVOntt1OCYypZPRt6skGbddska44K8iocdpxHTMMNui5oH4elPH4QOLrFQ==\",\n      \"cpu\": [\n        \"s390x\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ]\n    },\n    \"node_modules/@rollup/rollup-linux-x64-gnu\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.52.5.tgz\",\n      \"integrity\": \"sha512-hXGLYpdhiNElzN770+H2nlx+jRog8TyynpTVzdlc6bndktjKWyZyiCsuDAlpd+j+W+WNqfcyAWz9HxxIGfZm1Q==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ]\n    },\n    \"node_modules/@rollup/rollup-linux-x64-musl\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.52.5.tgz\",\n      \"integrity\": \"sha512-arCGIcuNKjBoKAXD+y7XomR9gY6Mw7HnFBv5Rw7wQRvwYLR7gBAgV7Mb2QTyjXfTveBNFAtPt46/36vV9STLNg==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ]\n    },\n    \"node_modules/@rollup/rollup-openharmony-arm64\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/@rollup/rollup-openharmony-arm64/-/rollup-openharmony-arm64-4.52.5.tgz\",\n      \"integrity\": \"sha512-QoFqB6+/9Rly/RiPjaomPLmR/13cgkIGfA40LHly9zcH1S0bN2HVFYk3a1eAyHQyjs3ZJYlXvIGtcCs5tko9Cw==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"openharmony\"\n      ]\n    },\n    \"node_modules/@rollup/rollup-win32-arm64-msvc\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.52.5.tgz\",\n      \"integrity\": \"sha512-w0cDWVR6MlTstla1cIfOGyl8+qb93FlAVutcor14Gf5Md5ap5ySfQ7R9S/NjNaMLSFdUnKGEasmVnu3lCMqB7w==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"win32\"\n      ]\n    },\n    \"node_modules/@rollup/rollup-win32-ia32-msvc\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.52.5.tgz\",\n      \"integrity\": \"sha512-Aufdpzp7DpOTULJCuvzqcItSGDH73pF3ko/f+ckJhxQyHtp67rHw3HMNxoIdDMUITJESNE6a8uh4Lo4SLouOUg==\",\n      \"cpu\": [\n        \"ia32\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"win32\"\n      ]\n    },\n    \"node_modules/@rollup/rollup-win32-x64-gnu\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/@rollup/rollup-win32-x64-gnu/-/rollup-win32-x64-gnu-4.52.5.tgz\",\n      \"integrity\": \"sha512-UGBUGPFp1vkj6p8wCRraqNhqwX/4kNQPS57BCFc8wYh0g94iVIW33wJtQAx3G7vrjjNtRaxiMUylM0ktp/TRSQ==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"win32\"\n      ]\n    },\n    \"node_modules/@rollup/rollup-win32-x64-msvc\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.52.5.tgz\",\n      \"integrity\": \"sha512-TAcgQh2sSkykPRWLrdyy2AiceMckNf5loITqXxFI5VuQjS5tSuw3WlwdN8qv8vzjLAUTvYaH/mVjSFpbkFbpTg==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"win32\"\n      ]\n    },\n    \"node_modules/@types/bun\": {\n      \"version\": \"1.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/@types/bun/-/bun-1.3.0.tgz\",\n      \"integrity\": \"sha512-+lAGCYjXjip2qY375xX/scJeVRmZ5cY0wyHYyCYxNcdEXrQ4AOe3gACgd4iQ8ksOslJtW4VNxBJ8llUwc3a6AA==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"bun-types\": \"1.3.0\"\n      }\n    },\n    \"node_modules/@types/estree\": {\n      \"version\": \"1.0.8\",\n      \"resolved\": \"https://registry.npmjs.org/@types/estree/-/estree-1.0.8.tgz\",\n      \"integrity\": \"sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/@types/js-yaml\": {\n      \"version\": \"4.0.9\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/@types/json-schema\": {\n      \"version\": \"7.0.15\",\n      \"resolved\": \"https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.15.tgz\",\n      \"integrity\": \"sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==\",\n      \"peer\": true\n    },\n    \"node_modules/@types/node\": {\n      \"version\": \"24.3.0\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"undici-types\": \"~7.10.0\"\n      }\n    },\n    \"node_modules/@types/react\": {\n      \"version\": \"19.1.12\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"peer\": true,\n      \"dependencies\": {\n        \"csstype\": \"^3.0.2\"\n      }\n    },\n    \"node_modules/@utcp/cli\": {\n      \"resolved\": \"packages/cli\",\n      \"link\": true\n    },\n    \"node_modules/@utcp/code-mode\": {\n      \"resolved\": \"packages/code-mode\",\n      \"link\": true\n    },\n    \"node_modules/@utcp/direct-call\": {\n      \"resolved\": \"packages/direct-call\",\n      \"link\": true\n    },\n    \"node_modules/@utcp/dotenv-loader\": {\n      \"resolved\": \"packages/dotenv-loader\",\n      \"link\": true\n    },\n    \"node_modules/@utcp/file\": {\n      \"resolved\": \"packages/file\",\n      \"link\": true\n    },\n    \"node_modules/@utcp/http\": {\n      \"resolved\": \"packages/http\",\n      \"link\": true\n    },\n    \"node_modules/@utcp/mcp\": {\n      \"resolved\": \"packages/mcp\",\n      \"link\": true\n    },\n    \"node_modules/@utcp/sdk\": {\n      \"resolved\": \"packages/core\",\n      \"link\": true\n    },\n    \"node_modules/@utcp/text\": {\n      \"resolved\": \"packages/text\",\n      \"link\": true\n    },\n    \"node_modules/accepts\": {\n      \"version\": \"2.0.0\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"mime-types\": \"^3.0.0\",\n        \"negotiator\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/accepts/node_modules/mime-types\": {\n      \"version\": \"3.0.1\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"mime-db\": \"^1.54.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/accepts/node_modules/mime-types/node_modules/mime-db\": {\n      \"version\": \"1.54.0\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/acorn\": {\n      \"version\": \"8.15.0\",\n      \"resolved\": \"https://registry.npmjs.org/acorn/-/acorn-8.15.0.tgz\",\n      \"integrity\": \"sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"bin\": {\n        \"acorn\": \"bin/acorn\"\n      },\n      \"engines\": {\n        \"node\": \">=0.4.0\"\n      }\n    },\n    \"node_modules/ajv\": {\n      \"version\": \"6.12.6\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"fast-deep-equal\": \"^3.1.1\",\n        \"fast-json-stable-stringify\": \"^2.0.0\",\n        \"json-schema-traverse\": \"^0.4.1\",\n        \"uri-js\": \"^4.2.2\"\n      },\n      \"funding\": {\n        \"type\": \"github\",\n        \"url\": \"https://github.com/sponsors/epoberezkin\"\n      }\n    },\n    \"node_modules/ansi-regex\": {\n      \"version\": \"6.2.2\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz\",\n      \"integrity\": \"sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/ansi-regex?sponsor=1\"\n      }\n    },\n    \"node_modules/ansi-styles\": {\n      \"version\": \"6.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.3.tgz\",\n      \"integrity\": \"sha512-4Dj6M28JB+oAH8kFkTLUo+a2jwOFkuqb3yucU0CANcRRUbxS0cP0nZYCGjcc3BNXwRIsUVmDGgzawme7zvJHvg==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/ansi-styles?sponsor=1\"\n      }\n    },\n    \"node_modules/any-promise\": {\n      \"version\": \"1.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/any-promise/-/any-promise-1.3.0.tgz\",\n      \"integrity\": \"sha512-7UvmKalWRt1wgjL1RrGxoSJW/0QZFIegpeGvZG9kjp8vrRu55XTHbwnqq2GpXm9uLbcuhxm3IqX9OB4MZR1b2A==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/argparse\": {\n      \"version\": \"2.0.1\",\n      \"license\": \"Python-2.0\"\n    },\n    \"node_modules/asynckit\": {\n      \"version\": \"0.4.0\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/axios\": {\n      \"version\": \"1.12.2\",\n      \"resolved\": \"https://registry.npmjs.org/axios/-/axios-1.12.2.tgz\",\n      \"integrity\": \"sha512-vMJzPewAlRyOgxV2dU0Cuz2O8zzzx9VYtbJOaBgXFeLc4IV/Eg50n4LowmehOOR61S8ZMpc2K5Sa7g6A4jfkUw==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"follow-redirects\": \"^1.15.6\",\n        \"form-data\": \"^4.0.4\",\n        \"proxy-from-env\": \"^1.1.0\"\n      }\n    },\n    \"node_modules/balanced-match\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz\",\n      \"integrity\": \"sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/body-parser\": {\n      \"version\": \"2.2.0\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"bytes\": \"^3.1.2\",\n        \"content-type\": \"^1.0.5\",\n        \"debug\": \"^4.4.0\",\n        \"http-errors\": \"^2.0.0\",\n        \"iconv-lite\": \"^0.6.3\",\n        \"on-finished\": \"^2.4.1\",\n        \"qs\": \"^6.14.0\",\n        \"raw-body\": \"^3.0.0\",\n        \"type-is\": \"^2.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=18\"\n      }\n    },\n    \"node_modules/brace-expansion\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.2.tgz\",\n      \"integrity\": \"sha512-Jt0vHyM+jmUBqojB7E1NIYadt0vI0Qxjxd2TErW94wDz+E2LAm5vKMXXwg6ZZBTHPuUlDgQHKXvjGBdfcF1ZDQ==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"balanced-match\": \"^1.0.0\"\n      }\n    },\n    \"node_modules/bun-types\": {\n      \"version\": \"1.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/bun-types/-/bun-types-1.3.0.tgz\",\n      \"integrity\": \"sha512-u8X0thhx+yJ0KmkxuEo9HAtdfgCBaM/aI9K90VQcQioAmkVp3SG3FkwWGibUFz3WdXAdcsqOcbU40lK7tbHdkQ==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@types/node\": \"*\"\n      },\n      \"peerDependencies\": {\n        \"@types/react\": \"^19\"\n      }\n    },\n    \"node_modules/bundle-require\": {\n      \"version\": \"5.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/bundle-require/-/bundle-require-5.1.0.tgz\",\n      \"integrity\": \"sha512-3WrrOuZiyaaZPWiEt4G3+IffISVC9HYlWueJEBWED4ZH4aIAC2PnkdnuRrR94M+w6yGWn4AglWtJtBI8YqvgoA==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"load-tsconfig\": \"^0.2.3\"\n      },\n      \"engines\": {\n        \"node\": \"^12.20.0 || ^14.13.1 || >=16.0.0\"\n      },\n      \"peerDependencies\": {\n        \"esbuild\": \">=0.18\"\n      }\n    },\n    \"node_modules/bytes\": {\n      \"version\": \"3.1.2\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/cac\": {\n      \"version\": \"6.7.14\",\n      \"resolved\": \"https://registry.npmjs.org/cac/-/cac-6.7.14.tgz\",\n      \"integrity\": \"sha512-b6Ilus+c3RrdDk+JhLKUAQfzzgLEPy6wcXqS7f/xe1EETvsDP6GORG7SFuOs6cID5YkqchW/LXZbX5bc8j7ZcQ==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/call-bind-apply-helpers\": {\n      \"version\": \"1.0.2\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"es-errors\": \"^1.3.0\",\n        \"function-bind\": \"^1.1.2\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/call-bound\": {\n      \"version\": \"1.0.4\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"call-bind-apply-helpers\": \"^1.0.2\",\n        \"get-intrinsic\": \"^1.3.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/chokidar\": {\n      \"version\": \"4.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/chokidar/-/chokidar-4.0.3.tgz\",\n      \"integrity\": \"sha512-Qgzu8kfBvo+cA4962jnP1KkS6Dop5NS6g7R5LFYJr4b8Ub94PPQXUksCw9PvXoeXPRRddRNC5C1JQUR2SMGtnA==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"readdirp\": \"^4.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 14.16.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://paulmillr.com/funding/\"\n      }\n    },\n    \"node_modules/color-convert\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz\",\n      \"integrity\": \"sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"color-name\": \"~1.1.4\"\n      },\n      \"engines\": {\n        \"node\": \">=7.0.0\"\n      }\n    },\n    \"node_modules/color-name\": {\n      \"version\": \"1.1.4\",\n      \"resolved\": \"https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz\",\n      \"integrity\": \"sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/combined-stream\": {\n      \"version\": \"1.0.8\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"delayed-stream\": \"~1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/commander\": {\n      \"version\": \"4.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/commander/-/commander-4.1.1.tgz\",\n      \"integrity\": \"sha512-NOKm8xhkzAjzFx8B2v5OAHT+u5pRQc2UCa2Vq9jYL/31o2wi9mxBA7LIFs3sV5VSC49z6pEhfbMULvShKj26WA==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 6\"\n      }\n    },\n    \"node_modules/confbox\": {\n      \"version\": \"0.1.8\",\n      \"resolved\": \"https://registry.npmjs.org/confbox/-/confbox-0.1.8.tgz\",\n      \"integrity\": \"sha512-RMtmw0iFkeR4YV+fUOSucriAQNb9g8zFR52MWCtl+cCZOFRNL6zeB395vPzFhEjjn4fMxXudmELnl/KF/WrK6w==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/consola\": {\n      \"version\": \"3.4.2\",\n      \"resolved\": \"https://registry.npmjs.org/consola/-/consola-3.4.2.tgz\",\n      \"integrity\": \"sha512-5IKcdX0nnYavi6G7TtOhwkYzyjfJlatbjMjuLSfE2kYT5pMDOilZ4OvMhi637CcDICTmz3wARPoyhqyX1Y+XvA==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"^14.18.0 || >=16.10.0\"\n      }\n    },\n    \"node_modules/content-disposition\": {\n      \"version\": \"1.0.0\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"safe-buffer\": \"5.2.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/content-type\": {\n      \"version\": \"1.0.5\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/cookie\": {\n      \"version\": \"0.7.2\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/cookie-signature\": {\n      \"version\": \"1.2.2\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=6.6.0\"\n      }\n    },\n    \"node_modules/cors\": {\n      \"version\": \"2.8.5\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"object-assign\": \"^4\",\n        \"vary\": \"^1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.10\"\n      }\n    },\n    \"node_modules/cross-spawn\": {\n      \"version\": \"7.0.6\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"path-key\": \"^3.1.0\",\n        \"shebang-command\": \"^2.0.0\",\n        \"which\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 8\"\n      }\n    },\n    \"node_modules/csstype\": {\n      \"version\": \"3.1.3\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"peer\": true\n    },\n    \"node_modules/debug\": {\n      \"version\": \"4.4.1\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ms\": \"^2.1.3\"\n      },\n      \"engines\": {\n        \"node\": \">=6.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"supports-color\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/delayed-stream\": {\n      \"version\": \"1.0.0\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=0.4.0\"\n      }\n    },\n    \"node_modules/depd\": {\n      \"version\": \"2.0.0\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/dotenv\": {\n      \"version\": \"17.2.1\",\n      \"license\": \"BSD-2-Clause\",\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://dotenvx.com\"\n      }\n    },\n    \"node_modules/dunder-proto\": {\n      \"version\": \"1.0.1\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"call-bind-apply-helpers\": \"^1.0.1\",\n        \"es-errors\": \"^1.3.0\",\n        \"gopd\": \"^1.2.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/eastasianwidth\": {\n      \"version\": \"0.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz\",\n      \"integrity\": \"sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/ee-first\": {\n      \"version\": \"1.1.1\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/emoji-regex\": {\n      \"version\": \"9.2.2\",\n      \"resolved\": \"https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz\",\n      \"integrity\": \"sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/encodeurl\": {\n      \"version\": \"2.0.0\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/es-define-property\": {\n      \"version\": \"1.0.1\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/es-errors\": {\n      \"version\": \"1.3.0\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/es-object-atoms\": {\n      \"version\": \"1.1.1\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"es-errors\": \"^1.3.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/es-set-tostringtag\": {\n      \"version\": \"2.1.0\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"es-errors\": \"^1.3.0\",\n        \"get-intrinsic\": \"^1.2.6\",\n        \"has-tostringtag\": \"^1.0.2\",\n        \"hasown\": \"^2.0.2\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/esbuild\": {\n      \"version\": \"0.25.11\",\n      \"resolved\": \"https://registry.npmjs.org/esbuild/-/esbuild-0.25.11.tgz\",\n      \"integrity\": \"sha512-KohQwyzrKTQmhXDW1PjCv3Tyspn9n5GcY2RTDqeORIdIJY8yKIF7sTSopFmn/wpMPW4rdPXI0UE5LJLuq3bx0Q==\",\n      \"dev\": true,\n      \"hasInstallScript\": true,\n      \"license\": \"MIT\",\n      \"bin\": {\n        \"esbuild\": \"bin/esbuild\"\n      },\n      \"engines\": {\n        \"node\": \">=18\"\n      },\n      \"optionalDependencies\": {\n        \"@esbuild/aix-ppc64\": \"0.25.11\",\n        \"@esbuild/android-arm\": \"0.25.11\",\n        \"@esbuild/android-arm64\": \"0.25.11\",\n        \"@esbuild/android-x64\": \"0.25.11\",\n        \"@esbuild/darwin-arm64\": \"0.25.11\",\n        \"@esbuild/darwin-x64\": \"0.25.11\",\n        \"@esbuild/freebsd-arm64\": \"0.25.11\",\n        \"@esbuild/freebsd-x64\": \"0.25.11\",\n        \"@esbuild/linux-arm\": \"0.25.11\",\n        \"@esbuild/linux-arm64\": \"0.25.11\",\n        \"@esbuild/linux-ia32\": \"0.25.11\",\n        \"@esbuild/linux-loong64\": \"0.25.11\",\n        \"@esbuild/linux-mips64el\": \"0.25.11\",\n        \"@esbuild/linux-ppc64\": \"0.25.11\",\n        \"@esbuild/linux-riscv64\": \"0.25.11\",\n        \"@esbuild/linux-s390x\": \"0.25.11\",\n        \"@esbuild/linux-x64\": \"0.25.11\",\n        \"@esbuild/netbsd-arm64\": \"0.25.11\",\n        \"@esbuild/netbsd-x64\": \"0.25.11\",\n        \"@esbuild/openbsd-arm64\": \"0.25.11\",\n        \"@esbuild/openbsd-x64\": \"0.25.11\",\n        \"@esbuild/openharmony-arm64\": \"0.25.11\",\n        \"@esbuild/sunos-x64\": \"0.25.11\",\n        \"@esbuild/win32-arm64\": \"0.25.11\",\n        \"@esbuild/win32-ia32\": \"0.25.11\",\n        \"@esbuild/win32-x64\": \"0.25.11\"\n      }\n    },\n    \"node_modules/escape-html\": {\n      \"version\": \"1.0.3\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/etag\": {\n      \"version\": \"1.8.1\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/eventsource\": {\n      \"version\": \"3.0.7\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"eventsource-parser\": \"^3.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=18.0.0\"\n      }\n    },\n    \"node_modules/eventsource-parser\": {\n      \"version\": \"3.0.5\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=20.0.0\"\n      }\n    },\n    \"node_modules/express\": {\n      \"version\": \"5.1.0\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"accepts\": \"^2.0.0\",\n        \"body-parser\": \"^2.2.0\",\n        \"content-disposition\": \"^1.0.0\",\n        \"content-type\": \"^1.0.5\",\n        \"cookie\": \"^0.7.1\",\n        \"cookie-signature\": \"^1.2.1\",\n        \"debug\": \"^4.4.0\",\n        \"encodeurl\": \"^2.0.0\",\n        \"escape-html\": \"^1.0.3\",\n        \"etag\": \"^1.8.1\",\n        \"finalhandler\": \"^2.1.0\",\n        \"fresh\": \"^2.0.0\",\n        \"http-errors\": \"^2.0.0\",\n        \"merge-descriptors\": \"^2.0.0\",\n        \"mime-types\": \"^3.0.0\",\n        \"on-finished\": \"^2.4.1\",\n        \"once\": \"^1.4.0\",\n        \"parseurl\": \"^1.3.3\",\n        \"proxy-addr\": \"^2.0.7\",\n        \"qs\": \"^6.14.0\",\n        \"range-parser\": \"^1.2.1\",\n        \"router\": \"^2.2.0\",\n        \"send\": \"^1.1.0\",\n        \"serve-static\": \"^2.2.0\",\n        \"statuses\": \"^2.0.1\",\n        \"type-is\": \"^2.0.1\",\n        \"vary\": \"^1.1.2\"\n      },\n      \"engines\": {\n        \"node\": \">= 18\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/express\"\n      }\n    },\n    \"node_modules/express-rate-limit\": {\n      \"version\": \"7.5.1\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 16\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/express-rate-limit\"\n      },\n      \"peerDependencies\": {\n        \"express\": \">= 4.11\"\n      }\n    },\n    \"node_modules/express/node_modules/mime-types\": {\n      \"version\": \"3.0.1\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"mime-db\": \"^1.54.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/express/node_modules/mime-types/node_modules/mime-db\": {\n      \"version\": \"1.54.0\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/fast-deep-equal\": {\n      \"version\": \"3.1.3\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/fast-json-stable-stringify\": {\n      \"version\": \"2.1.0\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/fdir\": {\n      \"version\": \"6.5.0\",\n      \"resolved\": \"https://registry.npmjs.org/fdir/-/fdir-6.5.0.tgz\",\n      \"integrity\": \"sha512-tIbYtZbucOs0BRGqPJkshJUYdL+SDH7dVM8gjy+ERp3WAUjLEFJE+02kanyHtwjWOnwrKYBiwAmM0p4kLJAnXg==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=12.0.0\"\n      },\n      \"peerDependencies\": {\n        \"picomatch\": \"^3 || ^4\"\n      },\n      \"peerDependenciesMeta\": {\n        \"picomatch\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/finalhandler\": {\n      \"version\": \"2.1.0\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"debug\": \"^4.4.0\",\n        \"encodeurl\": \"^2.0.0\",\n        \"escape-html\": \"^1.0.3\",\n        \"on-finished\": \"^2.4.1\",\n        \"parseurl\": \"^1.3.3\",\n        \"statuses\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/fix-dts-default-cjs-exports\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/fix-dts-default-cjs-exports/-/fix-dts-default-cjs-exports-1.0.1.tgz\",\n      \"integrity\": \"sha512-pVIECanWFC61Hzl2+oOCtoJ3F17kglZC/6N94eRWycFgBH35hHx0Li604ZIzhseh97mf2p0cv7vVrOZGoqhlEg==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"magic-string\": \"^0.30.17\",\n        \"mlly\": \"^1.7.4\",\n        \"rollup\": \"^4.34.8\"\n      }\n    },\n    \"node_modules/follow-redirects\": {\n      \"version\": \"1.15.11\",\n      \"funding\": [\n        {\n          \"type\": \"individual\",\n          \"url\": \"https://github.com/sponsors/RubenVerborgh\"\n        }\n      ],\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=4.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"debug\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/foreground-child\": {\n      \"version\": \"3.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz\",\n      \"integrity\": \"sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==\",\n      \"dev\": true,\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"cross-spawn\": \"^7.0.6\",\n        \"signal-exit\": \"^4.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=14\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/isaacs\"\n      }\n    },\n    \"node_modules/form-data\": {\n      \"version\": \"4.0.4\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"asynckit\": \"^0.4.0\",\n        \"combined-stream\": \"^1.0.8\",\n        \"es-set-tostringtag\": \"^2.1.0\",\n        \"hasown\": \"^2.0.2\",\n        \"mime-types\": \"^2.1.12\"\n      },\n      \"engines\": {\n        \"node\": \">= 6\"\n      }\n    },\n    \"node_modules/forwarded\": {\n      \"version\": \"0.2.0\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/fresh\": {\n      \"version\": \"2.0.0\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/fsevents\": {\n      \"version\": \"2.3.3\",\n      \"resolved\": \"https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz\",\n      \"integrity\": \"sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==\",\n      \"dev\": true,\n      \"hasInstallScript\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"darwin\"\n      ],\n      \"engines\": {\n        \"node\": \"^8.16.0 || ^10.6.0 || >=11.0.0\"\n      }\n    },\n    \"node_modules/function-bind\": {\n      \"version\": \"1.1.2\",\n      \"license\": \"MIT\",\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/get-intrinsic\": {\n      \"version\": \"1.3.0\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"call-bind-apply-helpers\": \"^1.0.2\",\n        \"es-define-property\": \"^1.0.1\",\n        \"es-errors\": \"^1.3.0\",\n        \"es-object-atoms\": \"^1.1.1\",\n        \"function-bind\": \"^1.1.2\",\n        \"get-proto\": \"^1.0.1\",\n        \"gopd\": \"^1.2.0\",\n        \"has-symbols\": \"^1.1.0\",\n        \"hasown\": \"^2.0.2\",\n        \"math-intrinsics\": \"^1.1.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/get-proto\": {\n      \"version\": \"1.0.1\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"dunder-proto\": \"^1.0.1\",\n        \"es-object-atoms\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/glob\": {\n      \"version\": \"10.4.5\",\n      \"resolved\": \"https://registry.npmjs.org/glob/-/glob-10.4.5.tgz\",\n      \"integrity\": \"sha512-7Bv8RF0k6xjo7d4A/PxYLbUCfb6c+Vpd2/mB2yRDlew7Jb5hEXiCD9ibfO7wpk8i4sevK6DFny9h7EYbM3/sHg==\",\n      \"dev\": true,\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"foreground-child\": \"^3.1.0\",\n        \"jackspeak\": \"^3.1.2\",\n        \"minimatch\": \"^9.0.4\",\n        \"minipass\": \"^7.1.2\",\n        \"package-json-from-dist\": \"^1.0.0\",\n        \"path-scurry\": \"^1.11.1\"\n      },\n      \"bin\": {\n        \"glob\": \"dist/esm/bin.mjs\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/isaacs\"\n      }\n    },\n    \"node_modules/gopd\": {\n      \"version\": \"1.2.0\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/has-symbols\": {\n      \"version\": \"1.1.0\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/has-tostringtag\": {\n      \"version\": \"1.0.2\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"has-symbols\": \"^1.0.3\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/hasown\": {\n      \"version\": \"2.0.2\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"function-bind\": \"^1.1.2\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/http-errors\": {\n      \"version\": \"2.0.0\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"depd\": \"2.0.0\",\n        \"inherits\": \"2.0.4\",\n        \"setprototypeof\": \"1.2.0\",\n        \"statuses\": \"2.0.1\",\n        \"toidentifier\": \"1.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/iconv-lite\": {\n      \"version\": \"0.6.3\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"safer-buffer\": \">= 2.1.2 < 3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      }\n    },\n    \"node_modules/inherits\": {\n      \"version\": \"2.0.4\",\n      \"license\": \"ISC\"\n    },\n    \"node_modules/ipaddr.js\": {\n      \"version\": \"1.9.1\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.10\"\n      }\n    },\n    \"node_modules/is-fullwidth-code-point\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz\",\n      \"integrity\": \"sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/is-node-process\": {\n      \"version\": \"1.2.0\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/is-promise\": {\n      \"version\": \"4.0.0\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/isexe\": {\n      \"version\": \"2.0.0\",\n      \"license\": \"ISC\"\n    },\n    \"node_modules/jackspeak\": {\n      \"version\": \"3.4.3\",\n      \"resolved\": \"https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz\",\n      \"integrity\": \"sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==\",\n      \"dev\": true,\n      \"license\": \"BlueOak-1.0.0\",\n      \"dependencies\": {\n        \"@isaacs/cliui\": \"^8.0.2\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/isaacs\"\n      },\n      \"optionalDependencies\": {\n        \"@pkgjs/parseargs\": \"^0.11.0\"\n      }\n    },\n    \"node_modules/joycon\": {\n      \"version\": \"3.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/joycon/-/joycon-3.1.1.tgz\",\n      \"integrity\": \"sha512-34wB/Y7MW7bzjKRjUKTa46I2Z7eV62Rkhva+KkopW7Qvv/OSWBqvkSY7vusOPrNuZcUG3tApvdVgNB8POj3SPw==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=10\"\n      }\n    },\n    \"node_modules/js-yaml\": {\n      \"version\": \"4.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz\",\n      \"integrity\": \"sha512-qQKT4zQxXl8lLwBtHMWwaTcGfFOZviOJet3Oy/xmGk2gZH677CJM9EvtfdSkgWcATZhj/55JZ0rmy3myCT5lsA==\",\n      \"dependencies\": {\n        \"argparse\": \"^2.0.1\"\n      },\n      \"bin\": {\n        \"js-yaml\": \"bin/js-yaml.js\"\n      }\n    },\n    \"node_modules/json-schema-traverse\": {\n      \"version\": \"0.4.1\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/json-stringify-safe\": {\n      \"version\": \"5.0.1\",\n      \"dev\": true,\n      \"license\": \"ISC\"\n    },\n    \"node_modules/lilconfig\": {\n      \"version\": \"3.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/lilconfig/-/lilconfig-3.1.3.tgz\",\n      \"integrity\": \"sha512-/vlFKAoH5Cgt3Ie+JLhRbwOsCQePABiU3tJ1egGvyQ+33R/vcwM2Zl2QR/LzjsBeItPt3oSVXapn+m4nQDvpzw==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=14\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/antonk52\"\n      }\n    },\n    \"node_modules/lines-and-columns\": {\n      \"version\": \"1.2.4\",\n      \"resolved\": \"https://registry.npmjs.org/lines-and-columns/-/lines-and-columns-1.2.4.tgz\",\n      \"integrity\": \"sha512-7ylylesZQ/PV29jhEDl3Ufjo6ZX7gCqJr5F7PKrqc93v7fzSymt1BpwEU8nAUXs8qzzvqhbjhK5QZg6Mt/HkBg==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/load-tsconfig\": {\n      \"version\": \"0.2.5\",\n      \"resolved\": \"https://registry.npmjs.org/load-tsconfig/-/load-tsconfig-0.2.5.tgz\",\n      \"integrity\": \"sha512-IXO6OCs9yg8tMKzfPZ1YmheJbZCiEsnBdcB03l0OcfK9prKnJb96siuHCr5Fl37/yo9DnKU+TLpxzTUspw9shg==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"^12.20.0 || ^14.13.1 || >=16.0.0\"\n      }\n    },\n    \"node_modules/lodash.sortby\": {\n      \"version\": \"4.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/lodash.sortby/-/lodash.sortby-4.7.0.tgz\",\n      \"integrity\": \"sha512-HDWXG8isMntAyRF5vZ7xKuEvOhT4AhlRt/3czTSjvGUxjYCBVRQY48ViDHyfYz9VIoBkW4TMGQNapx+l3RUwdA==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/lru-cache\": {\n      \"version\": \"10.4.3\",\n      \"resolved\": \"https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz\",\n      \"integrity\": \"sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==\",\n      \"dev\": true,\n      \"license\": \"ISC\"\n    },\n    \"node_modules/magic-string\": {\n      \"version\": \"0.30.19\",\n      \"resolved\": \"https://registry.npmjs.org/magic-string/-/magic-string-0.30.19.tgz\",\n      \"integrity\": \"sha512-2N21sPY9Ws53PZvsEpVtNuSW+ScYbQdp4b9qUaL+9QkHUrGFKo56Lg9Emg5s9V/qrtNBmiR01sYhUOwu3H+VOw==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@jridgewell/sourcemap-codec\": \"^1.5.5\"\n      }\n    },\n    \"node_modules/math-intrinsics\": {\n      \"version\": \"1.1.0\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/media-typer\": {\n      \"version\": \"1.1.0\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/merge-descriptors\": {\n      \"version\": \"2.0.0\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=18\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/mime-db\": {\n      \"version\": \"1.52.0\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/mime-types\": {\n      \"version\": \"2.1.35\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"mime-db\": \"1.52.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/minimatch\": {\n      \"version\": \"9.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-9.0.5.tgz\",\n      \"integrity\": \"sha512-G6T0ZX48xgozx7587koeX9Ys2NYy6Gmv//P89sEte9V9whIapMNF4idKxnW2QtCcLiTWlb/wfCabAtAFWhhBow==\",\n      \"dev\": true,\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"brace-expansion\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=16 || 14 >=14.17\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/isaacs\"\n      }\n    },\n    \"node_modules/minipass\": {\n      \"version\": \"7.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz\",\n      \"integrity\": \"sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==\",\n      \"dev\": true,\n      \"license\": \"ISC\",\n      \"engines\": {\n        \"node\": \">=16 || 14 >=14.17\"\n      }\n    },\n    \"node_modules/mlly\": {\n      \"version\": \"1.8.0\",\n      \"resolved\": \"https://registry.npmjs.org/mlly/-/mlly-1.8.0.tgz\",\n      \"integrity\": \"sha512-l8D9ODSRWLe2KHJSifWGwBqpTZXIXTeo8mlKjY+E2HAakaTeNpqAyBZ8GSqLzHgw4XmHmC8whvpjJNMbFZN7/g==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"acorn\": \"^8.15.0\",\n        \"pathe\": \"^2.0.3\",\n        \"pkg-types\": \"^1.3.1\",\n        \"ufo\": \"^1.6.1\"\n      }\n    },\n    \"node_modules/ms\": {\n      \"version\": \"2.1.3\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/mz\": {\n      \"version\": \"2.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/mz/-/mz-2.7.0.tgz\",\n      \"integrity\": \"sha512-z81GNO7nnYMEhrGh9LeymoE4+Yr0Wn5McHIZMK5cfQCl+NDX08sCZgUc9/6MHni9IWuFLm1Z3HTCXu2z9fN62Q==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"any-promise\": \"^1.0.0\",\n        \"object-assign\": \"^4.0.1\",\n        \"thenify-all\": \"^1.0.0\"\n      }\n    },\n    \"node_modules/negotiator\": {\n      \"version\": \"1.0.0\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/nock\": {\n      \"version\": \"14.0.10\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@mswjs/interceptors\": \"^0.39.5\",\n        \"json-stringify-safe\": \"^5.0.1\",\n        \"propagate\": \"^2.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=18.20.0 <20 || >=20.12.1\"\n      }\n    },\n    \"node_modules/object-assign\": {\n      \"version\": \"4.1.1\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      }\n    },\n    \"node_modules/object-inspect\": {\n      \"version\": \"1.13.4\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/on-finished\": {\n      \"version\": \"2.4.1\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ee-first\": \"1.1.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/once\": {\n      \"version\": \"1.4.0\",\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"wrappy\": \"1\"\n      }\n    },\n    \"node_modules/outvariant\": {\n      \"version\": \"1.4.3\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/package-json-from-dist\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz\",\n      \"integrity\": \"sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==\",\n      \"dev\": true,\n      \"license\": \"BlueOak-1.0.0\"\n    },\n    \"node_modules/parseurl\": {\n      \"version\": \"1.3.3\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/path-key\": {\n      \"version\": \"3.1.1\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/path-scurry\": {\n      \"version\": \"1.11.1\",\n      \"resolved\": \"https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz\",\n      \"integrity\": \"sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==\",\n      \"dev\": true,\n      \"license\": \"BlueOak-1.0.0\",\n      \"dependencies\": {\n        \"lru-cache\": \"^10.2.0\",\n        \"minipass\": \"^5.0.0 || ^6.0.2 || ^7.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=16 || 14 >=14.18\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/isaacs\"\n      }\n    },\n    \"node_modules/path-to-regexp\": {\n      \"version\": \"8.2.0\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=16\"\n      }\n    },\n    \"node_modules/pathe\": {\n      \"version\": \"2.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/pathe/-/pathe-2.0.3.tgz\",\n      \"integrity\": \"sha512-WUjGcAqP1gQacoQe+OBJsFA7Ld4DyXuUIjZ5cc75cLHvJ7dtNsTugphxIADwspS+AraAUePCKrSVtPLFj/F88w==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/picocolors\": {\n      \"version\": \"1.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz\",\n      \"integrity\": \"sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==\",\n      \"dev\": true,\n      \"license\": \"ISC\"\n    },\n    \"node_modules/picomatch\": {\n      \"version\": \"4.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz\",\n      \"integrity\": \"sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/jonschlinkert\"\n      }\n    },\n    \"node_modules/pirates\": {\n      \"version\": \"4.0.7\",\n      \"resolved\": \"https://registry.npmjs.org/pirates/-/pirates-4.0.7.tgz\",\n      \"integrity\": \"sha512-TfySrs/5nm8fQJDcBDuUng3VOUKsd7S+zqvbOTiGXHfxX4wK31ard+hoNuvkicM/2YFzlpDgABOevKSsB4G/FA==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 6\"\n      }\n    },\n    \"node_modules/pkce-challenge\": {\n      \"version\": \"5.0.0\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=16.20.0\"\n      }\n    },\n    \"node_modules/pkg-types\": {\n      \"version\": \"1.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/pkg-types/-/pkg-types-1.3.1.tgz\",\n      \"integrity\": \"sha512-/Jm5M4RvtBFVkKWRu2BLUTNP8/M2a+UwuAX+ae4770q1qVGtfjG+WTCupoZixokjmHiry8uI+dlY8KXYV5HVVQ==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"confbox\": \"^0.1.8\",\n        \"mlly\": \"^1.7.4\",\n        \"pathe\": \"^2.0.1\"\n      }\n    },\n    \"node_modules/postcss-load-config\": {\n      \"version\": \"6.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/postcss-load-config/-/postcss-load-config-6.0.1.tgz\",\n      \"integrity\": \"sha512-oPtTM4oerL+UXmx+93ytZVN82RrlY/wPUV8IeDxFrzIjXOLF1pN+EmKPLbubvKHT2HC20xXsCAH2Z+CKV6Oz/g==\",\n      \"dev\": true,\n      \"funding\": [\n        {\n          \"type\": \"opencollective\",\n          \"url\": \"https://opencollective.com/postcss/\"\n        },\n        {\n          \"type\": \"github\",\n          \"url\": \"https://github.com/sponsors/ai\"\n        }\n      ],\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"lilconfig\": \"^3.1.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 18\"\n      },\n      \"peerDependencies\": {\n        \"jiti\": \">=1.21.0\",\n        \"postcss\": \">=8.0.9\",\n        \"tsx\": \"^4.8.1\",\n        \"yaml\": \"^2.4.2\"\n      },\n      \"peerDependenciesMeta\": {\n        \"jiti\": {\n          \"optional\": true\n        },\n        \"postcss\": {\n          \"optional\": true\n        },\n        \"tsx\": {\n          \"optional\": true\n        },\n        \"yaml\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/propagate\": {\n      \"version\": \"2.0.1\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 8\"\n      }\n    },\n    \"node_modules/proxy-addr\": {\n      \"version\": \"2.0.7\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"forwarded\": \"0.2.0\",\n        \"ipaddr.js\": \"1.9.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.10\"\n      }\n    },\n    \"node_modules/proxy-from-env\": {\n      \"version\": \"1.1.0\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/punycode\": {\n      \"version\": \"2.3.1\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=6\"\n      }\n    },\n    \"node_modules/qs\": {\n      \"version\": \"6.14.0\",\n      \"license\": \"BSD-3-Clause\",\n      \"dependencies\": {\n        \"side-channel\": \"^1.1.0\"\n      },\n      \"engines\": {\n        \"node\": \">=0.6\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/range-parser\": {\n      \"version\": \"1.2.1\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/raw-body\": {\n      \"version\": \"3.0.0\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"bytes\": \"3.1.2\",\n        \"http-errors\": \"2.0.0\",\n        \"iconv-lite\": \"0.6.3\",\n        \"unpipe\": \"1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/readdirp\": {\n      \"version\": \"4.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/readdirp/-/readdirp-4.1.2.tgz\",\n      \"integrity\": \"sha512-GDhwkLfywWL2s6vEjyhri+eXmfH6j1L7JE27WhqLeYzoh/A3DBaYGEj2H/HFZCn/kMfim73FXxEJTw06WtxQwg==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 14.18.0\"\n      },\n      \"funding\": {\n        \"type\": \"individual\",\n        \"url\": \"https://paulmillr.com/funding/\"\n      }\n    },\n    \"node_modules/resolve-from\": {\n      \"version\": \"5.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/resolve-from/-/resolve-from-5.0.0.tgz\",\n      \"integrity\": \"sha512-qYg9KP24dD5qka9J47d0aVky0N+b4fTU89LN9iDnjB5waksiC49rvMB0PrUJQGoTmH50XPiqOvAjDfaijGxYZw==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/rollup\": {\n      \"version\": \"4.52.5\",\n      \"resolved\": \"https://registry.npmjs.org/rollup/-/rollup-4.52.5.tgz\",\n      \"integrity\": \"sha512-3GuObel8h7Kqdjt0gxkEzaifHTqLVW56Y/bjN7PSQtkKr0w3V/QYSdt6QWYtd7A1xUtYQigtdUfgj1RvWVtorw==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@types/estree\": \"1.0.8\"\n      },\n      \"bin\": {\n        \"rollup\": \"dist/bin/rollup\"\n      },\n      \"engines\": {\n        \"node\": \">=18.0.0\",\n        \"npm\": \">=8.0.0\"\n      },\n      \"optionalDependencies\": {\n        \"@rollup/rollup-android-arm-eabi\": \"4.52.5\",\n        \"@rollup/rollup-android-arm64\": \"4.52.5\",\n        \"@rollup/rollup-darwin-arm64\": \"4.52.5\",\n        \"@rollup/rollup-darwin-x64\": \"4.52.5\",\n        \"@rollup/rollup-freebsd-arm64\": \"4.52.5\",\n        \"@rollup/rollup-freebsd-x64\": \"4.52.5\",\n        \"@rollup/rollup-linux-arm-gnueabihf\": \"4.52.5\",\n        \"@rollup/rollup-linux-arm-musleabihf\": \"4.52.5\",\n        \"@rollup/rollup-linux-arm64-gnu\": \"4.52.5\",\n        \"@rollup/rollup-linux-arm64-musl\": \"4.52.5\",\n        \"@rollup/rollup-linux-loong64-gnu\": \"4.52.5\",\n        \"@rollup/rollup-linux-ppc64-gnu\": \"4.52.5\",\n        \"@rollup/rollup-linux-riscv64-gnu\": \"4.52.5\",\n        \"@rollup/rollup-linux-riscv64-musl\": \"4.52.5\",\n        \"@rollup/rollup-linux-s390x-gnu\": \"4.52.5\",\n        \"@rollup/rollup-linux-x64-gnu\": \"4.52.5\",\n        \"@rollup/rollup-linux-x64-musl\": \"4.52.5\",\n        \"@rollup/rollup-openharmony-arm64\": \"4.52.5\",\n        \"@rollup/rollup-win32-arm64-msvc\": \"4.52.5\",\n        \"@rollup/rollup-win32-ia32-msvc\": \"4.52.5\",\n        \"@rollup/rollup-win32-x64-gnu\": \"4.52.5\",\n        \"@rollup/rollup-win32-x64-msvc\": \"4.52.5\",\n        \"fsevents\": \"~2.3.2\"\n      }\n    },\n    \"node_modules/router\": {\n      \"version\": \"2.2.0\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"debug\": \"^4.4.0\",\n        \"depd\": \"^2.0.0\",\n        \"is-promise\": \"^4.0.0\",\n        \"parseurl\": \"^1.3.3\",\n        \"path-to-regexp\": \"^8.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 18\"\n      }\n    },\n    \"node_modules/safe-buffer\": {\n      \"version\": \"5.2.1\",\n      \"funding\": [\n        {\n          \"type\": \"github\",\n          \"url\": \"https://github.com/sponsors/feross\"\n        },\n        {\n          \"type\": \"patreon\",\n          \"url\": \"https://www.patreon.com/feross\"\n        },\n        {\n          \"type\": \"consulting\",\n          \"url\": \"https://feross.org/support\"\n        }\n      ],\n      \"license\": \"MIT\"\n    },\n    \"node_modules/safer-buffer\": {\n      \"version\": \"2.1.2\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/send\": {\n      \"version\": \"1.2.0\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"debug\": \"^4.3.5\",\n        \"encodeurl\": \"^2.0.0\",\n        \"escape-html\": \"^1.0.3\",\n        \"etag\": \"^1.8.1\",\n        \"fresh\": \"^2.0.0\",\n        \"http-errors\": \"^2.0.0\",\n        \"mime-types\": \"^3.0.1\",\n        \"ms\": \"^2.1.3\",\n        \"on-finished\": \"^2.4.1\",\n        \"range-parser\": \"^1.2.1\",\n        \"statuses\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 18\"\n      }\n    },\n    \"node_modules/send/node_modules/mime-types\": {\n      \"version\": \"3.0.1\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"mime-db\": \"^1.54.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/send/node_modules/mime-types/node_modules/mime-db\": {\n      \"version\": \"1.54.0\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/serve-static\": {\n      \"version\": \"2.2.0\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"encodeurl\": \"^2.0.0\",\n        \"escape-html\": \"^1.0.3\",\n        \"parseurl\": \"^1.3.3\",\n        \"send\": \"^1.2.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 18\"\n      }\n    },\n    \"node_modules/setprototypeof\": {\n      \"version\": \"1.2.0\",\n      \"license\": \"ISC\"\n    },\n    \"node_modules/shebang-command\": {\n      \"version\": \"2.0.0\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"shebang-regex\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/shebang-regex\": {\n      \"version\": \"3.0.0\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/side-channel\": {\n      \"version\": \"1.1.0\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"es-errors\": \"^1.3.0\",\n        \"object-inspect\": \"^1.13.3\",\n        \"side-channel-list\": \"^1.0.0\",\n        \"side-channel-map\": \"^1.0.1\",\n        \"side-channel-weakmap\": \"^1.0.2\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/side-channel-list\": {\n      \"version\": \"1.0.0\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"es-errors\": \"^1.3.0\",\n        \"object-inspect\": \"^1.13.3\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/side-channel-map\": {\n      \"version\": \"1.0.1\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"call-bound\": \"^1.0.2\",\n        \"es-errors\": \"^1.3.0\",\n        \"get-intrinsic\": \"^1.2.5\",\n        \"object-inspect\": \"^1.13.3\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/side-channel-weakmap\": {\n      \"version\": \"1.0.2\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"call-bound\": \"^1.0.2\",\n        \"es-errors\": \"^1.3.0\",\n        \"get-intrinsic\": \"^1.2.5\",\n        \"object-inspect\": \"^1.13.3\",\n        \"side-channel-map\": \"^1.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/signal-exit\": {\n      \"version\": \"4.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz\",\n      \"integrity\": \"sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==\",\n      \"dev\": true,\n      \"license\": \"ISC\",\n      \"engines\": {\n        \"node\": \">=14\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/isaacs\"\n      }\n    },\n    \"node_modules/source-map\": {\n      \"version\": \"0.8.0-beta.0\",\n      \"resolved\": \"https://registry.npmjs.org/source-map/-/source-map-0.8.0-beta.0.tgz\",\n      \"integrity\": \"sha512-2ymg6oRBpebeZi9UUNsgQ89bhx01TcTkmNTGnNO88imTmbSgy4nfujrgVEFKWpMTEGA11EDkTt7mqObTPdigIA==\",\n      \"deprecated\": \"The work that was done in this beta branch won't be included in future versions\",\n      \"dev\": true,\n      \"license\": \"BSD-3-Clause\",\n      \"dependencies\": {\n        \"whatwg-url\": \"^7.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 8\"\n      }\n    },\n    \"node_modules/statuses\": {\n      \"version\": \"2.0.1\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/strict-event-emitter\": {\n      \"version\": \"0.5.1\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/string-width\": {\n      \"version\": \"5.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz\",\n      \"integrity\": \"sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"eastasianwidth\": \"^0.2.0\",\n        \"emoji-regex\": \"^9.2.2\",\n        \"strip-ansi\": \"^7.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/string-width-cjs\": {\n      \"name\": \"string-width\",\n      \"version\": \"4.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz\",\n      \"integrity\": \"sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"emoji-regex\": \"^8.0.0\",\n        \"is-fullwidth-code-point\": \"^3.0.0\",\n        \"strip-ansi\": \"^6.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/string-width-cjs/node_modules/ansi-regex\": {\n      \"version\": \"5.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz\",\n      \"integrity\": \"sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/string-width-cjs/node_modules/emoji-regex\": {\n      \"version\": \"8.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz\",\n      \"integrity\": \"sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/string-width-cjs/node_modules/strip-ansi\": {\n      \"version\": \"6.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz\",\n      \"integrity\": \"sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ansi-regex\": \"^5.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/strip-ansi\": {\n      \"version\": \"7.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz\",\n      \"integrity\": \"sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ansi-regex\": \"^6.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/strip-ansi?sponsor=1\"\n      }\n    },\n    \"node_modules/strip-ansi-cjs\": {\n      \"name\": \"strip-ansi\",\n      \"version\": \"6.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz\",\n      \"integrity\": \"sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ansi-regex\": \"^5.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/strip-ansi-cjs/node_modules/ansi-regex\": {\n      \"version\": \"5.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz\",\n      \"integrity\": \"sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/sucrase\": {\n      \"version\": \"3.35.0\",\n      \"resolved\": \"https://registry.npmjs.org/sucrase/-/sucrase-3.35.0.tgz\",\n      \"integrity\": \"sha512-8EbVDiu9iN/nESwxeSxDKe0dunta1GOlHufmSSXxMD2z2/tMZpDMpvXQGsc+ajGo8y2uYUmixaSRUc/QPoQ0GA==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@jridgewell/gen-mapping\": \"^0.3.2\",\n        \"commander\": \"^4.0.0\",\n        \"glob\": \"^10.3.10\",\n        \"lines-and-columns\": \"^1.1.6\",\n        \"mz\": \"^2.7.0\",\n        \"pirates\": \"^4.0.1\",\n        \"ts-interface-checker\": \"^0.1.9\"\n      },\n      \"bin\": {\n        \"sucrase\": \"bin/sucrase\",\n        \"sucrase-node\": \"bin/sucrase-node\"\n      },\n      \"engines\": {\n        \"node\": \">=16 || 14 >=14.17\"\n      }\n    },\n    \"node_modules/thenify\": {\n      \"version\": \"3.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/thenify/-/thenify-3.3.1.tgz\",\n      \"integrity\": \"sha512-RVZSIV5IG10Hk3enotrhvz0T9em6cyHBLkH/YAZuKqd8hRkKhSfCGIcP2KUY0EPxndzANBmNllzWPwak+bheSw==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"any-promise\": \"^1.0.0\"\n      }\n    },\n    \"node_modules/thenify-all\": {\n      \"version\": \"1.6.0\",\n      \"resolved\": \"https://registry.npmjs.org/thenify-all/-/thenify-all-1.6.0.tgz\",\n      \"integrity\": \"sha512-RNxQH/qI8/t3thXJDwcstUO4zeqo64+Uy/+sNVRBx4Xn2OX+OZ9oP+iJnNFqplFra2ZUVeKCSa2oVWi3T4uVmA==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"thenify\": \">= 3.1.0 < 4\"\n      },\n      \"engines\": {\n        \"node\": \">=0.8\"\n      }\n    },\n    \"node_modules/tinyexec\": {\n      \"version\": \"0.3.2\",\n      \"resolved\": \"https://registry.npmjs.org/tinyexec/-/tinyexec-0.3.2.tgz\",\n      \"integrity\": \"sha512-KQQR9yN7R5+OSwaK0XQoj22pwHoTlgYqmUscPYoknOoWCWfj/5/ABTMRi69FrKU5ffPVh5QcFikpWJI/P1ocHA==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/tinyglobby\": {\n      \"version\": \"0.2.15\",\n      \"resolved\": \"https://registry.npmjs.org/tinyglobby/-/tinyglobby-0.2.15.tgz\",\n      \"integrity\": \"sha512-j2Zq4NyQYG5XMST4cbs02Ak8iJUdxRM0XI5QyxXuZOzKOINmWurp3smXu3y5wDcJrptwpSjgXHzIQxR0omXljQ==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"fdir\": \"^6.5.0\",\n        \"picomatch\": \"^4.0.3\"\n      },\n      \"engines\": {\n        \"node\": \">=12.0.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/SuperchupuDev\"\n      }\n    },\n    \"node_modules/toidentifier\": {\n      \"version\": \"1.0.1\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=0.6\"\n      }\n    },\n    \"node_modules/tr46\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/tr46/-/tr46-1.0.1.tgz\",\n      \"integrity\": \"sha512-dTpowEjclQ7Kgx5SdBkqRzVhERQXov8/l9Ft9dVM9fmg0W0KQSVaXX9T4i6twCPNtYiZM53lpSSUAwJbFPOHxA==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"punycode\": \"^2.1.0\"\n      }\n    },\n    \"node_modules/tree-kill\": {\n      \"version\": \"1.2.2\",\n      \"resolved\": \"https://registry.npmjs.org/tree-kill/-/tree-kill-1.2.2.tgz\",\n      \"integrity\": \"sha512-L0Orpi8qGpRG//Nd+H90vFB+3iHnue1zSSGmNOOCh1GLJ7rUKVwV2HvijphGQS2UmhUZewS9VgvxYIdgr+fG1A==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"bin\": {\n        \"tree-kill\": \"cli.js\"\n      }\n    },\n    \"node_modules/ts-interface-checker\": {\n      \"version\": \"0.1.13\",\n      \"resolved\": \"https://registry.npmjs.org/ts-interface-checker/-/ts-interface-checker-0.1.13.tgz\",\n      \"integrity\": \"sha512-Y/arvbn+rrz3JCKl9C4kVNfTfSm2/mEp5FSz5EsZSANGPSlQrpRI5M4PKF+mJnE52jOO90PnPSc3Ur3bTQw0gA==\",\n      \"dev\": true,\n      \"license\": \"Apache-2.0\"\n    },\n    \"node_modules/tsup\": {\n      \"version\": \"8.5.0\",\n      \"resolved\": \"https://registry.npmjs.org/tsup/-/tsup-8.5.0.tgz\",\n      \"integrity\": \"sha512-VmBp77lWNQq6PfuMqCHD3xWl22vEoWsKajkF8t+yMBawlUS8JzEI+vOVMeuNZIuMML8qXRizFKi9oD5glKQVcQ==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"bundle-require\": \"^5.1.0\",\n        \"cac\": \"^6.7.14\",\n        \"chokidar\": \"^4.0.3\",\n        \"consola\": \"^3.4.0\",\n        \"debug\": \"^4.4.0\",\n        \"esbuild\": \"^0.25.0\",\n        \"fix-dts-default-cjs-exports\": \"^1.0.0\",\n        \"joycon\": \"^3.1.1\",\n        \"picocolors\": \"^1.1.1\",\n        \"postcss-load-config\": \"^6.0.1\",\n        \"resolve-from\": \"^5.0.0\",\n        \"rollup\": \"^4.34.8\",\n        \"source-map\": \"0.8.0-beta.0\",\n        \"sucrase\": \"^3.35.0\",\n        \"tinyexec\": \"^0.3.2\",\n        \"tinyglobby\": \"^0.2.11\",\n        \"tree-kill\": \"^1.2.2\"\n      },\n      \"bin\": {\n        \"tsup\": \"dist/cli-default.js\",\n        \"tsup-node\": \"dist/cli-node.js\"\n      },\n      \"engines\": {\n        \"node\": \">=18\"\n      },\n      \"peerDependencies\": {\n        \"@microsoft/api-extractor\": \"^7.36.0\",\n        \"@swc/core\": \"^1\",\n        \"postcss\": \"^8.4.12\",\n        \"typescript\": \">=4.5.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"@microsoft/api-extractor\": {\n          \"optional\": true\n        },\n        \"@swc/core\": {\n          \"optional\": true\n        },\n        \"postcss\": {\n          \"optional\": true\n        },\n        \"typescript\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/type-is\": {\n      \"version\": \"2.0.1\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"content-type\": \"^1.0.5\",\n        \"media-typer\": \"^1.1.0\",\n        \"mime-types\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/type-is/node_modules/mime-types\": {\n      \"version\": \"3.0.1\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"mime-db\": \"^1.54.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/type-is/node_modules/mime-types/node_modules/mime-db\": {\n      \"version\": \"1.54.0\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/typescript\": {\n      \"version\": \"5.9.2\",\n      \"license\": \"Apache-2.0\",\n      \"bin\": {\n        \"tsc\": \"bin/tsc\",\n        \"tsserver\": \"bin/tsserver\"\n      },\n      \"engines\": {\n        \"node\": \">=14.17\"\n      }\n    },\n    \"node_modules/ufo\": {\n      \"version\": \"1.6.1\",\n      \"resolved\": \"https://registry.npmjs.org/ufo/-/ufo-1.6.1.tgz\",\n      \"integrity\": \"sha512-9a4/uxlTWJ4+a5i0ooc1rU7C7YOw3wT+UGqdeNNHWnOF9qcMBgLRS+4IYUqbczewFx4mLEig6gawh7X6mFlEkA==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/undici-types\": {\n      \"version\": \"7.10.0\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/unpipe\": {\n      \"version\": \"1.0.0\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/uri-js\": {\n      \"version\": \"4.4.1\",\n      \"license\": \"BSD-2-Clause\",\n      \"dependencies\": {\n        \"punycode\": \"^2.1.0\"\n      }\n    },\n    \"node_modules/vary\": {\n      \"version\": \"1.1.2\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/webidl-conversions\": {\n      \"version\": \"4.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-4.0.2.tgz\",\n      \"integrity\": \"sha512-YQ+BmxuTgd6UXZW3+ICGfyqRyHXVlD5GtQr5+qjiNW7bF0cqrzX500HVXPBOvgXb5YnzDd+h0zqyv61KUD7+Sg==\",\n      \"dev\": true,\n      \"license\": \"BSD-2-Clause\"\n    },\n    \"node_modules/whatwg-url\": {\n      \"version\": \"7.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/whatwg-url/-/whatwg-url-7.1.0.tgz\",\n      \"integrity\": \"sha512-WUu7Rg1DroM7oQvGWfOiAK21n74Gg+T4elXEQYkOhtyLeWiJFoOGLXPKI/9gzIie9CtwVLm8wtw6YJdKyxSjeg==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"lodash.sortby\": \"^4.7.0\",\n        \"tr46\": \"^1.0.1\",\n        \"webidl-conversions\": \"^4.0.2\"\n      }\n    },\n    \"node_modules/which\": {\n      \"version\": \"2.0.2\",\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"isexe\": \"^2.0.0\"\n      },\n      \"bin\": {\n        \"node-which\": \"bin/node-which\"\n      },\n      \"engines\": {\n        \"node\": \">= 8\"\n      }\n    },\n    \"node_modules/wrap-ansi\": {\n      \"version\": \"8.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz\",\n      \"integrity\": \"sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ansi-styles\": \"^6.1.0\",\n        \"string-width\": \"^5.0.1\",\n        \"strip-ansi\": \"^7.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/wrap-ansi?sponsor=1\"\n      }\n    },\n    \"node_modules/wrap-ansi-cjs\": {\n      \"name\": \"wrap-ansi\",\n      \"version\": \"7.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz\",\n      \"integrity\": \"sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ansi-styles\": \"^4.0.0\",\n        \"string-width\": \"^4.1.0\",\n        \"strip-ansi\": \"^6.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/wrap-ansi?sponsor=1\"\n      }\n    },\n    \"node_modules/wrap-ansi-cjs/node_modules/ansi-regex\": {\n      \"version\": \"5.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz\",\n      \"integrity\": \"sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/wrap-ansi-cjs/node_modules/ansi-styles\": {\n      \"version\": \"4.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz\",\n      \"integrity\": \"sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"color-convert\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/ansi-styles?sponsor=1\"\n      }\n    },\n    \"node_modules/wrap-ansi-cjs/node_modules/emoji-regex\": {\n      \"version\": \"8.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz\",\n      \"integrity\": \"sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/wrap-ansi-cjs/node_modules/string-width\": {\n      \"version\": \"4.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz\",\n      \"integrity\": \"sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"emoji-regex\": \"^8.0.0\",\n        \"is-fullwidth-code-point\": \"^3.0.0\",\n        \"strip-ansi\": \"^6.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/wrap-ansi-cjs/node_modules/strip-ansi\": {\n      \"version\": \"6.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz\",\n      \"integrity\": \"sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ansi-regex\": \"^5.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/wrappy\": {\n      \"version\": \"1.0.2\",\n      \"license\": \"ISC\"\n    },\n    \"node_modules/zod\": {\n      \"version\": \"3.25.76\",\n      \"license\": \"MIT\",\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/colinhacks\"\n      }\n    },\n    \"node_modules/zod-to-json-schema\": {\n      \"version\": \"3.24.6\",\n      \"license\": \"ISC\",\n      \"peerDependencies\": {\n        \"zod\": \"^3.24.1\"\n      }\n    },\n    \"packages/cli\": {\n      \"name\": \"@utcp/cli\",\n      \"version\": \"1.0.12\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"@utcp/sdk\": \"^1.0.15\"\n      },\n      \"devDependencies\": {\n        \"@types/bun\": \"latest\",\n        \"bun-types\": \"latest\",\n        \"typescript\": \"^5.0.0\"\n      }\n    },\n    \"packages/code-mode\": {\n      \"name\": \"@utcp/code-mode\",\n      \"version\": \"1.0.5\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"@utcp/sdk\": \"^1.0.17\"\n      },\n      \"devDependencies\": {\n        \"@types/node\": \"^20.0.0\",\n        \"@utcp/direct-call\": \"^1.0.12\",\n        \"bun-types\": \"latest\",\n        \"typescript\": \"^5.0.0\"\n      }\n    },\n    \"packages/code-mode/node_modules/@types/node\": {\n      \"version\": \"20.19.25\",\n      \"resolved\": \"https://registry.npmjs.org/@types/node/-/node-20.19.25.tgz\",\n      \"integrity\": \"sha512-ZsJzA5thDQMSQO788d7IocwwQbI8B5OPzmqNvpf3NY/+MHDAS759Wo0gd2WQeXYt5AAAQjzcrTVC6SKCuYgoCQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"undici-types\": \"~6.21.0\"\n      }\n    },\n    \"packages/code-mode/node_modules/undici-types\": {\n      \"version\": \"6.21.0\",\n      \"resolved\": \"https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz\",\n      \"integrity\": \"sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==\",\n      \"dev\": true\n    },\n    \"packages/core\": {\n      \"name\": \"@utcp/sdk\",\n      \"version\": \"1.0.17\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"dotenv\": \"^17.2.1\",\n        \"zod\": \"^3.23.8\"\n      },\n      \"devDependencies\": {\n        \"bun-types\": \"latest\",\n        \"typescript\": \"^5.0.0\"\n      }\n    },\n    \"packages/direct-call\": {\n      \"name\": \"@utcp/direct-call\",\n      \"version\": \"1.0.12\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"@utcp/sdk\": \"^1.0.15\"\n      },\n      \"devDependencies\": {\n        \"@types/bun\": \"latest\",\n        \"bun-types\": \"latest\",\n        \"typescript\": \"^5.0.0\"\n      }\n    },\n    \"packages/dotenv-loader\": {\n      \"name\": \"@utcp/dotenv-loader\",\n      \"version\": \"1.0.1\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"dotenv\": \"^17.2.1\",\n        \"zod\": \"^3.23.8\"\n      },\n      \"devDependencies\": {\n        \"bun-types\": \"latest\",\n        \"typescript\": \"^5.0.0\"\n      },\n      \"peerDependencies\": {\n        \"@utcp/sdk\": \"^1.0.15\"\n      }\n    },\n    \"packages/file\": {\n      \"name\": \"@utcp/file\",\n      \"version\": \"1.0.1\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"@utcp/http\": \"^1.0.13\",\n        \"@utcp/sdk\": \"^1.0.15\",\n        \"js-yaml\": \"^4.1.0\"\n      },\n      \"devDependencies\": {\n        \"@types/bun\": \"latest\",\n        \"bun-types\": \"latest\",\n        \"typescript\": \"^5.0.0\"\n      }\n    },\n    \"packages/http\": {\n      \"name\": \"@utcp/http\",\n      \"version\": \"1.0.13\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"@utcp/sdk\": \"^1.0.15\",\n        \"axios\": \"^1.11.0\",\n        \"js-yaml\": \"^4.1.0\"\n      },\n      \"devDependencies\": {\n        \"@types/bun\": \"latest\",\n        \"bun-types\": \"latest\",\n        \"typescript\": \"^5.0.0\"\n      }\n    },\n    \"packages/mcp\": {\n      \"name\": \"@utcp/mcp\",\n      \"version\": \"1.0.16\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"@apidevtools/json-schema-ref-parser\": \"^15.1.2\",\n        \"@modelcontextprotocol/sdk\": \"^1.17.4\",\n        \"@utcp/sdk\": \"^1.0.15\",\n        \"axios\": \"^1.11.0\"\n      },\n      \"devDependencies\": {\n        \"@types/bun\": \"latest\",\n        \"bun-types\": \"latest\",\n        \"typescript\": \"^5.9.2\",\n        \"zod-to-json-schema\": \"^3.24.6\"\n      }\n    },\n    \"packages/text\": {\n      \"name\": \"@utcp/text\",\n      \"version\": \"1.0.12\",\n      \"license\": \"MPL-2.0\",\n      \"dependencies\": {\n        \"@utcp/http\": \"^1.0.13\",\n        \"@utcp/sdk\": \"^1.0.15\",\n        \"js-yaml\": \"^4.1.0\"\n      },\n      \"devDependencies\": {\n        \"bun-types\": \"latest\",\n        \"typescript\": \"^5.0.0\"\n      }\n    }\n  }\n}\n",
      "line_count": 3251,
      "word_count": 5785,
      "title": "Package Lock.Json",
      "summary": "\"name\": \"typescript-utcp\", \"lockfileVersion\": 3,",
      "key_terms": [
        "open",
        "sourcemap",
        "form-data",
        "packages",
        "parseargs",
        "gSZTCE",
        "convert",
        "lite",
        "oWEQ",
        "list",
        "tsup-node",
        "balanced-match",
        "mode",
        "cookie",
        "stable",
        "shebang",
        "dotenvx",
        "tUNWNHjmbMHg",
        "http-errors",
        "es-errors"
      ],
      "timestamp": "2025-12-24T18:56:16.381428"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\package.json",
      "content_type": "configuration",
      "content": "{\n  \"name\": \"typescript-utcp\",\n  \"module\": \"index.ts\",\n  \"type\": \"module\",\n  \"devDependencies\": {\n    \"@types/js-yaml\": \"^4.0.9\",\n    \"bun-types\": \"^1.2.22\",\n    \"nock\": \"^14.0.10\",\n    \"tsup\": \"^8.5.0\",\n    \"zod\": \"^3.25.76\"\n  },\n  \"peerDependencies\": {\n    \"typescript\": \"^5.9.2\",\n    \"zod\": \"^3.23.8\"\n  },\n  \"resolutions\": {\n    \"zod\": \"^3.23.8\"\n  },\n  \"scripts\": {\n    \"clean\": \"rm -rf packages/*/dist || rmdir /s /q packages\\\\*\\\\dist || true\",\n    \"build\": \"bun run build:core && bun run build:http && bun run build:mcp && bun run build:text && bun run build:file && bun run build:cli && bun run build:direct-call && bun run build:dotenv-loader && bun run build:code-mode\",\n    \"build:core\": \"cd packages/core && bun run build\",\n    \"build:http\": \"cd packages/http && bun run build\",\n    \"build:mcp\": \"cd packages/mcp && bun run build\",\n    \"build:text\": \"cd packages/text && bun run build\",\n    \"build:file\": \"cd packages/file && bun run build\",\n    \"build:cli\": \"cd packages/cli && bun run build\",\n    \"build:direct-call\": \"cd packages/direct-call && bun run build\",\n    \"build:dotenv-loader\": \"cd packages/dotenv-loader && bun run build\",\n    \"build:code-mode\": \"cd packages/code-mode && bun run build\",\n    \"rebuild\": \"bun run clean && bun run build\",\n    \"test\": \"bun test --config tsconfig.test.json\",\n    \"version:patch\": \"node scripts/update-versions.js patch\",\n    \"version:minor\": \"node scripts/update-versions.js minor\",\n    \"version:major\": \"node scripts/update-versions.js major\",\n    \"version:set\": \"node scripts/update-versions.js set\",\n    \"publish:core\": \"cd packages/core && npm publish\",\n    \"publish:text\": \"cd packages/text && npm publish\",\n    \"publish:file\": \"cd packages/file && npm publish\",\n    \"publish:http\": \"cd packages/http && npm publish\",\n    \"publish:mcp\": \"cd packages/mcp && npm publish\",\n    \"publish:cli\": \"cd packages/cli && npm publish\",\n    \"publish:direct-call\": \"cd packages/direct-call && npm publish\",\n    \"publish:dotenv-loader\": \"cd packages/dotenv-loader && npm publish\",\n    \"publish:code-mode\": \"cd packages/code-mode && npm publish\",\n    \"publish:all\": \"bun run build && bun run publish:core && bun run publish:text && bun run publish:file && bun run publish:http && bun run publish:mcp && bun run publish:cli && bun run publish:direct-call && bun run publish:dotenv-loader && bun run publish:code-mode\"\n  },\n  \"workspaces\": [\n    \"packages/*\"\n  ]\n}",
      "line_count": 51,
      "word_count": 273,
      "title": "Package.Json",
      "summary": "\"name\": \"typescript-utcp\", \"module\": \"index.ts\",",
      "key_terms": [
        "update",
        "loader",
        "build",
        "versions",
        "packages",
        "node",
        "yaml",
        "scripts",
        "config",
        "set",
        "module",
        "zod",
        "clean",
        "utcp",
        "index",
        "major",
        "workspaces",
        "file",
        "mode",
        "test"
      ],
      "timestamp": "2025-12-24T18:56:16.400137"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\README.md",
      "content_type": "documentation",
      "content": "# Universal Tool Calling Protocol (UTCP) for TypeScript\n\n[![Follow Org](https://img.shields.io/github/followers/universal-tool-calling-protocol?label=Follow%20Org&logo=github)](https://github.com/universal-tool-calling-protocol)\n[![NPM version](https://img.shields.io/npm/v/@utcp/sdk.svg)](https://www.npmjs.com/package/@utcp/sdk)\n[![License](https://img.shields.io/github/license/universal-tool-calling-protocol/python-utcp)](https://github.com/universal-tool-calling-protocol/typescript-utcp/blob/main/LICENSE)\n[![CDTM S23](https://img.shields.io/badge/CDTM-S23-0b84f3)](https://cdtm.com/)\n\n**The Universal Tool Calling Protocol (UTCP) is a secure and scalable standard for defining and interacting with tools across a wide variety of communication protocols. This repository contains the official TypeScript implementation, structured as a monorepo with a lean core and pluggable communication protocols.**\n\nUTCP offers a unified framework for integrating disparate tools and services, making them accessible through a consistent and well-defined interface. This TypeScript SDK provides a comprehensive toolkit for developers to leverage the full power of the UTCP standard in their applications.\n\n## Key Features\n\n*   **Automatic Plugin Registration**: The official plugins are automatically discovered and registered when you import the core client—no manual setup required. For other plugins, you will need to register them manually.\n*   **Scalability**: Designed to handle a large number of tools and providers without compromising performance.\n*   **Extensibility**: A pluggable architecture allows developers to easily add new communication protocols, tool storage mechanisms, and search strategies without modifying the core library.\n*   **Interoperability**: With a growing ecosystem of protocol plugins—including HTTP, MCP, Text, File, and CLI—UTCP can integrate with almost any existing service or infrastructure.\n*   **Code Execution Mode**: Execute TypeScript code with hierarchical access to tools, complete console output capture, and runtime interface introspection for powerful AI agent workflows.\n*   **Type Safety**: Built on well-defined TypeScript interfaces and runtime validation powered by Zod, making it robust and developer-friendly.\n*   **Secure Variable Management**: Namespace-isolated variables prevent leakage between manuals, with support for environment variables and .env files.\n\n![MCP vs. UTCP](https://github.com/user-attachments/assets/3cadfc19-8eea-4467-b606-66e580b89444)\n\n## Getting Started\n\n### Installation\n\nInstall UTCP packages from npm:\n\n```bash\n# Install core SDK and desired protocol plugins\nnpm install @utcp/sdk @utcp/http @utcp/mcp @utcp/text @utcp/file @utcp/code-mode\n\n# Optional: Add dotenv variable loader for Node.js\nnpm install @utcp/dotenv-loader\n\n# Or using bun\nbun add @utcp/sdk @utcp/http @utcp/mcp @utcp/text @utcp/file @utcp/code-mode\n```\n\n### For Development\n\nTo set up the monorepo for development:\n\n```bash\n# Clone the repository\ngit clone https://github.com/universal-tool-calling-protocol/typescript-utcp.git\ncd typescript-utcp\n\n# Install dependencies (requires bun)\nbun install\n\n# Build all packages\nbun run build\n```\n\n## Quick Start\n\n### Basic Usage\n\nPlugins are **automatically registered** when you import the UtcpClient—no manual registration needed!\n\n```typescript\nimport { UtcpClient } from '@utcp/sdk';\nimport { HttpCallTemplateSerializer } from '@utcp/http';\n\nasync function main() {\n  // Create client - plugins auto-register\n  const serializer = new HttpCallTemplateSerializer();\n  const githubTemplate = serializer.validateDict({\n    name: 'github_api',\n    call_template_type: 'http',\n    http_method: 'GET',\n    url: 'https://api.github.com/users/${username}',\n  });\n\n  const client = await UtcpClient.create(process.cwd(), {\n    manual_call_templates: [githubTemplate],\n    variables: {\n      // Namespace format: manual_name_VARIABLE\n      github__api_username: 'octocat'\n    }\n  });\n\n  // Search for tools\n  const tools = await client.searchTools('github user');\n  console.log('Found tools:', tools.map(t => t.name));\n\n  // Call a tool\n  const result = await client.callTool('github_api.get_user', {});\n  console.log('Result:', result);\n\n  await client.close();\n}\n\nmain().catch(console.error);\n```\n\n### Working with Multiple Protocols\n\n```typescript\nimport { UtcpClient } from '@utcp/sdk';\nimport { HttpCallTemplateSerializer } from '@utcp/http';\nimport { McpCallTemplateSerializer } from '@utcp/mcp';\nimport { FileCallTemplateSerializer } from '@utcp/file';\n\nasync function main() {\n  // Create serializers for each protocol\n  const httpSerializer = new HttpCallTemplateSerializer();\n  const mcpSerializer = new McpCallTemplateSerializer();\n  const fileSerializer = new FileCallTemplateSerializer();\n\n  // Validate and create call templates\n  const httpTemplate = httpSerializer.validateDict({\n    name: 'api_manual',\n    call_template_type: 'http',\n    http_method: 'GET',\n    url: 'https://api.example.com/data',\n    headers: {\n      'Authorization': 'Bearer ${API_KEY}'\n    }\n  });\n\n  const mcpTemplate = mcpSerializer.validateDict({\n    name: 'mcp_tools',\n    call_template_type: 'mcp',\n    config: {\n      mcpServers: {\n        my_mcp_server: {\n          transport: 'stdio',\n          command: 'node',\n          args: ['./mcp-server.js'],\n          cwd: './servers'\n        }\n      }\n    }\n  });\n\n  const fileTemplate = fileSerializer.validateDict({\n    name: 'local_tools',\n    call_template_type: 'file',\n    file_path: './config/tools.json'\n  });\n\n  const client = await UtcpClient.create(process.cwd(), {\n    variables: {\n      // Namespaced variables for security\n      api__manual_API_KEY: process.env.API_KEY || 'default-key',\n    },\n    load_variables_from: [\n      {\n        variable_loader_type: 'dotenv',\n        env_file_path: './.env'\n      }\n    ],\n    manual_call_templates: [\n      httpTemplate,  // HTTP API\n      mcpTemplate,   // MCP Server\n      fileTemplate   // Local file-based tools\n    ]\n  });\n\n  // Tools are namespaced: manual_name.tool_name\n  // For MCP: manual_name.server_name.tool_name\n  const allTools = await client.getTools();\n  console.log('Registered tools:', allTools.map(t => t.name));\n  \n  // Examples:\n  // - 'api_manual.get_data'\n  // - 'mcp_tools.my_mcp_server.echo'\n  // - 'local_tools.my_function'\n\n  await client.close();\n}\n```\n\n## API Reference\n\n### UtcpClient.create()\n\n```typescript\nstatic async create(\n  root_dir: string,\n  config: Partial<UtcpClientConfig>\n): Promise<UtcpClient>\n```\n\n**Parameters:**\n- `root_dir`: Base directory for resolving relative paths (usually `process.cwd()`)\n- `config`: Client configuration object\n\n**Configuration Options:**\n\n```typescript\ninterface UtcpClientConfig {\n  // Direct variable definitions (highest priority)\n  variables?: Record<string, string>;\n  \n  // External variable loaders (e.g., .env files)\n  load_variables_from?: Array<{\n    variable_loader_type: 'dotenv';\n    env_file_path: string;\n  }>;\n  \n  // Manual call templates to register at startup\n  manual_call_templates?: CallTemplate[];\n  \n  // Tool repository configuration (defaults to in-memory)\n  tool_repository?: ConcurrentToolRepository;\n  \n  // Search strategy configuration (defaults to tag_and_description_word_match)\n  tool_search_strategy?: ToolSearchStrategy;\n  \n  // Post-processing configurations\n  post_processing?: ToolPostProcessor[];\n}\n```\n\n### Core Methods\n\n#### Search Tools\n```typescript\nasync searchTools(\n  query: string,\n  limit?: number,\n  anyOfTagsRequired?: string[]\n): Promise<Tool[]>\n```\n\nSearches for tools matching the query. The search considers:\n- **Tool names** (highest priority)\n- **Tool tags**\n- **Tool descriptions**\n\n#### Call Tool\n```typescript\nasync callTool(\n  toolName: string,\n  args: Record<string, any>\n): Promise<any>\n```\n\nExecutes a tool with the given arguments. Tool names follow these formats:\n- HTTP/Text/CLI: `manual_name.tool_name`\n- MCP: `manual_name.server_name.tool_name`\n\n#### Get Tools\n```typescript\nasync getTools(): Promise<Tool[]>\nasync getTool(toolName: string): Promise<Tool | undefined>\n```\n\nRetrieve all registered tools or get a specific tool by name.\n\n#### Register/Deregister Manuals\n```typescript\nasync registerManual(callTemplate: CallTemplate): Promise<void>\nasync deregisterManual(manualName: string): Promise<boolean>\n```\n\nDynamically add or remove tool manuals at runtime.\n\n## Variable Management\n\n### Variable Namespacing (Security Feature)\n\nVariables are **namespace-isolated** by manual name to prevent variable leakage between manuals:\n\n```typescript\n// For a manual named \"github_api\", variables are accessed as:\n// ${VARIABLE} -> resolved from \"github__api_VARIABLE\"\n\nimport { HttpCallTemplateSerializer } from '@utcp/http';\n\nconst serializer = new HttpCallTemplateSerializer();\nconst githubTemplate = serializer.validateDict({\n  name: 'github_api',\n  call_template_type: 'http',\n  http_method: 'GET',\n  url: 'https://api.github.com/users',\n  headers: {\n    // Resolves to 'github__api_TOKEN' only\n    'Authorization': 'Bearer ${TOKEN}'\n  }\n});\n\nconst client = await UtcpClient.create(process.cwd(), {\n  variables: {\n    'github__api_TOKEN': 'github-token-123',\n    'slack__api_TOKEN': 'slack-token-456',\n  },\n  manual_call_templates: [githubTemplate]\n});\n```\n\n**Namespace transformation**: Manual name underscores become double underscores:\n- `github_api` → `github__api_`\n- `my-service` → `my_service_` (hyphens to underscores)\n\n### Variable Resolution Order\n\n1. **Client config variables** (highest priority)\n2. **Variable loaders** (e.g., .env files, in order)\n3. **Environment variables** (lowest priority)\n\nAll lookups use the namespaced key: `{namespace}_VARIABLE_NAME`.\n\n### Loading from .env Files\n\n```typescript\nconst client = await UtcpClient.create(process.cwd(), {\n  load_variables_from: [\n    {\n      variable_loader_type: 'dotenv',\n      env_file_path: './.env'\n    }\n  ]\n});\n```\n\n## Communication Protocols\n\n### HTTP Protocol\n\nSupports RESTful APIs with automatic OpenAPI specification conversion:\n\n```typescript\nimport { HttpCallTemplateSerializer } from '@utcp/http';\n\nconst serializer = new HttpCallTemplateSerializer();\nconst weatherTemplate = serializer.validateDict({\n  name: 'weather_api',\n  call_template_type: 'http',\n  http_method: 'GET',\n  url: 'https://api.weather.com/v1/forecast',\n  headers: {\n    'X-API-Key': '${API_KEY}'\n  },\n  // Optional: Basic, API Key, or OAuth2 authentication\n  auth: {\n    auth_type: 'api_key',\n    var_name: 'X-API-Key',\n    api_key_value: '${API_KEY}',\n    in: 'header'\n  }\n});\n```\n\n**Features:**\n- Path parameter substitution\n- Header and body templates\n- Multiple authentication methods\n- Automatic OpenAPI to UTCP conversion\n\n### MCP Protocol\n\nConnect to Model Context Protocol servers:\n\n```typescript\nimport { McpCallTemplateSerializer } from '@utcp/mcp';\n\nconst serializer = new McpCallTemplateSerializer();\nconst mcpTemplate = serializer.validateDict({\n  name: 'mcp_manual',\n  call_template_type: 'mcp',\n  config: {\n    mcpServers: {\n      server_name: {\n        transport: 'stdio', // or 'http'\n        command: 'bun',\n        args: ['run', './mcp-server.ts'],\n        cwd: './servers',\n        env: { DEBUG: 'true' }\n      }\n    }\n  }\n});\n```\n\n**Tool Naming:** `manual_name.server_name.tool_name`\n\n**Features:**\n- Stdio and HTTP transports\n- Persistent session management\n- Automatic retry on connection errors\n- Multiple servers per manual\n\n### Text Protocol\n\nHandle direct text/string content (browser-compatible):\n\n```typescript\nimport { TextCallTemplateSerializer } from '@utcp/text';\n\nconst serializer = new TextCallTemplateSerializer();\nconst textTemplate = serializer.validateDict({\n  name: 'inline_tools',\n  call_template_type: 'text',\n  content: JSON.stringify({\n    tools: [\n      // UTCP manual or OpenAPI spec as string\n    ]\n  })\n});\n```\n\n### File Protocol\n\nLoad tools from local JSON/YAML files or OpenAPI specs (Node.js only):\n\n```typescript\nimport { FileCallTemplateSerializer } from '@utcp/file';\n\nconst serializer = new FileCallTemplateSerializer();\nconst fileTemplate = serializer.validateDict({\n  name: 'local_tools',\n  call_template_type: 'file',\n  file_path: './config/tools.json'\n  // Supports: .json, .yaml, .yml, OpenAPI specs\n});\n```\n\n### CLI Protocol\n\nExecute command-line tools:\n\n```typescript\nimport { CliCallTemplateSerializer } from '@utcp/cli';\n\nconst serializer = new CliCallTemplateSerializer();\nconst cliTemplate = serializer.validateDict({\n  name: 'system_commands',\n  call_template_type: 'cli',\n  commands: [\n    {\n      command: 'git status'\n    }\n  ],\n  working_dir: './my-repo'\n});\n```\n\n## Code Execution Mode\n\nThe `@utcp/code-mode` package provides a powerful extension that allows executing TypeScript code with direct access to registered tools, perfect for AI agents and complex workflows:\n\n```typescript\nimport { CodeModeUtcpClient } from '@utcp/code-mode';\n\nasync function main() {\n  const client = await CodeModeUtcpClient.create();\n  \n  // Register your tools (same as regular UTCP)\n  await client.registerManual({\n    name: 'math_tools',\n    call_template_type: 'text',\n    content: '...' // Your tool definitions\n  });\n\n  // Execute TypeScript code with hierarchical tool access\n  const { result, logs } = await client.callToolChain(`\n    console.log('Starting calculation...');\n    \n    // Tools are organized by namespace: manual.tool\n    const sum = await math_tools.add({ a: 10, b: 20 });\n    console.log('Sum result:', sum.result);\n    \n    // Access TypeScript interfaces at runtime for introspection\n    const addInterface = __getToolInterface('math_tools.add');\n    console.log('Tool interface:', addInterface);\n    \n    // Chain multiple tool calls\n    const result = await math_tools.multiply({ \n      a: sum.result, \n      b: 2 \n    });\n    \n    return result;\n  `);\n  \n  console.log('Execution result:', result);\n  console.log('Console output:', logs);\n  // logs: ['Starting calculation...', 'Sum result: 30', 'Tool interface: ...']\n  \n  await client.close();\n}\n```\n\n### Code Mode Features\n\n- **Hierarchical Tool Access**: Tools organized by manual namespace (`manual.tool()`) preventing naming conflicts\n- **Console Output Capture**: All console output automatically captured and returned\n- **Runtime Interface Introspection**: Access TypeScript interface definitions during execution\n- **Type Safety**: Generated TypeScript interfaces for all tools with hierarchical namespaces\n- **Secure Execution**: VM-based sandboxed execution with timeout protection\n- **AI Agent Ready**: Built-in prompt template to guide AI agents on proper usage\n\n### Perfect for AI Agents\n\nThe `CodeModeUtcpClient.AGENT_PROMPT_TEMPLATE` provides comprehensive guidance for AI agents:\n\n```typescript\n// Add to your AI system prompt\nconst systemPrompt = `\n${CodeModeUtcpClient.AGENT_PROMPT_TEMPLATE}\n\nYour additional instructions...\n`;\n```\n\nThe template includes:\n- Tool discovery workflow\n- Interface introspection patterns\n- Best practices for hierarchical tool access\n- Error handling guidelines\n- Runtime context documentation\n\n## Monorepo Structure\n\n```\ntypescript-utcp/\n├── packages/\n│   ├── core/          # Core SDK with UtcpClient and interfaces\n│   ├── http/          # HTTP protocol plugin\n│   ├── mcp/           # MCP protocol plugin\n│   ├── text/          # Text/string content protocol plugin (browser-compatible)\n│   ├── file/          # File system protocol plugin (Node.js only)\n│   ├── code-mode/     # TypeScript code execution with hierarchical tool access\n│   ├── dotenv-loader/ # DotEnv variable loader plugin (Node.js only)\n│   ├── direct-call/   # Direct call protocol plugin\n│   └── cli/           # CLI protocol plugin\n├── tests/             # End-to-end integration tests\n└── README.md\n```\n\nEach package is independently published to npm:\n- `@utcp/sdk` - Core SDK library (required)\n- `@utcp/http` - HTTP protocol support\n- `@utcp/mcp` - MCP protocol support\n- `@utcp/text` - Direct text/string content (browser-compatible)\n- `@utcp/file` - File system operations (Node.js only)\n- `@utcp/code-mode` - TypeScript code execution with hierarchical tool access\n- `@utcp/dotenv-loader` - DotEnv variable loader (Node.js only)\n- `@utcp/direct-call` - Direct function call protocol\n- `@utcp/cli` - Command-line tools\n\n## Development & Testing\n\n### Build\n\n```bash\n# Build all packages\nbun run build\n\n# Clean and rebuild\nbun run rebuild\n```\n\n### Testing\n\n```bash\n# Run all tests\nbun test\n\n# Run specific test file\nbun test tests/utcp_client.test.ts\n```\n\n### Publishing\n\n```bash\n# Publish all packages\nbun run publish:all\n\n# Or publish individually\nbun run publish:core\nbun run publish:http\nbun run publish:mcp\n```\n\n## Advanced Features\n\n### Custom Tool Repositories\n\nImplement custom storage backends:\n\n```typescript\nimport { ConcurrentToolRepository } from '@utcp/sdk';\n\nclass RedisToolRepository implements ConcurrentToolRepository {\n  // Implement required methods\n  async getTools(): Promise<Tool[]> { /* ... */ }\n  async getTool(name: string): Promise<Tool | undefined> { /* ... */ }\n  // ... other methods\n}\n```\n\n### Custom Search Strategies\n\nImplement custom tool search algorithms:\n\n```typescript\nimport { ToolSearchStrategy } from '@utcp/sdk';\n\nclass SemanticSearchStrategy implements ToolSearchStrategy {\n  async searchTools(\n    repository: ConcurrentToolRepository,\n    query: string,\n    limit?: number\n  ): Promise<Tool[]> {\n    // Custom semantic search implementation\n  }\n}\n```\n\n### Post-Processors\n\nTransform tool results:\n\n```typescript\nconst client = await UtcpClient.create(process.cwd(), {\n  post_processing: [\n    {\n      tool_post_processor_type: 'filter_dict',\n      allowed_keys: ['id', 'name', 'email']\n    },\n    {\n      tool_post_processor_type: 'limit_strings',\n      max_length: 1000\n    }\n  ]\n});\n```\n\n## Best Practices\n\n1. **Always call `client.close()`** to properly clean up resources\n2. **Use namespaced variables** for security and isolation\n3. **Leverage automatic plugin registration** - no manual setup needed\n4. **Use TypeScript types** from protocol packages for call templates\n5. **Handle tool call errors** appropriately in production\n6. **Test with integration tests** using the test patterns in `/tests`\n\n## License\n\nThis project is licensed under the Mozilla Public License Version 2.0. See the `LICENSE` file for details.\n\n## Contributing\n\nContributions are welcome! Please feel free to submit a Pull Request.\n\n## Code of Conduct\n\nThis project has adopted the Contributor Covenant Code of Conduct. For more information, see the [Code of Conduct](https://www.contributor-covenant.org/version/2/1/code_of_conduct/).\n",
      "line_count": 655,
      "word_count": 2070,
      "title": "Universal Tool Calling Protocol (UTCP) for TypeScript",
      "summary": "[![Follow Org](https://img.shields.io/github/followers/universal-tool-calling-protocol?label=Follow%20Org&logo=github)](https://github.com/universal-tool-calling-protocol) [![NPM version](https://img....",
      "key_terms": [
        "double",
        "comprehensive",
        "close",
        "const",
        "packages",
        "Model",
        "img",
        "Type",
        "extension",
        "Code",
        "Record",
        "mode",
        "Clone",
        "during",
        "loaders",
        "callTemplate",
        "providers",
        "Found",
        "VM-based",
        "licensed"
      ],
      "timestamp": "2025-12-24T18:56:16.463791"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\tsconfig.json",
      "content_type": "configuration",
      "content": "// typescript-utcp/tsconfig.json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"ESNext\",\n    \"lib\": [\"ES2022\", \"DOM\"],\n    \"declaration\": true,\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true, \n    \"moduleResolution\": \"bundler\",\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@utcp/sdk\": [\"packages/core/src\"],\n      \"@utcp/sdk/*\": [\"packages/core/src/*\"],\n      \"@utcp/http\": [\"packages/http/src\"],\n      \"@utcp/http/*\": [\"packages/http/src/*\"],\n      \"@utcp/mcp\": [\"packages/mcp/src\"],\n      \"@utcp/mcp/*\": [\"packages/mcp/src/*\"],\n      \"@utcp/text\": [\"packages/text/src\"],\n      \"@utcp/text/*\": [\"packages/text/src/*\"],\n      \"@utcp/cli\": [\"packages/cli/src\"],\n      \"@utcp/cli/*\": [\"packages/cli/src/*\"],\n\n    },\n    \"outDir\": \"dist\",\n    \"composite\": true,\n    \"allowSyntheticDefaultImports\": true \n  },\n  \"include\": [\n    \"packages/**/src/**/*\",\n    \"packages/**/tests/**/*\",\n    \"examples/**/*\", \n    \"tests/**/*\",\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"**/dist\",\n    \"**/*.test.ts\",\n    \"**/*.spec.ts\"\n  ],\n  \"references\": [\n    { \"path\": \"./packages/core\" },\n    { \"path\": \"./packages/http\" },\n    { \"path\": \"./packages/mcp\" },\n    { \"path\": \"./packages/text\" },\n    { \"path\": \"./packages/cli\" }\n  ]\n}",
      "line_count": 50,
      "word_count": 94,
      "title": "Tsconfig.Json",
      "summary": "// typescript-utcp/tsconfig.json \"compilerOptions\": {",
      "key_terms": [
        "packages",
        "paths",
        "composite",
        "exclude",
        "lib",
        "esModuleInterop",
        "module",
        "skipLibCheck",
        "target",
        "allowSyntheticDefaultImports",
        "outDir",
        "utcp",
        "examples",
        "test",
        "spec",
        "cli",
        "ts",
        "baseUrl",
        "core",
        "tests"
      ],
      "timestamp": "2025-12-24T18:56:16.495209"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\tsconfig.test.json",
      "content_type": "configuration",
      "content": "// typescript-utcp/tsconfig.test.json\n{\n  \"extends\": \"./tsconfig.json\", \n  \"compilerOptions\": {\n  \n    \"outDir\": \"./dist-test\",\n    \"rootDir\": \".\",\n    \"types\": [\"bun-test\", \"node\"] \n  },\n  \"include\": [\n    \"tests/**/*.ts\",\n    \"packages/**/src/**/*.ts\" \n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"packages/**/dist\",\n    \"dist\"\n  ]\n}",
      "line_count": 19,
      "word_count": 27,
      "title": "Tsconfig.Test.Json",
      "summary": "// typescript-utcp/tsconfig.test.json \"extends\": \"./tsconfig.json\",",
      "key_terms": [
        "dist-test",
        "packages",
        "exclude",
        "node",
        "extends",
        "utcp",
        "outDir",
        "test",
        "rootDir",
        "ts",
        "types",
        "tests",
        "bun",
        "bun-test",
        "typescript-utcp",
        "dist",
        "include",
        "typescript",
        "tsconfig",
        "json"
      ],
      "timestamp": "2025-12-24T18:56:16.511399"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\cli\\package.json",
      "content_type": "configuration",
      "content": "{\n  \"name\": \"@utcp/cli\",\n  \"version\": \"1.1.0\",\n  \"description\": \"CLI utilities for UTCP\",\n  \"main\": \"dist/index.cjs\",\n  \"module\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"type\": \"module\",\n  \"license\": \"MPL-2.0\",\n  \"author\": \"UTCP Contributors\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/universal-tool-calling-protocol/typescript-utcp.git\",\n    \"directory\": \"packages/cli\"\n  },\n  \"keywords\": [\n    \"utcp\",\n    \"universal-tool-calling-protocol\",\n    \"tools\",\n    \"api\",\n    \"typescript\",\n    \"tool calling\",\n    \"cli\",\n    \"agent\",\n    \"ai\",\n    \"llm\"\n  ],\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"scripts\": {\n    \"build\": \"tsup\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\",\n      \"require\": \"./dist/index.cjs\",\n      \"default\": \"./dist/index.js\"\n    }\n  },\n  \"dependencies\": {\n    \"@utcp/sdk\": \"^1.1.0\"\n  },\n  \"devDependencies\": {\n    \"bun-types\": \"latest\",\n    \"typescript\": \"^5.0.0\",\n    \"@types/bun\": \"latest\"\n  }\n}\n",
      "line_count": 54,
      "word_count": 89,
      "title": "Package.Json",
      "summary": "\"name\": \"@utcp/cli\", \"version\": \"1.1.0\",",
      "key_terms": [
        "build",
        "packages",
        "calling-protocol",
        "scripts",
        "universal",
        "module",
        "utcp",
        "index",
        "calling",
        "MPL",
        "tool",
        "utilities",
        "dependencies",
        "type",
        "url",
        "github",
        "public",
        "protocol",
        "for",
        "default"
      ],
      "timestamp": "2025-12-24T18:56:16.550249"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\cli\\README.md",
      "content_type": "documentation",
      "content": "# @utcp/cli: Command Line Interface Communication Protocol for UTCP\n\nThe `@utcp/cli` package enables the `UtcpClient` to interact with command-line tools and programs as UTCP tool providers. This plugin provides a cross-platform way to execute shell commands, scripts, and CLI utilities with full support for multi-step workflows, environment variables, and output chaining.\n\n## Features\n\n*   **Automatic Plugin Registration**: Registers automatically when imported—no manual setup required.\n*   **Cross-Platform Support**: Automatically generates platform-specific scripts:\n    *   **Windows**: PowerShell scripts with proper error handling\n    *   **Unix/Linux/macOS**: Bash scripts with shell compatibility\n*   **Multi-Command Workflows**: Execute multiple commands in sequence within a single subprocess, maintaining state between commands.\n*   **Output Chaining**: Reference previous command outputs using variables (`$CMD_0_OUTPUT`, `$CMD_1_OUTPUT`, etc.).\n*   **Argument Placeholders**: Use `UTCP_ARG_argname_UTCP_END` placeholders for dynamic argument substitution.\n*   **Environment Variables**: Configure custom environment variables with UTCP variable substitution support.\n*   **Working Directory**: Specify custom working directories for command execution.\n*   **Tool Discovery**: Automatically discover tools by executing a discovery command that outputs a UTCP manual.\n*   **Smart Output Handling**: Control which command outputs are included in the final result.\n*   **JSON Output Parsing**: Automatically parses JSON responses when detected.\n\n## Installation\n\n```bash\nbun add @utcp/cli @utcp/sdk\n\n# Or using npm\nnpm install @utcp/cli @utcp/sdk\n```\n\nNote: `@utcp/sdk` is a peer dependency.\n\n## Usage\n\nThe CLI plugin registers automatically when you import it—no manual registration needed. Simply import from `@utcp/cli` to enable CLI support.\n\n```typescript\n// From your application's entry point\n\nimport { UtcpClient } from '@utcp/sdk';\nimport { CliCallTemplateSerializer } from '@utcp/cli';\n\nasync function main() {\n  // Define a CLI CallTemplate for single command execution\n  const serializer = new CliCallTemplateSerializer();\n  const gitStatusTemplate = serializer.validateDict({\n    name: 'git_status_tool',\n    call_template_type: 'cli',\n    commands: [\n      {\n        command: 'git status --porcelain',\n        append_to_final_output: true\n      }\n    ],\n    working_dir: '/path/to/your/repo'\n  });\n\n  const client = await UtcpClient.create(process.cwd(), {\n    manual_call_templates: [gitStatusTemplate]\n  });\n\n  console.log('CLI Plugin active. Executing tools...');\n\n  // Call the CLI tool\n  try {\n    const result = await client.callTool('git_status_tool', {});\n    console.log('Git status result:', result);\n  } catch (error) {\n    console.error('Error calling CLI tool:', error);\n  }\n\n  await client.close();\n}\n\nmain().catch(console.error);\n```\n\n## Advanced Configuration\n\n### Multi-Command Workflows\n\nExecute multiple commands in sequence within a single subprocess. State (like directory changes) is maintained between commands:\n\n```typescript\nconst serializer = new CliCallTemplateSerializer();\nconst multiStepTemplate = serializer.validateDict({\n  name: 'multi_step_workflow',\n  call_template_type: 'cli',\n  commands: [\n    {\n      command: 'cd UTCP_ARG_target_dir_UTCP_END',\n      append_to_final_output: false  // Don't include this output in final result\n    },\n    {\n      command: 'git pull origin main',\n      append_to_final_output: false  // Don't include this output\n    },\n    {\n      command: 'npm install',\n      append_to_final_output: false  // Don't include this output\n    },\n    {\n      command: 'npm test',\n      append_to_final_output: true   // Include this output in final result\n    }\n  ]\n});\n\n// Call with arguments\nconst result = await client.callTool('multi_step_workflow', {\n  target_dir: '/path/to/project'\n});\n```\n\n### Output Chaining\n\nReference the output of previous commands using variables:\n\n```typescript\nconst serializer = new CliCallTemplateSerializer();\nconst outputChainingTemplate = serializer.validateDict({\n  name: 'chained_commands',\n  call_template_type: 'cli',\n  commands: [\n    {\n      command: 'git rev-parse --short HEAD',\n      append_to_final_output: false\n    },\n    {\n      command: 'echo \"Building version: $CMD_0_OUTPUT\"',\n      append_to_final_output: false\n    },\n    {\n      command: 'docker build -t myapp:$CMD_0_OUTPUT .',\n      append_to_final_output: true\n    }\n  ]\n});\n```\n\n**Platform-Specific Variable Reference:**\n- **PowerShell** (Windows): `$CMD_0_OUTPUT`, `$CMD_1_OUTPUT`, etc.\n- **Bash** (Unix/Linux/macOS): `$CMD_0_OUTPUT`, `$CMD_1_OUTPUT`, etc.\n\n### Argument Placeholders\n\nUse `UTCP_ARG_argname_UTCP_END` placeholders for dynamic argument substitution:\n\n```typescript\nconst serializer = new CliCallTemplateSerializer();\nconst templateWithArgs = serializer.validateDict({\n  name: 'deploy_service',\n  call_template_type: 'cli',\n  commands: [\n    {\n      command: 'kubectl set image deployment/UTCP_ARG_service_name_UTCP_END ' +\n               'UTCP_ARG_service_name_UTCP_END=UTCP_ARG_image_tag_UTCP_END',\n      append_to_final_output: true\n    },\n    {\n      command: 'kubectl rollout status deployment/UTCP_ARG_service_name_UTCP_END',\n      append_to_final_output: true\n    }\n  ]\n});\n\n// Call with arguments - placeholders will be replaced\nconst result = await client.callTool('deploy_service', {\n  service_name: 'api-server',\n  image_tag: 'myapp:v1.2.3'\n});\n```\n\n### Environment Variables\n\nConfigure custom environment variables with UTCP variable substitution:\n\n```typescript\nconst serializer = new CliCallTemplateSerializer();\nconst envVarTemplate = serializer.validateDict({\n  name: 'python_script',\n  call_template_type: 'cli',\n  commands: [\n    {\n      command: 'python analysis.py --input UTCP_ARG_input_file_UTCP_END'\n    }\n  ],\n  env_vars: {\n    PYTHONPATH: '/custom/python/path',\n    API_KEY: '${MY_API_KEY}',        // Uses UTCP variable substitution\n    LOG_LEVEL: 'debug',\n    DATABASE_URL: '${DATABASE_URL}'\n  },\n  working_dir: '/path/to/scripts'\n});\n\nconst client = await UtcpClient.create(process.cwd(), {\n  manual_call_templates: [envVarTemplate],\n  variables: {\n    python__script_MY_API_KEY: 'secret-key-123',        // Namespaced variable\n    python__script_DATABASE_URL: 'postgresql://localhost/mydb'  // Namespaced variable\n  }\n});\n```\n\n### Tool Discovery\n\nCreate a CLI provider that discovers its tools dynamically:\n\n```typescript\n// Your CLI script should output a UTCP manual when called with a discovery flag\nconst serializer = new CliCallTemplateSerializer();\nconst discoveryTemplate = serializer.validateDict({\n  name: 'my_cli_tools',\n  call_template_type: 'cli',\n  commands: [\n    {\n      command: 'node my-cli-tool.js --utcp-discover',\n      append_to_final_output: true\n    }\n  ]\n});\n\nconst client = await UtcpClient.create(process.cwd(), {\n  manual_call_templates: [discoveryTemplate]\n});\n\n// Tools are automatically discovered and registered\nconst tools = await client.searchTools('my_cli_tools');\nconsole.log('Discovered tools:', tools.map(t => t.name));\n```\n\n**Example CLI Tool with Discovery:**\n\n```typescript\n// my-cli-tool.ts\nif (process.argv.includes('--utcp-discover')) {\n  const manual = {\n    utcp_version: \"1.0.0\",\n    manual_version: \"1.0.0\",\n    tools: [\n      {\n        name: \"echo_cli\",\n        description: \"Echoes a message via CLI.\",\n        inputs: {\n          type: \"object\",\n          properties: { message: { type: \"string\" } },\n          required: [\"message\"]\n        },\n        outputs: { type: \"string\" },\n        tags: [\"cli\", \"echo\"],\n        tool_call_template: {\n          name: \"my_cli_tools\",\n          call_template_type: \"cli\"\n        }\n      }\n    ]\n  };\n  console.log(JSON.stringify(manual));\n  process.exit(0);\n}\n\n// Handle other commands...\n```\n\n### Cross-Platform Commands\n\n**Important:** Use platform-appropriate syntax for your commands:\n\n**Windows (PowerShell):**\n```typescript\n{\n  commands: [\n    { command: 'Get-ChildItem -Path UTCP_ARG_path_UTCP_END' },\n    { command: 'Set-Location -Path UTCP_ARG_new_dir_UTCP_END' }\n  ]\n}\n```\n\n**Unix/Linux/macOS (Bash):**\n```typescript\n{\n  commands: [\n    { command: 'ls -la UTCP_ARG_path_UTCP_END' },\n    { command: 'cd UTCP_ARG_new_dir_UTCP_END' }\n  ]\n}\n```\n\nThe CLI plugin automatically detects the platform and executes commands using the appropriate shell.\n\n## Output Control\n\nControl which command outputs appear in the final result using `append_to_final_output`:\n\n```typescript\n{\n  commands: [\n    {\n      command: 'git pull',\n      append_to_final_output: false  // Don't include in result\n    },\n    {\n      command: 'npm test',\n      append_to_final_output: true   // Include in result\n    },\n    {\n      command: 'npm run build',\n      append_to_final_output: true   // Include in result\n    }\n  ]\n}\n```\n\n**Default Behavior:**\n- If `append_to_final_output` is not specified, only the **last command's output** is included in the final result.\n- Set explicitly to `true` or `false` to override this behavior for any command.\n\n## JSON Output Handling\n\nThe CLI plugin automatically detects and parses JSON output:\n\n```typescript\nconst serializer = new CliCallTemplateSerializer();\nconst jsonOutputTemplate = serializer.validateDict({\n  name: 'json_cli_tool',\n  call_template_type: 'cli',\n  commands: [\n    {\n      command: 'echo \\'{\"status\": \"success\", \"count\": 42}\\''\n    }\n  ]\n});\n\nconst result = await client.callTool('json_cli_tool', {});\n// result = { status: \"success\", count: 42 }  // Automatically parsed as JSON\n```\n\nIf output doesn't start with `{` or `[`, it's returned as plain text.\n\n## Command Execution Details\n\n### Single Subprocess Execution\n\nAll commands in a template are executed in a **single subprocess**, which means:\n- State is preserved between commands (e.g., directory changes with `cd`)\n- Environment variables persist across commands\n- Variables set in one command can be used in later commands\n\n### Script Generation\n\nThe plugin generates platform-specific scripts:\n\n**Windows (PowerShell):**\n```powershell\n$ErrorActionPreference = \"Stop\"\n# Variables to store command outputs\n$CMD_0_OUTPUT = git status 2>&1 | Out-String\n$CMD_1_OUTPUT = echo \"Status: $CMD_0_OUTPUT\" 2>&1 | Out-String\nWrite-Output $CMD_1_OUTPUT\n```\n\n**Unix (Bash):**\n```bash\n#!/bin/bash\n# Variables to store command outputs\nCMD_0_OUTPUT=$(git status 2>&1)\nCMD_1_OUTPUT=$(echo \"Status: $CMD_0_OUTPUT\" 2>&1)\necho \"${CMD_1_OUTPUT}\"\n```\n\n### Timeout Configuration\n\nDefault timeouts:\n- **Tool Discovery**: 30 seconds\n- **Tool Execution**: 120 seconds\n\nThese provide ample time for multi-command workflows.\n\n## API Reference\n\n### CliCallTemplate\n\n```typescript\ninterface CliCallTemplate {\n  name?: string;\n  call_template_type: 'cli';\n  commands: CommandStep[];\n  env_vars?: Record<string, string> | null;\n  working_dir?: string | null;\n  auth?: undefined;  // Not applicable for CLI\n}\n```\n\n### CommandStep\n\n```typescript\ninterface CommandStep {\n  command: string;                     // Command to execute with optional placeholders\n  append_to_final_output?: boolean;    // Include in final result (default: true for last command only)\n}\n```\n\n### Placeholder Syntax\n\n- **Argument Placeholder**: `UTCP_ARG_argname_UTCP_END`\n  - Replaced with the value from `tool_args`\n  - Example: `UTCP_ARG_filename_UTCP_END` → `'myfile.txt'`\n\n- **Output Reference**: `$CMD_N_OUTPUT` (where N is the command index starting from 0)\n  - References the output of previous commands\n  - Example: `$CMD_0_OUTPUT` → output from first command\n\n## Security Considerations\n\n**⚠️ Important Security Notes:**\n\n1. **Trusted Commands Only**: Commands are executed in a subprocess. Only use CLI templates from trusted sources.\n2. **Avoid Unsanitized Input**: Do not pass unsanitized user input directly into command strings.\n3. **Command Injection**: Be cautious when using output references (`$CMD_N_OUTPUT`) to avoid command injection vulnerabilities.\n4. **Validate Arguments**: Use proper input validation in your tool definitions.\n5. **Environment Variables**: Be careful with sensitive data in environment variables.\n\n## Best Practices\n\n1. **Use Placeholders**: Always use `UTCP_ARG_*_UTCP_END` placeholders instead of string concatenation.\n2. **Explicit Output Control**: Explicitly set `append_to_final_output` for clarity in multi-command workflows.\n3. **Error Handling**: Wrap tool calls in try-catch blocks for robust error handling.\n4. **Working Directory**: Specify `working_dir` when commands depend on specific file locations.\n5. **Platform-Specific Syntax**: Use appropriate command syntax for your target platform(s).\n6. **Tool Discovery**: Implement discovery commands that output valid UTCP manuals for dynamic tool registration.\n7. **Timeouts**: Be mindful of execution time for long-running commands.\n\n## Examples\n\n### Basic File Operations\n\n```typescript\nconst serializer = new CliCallTemplateSerializer();\nconst fileOpsTemplate = serializer.validateDict({\n  name: 'file_operations',\n  call_template_type: 'cli',\n  commands: [\n    {\n      command: 'cat UTCP_ARG_filename_UTCP_END'\n    }\n  ]\n});\n\nconst content = await client.callTool('file_operations', {\n  filename: '/path/to/file.txt'\n});\n```\n\n### Build and Test Pipeline\n\n```typescript\nconst serializer = new CliCallTemplateSerializer();\nconst buildPipeline = serializer.validateDict({\n  name: 'build_and_test',\n  call_template_type: 'cli',\n  commands: [\n    {\n      command: 'npm run lint',\n      append_to_final_output: false\n    },\n    {\n      command: 'npm test',\n      append_to_final_output: true\n    },\n    {\n      command: 'npm run build',\n      append_to_final_output: true\n    }\n  ],\n  env_vars: {\n    NODE_ENV: 'production',\n    CI: 'true'\n  }\n});\n```\n\n### Git Workflow\n\n```typescript\nconst serializer = new CliCallTemplateSerializer();\nconst gitWorkflow = serializer.validateDict({\n  name: 'git_commit_push',\n  call_template_type: 'cli',\n  commands: [\n    {\n      command: 'git add .',\n      append_to_final_output: false\n    },\n    {\n      command: 'git commit -m \"UTCP_ARG_message_UTCP_END\"',\n      append_to_final_output: false\n    },\n    {\n      command: 'git push origin UTCP_ARG_branch_UTCP_END',\n      append_to_final_output: true\n    }\n  ]\n});\n\nconst result = await client.callTool('git_commit_push', {\n  message: 'feat: add new feature',\n  branch: 'main'\n});\n```\n\n## Limitations\n\n- **No Streaming Support**: The CLI protocol does not support streaming. All output is returned when the command completes.\n- **Platform-Specific**: Commands must be written for the target platform (Windows/Unix).\n- **No Interactive Commands**: Interactive CLI tools (that require user input) are not supported.\n- **Fixed Timeouts**: Timeout durations are currently fixed (though generous).\n\n## License\n\nThis package is part of the UTCP project. See the main repository for license information.\n",
      "line_count": 520,
      "word_count": 1673,
      "title": "@utcp/cli: Command Line Interface Communication Protocol for UTCP",
      "summary": "The `@utcp/cli` package enables the `UtcpClient` to interact with command-line tools and programs as UTCP tool providers. This plugin provides a cross-platform way to execute shell commands, scripts, ...",
      "key_terms": [
        "Out-String",
        "Explicitly",
        "close",
        "const",
        "Important",
        "localhost",
        "etc",
        "Record",
        "long-running",
        "providers",
        "rollout",
        "starting",
        "multiple",
        "Platform",
        "dynamically",
        "image",
        "if",
        "that",
        "Features",
        "interface"
      ],
      "timestamp": "2025-12-24T18:56:16.590250"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\cli\\tsconfig.json",
      "content_type": "configuration",
      "content": "{\n    \"extends\": \"../../tsconfig.json\",\n    \"compilerOptions\": {\n      \"outDir\": \"./dist\",\n      \"rootDir\": \"./src\",\n      \"composite\": true\n    },\n    \"include\": [\n      \"src/**/*\"\n    ],\n    \"exclude\": [\n      \"node_modules\",\n      \"dist\",\n      \"**/*.test.ts\",\n      \"**/*.spec.ts\"\n    ],\n    \"references\": [\n      { \"path\": \"../core\" }\n    ]\n  }",
      "line_count": 20,
      "word_count": 31,
      "title": "Tsconfig.Json",
      "summary": "\"extends\": \"../../tsconfig.json\", \"compilerOptions\": {",
      "key_terms": [
        "rootDir",
        "composite",
        "exclude",
        "include",
        "references",
        "tsconfig",
        "ts",
        "spec",
        "json",
        "path",
        "core",
        "extends",
        "compilerOptions",
        "dist",
        "src",
        "outDir",
        "test",
        "true"
      ],
      "timestamp": "2025-12-24T18:56:16.606200"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\cli\\tsup.config.ts",
      "content_type": "code",
      "content": "import { defineConfig } from 'tsup';\n\nexport default defineConfig({\n  entry: ['src/index.ts'],\n  format: ['esm', 'cjs'],\n  dts: {\n    compilerOptions: {\n      composite: false,\n      paths: {},\n    },\n  },\n  splitting: false,\n  sourcemap: true,\n  clean: true,\n  outDir: 'dist',\n  external: ['@utcp/sdk'],\n});\n",
      "line_count": 18,
      "word_count": 35,
      "title": "Tsup.Config.Ts",
      "summary": "import { defineConfig } from 'tsup'; export default defineConfig({",
      "key_terms": [
        "from",
        "sourcemap",
        "composite",
        "paths",
        "entry",
        "clean",
        "utcp",
        "outDir",
        "index",
        "format",
        "default",
        "ts",
        "cjs",
        "false",
        "import",
        "export",
        "sdk",
        "dist",
        "splitting",
        "tsup"
      ],
      "timestamp": "2025-12-24T18:56:16.606200"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\cli\\src\\cli_call_template.ts",
      "content_type": "code",
      "content": "// packages/cli/src/cli_call_template.ts\nimport { z } from 'zod';\nimport { CallTemplate } from '@utcp/sdk';\nimport { Serializer } from '@utcp/sdk';\n\n/**\n * REQUIRED\n * Configuration for a single command step in a CLI execution flow.\n * \n * Attributes:\n *     command: The command string to execute. Can contain UTCP_ARG_argname_UTCP_END\n *         placeholders that will be replaced with values from tool_args. Can also\n *         reference previous command outputs using $CMD_0_OUTPUT, $CMD_1_OUTPUT, etc.\n *     append_to_final_output: Whether this command's output should be included\n *         in the final result. If not specified, defaults to False for all\n *         commands except the last one.\n * \n * Examples:\n *     Basic command step:\n *     ```json\n *     {\n *       \"command\": \"git status\",\n *       \"append_to_final_output\": true\n *     }\n *     ```\n *     \n *     Command with argument placeholders and output reference:\n *     ```json\n *     {\n *       \"command\": \"echo \\\"Cloning to: UTCP_ARG_target_dir_UTCP_END, previous status: $CMD_0_OUTPUT\\\"\",\n *       \"append_to_final_output\": true\n *     }\n *     ```\n */\nexport interface CommandStep {\n  /**\n   * Command string to execute, may contain UTCP_ARG_argname_UTCP_END placeholders\n   */\n  command: string;\n  /**\n   * Whether to include this command's output in final result. Defaults to False for all except last command\n   */\n  append_to_final_output?: boolean | null;\n}\n\n/**\n * Zod schema for CommandStep.\n */\nexport const CommandStepSchema: z.ZodType<CommandStep> = z.object({\n  command: z.string().describe('Command string to execute, may contain UTCP_ARG_argname_UTCP_END placeholders'),\n  append_to_final_output: z.boolean().nullable().optional().describe('Whether to include this command\\'s output in final result. Defaults to False for all except last command'),\n}).strict() as z.ZodType<CommandStep>;\n\n/**\n * REQUIRED\n * Call template configuration for Command Line Interface (CLI) tools.\n *\n * This class defines the configuration for executing command-line tools and\n * programs as UTCP tool providers. Commands are executed in a single subprocess\n * to maintain state (like directory changes) between commands.\n *\n * **Cross-Platform Script Generation:**\n * - **Windows**: Commands are converted to a PowerShell script\n * - **Unix/Linux/macOS**: Commands are converted to a Bash script\n * \n * **Command Syntax Requirements:**\n * - Windows: Use PowerShell syntax (e.g., `Get-ChildItem`, `Set-Location`)\n * - Unix: Use Bash/shell syntax (e.g., `ls`, `cd`)\n * \n * **Referencing Previous Command Output:**\n * You can reference the output of previous commands using variables:\n * - **PowerShell**: `$CMD_0_OUTPUT`, `$CMD_1_OUTPUT`, etc.\n * - **Bash**: `$CMD_0_OUTPUT`, `$CMD_1_OUTPUT`, etc.\n * \n * Example: `echo \"Previous result: $CMD_0_OUTPUT\"`\n *\n * Attributes:\n *     call_template_type: The type of the call template. Must be \"cli\".\n *     commands: A list of CommandStep objects defining the commands to execute\n *         in order. Each command can contain UTCP_ARG_argname_UTCP_END placeholders\n *         that will be replaced with values from tool_args during execution.\n *     env_vars: A dictionary of environment variables to set for the command's\n *         execution context. Values can be static strings or placeholders for\n *         variables from the UTCP client's variable substitutor.\n *     working_dir: The working directory from which to run the commands. If not\n *         provided, it defaults to the current process's working directory.\n *     auth: Authentication details. Not applicable to the CLI protocol, so it\n *         is always None.\n *\n * Examples:\n *     Cross-platform directory operations:\n *     ```json\n *     {\n *       \"name\": \"cross_platform_dir_tool\",\n *       \"call_template_type\": \"cli\",\n *       \"commands\": [\n *         {\n *           \"command\": \"cd UTCP_ARG_target_dir_UTCP_END\",\n *           \"append_to_final_output\": false\n *         },\n *         {\n *           \"command\": \"ls -la\",\n *           \"append_to_final_output\": true\n *         }\n *       ]\n *     }\n *     ```\n *     \n *     Referencing previous command output:\n *     ```json\n *     {\n *       \"name\": \"reference_previous_output_tool\",\n *       \"call_template_type\": \"cli\",\n *       \"commands\": [\n *         {\n *           \"command\": \"git status --porcelain\",\n *           \"append_to_final_output\": false\n *         },\n *         {\n *           \"command\": \"echo \\\"Found changes: $CMD_0_OUTPUT\\\"\",\n *           \"append_to_final_output\": true\n *         }\n *       ]\n *     }\n *     ```\n *\n *     Command with environment variables and placeholders:\n *     ```json\n *     {\n *       \"name\": \"python_multi_step_tool\",\n *       \"call_template_type\": \"cli\",\n *       \"commands\": [\n *         {\n *           \"command\": \"python setup.py install\",\n *           \"append_to_final_output\": false\n *         },\n *         {\n *           \"command\": \"python script.py --input UTCP_ARG_input_file_UTCP_END --result \\\"$CMD_0_OUTPUT\\\"\"\n *         }\n *       ],\n *       \"env_vars\": {\n *         \"PYTHONPATH\": \"/custom/path\",\n *         \"API_KEY\": \"${API_KEY_VAR}\"\n *       }\n *     }\n *     ```\n *\n * Security Considerations:\n *     - Commands are executed in a subprocess. Ensure that the commands\n *       specified are from a trusted source.\n *     - Avoid passing unsanitized user input directly into the command string.\n *       Use tool argument validation where possible.\n *     - All placeholders are replaced with string values from tool_args.\n *     - Commands should use the appropriate syntax for the target platform\n *       (PowerShell on Windows, Bash on Unix).\n *     - Previous command outputs are available as variables but should be\n *       used carefully to avoid command injection.\n */\nexport interface CliCallTemplate extends CallTemplate {\n  call_template_type: 'cli';\n  commands: CommandStep[];\n  env_vars?: Record<string, string> | null;\n  working_dir?: string | null;\n  auth?: undefined;\n  allowed_communication_protocols?: string[];\n}\n\n/**\n * Zod schema for CLI Call Template.\n */\nexport const CliCallTemplateSchema: z.ZodType<CliCallTemplate> = z.object({\n  name: z.string().optional(),\n  call_template_type: z.literal('cli'),\n  commands: z.array(CommandStepSchema).describe('List of commands to execute in order. Each command can contain UTCP_ARG_argname_UTCP_END placeholders.'),\n  env_vars: z.record(z.string(), z.string()).nullable().optional().describe('Environment variables to set when executing the commands'),\n  working_dir: z.string().nullable().optional().describe('Working directory for command execution'),\n  auth: z.undefined().optional(),\n  allowed_communication_protocols: z.array(z.string()).optional().describe('Optional list of allowed communication protocol types for tools within this manual.'),\n}).strict() as z.ZodType<CliCallTemplate>;\n\n/**\n * REQUIRED\n * Serializer for converting between `CliCallTemplate` and dictionary representations.\n *\n * This class handles the serialization and deserialization of `CliCallTemplate`\n * objects, ensuring that they can be correctly represented as dictionaries and\n * reconstructed from them, with validation.\n */\nexport class CliCallTemplateSerializer extends Serializer<CliCallTemplate> {\n  /**\n   * REQUIRED\n   * Converts a `CliCallTemplate` instance to its dictionary representation.\n   *\n   * @param obj The `CliCallTemplate` instance to serialize.\n   * @returns A dictionary representing the `CliCallTemplate`.\n   */\n  toDict(obj: CliCallTemplate): Record<string, unknown> {\n    return {\n      name: obj.name,\n      call_template_type: obj.call_template_type,\n      commands: obj.commands,\n      env_vars: obj.env_vars,\n      working_dir: obj.working_dir,\n      auth: obj.auth,\n      allowed_communication_protocols: obj.allowed_communication_protocols,\n    };\n  }\n\n  /**\n   * REQUIRED\n   * Validates a dictionary and constructs a `CliCallTemplate` instance.\n   *\n   * @param obj The dictionary to validate and deserialize.\n   * @returns A `CliCallTemplate` instance.\n   * @throws Error if the dictionary is not a valid representation of a `CliCallTemplate`.\n   */\n  validateDict(obj: Record<string, unknown>): CliCallTemplate {\n    try {\n      return CliCallTemplateSchema.parse(obj);\n    } catch (e: any) {\n      throw new Error(`Invalid CliCallTemplate: ${e.message}\\n${e.stack || ''}`);\n    }\n  }\n}",
      "line_count": 224,
      "word_count": 990,
      "title": "Cli Call Template.Ts",
      "summary": "// packages/cli/src/cli_call_template.ts import { z } from 'zod';",
      "key_terms": [
        "nullable",
        "output",
        "executing",
        "const",
        "contain",
        "packages",
        "maintain",
        "null",
        "REQUIRED",
        "etc",
        "If",
        "record",
        "Cross",
        "Record",
        "list",
        "during",
        "available",
        "unknown",
        "Linux",
        "specified"
      ],
      "timestamp": "2025-12-24T18:56:16.653866"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\cli\\src\\cli_communication_protocol.ts",
      "content_type": "code",
      "content": "/**\n * Command Line Interface (CLI) communication protocol for the UTCP client.\n *\n * This module provides an implementation of the `CommunicationProtocol` interface\n * that enables the UTCP client to interact with command-line tools. It supports\n * discovering tools by executing a command and parsing its output for a UTCP\n * manual, as well as calling those tools with arguments.\n *\n * Key Features:\n *     - Asynchronous execution of shell commands.\n *     - Tool discovery by running a command that outputs a UTCP manual.\n *     - Flexible argument formatting for different CLI conventions.\n *     - Support for environment variables and custom working directories.\n *     - Cross-platform command parsing for Windows and Unix-like systems.\n *\n * Security Considerations:\n *     Executing arbitrary command-line tools can be dangerous. This protocol\n *     should only be used with trusted tools.\n */\n// packages/cli/src/cli_communication_protocol.ts\nimport { CommunicationProtocol, UtcpManualSchema, UtcpManualSerializer } from '@utcp/sdk';\nimport { RegisterManualResult } from '@utcp/sdk';\nimport { CallTemplate } from '@utcp/sdk';\nimport { UtcpManual } from '@utcp/sdk';\nimport { Tool } from '@utcp/sdk';\nimport { IUtcpClient } from '@utcp/sdk';\nimport { CliCallTemplate, CliCallTemplateSchema, CommandStep } from './cli_call_template';\nimport { spawn, ChildProcess } from 'child_process';\nimport { clearTimeout } from 'timers';\nimport { Readable } from 'stream';\n\n/**\n * REQUIRED\n * Communication protocol for interacting with CLI-based tool providers.\n *\n * This class implements the `CommunicationProtocol` interface to handle\n * communication with command-line tools. It discovers tools by executing a\n * command specified in a `CliCallTemplate` and parsing the output for a UTCP\n * manual. It also executes tool calls by running the corresponding command\n * with the provided arguments.\n */\nexport class CliCommunicationProtocol implements CommunicationProtocol {\n  /**\n   * Log informational messages.\n   */\n  private _log_info(message: string): void {\n    console.log(`[CliCommunicationProtocol] ${message}`);\n  }\n\n  /**\n   * Log error messages.\n   */\n  private _log_error(message: string): void {\n    console.error(`[CliCommunicationProtocol Error] ${message}`);\n  }\n\n  /**\n   * Prepare environment variables for command execution.\n   * \n   * @param provider The CLI provider\n   * @returns Environment variables dictionary\n   */\n  private _prepare_environment(provider: CliCallTemplate): Record<string, string> {\n    const env = { ...process.env } as Record<string, string>;\n    \n    // Add custom environment variables if provided\n    if (provider.env_vars) {\n      Object.assign(env, provider.env_vars);\n    }\n    \n    return env;\n  }\n\n  private async _executeShellScript(\n    script: string,\n    options: { cwd?: string; env?: Record<string, string> } = {},\n    timeoutMs: number = 60000,\n  ): Promise<{ stdout: string; stderr: string; exitCode: number | null }> {\n    const isWindows = process.platform === 'win32';\n    const shell = isWindows ? 'powershell.exe' : '/bin/bash';\n    const args = isWindows ? ['-NoProfile', '-Command', script] : ['-c', script];\n    \n    let childProcess: ChildProcess | undefined;\n\n    try {\n      const currentProcessEnv = typeof process !== 'undefined' ? process.env : {};\n      const mergedEnv = { ...currentProcessEnv, ...options.env };\n\n      childProcess = spawn(shell, args, {\n        cwd: options.cwd,\n        env: mergedEnv,\n        stdio: ['ignore', 'pipe', 'pipe'],\n      });\n\n      const readStream = async (stream: Readable | null): Promise<string> => {\n        if (!stream) return '';\n        let buffer = '';\n        for await (const chunk of stream) {\n          buffer += chunk.toString();\n        }\n        return buffer;\n      };\n\n      const stdoutPromise = readStream(childProcess.stdout);\n      const stderrPromise = readStream(childProcess.stderr);\n      const exitCodePromise = new Promise<number | null>((resolve) => {\n        childProcess?.on('close', (code) => resolve(code));\n        childProcess?.on('error', () => resolve(1));\n      });\n\n      const timeoutPromise = new Promise<never>((_, reject) => {\n        const id = setTimeout(() => {\n          childProcess?.kill();\n          reject(new Error(`Command script timed out after ${timeoutMs}ms.`));\n        }, timeoutMs);\n        childProcess?.on('close', () => clearTimeout(id));\n      });\n\n      const [stdout, stderr, exitCode] = await Promise.race([\n        Promise.all([stdoutPromise, stderrPromise, exitCodePromise]),\n        timeoutPromise,\n      ]);\n\n      return { stdout, stderr, exitCode };\n    } catch (e: any) {\n      childProcess?.kill();\n      this._log_error(`Error executing shell script: ${e}`);\n      throw e;\n    }\n  }\n\n  /**\n   * Substitute UTCP_ARG placeholders in command string with tool arguments.\n   * \n   * @param command Command string containing UTCP_ARG_argname_UTCP_END placeholders\n   * @param toolArgs Dictionary of argument names and values\n   * @returns Command string with placeholders replaced by actual values\n   */\n  private _substitute_utcp_args(command: string, toolArgs: Record<string, any>): string {\n    const pattern = /UTCP_ARG_([a-zA-Z0-9_]+?)_UTCP_END/g;\n    return command.replace(pattern, (match, argName) => {\n      if (argName in toolArgs) {\n        // Return the raw value. The shell will handle it correctly when it's inside quotes\n        // in the final command (e.g., echo \"Initial message: Workflow Argument\").\n        return String(toolArgs[argName]);\n      }\n      this._log_error(`Missing argument '${argName}' for placeholder in command: ${command}`);\n      return `MISSING_ARG_${argName}`;\n    });\n  }\n  \n  /**\n   * Build a combined shell script from multiple commands.\n   * \n   * @param commands List of CommandStep objects to combine\n   * @param toolArgs Tool arguments for placeholder substitution\n   * @returns Shell script string that executes all commands in sequence\n   */\n  private _build_combined_shell_script(commands: CommandStep[], toolArgs: Record<string, any>): string {\n    const isWindows = process.platform === 'win32';\n    const scriptLines: string[] = [];\n\n    // Add error handling and setup\n    if (isWindows) {\n      // PowerShell script\n      scriptLines.push('$ErrorActionPreference = \"Stop\"');  // Exit on error\n      scriptLines.push('# Variables to store command outputs');\n    } else {\n      // Unix shell script\n      scriptLines.push('#!/bin/bash');\n      // Don't use set -e to allow error output capture and processing\n      scriptLines.push('# Variables to store command outputs');\n    }\n\n    // Execute each command and store output in variables\n    for (let i = 0; i < commands.length; i++) {\n      const commandStep = commands[i];\n      // Substitute UTCP_ARG placeholders\n      const substitutedCommand = this._substitute_utcp_args(commandStep.command, toolArgs);\n      \n      const varName = `CMD_${i}_OUTPUT`;\n      \n      if (isWindows) {\n        // PowerShell - capture command output in variable\n        scriptLines.push(`\\$${varName} = ${substitutedCommand} 2>&1 | Out-String`);\n      } else {\n        // Unix shell - capture command output in variable\n        scriptLines.push(`${varName}=$(${substitutedCommand} 2>&1)`);\n      }\n    }\n\n    // Echo only the outputs we want based on append_to_final_output\n    for (let i = 0; i < commands.length; i++) {\n      const commandStep = commands[i];\n      const isLastCommand = i === commands.length - 1;\n      let shouldAppend = commandStep.append_to_final_output;\n      \n      if (shouldAppend === null || shouldAppend === undefined) {\n        // Default: only append the last command's output\n        shouldAppend = isLastCommand;\n      }\n      \n      if (shouldAppend) {\n        const varName = `CMD_${i}_OUTPUT`;\n        if (isWindows) {\n          // PowerShell\n          scriptLines.push(`Write-Output \\$${varName}`);\n        } else {\n          // Unix shell\n          scriptLines.push(`echo \"\\${${varName}}\"`);\n        }\n      }\n    }\n\n    return scriptLines.join('\\n');\n  }\n\n  /**\n   * REQUIRED\n   * Registers a CLI-based manual and discovers its tools.\n   *\n   * This method executes the command specified in the `CliCallTemplate`'s\n   * commands. It then attempts to parse the command's output (stdout) as a\n   * UTCP manual in JSON format.\n   *\n   * @param caller The UTCP client instance that is calling this method.\n   * @param manualCallTemplate The `CliCallTemplate` containing the details for\n   *     tool discovery, such as the command to run.\n   * @returns A `RegisterManualResult` object indicating whether the registration\n   *     was successful and containing the discovered tools.\n   * @throws Error if the `manualCallTemplate` is not an instance of\n   *     `CliCallTemplate` or if commands are not set.\n   */\n  public async registerManual(caller: IUtcpClient, manualCallTemplate: CallTemplate): Promise<RegisterManualResult> {\n    if (!(manualCallTemplate as any).commands || (manualCallTemplate as any).commands.length === 0) {\n      throw new Error(`CliCallTemplate '${manualCallTemplate.name}' must have at least one command`);\n    }\n\n    const cliCallTemplate = CliCallTemplateSchema.parse(manualCallTemplate);\n    this._log_info(`Registering CLI manual '${manualCallTemplate.name}' with ${cliCallTemplate.commands.length} command(s)`);\n\n    try {\n      // Execute commands using the same approach as call_tool but with no arguments\n      const env = this._prepare_environment(cliCallTemplate);\n      const shellScript = this._build_combined_shell_script(cliCallTemplate.commands, {});\n      \n      this._log_info(`Executing shell script for tool discovery from provider '${manualCallTemplate.name}'`);\n\n      const { stdout, stderr, exitCode } = await this._executeShellScript(shellScript, {\n        cwd: cliCallTemplate.working_dir || undefined,\n        env,\n      }, 30000);\n\n      // Get output based on exit code\n      const output = exitCode === 0 ? stdout : stderr;\n\n      if (!output.trim()) {\n        this._log_info(`No output from commands for CLI provider '${manualCallTemplate.name}'`);\n        return {\n          success: false,\n          manualCallTemplate,\n          manual: new UtcpManualSerializer().validateDict({ tools: [] }),\n          errors: [`No output from discovery commands for CLI provider '${manualCallTemplate.name}'`],\n        };\n      }\n\n      // Try to parse UTCP manual from the output\n      try {\n        const utcpManual = UtcpManualSchema.parse(JSON.parse(output.trim()));\n        this._log_info(`Discovered ${utcpManual.tools.length} tools from CLI provider '${manualCallTemplate.name}'`);\n        return {\n          success: true,\n          manualCallTemplate,\n          manual: utcpManual,\n          errors: [],\n        };\n      } catch (parseError: any) {\n        const errorMsg = `Could not parse UTCP manual from CLI provider '${manualCallTemplate.name}' output: ${parseError.message}`;\n        this._log_error(errorMsg);\n        return {\n          success: false,\n          manualCallTemplate,\n          manual: new UtcpManualSerializer().validateDict({ tools: [] }),\n          errors: [errorMsg],\n        };\n      }\n    } catch (e: any) {\n      const errorMsg = `Error discovering tools from CLI provider '${manualCallTemplate.name}': ${e.message || e}`;\n      this._log_error(errorMsg);\n      return {\n        success: false,\n        manualCallTemplate,\n        manual: new UtcpManualSerializer().validateDict({ tools: [] }),\n        errors: [errorMsg],\n      };\n    }\n  }\n\n  /**\n   * REQUIRED\n   * Deregisters a CLI manual.\n   *\n   * For the CLI protocol, this is a no-op as there are no persistent\n   * connections to terminate.\n   *\n   * @param caller The UTCP client instance that is calling this method.\n   * @param manualCallTemplate The call template of the manual to deregister.\n   */\n  public async deregisterManual(caller: IUtcpClient, manualCallTemplate: CallTemplate): Promise<void> {\n    this._log_info(`Deregistering CLI manual '${manualCallTemplate.name}' (no-op)`);\n  }\n\n  /**\n   * REQUIRED\n   * Calls a CLI tool by executing its command.\n   *\n   * This method constructs and executes the command specified in the\n   * `CliCallTemplate`. It formats the provided `tool_args` as command-line\n   * arguments and runs the command in a subprocess.\n   *\n   * @param caller The UTCP client instance that is calling this method.\n   * @param toolName The name of the tool to call.\n   * @param toolArgs A dictionary of arguments for the tool call.\n   * @param toolCallTemplate The `CliCallTemplate` for the tool.\n   * @returns The result of the command execution. If the command exits with a code\n   *     of 0, it returns the content of stdout. If the exit code is non-zero,\n   *     it returns the content of stderr.\n   * @throws Error if `toolCallTemplate` is not an instance of\n   *     `CliCallTemplate` or if commands are not set.\n   */\n  public async callTool(caller: IUtcpClient, toolName: string, toolArgs: Record<string, any>, toolCallTemplate: CallTemplate): Promise<any> {\n    if (!(toolCallTemplate as any).commands || (toolCallTemplate as any).commands.length === 0) {\n      throw new Error(`CliCallTemplate '${toolCallTemplate.name}' must have at least one command`);\n    }\n\n    const cliCallTemplate = CliCallTemplateSchema.parse(toolCallTemplate);\n    this._log_info(`Executing CLI tool '${toolName}' with ${cliCallTemplate.commands.length} command(s) in single subprocess`);\n    \n    try {\n      const env = this._prepare_environment(cliCallTemplate);\n      \n      // Build combined shell script with output capture\n      const shellScript = this._build_combined_shell_script(cliCallTemplate.commands, toolArgs);\n      \n      this._log_info('Executing combined shell script');\n      \n      // Execute the combined script in a single subprocess\n      const { stdout, stderr, exitCode } = await this._executeShellScript(shellScript, {\n        cwd: cliCallTemplate.working_dir || undefined,\n        env,\n      }, 120000);  // Longer timeout for multi-command execution\n      \n      // Platform-specific output handling\n      const isWindows = process.platform === 'win32';\n      let output: string;\n      \n      if (isWindows) {\n        // Windows (PowerShell): Use stdout on success, stderr on failure\n        output = exitCode === 0 ? stdout : stderr;\n      } else {\n        // Unix (Bash): Our script captures everything and echoes to stdout\n        // So we always use stdout first, fallback to stderr if stdout is empty\n        output = stdout.trim() ? stdout : stderr;\n      }\n      \n      if (!output.trim()) {\n        this._log_info(`CLI tool '${toolName}' produced no output`);\n        return '';\n      }\n      \n      // With the variable approach, output is already filtered - just return it\n      output = output.trim();\n      \n      // Try to parse as JSON if it looks like JSON\n      if (output.startsWith('{') || output.startsWith('[')) {\n        try {\n          const result = JSON.parse(output);\n          this._log_info(`Returning JSON output from CLI tool '${toolName}'`);\n          return result;\n        } catch {\n          // Not valid JSON, continue to return as text\n        }\n      }\n      \n      this._log_info(`Returning text output from CLI tool '${toolName}'`);\n      return output;\n    } catch (e: any) {\n      this._log_error(`Error executing CLI tool '${toolName}': ${e.message || e}`);\n      throw e;\n    }\n  }\n\n  /**\n   * REQUIRED\n   * Streaming calls are not supported for the CLI protocol.\n   *\n   * @throws Error Always, as this functionality is not supported.\n   */\n  public async *callToolStreaming(caller: IUtcpClient, toolName: string, toolArgs: Record<string, any>, toolCallTemplate: CallTemplate): AsyncGenerator<any, void, unknown> {\n    throw new Error('Streaming is not supported by the CLI communication protocol.');\n  }\n\n  public async close(): Promise<void> {\n    this._log_info('CLI Communication Protocol closed (no-op).');\n  }\n}",
      "line_count": 406,
      "word_count": 1837,
      "title": "Cli Communication Protocol.Ts",
      "summary": "* Command Line Interface (CLI) communication protocol for the UTCP client. * This module provides an implementation of the `CommunicationProtocol` interface",
      "key_terms": [
        "Out-String",
        "close",
        "const",
        "packages",
        "Record",
        "corresponding",
        "echoes",
        "providers",
        "reject",
        "cliCallTemplate",
        "exe",
        "multiple",
        "toolName",
        "Log",
        "Platform",
        "stdoutPromise",
        "if",
        "that",
        "Features",
        "interface"
      ],
      "timestamp": "2025-12-24T18:56:16.701516"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\cli\\src\\index.ts",
      "content_type": "code",
      "content": "// packages/cli/src/index.ts\nimport { CommunicationProtocol, CallTemplateSerializer } from '@utcp/sdk';\nimport { CliCallTemplateSerializer } from './cli_call_template';\nimport { CliCommunicationProtocol } from './cli_communication_protocol';\n\n/**\n * Registers the CLI protocol's CallTemplate serializer\n * and its CommunicationProtocol implementation.\n * This function should be called once when the CLI plugin is loaded.\n */\nexport function register(override: boolean = false): void {\n  CallTemplateSerializer.registerCallTemplate('cli', new CliCallTemplateSerializer(), override);\n  CommunicationProtocol.communicationProtocols['cli'] = new CliCommunicationProtocol();\n}\n\n// Automatically register CLI plugins on import\nregister();\n\nexport * from './cli_call_template';\nexport * from './cli_communication_protocol';",
      "line_count": 20,
      "word_count": 81,
      "title": "Index.Ts",
      "summary": "// packages/cli/src/index.ts import { CommunicationProtocol, CallTemplateSerializer } from '@utcp/sdk';",
      "key_terms": [
        "from",
        "communicationProtocols",
        "packages",
        "serializer",
        "is",
        "utcp",
        "index",
        "Automatically",
        "register",
        "and",
        "protocol",
        "boolean",
        "when",
        "cli",
        "ts",
        "This",
        "CommunicationProtocol",
        "Registers",
        "false",
        "plugins"
      ],
      "timestamp": "2025-12-24T18:56:16.733341"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\cli\\tests\\cli_communication_protocol.test.ts",
      "content_type": "code",
      "content": "// packages/cli/tests/cli_communication_protocol.test.ts\nimport { test, expect, describe, afterEach } from \"bun:test\";\nimport { CliCommunicationProtocol } from '../src/cli_communication_protocol';\nimport { CliCallTemplateSchema, CliCallTemplate } from '../src/cli_call_template';\nimport { IUtcpClient } from '@utcp/sdk';\nimport * as path from 'path';\nimport * as fs from 'fs/promises';\n\nconst mockClient = { root_dir: process.cwd() } as IUtcpClient;\nconst tempDirs: string[] = [];\n\nafterEach(async () => {\n  for (const dir of tempDirs) {\n    await fs.rm(dir, { recursive: true, force: true });\n  }\n  tempDirs.length = 0;\n});\n\nconst createTempDir = async (name: string): Promise<string> => {\n  const dirPath = path.join(import.meta.dir, name);\n  await fs.mkdir(dirPath, { recursive: true });\n  tempDirs.push(dirPath);\n  return dirPath;\n};\n\ndescribe('CliCommunicationProtocol (Multi-Command)', () => {\n  const cliProtocol = new CliCommunicationProtocol();\n  const isWindows = process.platform === 'win32';\n\n  test('should execute a multi-step workflow and return the final output', async () => {\n    const callTemplate: CliCallTemplate = CliCallTemplateSchema.parse({\n      name: 'multi_step_test',\n      call_template_type: 'cli',\n      commands: [\n        { command: 'echo \"Step 1\"', append_to_final_output: false },\n        { command: 'echo \"Step 2\"' },\n      ],\n    });\n\n    const result = await cliProtocol.callTool(mockClient, 'test.workflow', {}, callTemplate);\n    expect(result.trim()).toBe('Step 2');\n  });\n\n  test('should preserve state (current directory) between commands', async () => {\n    const tempDir = await createTempDir('state_test_dir');\n    const finalCommand = isWindows ? 'Write-Output (Get-Location).Path' : 'pwd';\n    \n    const callTemplate: CliCallTemplate = CliCallTemplateSchema.parse({\n      name: 'state_preservation_test',\n      call_template_type: 'cli',\n      commands: [\n        { command: `cd \"${tempDir}\"`, append_to_final_output: false },\n        { command: finalCommand, append_to_final_output: true },\n      ],\n    });\n\n    const result = await cliProtocol.callTool(mockClient, 'test.state', {}, callTemplate);\n    expect(path.normalize(result.trim())).toBe(path.normalize(tempDir));\n  });\n\n  test('should reference the output of previous commands', async () => {\n    const callTemplate: CliCallTemplate = CliCallTemplateSchema.parse({\n      name: 'output_referencing_test',\n      call_template_type: 'cli',\n      commands: [\n        { command: 'echo \"Hello from command 0\"', append_to_final_output: false },\n        { command: 'echo \"Output of previous step was: $CMD_0_OUTPUT\"' },\n      ],\n    });\n\n    const result = await cliProtocol.callTool(mockClient, 'test.reference', {}, callTemplate);\n    expect(result.trim()).toBe('Output of previous step was: Hello from command 0');\n  });\n\n  test('should aggregate outputs based on append_to_final_output flag', async () => {\n    const callTemplate: CliCallTemplate = CliCallTemplateSchema.parse({\n      name: 'output_aggregation_test',\n      call_template_type: 'cli',\n      commands: [\n        { command: 'echo \"First\"', append_to_final_output: true },\n        { command: 'echo \"Second\"', append_to_final_output: false },\n        { command: 'echo \"Third\"', append_to_final_output: true },\n      ],\n    });\n\n    const result = await cliProtocol.callTool(mockClient, 'test.aggregation', {}, callTemplate);\n    // Normalize line endings for cross-platform comparison\n    const normalized = result.trim().replace(/\\r\\n/g, '\\n');\n    expect(normalized).toContain('First');\n    expect(normalized).toContain('Third');\n    expect(normalized).not.toContain('Second');\n  });\n  \n  test('should handle argument substitution in multi-step workflows', async () => {\n    const callTemplate: CliCallTemplate = CliCallTemplateSchema.parse({\n      name: 'arg_substitution_test',\n      call_template_type: 'cli',\n      commands: [\n        { command: 'echo \"Initial message: UTCP_ARG_message_UTCP_END\"', append_to_final_output: false },\n        { command: 'echo \"Received: $CMD_0_OUTPUT\"' },\n      ],\n    });\n    \n    const result = await cliProtocol.callTool(mockClient, 'test.args', { message: 'Workflow Argument' }, callTemplate);\n    // The argument is substituted directly without extra quoting\n    expect(result.trim()).toContain('Received: Initial message: Workflow Argument');\n  });\n  \n  test('should use custom environment variables and working directory', async () => {\n    const tempDir = await createTempDir('env_test_dir');\n    // Use correct PowerShell syntax for environment variables and current directory.\n    const envCommand = isWindows ? 'Write-Output \"Var is $env:MY_CUSTOM_VAR, CWD is $((Get-Location).Path)\"' : 'echo \"Var is $MY_CUSTOM_VAR, CWD is $(pwd)\"';\n\n    const callTemplate: CliCallTemplate = CliCallTemplateSchema.parse({\n      name: 'env_var_test',\n      call_template_type: 'cli',\n      working_dir: tempDir,\n      env_vars: {\n        MY_CUSTOM_VAR: 'Hello World from Env',\n      },\n      commands: [\n        { command: envCommand },\n      ],\n    });\n\n    const result = await cliProtocol.callTool(mockClient, 'test.env', {}, callTemplate);\n    expect(result).toInclude('Var is Hello World from Env');\n    expect(path.normalize(result.trim())).toContain(path.normalize(tempDir));\n  });\n});",
      "line_count": 130,
      "word_count": 521,
      "title": "Cli Communication Protocol.Test.Ts",
      "summary": "// packages/cli/tests/cli_communication_protocol.test.ts import { test, expect, describe, afterEach } from \"bun:test\";",
      "key_terms": [
        "output",
        "const",
        "packages",
        "async",
        "based",
        "World",
        "preserve",
        "Utcp",
        "callTemplate",
        "trim",
        "envCommand",
        "string",
        "path",
        "cd",
        "correct",
        "between",
        "dirPath",
        "promises",
        "Hello",
        "true"
      ],
      "timestamp": "2025-12-24T18:56:16.765223"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\cli\\tests\\mock_cli_script.d.ts",
      "content_type": "code",
      "content": "export {};\n",
      "line_count": 2,
      "word_count": 2,
      "title": "Mock Cli Script.D.Ts",
      "summary": "",
      "key_terms": [
        "export"
      ],
      "timestamp": "2025-12-24T18:56:16.796679"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\cli\\tests\\mock_cli_script.js",
      "content_type": "code",
      "content": "// packages/cli/tests/mock_cli_script.ts\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nasync function main() {\n    const fullArgs = process.argv.slice(2);\n    const parsedArgs = {};\n    for (let i = 0; i < fullArgs.length; i++) {\n        const arg = fullArgs[i];\n        if (arg.startsWith('--')) {\n            const key = arg.substring(2);\n            if (i + 1 < fullArgs.length && !fullArgs[i + 1].startsWith('--')) {\n                parsedArgs[key] = fullArgs[++i]; // Value follows key\n            }\n            else {\n                parsedArgs[key] = true; // Flag without value\n            }\n        }\n    }\n    // Use console.log for discovery output to ensure newline and flush\n    if (parsedArgs['utcp-discover']) {\n        const manual = {\n            utcp_version: \"1.0.0\",\n            manual_version: \"1.0.0\",\n            tools: [\n                {\n                    name: \"echo_cli\",\n                    description: \"Echoes a message via CLI.\",\n                    inputs: { type: \"object\", properties: { message: { type: \"string\" } }, required: [\"message\"] },\n                    outputs: { type: \"string\" },\n                    tags: [\"cli\", \"echo\"],\n                    tool_call_template: {\n                        name: \"mock_cli_manual\",\n                        call_template_type: \"cli\",\n                        command_name: `node \"${path.resolve(__dirname, 'mock_cli_script.ts')}\"`\n                    }\n                },\n                {\n                    name: \"add_numbers_cli\",\n                    description: \"Adds two numbers via CLI.\",\n                    inputs: { type: \"object\", properties: { a: { type: \"number\" }, b: { type: \"number\" } }, required: [\"a\", \"b\"] },\n                    outputs: { type: \"number\" },\n                    tags: [\"cli\", \"math\"],\n                    tool_call_template: {\n                        name: \"mock_cli_manual\",\n                        call_template_type: \"cli\",\n                        command_name: `node \"${path.resolve(__dirname, 'mock_cli_script.ts')}\"`\n                    }\n                },\n                {\n                    name: \"read_env\",\n                    description: \"Reads a specific environment variable.\",\n                    inputs: { type: \"object\", properties: { var_name: { type: \"string\" } }, required: [\"var_name\"] },\n                    outputs: { type: \"string\" },\n                    tags: [\"cli\", \"env\"],\n                    tool_call_template: {\n                        name: \"mock_cli_manual\",\n                        call_template_type: \"cli\",\n                        command_name: `node \"${path.resolve(__dirname, 'mock_cli_script.ts')}\"`\n                    }\n                },\n                {\n                    name: \"write_file_cli\",\n                    description: \"Writes content to a file in the CWD.\",\n                    inputs: { type: \"object\", properties: { filename: { type: \"string\" }, content: { type: \"string\" } }, required: [\"filename\", \"content\"] },\n                    outputs: { type: \"string\" },\n                    tags: [\"cli\", \"file\"],\n                    tool_call_template: {\n                        name: \"mock_cli_manual\",\n                        call_template_type: \"cli\",\n                        command_name: `node \"${path.resolve(__dirname, 'mock_cli_script.ts')}\"`\n                    }\n                }\n            ]\n        };\n        console.log(JSON.stringify(manual)); // console.log adds a newline by default\n        process.exit(0);\n    }\n    else if (parsedArgs['message']) {\n        // echo_cli\n        console.log(JSON.stringify({ echoed_message: parsedArgs['message'] }));\n    }\n    else if (parsedArgs['a'] && parsedArgs['b']) {\n        // add_numbers_cli\n        const a = parseFloat(parsedArgs['a']);\n        const b = parseFloat(parsedArgs['b']);\n        if (!isNaN(a) && !isNaN(b)) {\n            console.log(JSON.stringify({ sum: a + b }));\n        }\n        else {\n            console.error(\"Invalid numbers provided for add_numbers_cli.\");\n            process.exit(1);\n        }\n    }\n    else if (parsedArgs['var_name']) { // Correctly checks for 'var_name' argument\n        // read_env\n        const varName = parsedArgs['var_name'];\n        const value = process.env[varName];\n        console.log(JSON.stringify({ [varName]: value ?? null }));\n    }\n    else if (parsedArgs['filename'] && parsedArgs['content']) {\n        // write_file_cli\n        const filename = parsedArgs['filename'];\n        const content = parsedArgs['content'];\n        try {\n            await fs.writeFile(filename, content);\n            console.log(JSON.stringify({ status: `wrote ${filename}` }));\n        }\n        catch (error) {\n            console.error(`Error writing file: ${error}`);\n            process.exit(1);\n        }\n    }\n    else if (parsedArgs['error']) { // Correctly checks for 'error' flag\n        // error command\n        console.error(\"This is a simulated error from CLI.\");\n        process.exit(1);\n    }\n    else {\n        // Default error for unknown command\n        console.error(\"Unknown command or missing arguments.\");\n        process.exit(1);\n    }\n}\nmain().catch(console.error);\n",
      "line_count": 125,
      "word_count": 457,
      "title": "Mock Cli Script.Js",
      "summary": "// packages/cli/tests/mock_cli_script.ts import * as fs from 'fs/promises';",
      "key_terms": [
        "output",
        "null",
        "const",
        "packages",
        "Writes",
        "async",
        "number",
        "error",
        "Reads",
        "unknown",
        "string",
        "Error",
        "utcp-discover",
        "path",
        "let",
        "if",
        "status",
        "parsedArgs",
        "filename",
        "exit"
      ],
      "timestamp": "2025-12-24T18:56:16.854017"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\cli\\tests\\mock_cli_script.ts",
      "content_type": "code",
      "content": "// packages/cli/tests/mock_cli_script.ts\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\nasync function main() {\n  const fullArgs = process.argv.slice(2);\n\n  const parsedArgs: Record<string, string | boolean> = {};\n  for (let i = 0; i < fullArgs.length; i++) {\n    const arg = fullArgs[i];\n    if (arg.startsWith('--')) {\n      const key = arg.substring(2);\n      if (i + 1 < fullArgs.length && !fullArgs[i + 1].startsWith('--')) {\n        parsedArgs[key] = fullArgs[++i]; // Value follows key\n      } else {\n        parsedArgs[key] = true; // Flag without value\n      }\n    }\n  }\n\n  // Use console.log for discovery output to ensure newline and flush\n  if (parsedArgs['utcp-discover']) {\n    const manual = {\n      utcp_version: \"1.0.0\",\n      manual_version: \"1.0.0\",\n      tools: [\n        {\n          name: \"echo_cli\",\n          description: \"Echoes a message via CLI.\",\n          inputs: { type: \"object\", properties: { message: { type: \"string\" } }, required: [\"message\"] },\n          outputs: { type: \"string\" },\n          tags: [\"cli\", \"echo\"],\n          tool_call_template: {\n            name: \"mock_cli_manual\",\n            call_template_type: \"cli\",\n            command_name: `node \"${path.resolve(__dirname, 'mock_cli_script.ts')}\"`\n          }\n        },\n        {\n          name: \"add_numbers_cli\",\n          description: \"Adds two numbers via CLI.\",\n          inputs: { type: \"object\", properties: { a: { type: \"number\" }, b: { type: \"number\" } }, required: [\"a\", \"b\"] },\n          outputs: { type: \"number\" },\n          tags: [\"cli\", \"math\"],\n          tool_call_template: {\n            name: \"mock_cli_manual\",\n            call_template_type: \"cli\",\n            command_name: `node \"${path.resolve(__dirname, 'mock_cli_script.ts')}\"`\n          }\n        },\n        {\n          name: \"read_env\",\n          description: \"Reads a specific environment variable.\",\n          inputs: { type: \"object\", properties: { var_name: { type: \"string\" } }, required: [\"var_name\"] },\n          outputs: { type: \"string\" },\n          tags: [\"cli\", \"env\"],\n          tool_call_template: {\n            name: \"mock_cli_manual\",\n            call_template_type: \"cli\",\n            command_name: `node \"${path.resolve(__dirname, 'mock_cli_script.ts')}\"`\n          }\n        },\n        {\n          name: \"write_file_cli\",\n          description: \"Writes content to a file in the CWD.\",\n          inputs: { type: \"object\", properties: { filename: { type: \"string\" }, content: { type: \"string\" } }, required: [\"filename\", \"content\"] },\n          outputs: { type: \"string\" },\n          tags: [\"cli\", \"file\"],\n          tool_call_template: {\n            name: \"mock_cli_manual\",\n            call_template_type: \"cli\",\n            command_name: `node \"${path.resolve(__dirname, 'mock_cli_script.ts')}\"`\n          }\n        }\n      ]\n    };\n    console.log(JSON.stringify(manual)); // console.log adds a newline by default\n    process.exit(0);\n  } else if (parsedArgs['message']) {\n    // echo_cli\n    console.log(JSON.stringify({ echoed_message: parsedArgs['message'] }));\n  } else if (parsedArgs['a'] && parsedArgs['b']) {\n    // add_numbers_cli\n    const a = parseFloat(parsedArgs['a'] as string);\n    const b = parseFloat(parsedArgs['b'] as string);\n    if (!isNaN(a) && !isNaN(b)) {\n      console.log(JSON.stringify({ sum: a + b }));\n    } else {\n      console.error(\"Invalid numbers provided for add_numbers_cli.\");\n      process.exit(1);\n    }\n  } else if (parsedArgs['var_name']) { // Correctly checks for 'var_name' argument\n    // read_env\n    const varName = parsedArgs['var_name'] as string;\n    const value = process.env[varName];\n    console.log(JSON.stringify({ [varName]: value ?? null }));\n  } else if (parsedArgs['filename'] && parsedArgs['content']) {\n    // write_file_cli\n    const filename = parsedArgs['filename'] as string;\n    const content = parsedArgs['content'] as string;\n    try {\n      await fs.writeFile(filename, content);\n      console.log(JSON.stringify({ status: `wrote ${filename}` }));\n    } catch (error) {\n      console.error(`Error writing file: ${error}`);\n      process.exit(1);\n    }\n  } else if (parsedArgs['error']) { // Correctly checks for 'error' flag\n    // error command\n    console.error(\"This is a simulated error from CLI.\");\n    process.exit(1);\n  } else {\n    // Default error for unknown command\n    console.error(\"Unknown command or missing arguments.\");\n    process.exit(1);\n  }\n}\n\nmain().catch(console.error);",
      "line_count": 119,
      "word_count": 471,
      "title": "Mock Cli Script.Ts",
      "summary": "// packages/cli/tests/mock_cli_script.ts import * as fs from 'fs/promises';",
      "key_terms": [
        "output",
        "null",
        "const",
        "packages",
        "Writes",
        "async",
        "number",
        "error",
        "Record",
        "Reads",
        "unknown",
        "string",
        "Error",
        "utcp-discover",
        "path",
        "let",
        "if",
        "status",
        "parsedArgs",
        "filename"
      ],
      "timestamp": "2025-12-24T18:56:16.883524"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\code-mode\\package.json",
      "content_type": "configuration",
      "content": "{\n  \"name\": \"@utcp/code-mode\",\n  \"version\": \"1.1.0\",\n  \"description\": \"Code execution mode for UTCP - enables executing TypeScript code chains with tool access\",\n  \"main\": \"dist/index.cjs\",\n  \"module\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"type\": \"module\",\n  \"license\": \"MPL-2.0\",\n  \"author\": \"UTCP Contributors\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/universal-tool-calling-protocol/typescript-utcp.git\",\n    \"directory\": \"packages/code-mode\"\n  },\n  \"keywords\": [\n    \"utcp\",\n    \"code\",\n    \"typescript\",\n    \"execution\",\n    \"tool calling\",\n    \"chain\"\n  ],\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"test\": \"bun test\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\",\n      \"require\": \"./dist/index.cjs\",\n      \"default\": \"./dist/index.js\"\n    }\n  },\n  \"dependencies\": {\n    \"@utcp/sdk\": \"^1.1.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"@utcp/direct-call\": \"^1.0.12\",\n    \"bun-types\": \"latest\",\n    \"typescript\": \"^5.0.0\"\n  }\n}\n",
      "line_count": 52,
      "word_count": 100,
      "title": "Package.Json",
      "summary": "\"name\": \"@utcp/code-mode\", \"version\": \"1.1.0\",",
      "key_terms": [
        "executing",
        "build",
        "packages",
        "node",
        "calling-protocol",
        "scripts",
        "universal",
        "Code",
        "module",
        "utcp",
        "index",
        "calling",
        "mode",
        "with",
        "MPL",
        "tool",
        "test",
        "dependencies",
        "type",
        "url"
      ],
      "timestamp": "2025-12-24T18:56:16.908332"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\code-mode\\README.md",
      "content_type": "documentation",
      "content": "# @utcp/code-mode\n\nA powerful extension for UTCP that enables executing TypeScript code with direct access to all registered tools as native TypeScript functions.\n\n## Features\n\n- **TypeScript Code Execution**: Execute TypeScript code snippets with full access to registered tools\n- **Hierarchical Tool Access**: Tools organized by manual namespace (e.g., `math_tools.add()`)\n- **Hierarchical Type Definitions**: TypeScript interfaces organized in namespaces matching tool structure\n- **Runtime Interface Access**: Access TypeScript interfaces at runtime for introspection\n- **Type Safety**: Generates proper TypeScript interfaces for all tool inputs and outputs\n- **Secure Execution**: Uses Node.js VM module for safe code execution with timeout support\n- **Chain Tool Calls**: Combine multiple tool calls in a single TypeScript code block\n\n## Installation\n\n```bash\nnpm install @utcp/code-mode\n```\n\n## Basic Usage\n\n```typescript\nimport { CodeModeUtcpClient } from '@utcp/code-mode';\n\nconst client = await CodeModeUtcpClient.create();\n\n// Register some tools first (example)\nawait client.registerManual({\n  name: 'math_tools',\n  call_template_type: 'text',\n  content: `\n    name: add\n    description: Adds two numbers\n    inputs:\n      type: object\n      properties:\n        a: { type: number }\n        b: { type: number }\n      required: [a, b]\n    outputs:\n      type: object\n      properties:\n        result: { type: number }\n  `\n});\n\n// Now execute TypeScript code that uses the tools\nconst { result, logs } = await client.callToolChain(`\n  // Call the add tool using hierarchical access\n  const sum1 = await math_tools.add({ a: 5, b: 3 });\n  console.log('First sum:', sum1.result);\n  \n  // Chain multiple tool calls\n  const sum2 = await math_tools.add({ a: sum1.result, b: 10 });\n  console.log('Second sum:', sum2.result);\n  \n  // Access TypeScript interfaces at runtime\n  const addInterface = __getToolInterface('math_tools.add');\n  console.log('Add tool interface:', addInterface);\n  \n  // Return final result\n  return sum2.result;\n`);\n\nconsole.log('Final result:', result); // 18\nconsole.log('Console output:', logs); // ['First sum: 8', 'Second sum: 18', 'Add tool interface: ...']\n```\n\n## Advanced Usage\n\n### Console Output Capture\n\nAll console output is automatically captured and returned alongside execution results:\n\n```typescript\nconst { result, logs } = await client.callToolChain(`\n  console.log('Starting calculation...');\n  console.error('This will show as [ERROR]');\n  console.warn('This will show as [WARN]');\n  \n  const sum1 = await math_tools.add({ a: 5, b: 3 });\n  console.log('First sum:', sum1.result);\n  \n  const sum2 = await math_tools.add({ a: sum1.result, b: 10 });\n  console.log('Final sum:', sum2.result);\n  \n  return sum2.result;\n`);\n\nconsole.log('Result:', result); // 18\nconsole.log('Captured logs:');\nlogs.forEach((log, i) => console.log(`${i + 1}: ${log}`));\n// Output:\n// 1: Starting calculation...\n// 2: [ERROR] This will show as [ERROR]\n// 3: [WARN] This will show as [WARN]\n// 4: First sum: 8\n// 5: Final sum: 18\n```\n\n### Getting TypeScript Interfaces\n\nYou can generate TypeScript interfaces for all your tools to get better IDE support:\n\n```typescript\nconst interfaces = await client.getAllToolsTypeScriptInterfaces();\nconsole.log(interfaces);\n```\n\nThis will output something like:\n\n```typescript\n// Auto-generated TypeScript interfaces for UTCP tools\n\nnamespace math_tools {\n  interface addInput {\n    /** First number */\n    a: number;\n    /** Second number */\n    b: number;\n  }\n\n  interface addOutput {\n    /** The sum result */\n    result: number;\n  }\n}\n\n/**\n * Adds two numbers\n * Tags: math, arithmetic\n * Access as: math_tools.add(args)\n */\n```\n\n### Complex Tool Chains\n\nExecute complex logic with multiple tools using hierarchical access:\n\n```typescript\nconst result = await client.callToolChain(`\n  // Get user data (assuming 'user_service' manual)\n  const user = await user_service.getUserData({ userId: \"123\" });\n  \n  // Process the data (assuming 'data_processing' manual)\n  const processedData = await data_processing.processUserData({\n    userData: user,\n    options: { normalize: true, validate: true }\n  });\n  \n  // Generate report (assuming 'reporting' manual)\n  const report = await reporting.generateReport({\n    data: processedData,\n    format: \"json\",\n    includeMetrics: true\n  });\n  \n  // Send notification (assuming 'notifications' manual)\n  await notifications.sendNotification({\n    recipient: user.email,\n    subject: \"Your report is ready\",\n    body: \\`Report generated with \\${report.metrics.totalItems} items\\`\n  });\n  \n  return {\n    reportId: report.id,\n    itemCount: report.metrics.totalItems,\n    notificationSent: true\n  };\n`);\n```\n\n### Error Handling\n\nThe code execution includes proper error handling:\n\n```typescript\ntry {\n  const result = await client.callToolChain(`\n    const result = await someToolThatMightFail({ input: \"test\" });\n    return result;\n  `);\n} catch (error) {\n  console.error('Code execution failed:', error.message);\n}\n```\n\n### Timeout Configuration\n\nYou can set custom timeouts for code execution:\n\n```typescript\nconst result = await client.callToolChain(`\n  // Long running operation\n  const result = await processLargeDataset({ data: largeArray });\n  return result;\n`, 60000); // 60 second timeout\n```\n\n### Runtime Interface Access\n\nThe code execution context provides access to TypeScript interfaces at runtime:\n\n```typescript\nconst result = await client.callToolChain(`\n  // Access all interfaces\n  console.log('All interfaces:', __interfaces);\n  \n  // Get interface for a specific tool\n  const addInterface = __getToolInterface('math_tools.add');\n  console.log('Add tool interface:', addInterface);\n  \n  // Parse interface information\n  const hasNamespaces = __interfaces.includes('namespace math_tools');\n  const availableNamespaces = __interfaces.match(/namespace \\\\w+/g) || [];\n  \n  // Use this for dynamic validation, documentation, or debugging\n  return {\n    hasInterfaces: typeof __interfaces === 'string',\n    namespaceCount: availableNamespaces.length,\n    canIntrospect: typeof __getToolInterface === 'function',\n    specificToolInterface: !!addInterface\n  };\n`);\n```\n\n#### Available Context Variables\n\n- **`__interfaces`**: String containing all TypeScript interface definitions\n- **`__getToolInterface(toolName: string)`**: Function to get interface for a specific tool\n\n## AI Agent Integration\n\nFor AI agents that will use CodeModeUtcpClient, include the built-in prompt template in your system prompt:\n\n```typescript\nimport { CodeModeUtcpClient } from '@utcp/code-mode';\n\n// Add this to your AI agent's system prompt\nconst systemPrompt = `\nYou are an AI assistant with access to tools via UTCP CodeMode.\n\n${CodeModeUtcpClient.AGENT_PROMPT_TEMPLATE}\n\nAdditional instructions...\n`;\n```\n\nThis template provides essential guidance on:\n- **Tool Discovery Workflow**: How to explore available tools before coding\n- **Hierarchical Access Patterns**: Using `manual.tool()` syntax correctly  \n- **Interface Introspection**: Leveraging `__interfaces` and `__getToolInterface()`\n- **Best Practices**: Error handling, data flow, and proper code structure\n- **Runtime Context**: Available variables and functions in the execution environment\n\n## API Reference\n\n### CodeModeUtcpClient\n\nExtends `UtcpClient` with additional code execution capabilities.\n\n#### Methods\n\n##### `callToolChain(code: string, timeout?: number): Promise<{result: any, logs: string[]}>`\n\nExecutes TypeScript code with access to all registered tools and captures console output.\n\n- **code**: TypeScript code to execute\n- **timeout**: Optional timeout in milliseconds (default: 30000)\n- **Returns**: Object containing both the execution result and captured console logs (`console.log`, `console.error`, `console.warn`, `console.info`)\n\n##### `toolToTypeScriptInterface(tool: Tool): string`\n\nConverts a single tool to its TypeScript interface definition.\n\n- **tool**: The Tool object to convert\n- **Returns**: TypeScript interface as a string\n\n##### `getAllToolsTypeScriptInterfaces(): Promise<string>`\n\nGenerates TypeScript interfaces for all registered tools.\n\n- **Returns**: Complete TypeScript interface definitions\n\n### Static Properties\n\n##### `CodeModeUtcpClient.AGENT_PROMPT_TEMPLATE: string`\n\nA comprehensive prompt template designed for AI agents using CodeModeUtcpClient. Contains detailed guidance on tool discovery, hierarchical access patterns, interface introspection, and best practices for code execution.\n\n### Static Methods\n\n##### `CodeModeUtcpClient.create(root_dir?: string, config?: UtcpClientConfig): Promise<CodeModeUtcpClient>`\n\nCreates a new CodeModeUtcpClient instance.\n\n- **root_dir**: Root directory for relative path resolution\n- **config**: UTCP client configuration\n- **Returns**: New CodeModeUtcpClient instance\n\n## Security Considerations\n\n- Code execution happens in a secure Node.js VM context\n- No access to Node.js modules or filesystem by default\n- Timeout protection prevents infinite loops\n- Only registered tools are accessible in the execution context\n\n## Type Safety\n\nThe code mode client generates hierarchical TypeScript interfaces for all tools, providing:\n\n- **Namespace Organization**: Tools grouped by manual (e.g., `namespace math_tools`)\n- **Hierarchical Access**: Clean dot notation (`math_tools.add()`) prevents naming conflicts\n- **Compile-time Type Checking**: Full type safety for tool parameters and return values\n- **IntelliSense Support**: Enhanced IDE autocompletion with organized namespaces\n- **Runtime Introspection**: Access interface definitions during code execution\n- **Self-Documenting Code**: Generated interfaces include descriptions and access patterns\n\n## Integration with IDEs\n\nFor the best development experience:\n\n1. Generate TypeScript interfaces for your tools\n2. Save them to a `.d.ts` file in your project\n3. Reference the file in your TypeScript configuration\n4. Enjoy full IntelliSense support for tool functions\n\n```typescript\n// Generate and save interfaces\nconst interfaces = await client.getAllToolsTypeScriptInterfaces();\nawait fs.writeFile('tools.d.ts', interfaces);\n```\n\n## License\n\nMPL-2.0\n",
      "line_count": 338,
      "word_count": 1234,
      "title": "@utcp/code-mode",
      "summary": "A powerful extension for UTCP that enables executing TypeScript code with direct access to all registered tools as native TypeScript functions. - **TypeScript Code Execution**: Execute TypeScript code...",
      "key_terms": [
        "subject",
        "comprehensive",
        "const",
        "convert",
        "Type",
        "extension",
        "Code",
        "filesystem",
        "mode",
        "during",
        "Enjoy",
        "Self",
        "multiple",
        "toolName",
        "CodeModeUtcpClient",
        "Creates",
        "Tags",
        "Extends",
        "native",
        "that"
      ],
      "timestamp": "2025-12-24T18:56:16.956004"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\code-mode\\tsconfig.json",
      "content_type": "configuration",
      "content": "{\n  \"extends\": \"../../tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"composite\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"],\n  \"references\": [\n    { \"path\": \"../core\" }\n  ]\n}\n",
      "line_count": 14,
      "word_count": 25,
      "title": "Tsconfig.Json",
      "summary": "\"extends\": \"../../tsconfig.json\", \"compilerOptions\": {",
      "key_terms": [
        "rootDir",
        "composite",
        "exclude",
        "include",
        "references",
        "tsconfig",
        "path",
        "json",
        "core",
        "extends",
        "compilerOptions",
        "dist",
        "src",
        "outDir",
        "true"
      ],
      "timestamp": "2025-12-24T18:56:16.988021"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\code-mode\\tsup.config.ts",
      "content_type": "code",
      "content": "import { defineConfig } from 'tsup';\n\nexport default defineConfig({\n  entry: ['src/index.ts'],\n  format: ['esm', 'cjs'],\n  dts: {\n    compilerOptions: {\n      composite: false,\n      paths: {},\n    },\n  },\n  splitting: false,\n  sourcemap: true,\n  clean: true,\n  outDir: 'dist',\n  external: ['@utcp/sdk'],\n});\n",
      "line_count": 18,
      "word_count": 35,
      "title": "Tsup.Config.Ts",
      "summary": "import { defineConfig } from 'tsup'; export default defineConfig({",
      "key_terms": [
        "from",
        "sourcemap",
        "composite",
        "paths",
        "entry",
        "clean",
        "utcp",
        "outDir",
        "index",
        "format",
        "default",
        "ts",
        "cjs",
        "false",
        "import",
        "export",
        "sdk",
        "dist",
        "splitting",
        "tsup"
      ],
      "timestamp": "2025-12-24T18:56:16.988021"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\code-mode\\src\\code_mode_utcp_client.ts",
      "content_type": "code",
      "content": "import { UtcpClient, Tool, JsonSchema, UtcpClientConfig } from '@utcp/sdk';\nimport { createContext, runInContext } from 'vm';\n\n/**\n * CodeModeUtcpClient extends UtcpClient to provide TypeScript code execution capabilities.\n * This allows executing TypeScript code that can directly call registered tools as functions.\n */\nexport class CodeModeUtcpClient extends UtcpClient {\n  private toolFunctionCache: Map<string, string> = new Map();\n\n  /**\n   * Standard prompt template for AI agents using CodeModeUtcpClient.\n   * This provides guidance on how to properly discover and use tools within code execution.\n   */\n  public static readonly AGENT_PROMPT_TEMPLATE = `\n## UTCP CodeMode Tool Usage Guide\n\nYou have access to a CodeModeUtcpClient that allows you to execute TypeScript code with access to registered tools. Follow this workflow:\n\n### 1. Tool Discovery Phase\n**Always start by discovering available tools:**\n- Tools are organized by manual namespace (e.g., \\`manual_name.tool_name\\`)\n- Use hierarchical access patterns: \\`await manual.tool({ param: value })\\`\n- Multiple manuals can contain tools with the same name - namespaces prevent conflicts\n\n### 2. Interface Introspection\n**Understand tool contracts before using them:**\n- Access \\`__interfaces\\` to see all available TypeScript interface definitions\n- Use \\`__getToolInterface('manual.tool')\\` to get specific tool interfaces\n- Interfaces show required inputs, expected outputs, and descriptions\n- Look for \"Access as: manual.tool(args)\" comments for usage patterns\n\n### 3. Code Execution Guidelines\n**When writing code for \\`callToolChain\\`:**\n- Use \\`await manual.tool({ param: value })\\` syntax for all tool calls\n- Tools are async functions that return promises\n- You have access to standard JavaScript globals: \\`console\\`, \\`JSON\\`, \\`Math\\`, \\`Date\\`, etc.\n- All console output (\\`console.log\\`, \\`console.error\\`, etc.) is automatically captured and returned\n- Build properly structured input objects based on interface definitions\n- Handle errors appropriately with try/catch blocks\n- Chain tool calls by using results from previous calls\n\n### 4. Best Practices\n- **Discover first, code second**: Always explore available tools before writing execution code\n- **Respect namespaces**: Use full \\`manual.tool\\` names to avoid conflicts\n- **Parse interfaces**: Use interface information to construct proper input objects\n- **Error handling**: Wrap tool calls in try/catch for robustness\n- **Data flow**: Chain tools by passing outputs as inputs to subsequent tools\n\n### 5. Available Runtime Context\n- \\`__interfaces\\`: String containing all TypeScript interface definitions\n- \\`__getToolInterface(toolName)\\`: Function to get specific tool interface\n- All registered tools as \\`manual.tool\\` functions\n- Standard JavaScript built-ins for data processing\n\nRemember: Always discover and understand available tools before attempting to use them in code execution.\n`.trim();\n\n  /**\n   * Creates a new CodeModeUtcpClient instance.\n   * This creates a regular UtcpClient and then upgrades it to a CodeModeUtcpClient\n   * with all the same configuration and additional code execution capabilities.\n   * \n   * @param root_dir The root directory for the client to resolve relative paths from\n   * @param config The configuration for the client\n   * @returns A new CodeModeUtcpClient instance\n   */\n  public static async create(\n    root_dir: string = process.cwd(),\n    config: UtcpClientConfig | null = null\n  ): Promise<CodeModeUtcpClient> {\n    // Create a regular UtcpClient first\n    const baseClient = await UtcpClient.create(root_dir, config);\n    \n    // Create a CodeModeUtcpClient using the same configuration\n    const codeModeClient = Object.setPrototypeOf(baseClient, CodeModeUtcpClient.prototype) as CodeModeUtcpClient;\n    \n    // Initialize the cache\n    (codeModeClient as any).toolFunctionCache = new Map();\n    \n    return codeModeClient;\n  }\n\n  /**\n   * Sanitizes an identifier to be a valid TypeScript identifier.\n   * Replaces any non-alphanumeric character (except underscore) with underscore\n   * and ensures the first character is not a number.\n   * \n   * @param name The name to sanitize\n   * @returns Sanitized identifier\n   */\n  private sanitizeIdentifier(name: string): string {\n    return name\n      .replace(/[^a-zA-Z0-9_]/g, '_')\n      .replace(/^[0-9]/, '_$&');\n  }\n\n  /**\n   * Converts a Tool object into a TypeScript function interface string.\n   * This generates the function signature that can be used in TypeScript code.\n   * \n   * @param tool The Tool object to convert\n   * @returns TypeScript function interface as a string\n   */\n  public toolToTypeScriptInterface(tool: Tool): string {\n    if (this.toolFunctionCache.has(tool.name)) {\n      return this.toolFunctionCache.get(tool.name)!;\n    }\n\n    // Generate hierarchical interface structure\n    let interfaceContent: string;\n    let accessPattern: string;\n    \n    if (tool.name.includes('.')) {\n      const [manualName, ...toolParts] = tool.name.split('.');\n      const sanitizedManualName = this.sanitizeIdentifier(manualName);\n      const toolName = toolParts.map(part => this.sanitizeIdentifier(part)).join('_');\n      accessPattern = `${sanitizedManualName}.${toolName}`;\n      \n      // Generate interfaces within namespace\n      const inputInterfaceContent = this.jsonSchemaToObjectContent(tool.inputs);\n      const outputInterfaceContent = this.jsonSchemaToObjectContent(tool.outputs);\n      \n      interfaceContent = `\nnamespace ${sanitizedManualName} {\n  interface ${toolName}Input {\n${inputInterfaceContent}\n  }\n\n  interface ${toolName}Output {\n${outputInterfaceContent}\n  }\n}`;\n    } else {\n      // No manual namespace, generate flat interfaces\n      const sanitizedToolName = this.sanitizeIdentifier(tool.name);\n      accessPattern = sanitizedToolName;\n      const inputType = this.jsonSchemaToTypeScript(tool.inputs, `${sanitizedToolName}Input`);\n      const outputType = this.jsonSchemaToTypeScript(tool.outputs, `${sanitizedToolName}Output`);\n      interfaceContent = `${inputType}\\n\\n${outputType}`;\n    }\n    const interfaceString = `\n${interfaceContent}\n\n/**\n * ${tool.description}\n * Tags: ${tool.tags.join(', ')}\n * Access as: ${accessPattern}(args)\n */`;\n\n    this.toolFunctionCache.set(tool.name, interfaceString);\n    return interfaceString;\n  }\n\n  /**\n   * Converts all registered tools to TypeScript interface definitions.\n   * This provides the complete type definitions for all available tools.\n   * \n   * @returns A complete TypeScript interface definition string\n   */\n  public async getAllToolsTypeScriptInterfaces(): Promise<string> {\n    const tools = await this.getTools();\n    const interfaces = tools.map(tool => this.toolToTypeScriptInterface(tool));\n    \n    return `// Auto-generated TypeScript interfaces for UTCP tools\n${interfaces.join('\\n\\n')}`;\n  }\n\n  /**\n   * Executes TypeScript code with access to registered tools and captures console output.\n   * The code can call tools directly as functions and has access to standard JavaScript globals.\n   * \n   * @param code TypeScript code to execute  \n   * @param timeout Optional timeout in milliseconds (default: 30000)\n   * @returns Object containing both the execution result and captured console logs\n   */\n  public async callToolChain(code: string, timeout: number = 30000): Promise<{result: any, logs: string[]}> {\n    const tools = await this.getTools();\n    \n    // Create the execution context with tool functions and log capture\n    const logs: string[] = [];\n    const context = await this.createExecutionContext(tools, logs);\n    \n    try {\n      // Create VM context\n      const vmContext = createContext(context);\n      \n      // Wrap the user code in an async function and execute it\n      const wrappedCode = `\n        (async () => {\n          ${code}\n        })()\n      `;\n      \n      // Execute with timeout\n      const result = await this.runWithTimeout(wrappedCode, vmContext, timeout);\n      return { result, logs };\n    } catch (error) {\n      return { result: null, logs: [...logs, `[ERROR] Code execution failed: ${error instanceof Error ? error.message : String(error)}`] };\n    }\n  }\n\n  /**\n   * Runs code in VM context with timeout support.\n   * \n   * @param code Code to execute\n   * @param context VM context\n   * @param timeout Timeout in milliseconds\n   * @returns Execution result\n   */\n  private async runWithTimeout(code: string, context: any, timeout: number): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new Error(`Code execution timed out after ${timeout}ms`));\n      }, timeout);\n\n      try {\n        const result = runInContext(code, context);\n        \n        // Handle both sync and async results\n        Promise.resolve(result)\n          .then(finalResult => {\n            clearTimeout(timeoutId);\n            resolve(finalResult);\n          })\n          .catch(error => {\n            clearTimeout(timeoutId);\n            reject(error);\n          });\n      } catch (error) {\n        clearTimeout(timeoutId);\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Creates the execution context for running TypeScript code.\n   * This context includes tool functions and basic JavaScript globals.\n   * \n   * @param tools Array of tools to make available\n   * @param logs Optional array to capture console.log output\n   * @returns Execution context object\n   */\n  private async createExecutionContext(tools: Tool[], logs?: string[]): Promise<Record<string, any>> {\n    // Create console object (either capturing logs or using standard console)\n    const consoleObj = logs ? {\n      log: (...args: any[]) => {\n        logs.push(args.map(arg => \n          typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)\n        ).join(' '));\n      },\n      error: (...args: any[]) => {\n        logs.push('[ERROR] ' + args.map(arg => \n          typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)\n        ).join(' '));\n      },\n      warn: (...args: any[]) => {\n        logs.push('[WARN] ' + args.map(arg => \n          typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)\n        ).join(' '));\n      },\n      info: (...args: any[]) => {\n        logs.push('[INFO] ' + args.map(arg => \n          typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)\n        ).join(' '));\n      }\n    } : console;\n\n    const context: Record<string, any> = {\n      // Add basic utilities\n      console: consoleObj,\n      JSON,\n      Promise,\n      Array,\n      Object,\n      String,\n      Number,\n      Boolean,\n      Math,\n      Date,\n      \n      // Add TypeScript interface definitions for reference\n      __interfaces: await this.getAllToolsTypeScriptInterfaces(),\n      __getToolInterface: (toolName: string) => {\n        const tool = tools.find(t => t.name === toolName);\n        return tool ? this.toolToTypeScriptInterface(tool) : null;\n      }\n    };\n\n    // Add tool functions to context organized by manual name\n    for (const tool of tools) {\n      if (tool.name.includes('.')) {\n        const [manualName, ...toolParts] = tool.name.split('.');\n        const sanitizedManualName = this.sanitizeIdentifier(manualName);\n        const toolName = toolParts.map(part => this.sanitizeIdentifier(part)).join('_');\n        \n        // Create manual namespace object if it doesn't exist\n        if (!context[sanitizedManualName]) {\n          context[sanitizedManualName] = {};\n        }\n        \n        // Add the tool function to the manual namespace\n        context[sanitizedManualName][toolName] = async (args: Record<string, any>) => {\n          try {\n            return await this.callTool(tool.name, args);\n          } catch (error) {\n            throw new Error(`Error calling tool '${tool.name}': ${error instanceof Error ? error.message : String(error)}`);\n          }\n        };\n      } else {\n        // If no dot, add directly to root context (no manual name)\n        const sanitizedToolName = this.sanitizeIdentifier(tool.name);\n        context[sanitizedToolName] = async (args: Record<string, any>) => {\n          try {\n            return await this.callTool(tool.name, args);\n          } catch (error) {\n            throw new Error(`Error calling tool '${tool.name}': ${error instanceof Error ? error.message : String(error)}`);\n          }\n        };\n      }\n    }\n\n    return context;\n  }\n\n  /**\n   * Converts a JSON Schema to TypeScript object content (properties only, no interface wrapper).\n   * This generates the content inside an interface definition.\n   * \n   * @param schema JSON Schema to convert\n   * @returns TypeScript interface properties as string\n   */\n  private jsonSchemaToObjectContent(schema: JsonSchema): string {\n    if (!schema || typeof schema !== 'object' || schema.type !== 'object') {\n      return '    [key: string]: any;';\n    }\n\n    const properties = schema.properties || {};\n    const required = schema.required || [];\n    const lines: string[] = [];\n\n    for (const [propName, propSchema] of Object.entries(properties)) {\n      const isRequired = required.includes(propName);\n      const optionalMarker = isRequired ? '' : '?';\n      const description = (propSchema as any).description || '';\n      const tsType = this.jsonSchemaToTypeScriptType(propSchema as JsonSchema);\n\n      if (description) {\n        lines.push(`    /** ${description} */`);\n      }\n      lines.push(`    ${propName}${optionalMarker}: ${tsType};`);\n    }\n\n    return lines.length > 0 ? lines.join('\\n') : '    [key: string]: any;';\n  }\n\n  /**\n   * Converts a JSON Schema to TypeScript interface definition.\n   * This handles the most common JSON Schema patterns used in UTCP tools.\n   * \n   * @param schema JSON Schema to convert\n   * @param typeName Name for the generated TypeScript type\n   * @returns TypeScript type definition as string\n   */\n  private jsonSchemaToTypeScript(schema: JsonSchema, typeName: string): string {\n    if (!schema || typeof schema !== 'object') {\n      return `type ${typeName} = any;`;\n    }\n\n    // Handle different schema types\n    switch (schema.type) {\n      case 'object':\n        return this.objectSchemaToTypeScript(schema, typeName);\n      case 'array':\n        return this.arraySchemaToTypeScript(schema, typeName);\n      case 'string':\n        return this.primitiveSchemaToTypeScript(schema, typeName, 'string');\n      case 'number':\n      case 'integer':\n        return this.primitiveSchemaToTypeScript(schema, typeName, 'number');\n      case 'boolean':\n        return this.primitiveSchemaToTypeScript(schema, typeName, 'boolean');\n      case 'null':\n        return `type ${typeName} = null;`;\n      default:\n        // Handle union types or fallback to any\n        if (Array.isArray(schema.type)) {\n          const types = schema.type.map(t => this.mapJsonTypeToTS(t)).join(' | ');\n          return `type ${typeName} = ${types};`;\n        }\n        return `type ${typeName} = any;`;\n    }\n  }\n\n  /**\n   * Converts an object JSON Schema to TypeScript interface.\n   */\n  private objectSchemaToTypeScript(schema: JsonSchema, typeName: string): string {\n    if (!schema.properties) {\n      return `interface ${typeName} {\n  [key: string]: any;\n}`;\n    }\n\n    const properties = Object.entries(schema.properties).map(([key, propSchema]) => {\n      const isRequired = schema.required?.includes(key) ?? false;\n      const optional = isRequired ? '' : '?';\n      const propType = this.jsonSchemaToTypeScriptType(propSchema);\n      const description = propSchema.description ? `  /** ${propSchema.description} */\\n` : '';\n      \n      return `${description}  ${key}${optional}: ${propType};`;\n    }).join('\\n');\n\n    return `interface ${typeName} {\n${properties}\n}`;\n  }\n\n  /**\n   * Converts an array JSON Schema to TypeScript type.\n   */\n  private arraySchemaToTypeScript(schema: JsonSchema, typeName: string): string {\n    if (!schema.items) {\n      return `type ${typeName} = any[];`;\n    }\n\n    const itemType = Array.isArray(schema.items) \n      ? schema.items.map(item => this.jsonSchemaToTypeScriptType(item)).join(' | ')\n      : this.jsonSchemaToTypeScriptType(schema.items);\n\n    return `type ${typeName} = (${itemType})[];`;\n  }\n\n  /**\n   * Converts a primitive JSON Schema to TypeScript type with enum support.\n   */\n  private primitiveSchemaToTypeScript(schema: JsonSchema, typeName: string, baseType: string): string {\n    if (schema.enum) {\n      const enumValues = schema.enum.map(val => \n        typeof val === 'string' ? `\"${val}\"` : String(val)\n      ).join(' | ');\n      return `type ${typeName} = ${enumValues};`;\n    }\n\n    return `type ${typeName} = ${baseType};`;\n  }\n\n  /**\n   * Converts a JSON Schema to a TypeScript type (not a full type definition).\n   */\n  private jsonSchemaToTypeScriptType(schema: JsonSchema): string {\n    if (!schema || typeof schema !== 'object') {\n      return 'any';\n    }\n\n    if (schema.enum) {\n      return schema.enum.map(val => \n        typeof val === 'string' ? `\"${val}\"` : String(val)\n      ).join(' | ');\n    }\n\n    switch (schema.type) {\n      case 'object':\n        if (!schema.properties) return '{ [key: string]: any }';\n        const props = Object.entries(schema.properties).map(([key, propSchema]) => {\n          const isRequired = schema.required?.includes(key) ?? false;\n          const optional = isRequired ? '' : '?';\n          const propType = this.jsonSchemaToTypeScriptType(propSchema);\n          return `${key}${optional}: ${propType}`;\n        }).join('; ');\n        return `{ ${props} }`;\n      \n      case 'array':\n        if (!schema.items) return 'any[]';\n        const itemType = Array.isArray(schema.items)\n          ? schema.items.map(item => this.jsonSchemaToTypeScriptType(item)).join(' | ')\n          : this.jsonSchemaToTypeScriptType(schema.items);\n        return `(${itemType})[]`;\n      \n      case 'string':\n        return 'string';\n      case 'number':\n      case 'integer':\n        return 'number';\n      case 'boolean':\n        return 'boolean';\n      case 'null':\n        return 'null';\n      \n      default:\n        if (Array.isArray(schema.type)) {\n          return schema.type.map(t => this.mapJsonTypeToTS(t)).join(' | ');\n        }\n        return 'any';\n    }\n  }\n\n  /**\n   * Maps basic JSON Schema types to TypeScript types.\n   */\n  private mapJsonTypeToTS(type: string): string {\n    switch (type) {\n      case 'string': return 'string';\n      case 'number':\n      case 'integer': return 'number';\n      case 'boolean': return 'boolean';\n      case 'null': return 'null';\n      case 'object': return 'object';\n      case 'array': return 'any[]';\n      default: return 'any';\n    }\n  }\n}\n",
      "line_count": 515,
      "word_count": 2097,
      "title": "Code Mode Utcp Client.Ts",
      "summary": "import { UtcpClient, Tool, JsonSchema, UtcpClientConfig } from '@utcp/sdk'; import { createContext, runInContext } from 'vm';",
      "key_terms": [
        "const",
        "contain",
        "interfaceString",
        "etc",
        "convert",
        "Code",
        "either",
        "Record",
        "reject",
        "toolName",
        "CodeModeUtcpClient",
        "Creates",
        "Tags",
        "if",
        "capturing",
        "that",
        "interface",
        "basic",
        "how",
        "timed"
      ],
      "timestamp": "2025-12-24T18:56:17.035837"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\code-mode\\src\\index.ts",
      "content_type": "code",
      "content": "/**\n * Code Mode plugin for UTCP.\n * Enables TypeScript code execution with direct access to registered tools.\n */\n\n// Export all public APIs\nexport { CodeModeUtcpClient } from './code_mode_utcp_client';\n\n// Type exports for better TypeScript support\nexport type {\n  Tool,\n  JsonSchema,\n  UtcpClientConfig,\n} from '@utcp/sdk';\n",
      "line_count": 15,
      "word_count": 46,
      "title": "Index.Ts",
      "summary": "* Code Mode plugin for UTCP. * Enables TypeScript code execution with direct access to registered tools.",
      "key_terms": [
        "from",
        "UtcpClientConfig",
        "Type",
        "support",
        "Code",
        "utcp",
        "with",
        "Tool",
        "Utcp",
        "type",
        "public",
        "for",
        "JsonSchema",
        "registered",
        "execution",
        "UTCP",
        "CodeModeUtcpClient",
        "exports",
        "TypeScript",
        "Mode"
      ],
      "timestamp": "2025-12-24T18:56:17.067627"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\code-mode\\tests\\code_mode_utcp_client.test.ts",
      "content_type": "code",
      "content": "/**\n * Tests for CodeModeUtcpClient\n * This validates the code mode functionality using direct-call tools\n */\n\nimport { test, expect, describe, beforeAll, afterAll } from 'bun:test';\nimport { CodeModeUtcpClient } from '../src/index';\nimport { addFunctionToUtcpDirectCall } from '@utcp/direct-call';\n\n// Test utility functions\nconst testResults: Record<string, any> = {};\n\n// Setup test tools using direct-call\nbeforeAll(async () => {\n  // Register test functions as direct-call tools\n  \n  // Simple math function\n  addFunctionToUtcpDirectCall('add', async (a: number, b: number) => {\n    testResults.addCalled = { a, b, timestamp: Date.now() };\n    return { result: a + b, operation: 'addition' };\n  });\n\n  // String manipulation function\n  addFunctionToUtcpDirectCall('greet', async (name: string, formal: boolean = false) => {\n    testResults.greetCalled = { name, formal, timestamp: Date.now() };\n    const greeting = formal ? `Good day, ${name}` : `Hey ${name}!`;\n    return { greeting, isFormal: formal };\n  });\n\n  // Complex object handling function\n  addFunctionToUtcpDirectCall('processData', async (data: any, options: any = {}) => {\n    testResults.processDataCalled = { data, options, timestamp: Date.now() };\n    return {\n      processedData: {\n        ...data,\n        processed: true,\n        processedAt: new Date().toISOString(),\n        options\n      },\n      metadata: {\n        itemCount: Array.isArray(data) ? data.length : 1,\n        hasOptions: Object.keys(options).length > 0\n      }\n    };\n  });\n\n  // Function that throws an error\n  addFunctionToUtcpDirectCall('throwError', async (message: string) => {\n    testResults.throwErrorCalled = { message, timestamp: Date.now() };\n    throw new Error(message);\n  });\n\n  // Function with no parameters\n  addFunctionToUtcpDirectCall('getCurrentTime', async () => {\n    testResults.getCurrentTimeCalled = { timestamp: Date.now() };\n    return { \n      timestamp: Date.now(),\n      iso: new Date().toISOString()\n    };\n  });\n\n  // Array processing function\n  addFunctionToUtcpDirectCall('sumArray', async (numbers: number[]) => {\n    testResults.sumArrayCalled = { numbers, timestamp: Date.now() };\n    return {\n      sum: numbers.reduce((a, b) => a + b, 0),\n      count: numbers.length,\n      average: numbers.length > 0 ? numbers.reduce((a, b) => a + b, 0) / numbers.length : 0\n    };\n  });\n});\n\ndescribe('CodeModeUtcpClient', () => {\n  let client: CodeModeUtcpClient;\n\n  beforeAll(async () => {\n    // Create client\n    client = await CodeModeUtcpClient.create();\n\n    // First register the manual provider function\n    addFunctionToUtcpDirectCall('getTestManual', async () => {\n      return {\n        utcp_version: '1.0.0',\n        manual_version: '1.0.0',\n        tools: [\n          {\n            name: 'add',\n            description: 'Adds two numbers together',\n            inputs: {\n              type: 'object',\n              properties: {\n                a: { type: 'number', description: 'First number' },\n                b: { type: 'number', description: 'Second number' }\n              },\n              required: ['a', 'b']\n            },\n            outputs: {\n              type: 'object',\n              properties: {\n                result: { type: 'number', description: 'Sum of the numbers' },\n                operation: { type: 'string', description: 'Type of operation' }\n              },\n              required: ['result', 'operation']\n            },\n            tags: ['math', 'arithmetic'],\n            tool_call_template: {\n              call_template_type: 'direct-call',\n              callable_name: 'add'\n            }\n          },\n          {\n            name: 'greet',\n            description: 'Generates a greeting message',\n            inputs: {\n              type: 'object',\n              properties: {\n                name: { type: 'string', description: 'Name to greet' },\n                formal: { type: 'boolean', description: 'Whether to use formal greeting', default: false }\n              },\n              required: ['name']\n            },\n            outputs: {\n              type: 'object',\n              properties: {\n                greeting: { type: 'string', description: 'The greeting message' },\n                isFormal: { type: 'boolean', description: 'Whether the greeting was formal' }\n              },\n              required: ['greeting', 'isFormal']\n            },\n            tags: ['text', 'greeting'],\n            tool_call_template: {\n              call_template_type: 'direct-call',\n              callable_name: 'greet'\n            }\n          },\n          {\n            name: 'processData',\n            description: 'Processes data with optional configuration',\n            inputs: {\n              type: 'object',\n              properties: {\n                data: { description: 'Data to process' },\n                options: { type: 'object', description: 'Processing options', default: {} }\n              },\n              required: ['data']\n            },\n            outputs: {\n              type: 'object',\n              properties: {\n                processedData: { description: 'The processed data' },\n                metadata: { type: 'object', description: 'Processing metadata' }\n              },\n              required: ['processedData', 'metadata']\n            },\n            tags: ['processing', 'data'],\n            tool_call_template: {\n              call_template_type: 'direct-call',\n              callable_name: 'processData'\n            }\n          },\n          {\n            name: 'throwError',\n            description: 'Throws an error for testing error handling',\n            inputs: {\n              type: 'object',\n              properties: {\n                message: { type: 'string', description: 'Error message' }\n              },\n              required: ['message']\n            },\n            outputs: {\n              type: 'object',\n              properties: {}\n            },\n            tags: ['testing', 'error'],\n            tool_call_template: {\n              call_template_type: 'direct-call',\n              callable_name: 'throwError'\n            }\n          },\n          {\n            name: 'getCurrentTime',\n            description: 'Gets the current timestamp',\n            inputs: {\n              type: 'object',\n              properties: {},\n              required: []\n            },\n            outputs: {\n              type: 'object',\n              properties: {\n                timestamp: { type: 'number', description: 'Unix timestamp' },\n                iso: { type: 'string', description: 'ISO date string' }\n              },\n              required: ['timestamp', 'iso']\n            },\n            tags: ['time', 'utility'],\n            tool_call_template: {\n              call_template_type: 'direct-call',\n              callable_name: 'getCurrentTime'\n            }\n          },\n          {\n            name: 'sumArray',\n            description: 'Calculates sum and statistics of a number array',\n            inputs: {\n              type: 'object',\n              properties: {\n                numbers: {\n                  type: 'array',\n                  items: { type: 'number' },\n                  description: 'Array of numbers to sum'\n                }\n              },\n              required: ['numbers']\n            },\n            outputs: {\n              type: 'object',\n              properties: {\n                sum: { type: 'number', description: 'Sum of all numbers' },\n                count: { type: 'number', description: 'Count of numbers' },\n                average: { type: 'number', description: 'Average of numbers' }\n              },\n              required: ['sum', 'count', 'average']\n            },\n            tags: ['math', 'array', 'statistics'],\n            tool_call_template: {\n              call_template_type: 'direct-call',\n              callable_name: 'sumArray'\n            }\n          }\n        ]\n      };\n    });\n\n    // Now register the manual that uses the getTestManual function\n    try {\n      const result = await client.registerManual({\n        name: 'test_tools',\n        call_template_type: 'direct-call',\n        callable_name: 'getTestManual'\n      });\n      \n      if (!result.success) {\n        console.error('Manual registration failed:', result.errors);\n        throw new Error(`Manual registration failed: ${result.errors.join(', ')}`);\n      }\n    } catch (error) {\n      console.error('Manual registration error:', error);\n      throw error;\n    }\n  });\n\n  afterAll(async () => {\n    if (client) {\n      await client.close();\n    }\n  });\n\n  test('should create CodeModeUtcpClient instance', async () => {\n    expect(client).toBeDefined();\n    expect(client).toBeInstanceOf(CodeModeUtcpClient);\n  });\n\n  test('should have registered tools', async () => {\n    const tools = await client.getTools();\n    expect(tools.length).toBeGreaterThan(0);\n    \n    const toolNames = tools.map(t => t.name.split('.').pop());\n    expect(toolNames).toContain('add');\n    expect(toolNames).toContain('greet');\n    expect(toolNames).toContain('processData');\n  });\n\n  test('should convert tool to TypeScript interface', async () => {\n    const tools = await client.getTools();\n    const addTool = tools.find(t => t.name.endsWith('.add'));\n    expect(addTool).toBeDefined();\n\n    const tsInterface = client.toolToTypeScriptInterface(addTool!);\n    expect(tsInterface).toContain('namespace test_tools');\n    expect(tsInterface).toContain('interface addInput');\n    expect(tsInterface).toContain('interface addOutput');\n    expect(tsInterface).toContain('a: number');\n    expect(tsInterface).toContain('b: number');\n    expect(tsInterface).toContain('result: number');\n    expect(tsInterface).toContain('operation: string');\n    expect(tsInterface).toContain('Access as: test_tools.add(args)');\n  });\n\n  test('should generate all tools TypeScript interfaces', async () => {\n    const interfaces = await client.getAllToolsTypeScriptInterfaces();\n    expect(interfaces).toContain('// Auto-generated TypeScript interfaces for UTCP tools');\n    expect(interfaces).toContain('namespace test_tools');\n    expect(interfaces).toContain('interface addInput');\n    expect(interfaces).toContain('interface greetInput');\n    expect(interfaces).toContain('interface processDataInput');\n  });\n\n  test('should execute simple code with basic operations', async () => {\n    const code = `\n      const x = 5;\n      const y = 10;\n      return x + y;\n    `;\n    \n    const { result } = await client.callToolChain(code);\n    expect(result).toBe(15);\n  });\n\n  test('should execute code that calls a simple tool', async () => {\n    // Clear previous call records\n    delete testResults.addCalled;\n    \n    const code = `\n      const result = await test_tools.add({ a: 15, b: 25 });\n      return result;\n    `;\n    \n    const { result } = await client.callToolChain(code);\n    expect(result.result).toBe(40);\n    expect(result.operation).toBe('addition');\n    \n    // Verify the tool was called with correct parameters\n    expect(testResults.addCalled).toBeDefined();\n    expect(testResults.addCalled.a).toBe(15);\n    expect(testResults.addCalled.b).toBe(25);\n  });\n\n  test('should execute code with multiple tool calls', async () => {\n    // Clear previous call records\n    delete testResults.addCalled;\n    delete testResults.greetCalled;\n    \n    const code = `\n      const mathResult = await test_tools.add({ a: 10, b: 5 });\n      const greetResult = await test_tools.greet({ name: \"Alice\", formal: true });\n      \n      return {\n        math: mathResult,\n        greeting: greetResult,\n        combined: \\`\\${greetResult.greeting} The sum is \\${mathResult.result}\\`\n      };\n    `;\n    \n    const { result } = await client.callToolChain(code);\n    expect(result.math.result).toBe(15);\n    expect(result.greeting.greeting).toBe(\"Good day, Alice\");\n    expect(result.greeting.isFormal).toBe(true);\n    expect(result.combined).toBe(\"Good day, Alice The sum is 15\");\n    \n    // Verify both tools were called\n    expect(testResults.addCalled).toBeDefined();\n    expect(testResults.greetCalled).toBeDefined();\n  });\n\n  test('should handle complex data structures', async () => {\n    delete testResults.processDataCalled;\n    \n    const code = `\n      const complexData = {\n        users: [\n          { name: \"John\", age: 30 },\n          { name: \"Jane\", age: 25 }\n        ],\n        settings: { theme: \"dark\", notifications: true }\n      };\n      \n      const result = await test_tools.processData({ \n        data: complexData, \n        options: { validate: true, transform: \"uppercase\" } \n      });\n      \n      return result;\n    `;\n    \n    const { result } = await client.callToolChain(code);\n    expect(result.processedData.processed).toBe(true);\n    expect(result.processedData.users).toBeDefined();\n    expect(result.metadata.itemCount).toBe(1);\n    expect(result.metadata.hasOptions).toBe(true);\n    \n    // Verify the tool was called with the complex data\n    expect(testResults.processDataCalled).toBeDefined();\n    expect(testResults.processDataCalled.data.users.length).toBe(2);\n    expect(testResults.processDataCalled.options.validate).toBe(true);\n  });\n\n  test('should handle arrays and array processing tools', async () => {\n    delete testResults.sumArrayCalled;\n    \n    const code = `\n      const numbers = [1, 2, 3, 4, 5, 10];\n      const stats = await test_tools.sumArray({ numbers });\n      \n      return {\n        original: numbers,\n        statistics: stats,\n        doubled: numbers.map(n => n * 2)\n      };\n    `;\n    \n    const { result } = await client.callToolChain(code);\n    expect(result.statistics.sum).toBe(25);\n    expect(result.statistics.count).toBe(6);\n    expect(result.statistics.average).toBe(25/6);\n    expect(result.doubled).toEqual([2, 4, 6, 8, 10, 20]);\n    \n    // Verify the tool was called correctly\n    expect(testResults.sumArrayCalled).toBeDefined();\n    expect(testResults.sumArrayCalled.numbers).toEqual([1, 2, 3, 4, 5, 10]);\n  });\n\n  test('should handle tool calls with no parameters', async () => {\n    delete testResults.getCurrentTimeCalled;\n    \n    const code = `\n      const timeResult = await test_tools.getCurrentTime({});\n      return {\n        timeData: timeResult,\n        isRecent: timeResult.timestamp > Date.now() - 5000\n      };\n    `;\n    \n    const { result } = await client.callToolChain(code);\n    expect(result.timeData.timestamp).toBeDefined();\n    expect(result.timeData.iso).toBeDefined();\n    expect(result.isRecent).toBe(true);\n    \n    // Verify the tool was called\n    expect(testResults.getCurrentTimeCalled).toBeDefined();\n  });\n\n  test('should handle tool errors correctly', async () => {\n    const code = `\n      try {\n        await test_tools.throwError({ message: \"Test error message\" });\n        return { error: false };\n      } catch (error) {\n        return { \n          error: true, \n          message: error.message,\n          caught: true\n        };\n      }\n    `;\n    \n    const { result } = await client.callToolChain(code);\n    expect(result.error).toBe(true);\n    expect(result.caught).toBe(true);\n    expect(result.message).toContain(\"Test error message\");\n  });\n\n  test('should handle code execution timeout', async () => {\n    const code = `\n      // Infinite loop to test timeout\n      while (true) {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      }\n      return { completed: true };\n    `;\n    \n    const result = await client.callToolChain(code, 1000);\n    expect(result.result).toBeNull();\n    expect(result.logs.some(log => log.includes('Code execution failed'))).toBe(true);\n  });\n\n  test('should handle code syntax errors', async () => {\n    const invalidCode = `\n      const invalid syntax here\n      return result;\n    `;\n    \n    const result = await client.callToolChain(invalidCode);\n    expect(result.result).toBeNull();\n    expect(result.logs.some(log => log.includes('Code execution failed'))).toBe(true);\n  });\n\n  test('should have access to basic JavaScript globals', async () => {\n    const code = `\n      return {\n        mathPi: Math.PI,\n        dateNow: Date.now(),\n        arrayMethods: Array.isArray([1, 2, 3]),\n        jsonStringify: JSON.stringify({ test: true }),\n        objectKeys: Object.keys({ a: 1, b: 2 })\n      };\n    `;\n    \n    const { result } = await client.callToolChain(code);\n    expect(result.mathPi).toBe(Math.PI);\n    expect(typeof result.dateNow).toBe('number');\n    expect(result.arrayMethods).toBe(true);\n    expect(result.jsonStringify).toBe('{\"test\":true}');\n    expect(result.objectKeys).toEqual(['a', 'b']);\n  });\n\n  test('should have access to TypeScript interfaces in execution context', async () => {\n    const code = `\n      return {\n        hasInterfaces: typeof __interfaces === 'string',\n        interfacesContainNamespace: __interfaces.includes('namespace test_tools'),\n        canGetSpecificInterface: typeof __getToolInterface === 'function',\n        addToolInterface: __getToolInterface('test_tools.add'),\n        interfaceIsString: typeof __getToolInterface('test_tools.add') === 'string'\n      };\n    `;\n    \n    const { result } = await client.callToolChain(code);\n    expect(result.hasInterfaces).toBe(true);\n    expect(result.interfacesContainNamespace).toBe(true);\n    expect(result.canGetSpecificInterface).toBe(true);\n    expect(result.addToolInterface).toBeTruthy();\n    expect(result.interfaceIsString).toBe(true);\n  });\n\n  test('should execute complex chained operations', async () => {\n    // Clear call records\n    Object.keys(testResults).forEach(key => delete testResults[key]);\n    \n    const code = `\n      // Step 1: Get some numbers and process them\n      const numbers = [5, 10, 15, 20];\n      const arrayStats = await test_tools.sumArray({ numbers });\n      \n      // Step 2: Use the sum in another calculation\n      const addResult = await test_tools.add({ a: arrayStats.sum, b: 100 });\n      \n      // Step 3: Create a greeting with the result\n      const greeting = await test_tools.greet({ name: \"CodeMode\", formal: false });\n      \n      // Step 4: Process all the data together\n      const finalData = await test_tools.processData({\n        data: {\n          arrayStats,\n          addResult,\n          greeting,\n          executionTime: Date.now()\n        },\n        options: {\n          includeMetadata: true,\n          format: \"enhanced\"\n        }\n      });\n      \n      return {\n        steps: {\n          arrayProcessing: arrayStats,\n          addition: addResult,\n          greeting: greeting,\n          finalProcessing: finalData\n        },\n        summary: {\n          originalSum: arrayStats.sum,\n          finalSum: addResult.result,\n          greetingMessage: greeting.greeting,\n          chainCompleted: true\n        }\n      };\n    `;\n    \n    const result = await client.callToolChain(code, 15000);\n    \n    // Verify the chain worked correctly\n    expect(result.result.steps.arrayProcessing.sum).toBe(50);\n    expect(result.result.steps.addition.result).toBe(150);\n    expect(result.result.steps.greeting.greeting).toBe(\"Hey CodeMode!\");\n    expect(result.result.steps.finalProcessing.processedData.processed).toBe(true);\n    expect(result.result.summary.chainCompleted).toBe(true);\n    \n    // Verify all tools were called in the correct order\n    expect(testResults.sumArrayCalled).toBeDefined();\n    expect(testResults.addCalled).toBeDefined();\n    expect(testResults.greetCalled).toBeDefined();\n    expect(testResults.processDataCalled).toBeDefined();\n    \n    // Verify the parameters were passed correctly through the chain\n    expect(testResults.addCalled.a).toBe(50); // Sum from array\n    expect(testResults.addCalled.b).toBe(100);\n    expect(testResults.greetCalled.name).toBe(\"CodeMode\");\n    expect(testResults.greetCalled.formal).toBe(false);\n  });\n\n  test('should provide agent prompt template', () => {\n    const promptTemplate = CodeModeUtcpClient.AGENT_PROMPT_TEMPLATE;\n    \n    expect(typeof promptTemplate).toBe('string');\n    expect(promptTemplate.length).toBeGreaterThan(0);\n    expect(promptTemplate).toContain('Tool Discovery Phase');\n    expect(promptTemplate).toContain('Interface Introspection');\n    expect(promptTemplate).toContain('Code Execution Guidelines');\n    expect(promptTemplate).toContain('await manual.tool');\n    expect(promptTemplate).toContain('__interfaces');\n    expect(promptTemplate).toContain('__getToolInterface');\n    expect(promptTemplate).toContain('Discover first, code second');\n  });\n\n  test('should capture console.log output with callToolChain', async () => {\n    const code = `\n      console.log('First log message');\n      console.log('Number:', 42);\n      console.log('Object:', { name: 'test', value: 123 });\n      \n      const addResult = await test_tools.add({ a: 10, b: 20 });\n      console.log('Addition result:', addResult);\n      \n      return addResult.result;\n    `;\n    \n    const { result, logs } = await client.callToolChain(code);\n    \n    expect(result).toBe(30);\n    expect(logs).toHaveLength(4);\n    expect(logs[0]).toBe('First log message');\n    expect(logs[1]).toBe('Number: 42');\n    expect(logs[2]).toContain('\"name\": \"test\"');\n    expect(logs[2]).toContain('\"value\": 123');\n    expect(logs[3]).toContain('Addition result:');\n    expect(logs[3]).toContain('\"result\": 30');\n  });\n\n  test('should capture console error and warn with callToolChain', async () => {\n    const code = `\n      console.log('Regular log');\n      console.error('This is an error');\n      console.warn('This is a warning');\n      console.info('This is info');\n      \n      return 'done';\n    `;\n    \n    const { result, logs } = await client.callToolChain(code);\n    \n    expect(result).toBe('done');\n    expect(logs).toHaveLength(4);\n    expect(logs[0]).toBe('Regular log');\n    expect(logs[1]).toBe('[ERROR] This is an error');\n    expect(logs[2]).toBe('[WARN] This is a warning');\n    expect(logs[3]).toBe('[INFO] This is info');\n  });\n});\n\n// Export for potential manual testing\nexport { testResults };\n",
      "line_count": 645,
      "word_count": 1913,
      "title": "Code Mode Utcp Client.Test.Ts",
      "summary": "* Tests for CodeModeUtcpClient * This validates the code mode functionality using direct-call tools",
      "key_terms": [
        "close",
        "const",
        "convert",
        "Type",
        "Code",
        "Setup",
        "Record",
        "utility",
        "afterAll",
        "mode",
        "greetCalled",
        "multiple",
        "CodeModeUtcpClient",
        "if",
        "that",
        "interface",
        "Processing",
        "basic",
        "correct",
        "Hey"
      ],
      "timestamp": "2025-12-24T18:56:17.124551"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\package.json",
      "content_type": "configuration",
      "content": "{\n  \"name\": \"@utcp/sdk\",\n  \"version\": \"1.1.0\",\n  \"description\": \"Universal Tool Calling Protocol SDK\",\n  \"main\": \"dist/index.cjs\",\n  \"module\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"type\": \"module\",\n  \"license\": \"MPL-2.0\",\n  \"author\": \"UTCP Contributors\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/universal-tool-calling-protocol/typescript-utcp\",\n    \"directory\": \"packages/core\"\n  },\n  \"keywords\": [\n    \"utcp\",\n    \"universal-tool-calling-protocol\",\n    \"tools\",\n    \"api\",\n    \"typescript\",\n    \"tool calling\",\n    \"mcp\",\n    \"agent\",\n    \"ai\",\n    \"llm\"\n  ],\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"scripts\": {\n    \"prebuild\": \"rm -rf dist || rmdir /s /q dist || true\",\n    \"build\": \"tsup && node scripts/replace-version.js\"\n  },\n  \"files\": [\n    \"dist\",\n    \"README.md\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\",\n      \"require\": \"./dist/index.cjs\",\n      \"default\": \"./dist/index.js\"\n    }\n  },\n  \"dependencies\": {\n    \"dotenv\": \"^17.2.1\",\n    \"zod\": \"^3.23.8\"\n  },\n  \"devDependencies\": {\n    \"bun-types\": \"latest\",\n    \"typescript\": \"^5.0.0\"\n  }\n}\n",
      "line_count": 56,
      "word_count": 105,
      "title": "Package.Json",
      "summary": "\"name\": \"@utcp/sdk\", \"version\": \"1.1.0\",",
      "key_terms": [
        "build",
        "packages",
        "node",
        "calling-protocol",
        "scripts",
        "universal",
        "md",
        "module",
        "zod",
        "utcp",
        "index",
        "calling",
        "replace",
        "Tool",
        "MPL",
        "tool",
        "dependencies",
        "type",
        "url",
        "Universal"
      ],
      "timestamp": "2025-12-24T18:56:17.152339"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\README.md",
      "content_type": "documentation",
      "content": "# @utcp/sdk\n\nUniversal Tool Calling Protocol (UTCP) Core SDK for TypeScript\n\n## Overview\n\nThe `@utcp/sdk` package provides the fundamental components and interfaces for the Universal Tool Calling Protocol (UTCP) in TypeScript. It is designed to be lean and extensible, serving as the central hub for integrating various communication protocols via a plugin-based architecture.\n\n## Features\n\n### Core Components\n\n*   **UtcpClient**: The main client for interacting with the UTCP ecosystem\n    *   Plugin-based protocol support (HTTP, MCP, Text, File, CLI, etc.)\n    *   Manual and tool registration/deregistration\n    *   Tool search with name, tag, and description matching\n    *   Tool execution across multiple protocols\n    *   Secure namespace-isolated variable management\n\n*   **Data Models**: Type-safe data structures with Zod validation\n    *   `Tool`: Tool definitions with inputs/outputs schemas\n    *   `CallTemplate`: Protocol-specific call templates\n    *   `Auth`: Authentication configurations (API Key, Basic, OAuth2)\n    *   `UtcpManual`: Tool collections\n\n*   **Pluggable Architecture**:\n    *   `CommunicationProtocol`: Interface for protocol implementations\n    *   `ConcurrentToolRepository`: Interface for tool storage (default: in-memory)\n    *   `ToolSearchStrategy`: Interface for search algorithms (default: tag-based)\n    *   `VariableSubstitutor`: Interface for variable resolution\n\n*   **Security Features**:\n    *   Namespace-isolated variables prevent leakage between manuals\n    *   Multiple variable sources (config, .env files, environment)\n    *   Hierarchical variable resolution\n\n## Installation\n\n```bash\nnpm install @utcp/sdk\n\n# Or with bun\nbun add @utcp/sdk\n```\n\n## Quick Start\n\n### Basic Usage\n\n**Important:** Plugins must be explicitly imported to register their protocols:\n\n```typescript\nimport { UtcpClient } from '@utcp/sdk';\nimport '@utcp/http';  // Auto-registers HTTP protocol\nimport { HttpCallTemplateSerializer } from '@utcp/http';\n\nasync function main() {\n  // Create client\n  const serializer = new HttpCallTemplateSerializer();\n  const apiTemplate = serializer.validateDict({\n    name: 'api_manual',\n    call_template_type: 'http',\n    http_method: 'GET',\n    url: 'https://api.example.com/data',\n    headers: {\n      'Authorization': 'Bearer ${API_KEY}' // Resolves to api__manual_API_KEY\n    }\n  });\n\n  const client = await UtcpClient.create(process.cwd(), {\n    variables: {\n      // Namespaced format: manual_name_VARIABLE\n      api__manual_API_KEY: process.env.API_KEY || ''\n    },\n    manual_call_templates: [apiTemplate]\n  });\n\n  // Search for tools\n  const tools = await client.searchTools('data');\n  \n  // Call a tool\n  const result = await client.callTool('api_manual.get_data', {});\n  \n  await client.close();\n}\n```\n\n### With Environment Variables\n\n```typescript\nimport { UtcpClient } from '@utcp/sdk';\nimport '@utcp/dotenv-loader';  // Required for .env file support\n\nconst client = await UtcpClient.create(process.cwd(), {\n  load_variables_from: [\n    {\n      variable_loader_type: 'dotenv',\n      env_file_path: './.env'\n    }\n  ],\n  variables: {\n    // Direct config (highest priority)\n    'github__api_TOKEN': 'override-token'\n  }\n});\n```\n\n## API Reference\n\n### UtcpClient.create()\n\n```typescript\nstatic async create(\n  root_dir: string,\n  config?: Partial<UtcpClientConfig>\n): Promise<UtcpClient>\n```\n\n**Parameters:**\n- `root_dir`: Base directory for resolving relative paths (typically `process.cwd()`)\n- `config`: Optional configuration object\n\n**Configuration:**\n\n```typescript\ninterface UtcpClientConfig {\n  // Variable definitions (highest priority)\n  variables?: Record<string, string>;\n  \n  // External variable loaders\n  load_variables_from?: VariableLoader[];\n  \n  // Initial manuals to register\n  manual_call_templates?: CallTemplate[];\n  \n  // Tool storage (default: in-memory)\n  tool_repository?: ConcurrentToolRepository;\n  \n  // Search algorithm (default: tag and description matching)\n  tool_search_strategy?: ToolSearchStrategy;\n  \n  // Result post-processors\n  post_processing?: ToolPostProcessor[];\n}\n```\n\n### Core Methods\n\n#### Search Tools\n```typescript\nasync searchTools(\n  query: string,\n  limit?: number,\n  anyOfTagsRequired?: string[]\n): Promise<Tool[]>\n```\n\nSearches for tools matching the query. Considers:\n- Tool names (highest priority)\n- Tool tags\n- Tool descriptions\n\n#### Call Tool\n```typescript\nasync callTool(\n  toolName: string,\n  args: Record<string, any>\n): Promise<any>\n```\n\nExecute a tool. Tool names use format:\n- Standard: `manual_name.tool_name`\n- MCP: `manual_name.server_name.tool_name`\n\n#### Get Tools\n```typescript\nasync getTools(): Promise<Tool[]>\nasync getTool(toolName: string): Promise<Tool | undefined>\n```\n\n#### Register/Deregister Manuals\n```typescript\nasync registerManual(callTemplate: CallTemplate): Promise<void>\nasync deregisterManual(manualName: string): Promise<boolean>\nasync registerManuals(callTemplates: CallTemplate[]): Promise<void>\n```\n\n#### Variable Utilities\n```typescript\nasync getRequiredVariablesForTool(toolName: string): Promise<string[]>\n```\n\n#### Cleanup\n```typescript\nasync close(): Promise<void>\n```\n\nCloses all communication protocols and releases resources.\n\n## Variable Management\n\n### Namespace Isolation\n\nVariables are automatically namespaced by manual name for security:\n\n```typescript\n// Manual name: \"github_api\"\n// Variable reference: ${TOKEN}\n// Actual lookup: \"github__api_TOKEN\"\n\nconst client = await UtcpClient.create(process.cwd(), {\n  variables: {\n    'github__api_TOKEN': 'github-secret',\n    'slack__api_TOKEN': 'slack-secret',\n  },\n  manual_call_templates: [\n    {\n      name: 'github_api',\n      // ... \n      headers: {\n        // Resolves ONLY to 'github__api_TOKEN'\n        'Authorization': 'Bearer ${TOKEN}'\n      }\n    }\n  ]\n});\n```\n\n**Namespace transformation:**\n- `github_api` → `github__api_`\n- Underscores become double underscores\n- Hyphens converted to underscores\n\n### Variable Resolution Order\n\n1. `config.variables` (highest priority)\n2. Variable loaders (e.g., .env files, in order)\n3. Environment variables (lowest priority)\n\nAll lookups use the namespaced key: `{namespace}_VARIABLE_NAME`\n\n## Plugin System\n\n### Available Plugins\n\nUTCP provides several optional protocol plugins:\n\n**Browser-Compatible:**\n- `@utcp/http` - HTTP/HTTPS requests with full authentication support\n- `@utcp/text` - Direct text/string content (inline UTCP manuals or OpenAPI specs)\n- `@utcp/direct-call` - Direct function calls\n\n**Node.js Only:**\n- `@utcp/file` - File system access for loading manuals from local files\n- `@utcp/mcp` - Model Context Protocol support\n- `@utcp/cli` - CLI command execution\n- `@utcp/dotenv-loader` - Load variables from .env files\n\n### Explicit Plugin Import\n\nEach plugin must be **explicitly imported** to register its protocol:\n\n```typescript\n// Browser application - only import browser-compatible plugins\nimport { UtcpClient } from '@utcp/sdk';\nimport '@utcp/http';\nimport '@utcp/text';\nimport '@utcp/direct-call';\n\n// Node.js application - can use all plugins\nimport { UtcpClient } from '@utcp/sdk';\nimport '@utcp/http';\nimport '@utcp/mcp';\nimport '@utcp/file';\nimport '@utcp/dotenv-loader';\n```\n\nThis explicit import approach ensures:\n- ✅ Browser bundles only include what you use\n- ✅ No Node.js dependencies in browser builds\n- ✅ Perfect tree-shaking for minimal bundle sizes\n- ✅ Clear, explicit dependencies\n\n### Custom Plugin Registration\n\nFor custom or third-party plugins:\n\n```typescript\nimport { CallTemplateSerializer } from '@utcp/sdk';\nimport { CommunicationProtocol } from '@utcp/sdk';\n\n// Register custom call template\nCallTemplateSerializer.registerCallTemplate(\n  'custom_type',\n  new CustomCallTemplateSerializer()\n);\n\n// Register custom protocol\nCommunicationProtocol.communicationProtocols['custom_type'] = \n  new CustomCommunicationProtocol();\n```\n\n## Advanced Usage\n\n### Custom Tool Repository\n\n```typescript\nimport { ConcurrentToolRepository, Tool } from '@utcp/sdk';\n\nclass CustomRepository implements ConcurrentToolRepository {\n  tool_repository_type = 'custom' as const;\n  \n  async getTools(): Promise<Tool[]> { /* ... */ }\n  async getTool(name: string): Promise<Tool | undefined> { /* ... */ }\n  async saveManual(callTemplate: CallTemplate, manual: UtcpManual): Promise<void> { /* ... */ }\n  async removeManual(manualName: string): Promise<boolean> { /* ... */ }\n  // ... implement other required methods\n}\n\nconst client = await UtcpClient.create(process.cwd(), {\n  tool_repository: new CustomRepository()\n});\n```\n\n### Custom Search Strategy\n\n```typescript\nimport { ToolSearchStrategy } from '@utcp/sdk';\n\nclass CustomSearchStrategy implements ToolSearchStrategy {\n  tool_search_strategy_type = 'custom' as const;\n  \n  async searchTools(\n    repository: ConcurrentToolRepository,\n    query: string,\n    limit?: number,\n    anyOfTagsRequired?: string[]\n  ): Promise<Tool[]> {\n    // Implement custom search logic\n  }\n}\n```\n\n### Post-Processors\n\nTransform tool results:\n\n```typescript\nconst client = await UtcpClient.create(process.cwd(), {\n  post_processing: [\n    {\n      tool_post_processor_type: 'filter_dict',\n      allowed_keys: ['id', 'name', 'email']\n    },\n    {\n      tool_post_processor_type: 'limit_strings',\n      max_length: 1000\n    }\n  ]\n});\n```\n\n## Error Handling\n\n```typescript\nimport { UtcpVariableNotFoundError } from '@utcp/sdk';\n\ntry {\n  await client.callTool('manual.tool', {});\n} catch (error) {\n  if (error instanceof UtcpVariableNotFoundError) {\n    console.error(`Missing variable: ${error.variableName}`);\n  }\n  throw error;\n}\n```\n\n## TypeScript Support\n\nThe package is fully typed with TypeScript. All schemas are validated at runtime using Zod:\n\n```typescript\nimport { ToolSchema, CallTemplateSchema } from '@utcp/sdk';\n\n// Runtime validation\nconst tool = ToolSchema.parse(toolData);\nconst callTemplate = CallTemplateSchema.parse(templateData);\n```\n\n## Package Structure\n\n```\n@utcp/sdk/\n├── client/              # UtcpClient and configuration\n├── data/                # Core data models (Tool, CallTemplate, Auth, etc.)\n├── interfaces/          # Abstract interfaces for plugins\n├── implementations/     # Default implementations\n│   ├── in_mem_concurrent_tool_repository.ts\n│   ├── tag_search_strategy.ts\n│   └── default_variable_substitutor.ts\n└── plugins/             # Plugin loader and registry\n```\n\n## Related Packages\n\n- **`@utcp/sdk`** - Core SDK (this package)\n- `@utcp/http` - HTTP protocol support with OpenAPI conversion\n- `@utcp/mcp` - Model Context Protocol integration\n- `@utcp/text` - File-based tool loading\n- `@utcp/cli` - Command-line tool execution\n\n## Contributing\n\nSee the root repository for contribution guidelines.\n\n## License\n\nMozilla Public License Version 2.0",
      "line_count": 418,
      "word_count": 1207,
      "title": "@utcp/sdk",
      "summary": "Universal Tool Calling Protocol (UTCP) Core SDK for TypeScript The `@utcp/sdk` package provides the fundamental components and interfaces for the Universal Tool Calling Protocol (UTCP) in TypeScript. ...",
      "key_terms": [
        "double",
        "Important",
        "const",
        "close",
        "Model",
        "Architecture",
        "Closes",
        "etc",
        "Type",
        "Record",
        "loaders",
        "callTemplate",
        "multiple",
        "toolName",
        "Browser",
        "if",
        "Features",
        "interface",
        "removeManual",
        "Version"
      ],
      "timestamp": "2025-12-24T18:56:17.206992"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\tsconfig.json",
      "content_type": "configuration",
      "content": "// packages/core/tsconfig.json\n{\n  \"extends\": \"../../tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"composite\": true\n  },\n  \"include\": [\n    \"src/**/*\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"**/*.test.ts\",\n    \"**/*.spec.ts\"\n  ],\n}",
      "line_count": 18,
      "word_count": 26,
      "title": "Tsconfig.Json",
      "summary": "// packages/core/tsconfig.json \"extends\": \"../../tsconfig.json\",",
      "key_terms": [
        "rootDir",
        "packages",
        "composite",
        "include",
        "exclude",
        "tsconfig",
        "ts",
        "spec",
        "json",
        "core",
        "extends",
        "compilerOptions",
        "dist",
        "src",
        "outDir",
        "test",
        "true"
      ],
      "timestamp": "2025-12-24T18:56:17.227560"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\tsup.config.ts",
      "content_type": "code",
      "content": "import { defineConfig } from 'tsup';\n\nexport default defineConfig({\n  entry: ['src/index.ts'],\n  format: ['esm', 'cjs'],\n  dts: {\n    compilerOptions: {\n      composite: false,\n    },\n  },\n  splitting: false,\n  sourcemap: true,\n  clean: true,\n  outDir: 'dist',\n  external: ['dotenv', 'zod'],\n});\n",
      "line_count": 17,
      "word_count": 34,
      "title": "Tsup.Config.Ts",
      "summary": "import { defineConfig } from 'tsup'; export default defineConfig({",
      "key_terms": [
        "from",
        "sourcemap",
        "composite",
        "entry",
        "zod",
        "clean",
        "outDir",
        "index",
        "format",
        "default",
        "ts",
        "cjs",
        "false",
        "dotenv",
        "import",
        "export",
        "dist",
        "splitting",
        "tsup",
        "true"
      ],
      "timestamp": "2025-12-24T18:56:17.257511"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\scripts\\README.md",
      "content_type": "documentation",
      "content": "# Build Scripts\n\n## Version Replacement\n\nThe `replace-version.js` script automatically injects the package version into the compiled code during the build process.\n\n### How It Works\n\n1. **Source File**: `src/version.ts` contains a placeholder:\n   ```typescript\n   export const LIB_VERSION = \"__LIB_VERSION__\";\n   ```\n\n2. **TypeScript Compilation**: The TypeScript compiler builds `src/version.ts` → `dist/version.js`\n\n3. **Post-Build Replacement**: The `replace-version.js` script:\n   - Reads the version from `package.json`\n   - Replaces `__LIB_VERSION__` with the actual version in `dist/version.js`\n   - Example: `\"__LIB_VERSION__\"` → `\"1.0.1\"`\n\n4. **Usage in Code**: Other modules import the version:\n   ```typescript\n   import { LIB_VERSION } from '../version';\n   export const UTCP_PACKAGE_VERSION = LIB_VERSION;\n   ```\n\n### Build Process\n\n```bash\nnpm run build\n# or\nbun run build\n```\n\nThis runs:\n1. `prebuild`: Cleans the `dist` directory\n2. `build`: Compiles TypeScript (`tsc`) then runs version replacement\n3. Post-build: `replace-version.js` injects the actual version\n\n### Benefits\n\n- ✅ **No runtime environment variables needed**\n- ✅ **Version is baked into the compiled code**\n- ✅ **Single source of truth**: `package.json`\n- ✅ **Works in all environments** (Node.js, browsers, bundlers)\n- ✅ **Version consistency** across all modules using `UTCP_PACKAGE_VERSION`\n\n### Adding New Packages\n\nWhen adding new packages that need version information:\n\n1. Import from `@utcp/sdk`:\n   ```typescript\n   import { UTCP_PACKAGE_VERSION } from '@utcp/sdk';\n   ```\n\n2. Use it in your code:\n   ```typescript\n   const manual = {\n     utcp_version: UTCP_PACKAGE_VERSION,\n     manual_version: UTCP_PACKAGE_VERSION,\n     tools: []\n   };\n   ```\n\n**Do not** hardcode version strings like `'1.0'` or `'0.2.0'` anywhere in the codebase.\n",
      "line_count": 67,
      "word_count": 234,
      "title": "Build Scripts",
      "summary": "The `replace-version.js` script automatically injects the package version into the compiled code during the build process. 1. **Source File**: `src/version.ts` contains a placeholder:",
      "key_terms": [
        "build",
        "const",
        "Compiles",
        "packages",
        "File",
        "Code",
        "during",
        "Reads",
        "Scripts",
        "It",
        "prebuild",
        "consistency",
        "version",
        "using",
        "replacement",
        "that",
        "Version",
        "Packages",
        "bundlers",
        "script"
      ],
      "timestamp": "2025-12-24T18:56:17.286935"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\scripts\\replace-version.js",
      "content_type": "code",
      "content": "#!/usr/bin/env node\n/**\n * Build script to replace __LIB_VERSION__ placeholder with actual package version.\n * This runs after TypeScript compilation to inject the version into the built files.\n */\n\nimport { readFileSync, writeFileSync } from 'fs';\nimport { join, dirname } from 'path';\nimport { fileURLToPath } from 'url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\n// Read package.json to get the version\nconst packageJsonPath = join(__dirname, '..', 'package.json');\nconst packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8'));\nconst version = packageJson.version;\n\nconsole.log(`Replacing __LIB_VERSION__ with ${version}`);\n\n// Replace in both ESM and CJS bundles\nconst filesToUpdate = ['index.js', 'index.cjs'];\nlet hasError = false;\n\nfor (const file of filesToUpdate) {\n  const filePath = join(__dirname, '..', 'dist', file);\n  try {\n    let content = readFileSync(filePath, 'utf-8');\n    content = content.replace(/__LIB_VERSION__/g, version);\n    writeFileSync(filePath, content, 'utf-8');\n    console.log(`✓ Updated ${filePath}`);\n  } catch (error) {\n    console.error(`Error updating ${file}:`, error.message);\n    hasError = true;\n  }\n}\n\nif (hasError) {\n  process.exit(1);\n}\n\nconsole.log('Version replacement complete!');\n",
      "line_count": 43,
      "word_count": 151,
      "title": "Replace Version.Js",
      "summary": "* Build script to replace __LIB_VERSION__ placeholder with actual package version. * This runs after TypeScript compilation to inject the version into the built files.",
      "key_terms": [
        "const",
        "error",
        "Read",
        "index",
        "Error",
        "version",
        "replacement",
        "path",
        "let",
        "if",
        "Version",
        "exit",
        "Replacing",
        "true",
        "script",
        "files",
        "after",
        "fileURLToPath",
        "both",
        "file"
      ],
      "timestamp": "2025-12-24T18:56:17.338693"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\index.ts",
      "content_type": "code",
      "content": "// packages/core/src/index.ts\n// Client\nexport * from './client/utcp_client';\nexport * from './client/utcp_client_config';\n\n// Data Models\nexport * from './data/auth';\nexport * from './data/auth_implementations/api_key_auth';\nexport * from './data/auth_implementations/basic_auth';\nexport * from './data/auth_implementations/oauth2_auth';\nexport * from './data/call_template';\nexport * from './data/tool';\nexport * from './data/utcp_manual';\nexport * from './data/register_manual_result'; \nexport * from './data/variable_loader';\n\n// Interfaces\nexport * from './interfaces';\n\n// Implementations\nexport * from './implementations/in_mem_concurrent_tool_repository';\nexport * from './implementations/tag_search_strategy';\nexport * from './implementations/default_variable_substitutor';\nexport * from './implementations/post_processors/filter_dict_post_processor';\nexport * from './implementations/post_processors/limit_strings_post_processor';\n\n// Plugins\nexport * from './plugins/plugin_loader';",
      "line_count": 28,
      "word_count": 85,
      "title": "Index.Ts",
      "summary": "// packages/core/src/index.ts export * from './client/utcp_client';",
      "key_terms": [
        "implementations",
        "from",
        "packages",
        "Interfaces",
        "Interface",
        "utcp",
        "index",
        "auth",
        "tool",
        "ts",
        "core",
        "Data",
        "plugins",
        "Client",
        "interface",
        "export",
        "interfaces",
        "api",
        "Implementations",
        "client"
      ],
      "timestamp": "2025-12-24T18:56:17.358674"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\version.ts",
      "content_type": "code",
      "content": "/**\n * Library version - replaced during build process.\n * Do not modify this file manually.\n */\nconst _VERSION = \"__LIB_VERSION__\";\n\n/**\n * The library version. Falls back to \"1.0.0\" if the build script hasn't replaced the placeholder.\n */\nexport const LIB_VERSION = _VERSION === \"__LIB_VERSION__\" ? \"1.0.0\" : _VERSION;\n",
      "line_count": 11,
      "word_count": 50,
      "title": "Version.Ts",
      "summary": "* Library version - replaced during build process. * Do not modify this file manually.",
      "key_terms": [
        "hasn",
        "process",
        "build",
        "const",
        "file",
        "during",
        "back",
        "modify",
        "Falls",
        "placeholder",
        "version",
        "not",
        "if",
        "export",
        "library",
        "to",
        "script",
        "Do",
        "replaced",
        "the"
      ],
      "timestamp": "2025-12-24T18:56:17.388644"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\client\\utcp_client.ts",
      "content_type": "code",
      "content": "// packages/core/src/client/utcp_client.ts\nimport { CallTemplate, CallTemplateSchema } from '../data/call_template';\nimport { Tool } from '../data/tool';\nimport { UtcpManualSchema } from '../data/utcp_manual';\nimport { CommunicationProtocol } from '../interfaces/communication_protocol';\nimport { RegisterManualResult } from '../data/register_manual_result';\nimport { ConcurrentToolRepository } from '../interfaces/concurrent_tool_repository';\nimport { ToolSearchStrategy } from '../interfaces/tool_search_strategy';\nimport { VariableSubstitutor } from '../interfaces/variable_substitutor';\nimport { ToolPostProcessor } from '../interfaces/tool_post_processor';\nimport {\n  UtcpClientConfig,\n  UtcpClientConfigSchema,\n  UtcpClientConfigSerializer,\n} from './utcp_client_config';\nimport { DefaultVariableSubstitutor } from '../implementations/default_variable_substitutor';\nimport { ensureCorePluginsInitialized } from '../plugins/plugin_loader';\nimport { IUtcpClient } from '../interfaces/utcp_client_interface';\nimport { ToolSearchStrategyConfigSerializer } from '../interfaces/tool_search_strategy';\nimport { ToolPostProcessorConfigSerializer } from '../interfaces/tool_post_processor';\nimport { ConcurrentToolRepositoryConfigSerializer } from '../interfaces/concurrent_tool_repository';\n\n/**\n * REQUIRED\n * Abstract interface for UTCP client implementations.\n *\n * Defines the core contract for UTCP clients, including CallTemplate management,\n * tool execution, search capabilities, and variable handling. This interface\n * allows for different client implementations while maintaining consistency.\n */\nexport class UtcpClient implements IUtcpClient {\n  private _registeredCommProtocols: Map<string, CommunicationProtocol> = new Map();\n  public readonly postProcessors: ToolPostProcessor[];\n\n  protected constructor(\n    public readonly config: UtcpClientConfig,\n    public readonly variableSubstitutor: VariableSubstitutor,\n    public readonly root_dir: string | null = null,\n  ) {\n    // Dynamically populate registered protocols from the global registry\n    for (const [type, protocol] of Object.entries(CommunicationProtocol.communicationProtocols)) {\n      this._registeredCommProtocols.set(type, protocol);\n    }\n    // Instantiate post-processors dynamically based on registered factories\n    this.postProcessors = config.post_processing.map(ppConfig => {\n      const serializer = new ToolPostProcessorConfigSerializer();\n      return serializer.validateDict(ppConfig as any) as ToolPostProcessor;\n    });\n  }\n\n  /**\n   * REQUIRED\n   * Create a new instance of UtcpClient.\n   * \n   * @param root_dir The root directory for the client to resolve relative paths from. Defaults to the current working directory.\n   * @param config The configuration for the client. Can be a path to a configuration file, a dictionary, or UtcpClientConfig object.\n   * @returns A new instance of UtcpClient.\n   */\n  public static async create(\n    root_dir: string = process.cwd(),\n    config: UtcpClientConfig | null = null\n  ): Promise<UtcpClient> {\n    // Ensure core plugins are initialized before parsing config\n    ensureCorePluginsInitialized();\n\n    let loadedConfig: Partial<UtcpClientConfig>;\n    if (config === null) {\n        loadedConfig = new UtcpClientConfigSerializer().validateDict({});\n    } else {\n        loadedConfig = config;\n    }\n\n    const validatedConfig = UtcpClientConfigSchema.parse(loadedConfig);\n\n    // Dynamically instantiate ConcurrentToolRepository\n    const repoSerializer = new ConcurrentToolRepositoryConfigSerializer();\n    const concurrentToolRepository = repoSerializer.validateDict(validatedConfig.tool_repository as any) as ConcurrentToolRepository;\n\n    // Dynamically instantiate ToolSearchStrategy\n    const searchStrategySerializer = new ToolSearchStrategyConfigSerializer();\n    const searchStrategy = searchStrategySerializer.validateDict(validatedConfig.tool_search_strategy as any) as ToolSearchStrategy;\n\n    const variableSubstitutor = new DefaultVariableSubstitutor();\n\n    const client = new UtcpClient(\n      validatedConfig,\n      variableSubstitutor,\n      root_dir\n    );\n    const tempConfigWithoutOwnVars: UtcpClientConfig = { ...client.config, variables: {} };\n    client.config.variables = await client.variableSubstitutor.substitute(client.config.variables, tempConfigWithoutOwnVars);\n\n    // Register initial manuals specified in the config\n    await client.registerManuals(client.config.manual_call_templates || []);\n\n    return client;\n  }\n\n    /**\n   * Retrieves a tool by its full namespaced name.\n   * @param toolName The full namespaced name of the tool to retrieve.\n   * @returns A Promise resolving to the tool if found, otherwise undefined.\n   */\n    public async getTool(toolName: string): Promise<Tool | undefined> {\n      return this.config.tool_repository.getTool(toolName);\n    }\n  \n    /**\n     * Retrieves all tools from the repository.\n     * @returns A Promise resolving to a list of all registered tools.\n     */\n    public async getTools(): Promise<Tool[]> {\n      return this.config.tool_repository.getTools();\n    }\n\n  /**\n   * Registers a single tool manual.\n   * @param manualCallTemplate The call template describing how to discover and connect to the manual.\n   * @returns A promise that resolves to a result object indicating success or failure.\n   */\n  public async registerManual(manualCallTemplate: CallTemplate): Promise<RegisterManualResult> {\n    if (!manualCallTemplate.name) {\n      manualCallTemplate.name = crypto.randomUUID();\n    }\n    manualCallTemplate.name = manualCallTemplate.name.replace(/[^\\w]/g, '_');\n\n    if (await this.config.tool_repository.getManual(manualCallTemplate.name)) {\n      throw new Error(`Manual '${manualCallTemplate.name}' already registered. Please use a different name or deregister the existing manual.`);\n    }\n\n    const processedCallTemplate = await this.substituteCallTemplateVariables(manualCallTemplate, manualCallTemplate.name);\n\n    const protocol = this._registeredCommProtocols.get(processedCallTemplate.call_template_type);\n    if (!protocol) {\n      throw new Error(`No communication protocol registered for type: '${processedCallTemplate.call_template_type}'`);\n    }\n\n    const result = await protocol.registerManual(this, processedCallTemplate);\n\n    if (result.success) {\n      // Determine allowed protocols: use explicit list if provided, otherwise default to manual's own protocol\n      const allowedProtocols = (processedCallTemplate.allowed_communication_protocols?.length)\n        ? processedCallTemplate.allowed_communication_protocols\n        : [processedCallTemplate.call_template_type];\n\n      // Filter tools based on allowed protocols and prefix names\n      const filteredTools = [];\n      for (const tool of result.manual.tools) {\n        const toolProtocol = tool.tool_call_template.call_template_type;\n        if (!allowedProtocols.includes(toolProtocol)) {\n          console.warn(`Tool '${tool.name}' uses communication protocol '${toolProtocol}' which is not in allowed protocols [${allowedProtocols.map(p => `'${p}'`).join(', ')}] for manual '${manualCallTemplate.name}'. Tool will not be registered.`);\n          continue;\n        }\n        if (!tool.name.startsWith(`${processedCallTemplate.name}.`)) {\n          tool.name = `${processedCallTemplate.name}.${tool.name}`;\n        }\n        filteredTools.push(tool);\n      }\n      result.manual.tools = filteredTools;\n\n      await this.config.tool_repository.saveManual(processedCallTemplate, result.manual);\n      console.log(`Successfully registered manual '${manualCallTemplate.name}' with ${result.manual.tools.length} tools.`);\n    } else {\n      console.error(`Error registering manual '${manualCallTemplate.name}': ${result.errors.join(', ')}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Registers a list of tool manuals in parallel.\n   * @param manualCallTemplates An array of call templates to register.\n   * @returns A promise that resolves to an array of registration results.\n   */\n  public async registerManuals(manualCallTemplates: CallTemplate[]): Promise<RegisterManualResult[]> {\n    const registrationPromises = manualCallTemplates.map(async (template) => {\n      try {\n        return await this.registerManual(template);\n      } catch (error: any) {\n        console.error(`Error during batch registration for manual '${template.name}':`, error.message);\n        return {\n          manualCallTemplate: template,\n          manual: UtcpManualSchema.parse({ tools: [] }),\n          success: false,\n          errors: [error.message],\n        };\n      }\n    });\n    return Promise.all(registrationPromises);\n  }\n\n  /**\n   * Deregisters a tool manual and all of its associated tools.\n   * @param manualName The name of the manual to deregister.\n   * @returns A promise that resolves to true if the manual was found and removed, otherwise false.\n   */\n  public async deregisterManual(manualName: string): Promise<boolean> {\n    const manualCallTemplate = await this.config.tool_repository.getManualCallTemplate(manualName);\n    if (!manualCallTemplate) {\n      console.warn(`Manual '${manualName}' not found for deregistration.`);\n      return false;\n    }\n\n    const protocol = this._registeredCommProtocols.get(manualCallTemplate.call_template_type);\n    if (protocol) {\n      await protocol.deregisterManual(this, manualCallTemplate);\n      console.log(`Deregistered communication protocol for manual '${manualName}'.`);\n    } else {\n      console.warn(`No communication protocol found for type '${manualCallTemplate.call_template_type}' of manual '${manualName}'.`);\n    }\n\n    const removed = await this.config.tool_repository.removeManual(manualName);\n    if (removed) {\n      console.log(`Successfully deregistered manual '${manualName}' from repository.`);\n    } else {\n      console.warn(`Manual '${manualName}' was not found in the repository during deregistration.`);\n    }\n    return removed;\n  }\n\n  /**\n   * Calls a registered tool by its full namespaced name.\n   * @param toolName The full name of the tool (e.g., 'my_manual.my_tool').\n   * @param toolArgs A JSON object of arguments for the tool call.\n   * @returns A promise that resolves to the result of the tool call, with post-processing applied.\n   */\n  public async callTool(toolName: string, toolArgs: Record<string, any>): Promise<any> {\n    const manualName = toolName.split('.')[0];\n    if (!manualName) {\n      throw new Error(`Invalid tool name format for '${toolName}'. Expected 'manual_name.tool_name'.`);\n    }\n\n    const tool = await this.config.tool_repository.getTool(toolName);\n    if (!tool) {\n      throw new Error(`Tool '${toolName}' not found in the repository.`);\n    }\n    const manualCallTemplate = await this.config.tool_repository.getManualCallTemplate(manualName);\n    if (!manualCallTemplate) {\n        throw new Error(`Could not find manual call template for manual '${manualName}'.`);\n    }\n\n    // Validate protocol is allowed\n    const toolProtocol = tool.tool_call_template.call_template_type;\n    const allowedProtocols = (manualCallTemplate.allowed_communication_protocols?.length)\n      ? manualCallTemplate.allowed_communication_protocols\n      : [manualCallTemplate.call_template_type];\n    \n    if (!allowedProtocols.includes(toolProtocol)) {\n      throw new Error(`Tool '${toolName}' uses communication protocol '${toolProtocol}' which is not allowed by manual '${manualName}'. Allowed protocols: [${allowedProtocols.map(p => `'${p}'`).join(', ')}]`);\n    }\n\n    const processedToolCallTemplate = await this.substituteCallTemplateVariables(tool.tool_call_template, manualName);\n\n    const protocol = this._registeredCommProtocols.get(processedToolCallTemplate.call_template_type);\n    if (!protocol) {\n      throw new Error(`No communication protocol registered for type: '${processedToolCallTemplate.call_template_type}'.`);\n    }\n\n    console.log(`Calling tool '${toolName}' via protocol '${processedToolCallTemplate.call_template_type}'.`);\n    let result = await protocol.callTool(this, toolName, toolArgs, processedToolCallTemplate);\n    \n    // Apply post-processors\n    for (const processor of this.postProcessors) {\n        result = processor.postProcess(this, tool, manualCallTemplate, result);\n    }\n    \n    return result;\n  }\n\n  /**\n   * Calls a registered tool and streams the results.\n   * @param toolName The full name of the tool (e.g., 'my_manual.my_tool').\n   * @param toolArgs A JSON object of arguments for the tool call.\n   * @returns An async generator that yields chunks of the tool's response, with post-processing applied to each chunk.\n   */\n  public async *callToolStreaming(toolName: string, toolArgs: Record<string, any>): AsyncGenerator<any, void, unknown> {\n    const manualName = toolName.split('.')[0];\n    if (!manualName) {\n      throw new Error(`Invalid tool name format for '${toolName}'. Expected 'manual_name.tool_name'.`);\n    }\n\n    const tool = await this.config.tool_repository.getTool(toolName);\n    if (!tool) {\n      throw new Error(`Tool '${toolName}' not found in the repository.`);\n    }\n    const manualCallTemplate = await this.config.tool_repository.getManualCallTemplate(manualName);\n    if (!manualCallTemplate) {\n        throw new Error(`Could not find manual call template for manual '${manualName}'.`);\n    }\n\n    // Validate protocol is allowed\n    const toolProtocol = tool.tool_call_template.call_template_type;\n    const allowedProtocols = (manualCallTemplate.allowed_communication_protocols?.length)\n      ? manualCallTemplate.allowed_communication_protocols\n      : [manualCallTemplate.call_template_type];\n    \n    if (!allowedProtocols.includes(toolProtocol)) {\n      throw new Error(`Tool '${toolName}' uses communication protocol '${toolProtocol}' which is not allowed by manual '${manualName}'. Allowed protocols: [${allowedProtocols.map(p => `'${p}'`).join(', ')}]`);\n    }\n\n    const processedToolCallTemplate = await this.substituteCallTemplateVariables(tool.tool_call_template, manualName);\n\n    const protocol = this._registeredCommProtocols.get(processedToolCallTemplate.call_template_type);\n    if (!protocol) {\n      throw new Error(`No communication protocol registered for type: '${processedToolCallTemplate.call_template_type}'.`);\n    }\n\n    console.log(`Calling tool '${toolName}' streamingly via protocol '${processedToolCallTemplate.call_template_type}'.`);\n    for await (let chunk of protocol.callToolStreaming(this, toolName, toolArgs, processedToolCallTemplate)) {\n      // Apply post-processors to each chunk\n      for (const processor of this.postProcessors) {\n        chunk = processor.postProcess(this, tool, manualCallTemplate, chunk);\n      }\n      yield chunk;\n    }\n  }\n\n  /**\n   * Searches for relevant tools based on a task description.\n   * @param query A natural language description of the task.\n   * @param limit The maximum number of tools to return.\n   * @param anyOfTagsRequired An optional list of tags, where at least one must be present on a tool for it to be included.\n   * @returns A promise that resolves to a list of relevant `Tool` objects.\n   */\n  public async searchTools(query: string, limit?: number, anyOfTagsRequired?: string[]): Promise<Tool[]> {\n    console.log(`Searching for tools with query: '${query}'`);\n    return this.config.tool_search_strategy.searchTools(this.config.tool_repository, query, limit, anyOfTagsRequired);\n  }\n\n  /**\n   * Gets the required variables for a manual CallTemplate and its tools.\n   *\n   * @param manualCallTemplate The manual CallTemplate.\n   * @returns A list of required variables for the manual CallTemplate and its tools.\n   */\n    public async getRequiredVariablesForManualAndTools(manualCallTemplate: CallTemplate): Promise<string[]> {\n      const rawCallTemplate = manualCallTemplate as any;\n      return this.variableSubstitutor.findRequiredVariables(rawCallTemplate, manualCallTemplate.name);\n    }\n\n  /**\n   * Gets the required variables for a registered tool.\n   *\n   * @param toolName The name of a registered tool.\n   * @returns A list of required variables for the tool.\n   */\n  public async getRequiredVariablesForRegisteredTool(toolName: string): Promise<string[]> {\n    const manualName = toolName.split('.')[0];\n    if (!manualName) {\n      throw new Error(`Invalid tool name format for '${toolName}'. Expected 'manual_name.tool_name'.`);\n    }\n\n    const tool = await this.config.tool_repository.getTool(toolName);\n    if (!tool) {\n      throw new Error(`Tool '${toolName}' not found in the repository.`);\n    }\n\n    return this.variableSubstitutor.findRequiredVariables(tool.tool_call_template, manualName);\n  }\n\n  /**\n   * Substitutes variables in a given call template.\n   * @param callTemplate The call template to process.\n   * @param namespace An optional namespace for variable lookup.\n   * @returns A new call template instance with all variables substituted.\n   */\n  public async substituteCallTemplateVariables<T extends CallTemplate>(callTemplate: T, namespace?: string): Promise<T> {\n    // Use the variable substitutor to handle the replacement logic\n    const rawSubstituted = await this.variableSubstitutor.substitute(callTemplate, this.config, namespace);\n\n    const result = CallTemplateSchema.safeParse(rawSubstituted);\n\n    if (!result.success) {\n      console.error(`Zod validation failed for call template '${callTemplate.name}' after variable substitution.`, result.error.issues);\n      throw new Error(`Invalid call template after variable substitution: ${result.error.message}`);\n    }\n\n    return result.data as T;\n  }\n\n  /**\n   * Closes the UTCP client and releases any resources held by its communication protocols.\n   */\n  public async close(): Promise<void> {\n    const closePromises: Promise<void>[] = [];\n    for (const protocol of this._registeredCommProtocols.values()) {\n      if (typeof protocol.close === 'function') {\n        closePromises.push(protocol.close());\n      }\n    }\n    await Promise.all(closePromises);\n    console.log('UTCP Client and all registered protocols closed.');\n  }\n}",
      "line_count": 394,
      "word_count": 1718,
      "title": "Utcp Client.Ts",
      "summary": "// packages/core/src/client/utcp_client.ts import { CallTemplate, CallTemplateSchema } from '../data/call_template';",
      "key_terms": [
        "close",
        "const",
        "packages",
        "Closes",
        "Record",
        "list",
        "processedCallTemplate",
        "during",
        "callTemplate",
        "Instantiate",
        "yield",
        "global",
        "associated",
        "describing",
        "toolName",
        "dynamically",
        "protected",
        "if",
        "that",
        "interface"
      ],
      "timestamp": "2025-12-24T18:56:17.434822"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\client\\utcp_client_config.ts",
      "content_type": "code",
      "content": "// packages/core/src/client/utcp_client_config.ts\nimport { z } from 'zod';\nimport { ensureCorePluginsInitialized } from '../plugins/plugin_loader';\nimport { CallTemplate, CallTemplateSchema, CallTemplateSerializer } from '../data/call_template';\nimport { ToolSearchStrategy, ToolSearchStrategyConfigSerializer } from '../interfaces/tool_search_strategy';\nimport { VariableLoader, VariableLoaderSchema, VariableLoaderSerializer } from '../data/variable_loader';\nimport { ConcurrentToolRepository, ConcurrentToolRepositoryConfigSerializer } from '../interfaces/concurrent_tool_repository';\nimport { ToolPostProcessor, ToolPostProcessorConfigSerializer } from '../interfaces/tool_post_processor';\nimport { Serializer } from '../interfaces/serializer';\n\n// Ensure core plugins are initialized before this module uses any serializers\nensureCorePluginsInitialized();\n\n/**\n * REQUIRED\n * Configuration model for UTCP client setup.\n *\n * Provides comprehensive configuration options for UTCP clients including\n * variable definitions, provider file locations, and variable loading\n * mechanisms. Supports hierarchical variable resolution with multiple\n * sources.\n *\n * Variable Resolution Order:\n *     1. Direct variables dictionary\n *     2. Custom variable loaders (in order)\n *     3. Environment variables\n *\n * Attributes:\n *     variables: A dictionary of directly-defined\n *         variables for substitution.\n *     load_variables_from: A list of\n *         variable loader configurations for loading variables from external\n *         sources like .env files or remote services.\n *     tool_repository: Configuration for the tool\n *         repository, which manages the storage and retrieval of tools.\n *         Defaults to an in-memory repository.\n *     tool_search_strategy: Configuration for the tool\n *         search strategy, defining how tools are looked up. Defaults to a\n *         tag and description-based search.\n *     post_processing: A list of tool post-processor\n *         configurations to be applied after a tool call.\n *     manual_call_templates: A list of manually defined\n *         call templates for registering tools that don't have a provider.\n *\n * Example:\n *     ```typescript\n *     const config: UtcpClientConfig = {\n *         variables: {\"MANUAL__NAME_API_KEY_NAME\": \"$REMAPPED_API_KEY\"},\n *         load_variables_from: [\n *             new VariableLoaderSerializer().validateDict({\"variable_loader_type\": \"dotenv\", \"env_file_path\": \".env\"})\n *         ],\n *         tool_repository: new ConcurrentToolRepositoryConfigSerializer().validateDict({\n *             \"tool_repository_type\": \"in_memory\"\n *         }),\n *         tool_search_strategy: new ToolSearchStrategyConfigSerializer().validateDict({\n *             \"tool_search_strategy_type\": \"tag_and_description_word_match\"\n *         }),\n *         post_processing: [],\n *         manual_call_templates: []\n *     };\n *     ```\n */\nexport interface UtcpClientConfig {\n  /**\n   * A dictionary of directly-defined variables for substitution.\n   */\n  variables: Record<string, string>;\n\n  /**\n   * A list of variable loader configurations for loading variables from external\n   * sources like .env files. Loaders are processed in order.\n   */\n  load_variables_from: VariableLoader[] | null;\n\n  /**\n   * Configuration for the tool repository.\n   * Defaults to an in-memory repository.\n   */\n  tool_repository: ConcurrentToolRepository;\n\n  /**\n   * Configuration for the tool search strategy.\n   * Defaults to a tag and description-based search.\n   */\n  tool_search_strategy: ToolSearchStrategy;\n\n  /**\n   * A list of tool post-processor configurations to be applied after a tool call.\n   */\n  post_processing: ToolPostProcessor[];\n\n  /**\n   * A list of manually defined call templates for registering tools at client initialization.\n   */\n  manual_call_templates: CallTemplate[];\n}\n\n/**\n * The main configuration schema for the UTCP client.\n */\nexport const UtcpClientConfigSchema = z.object({\n  variables: z.record(z.string(), z.string()).optional().default({}),\n  \n  load_variables_from: z.array(VariableLoaderSchema).nullable().optional().default(null)\n    .transform((val) => {\n      if (val === null) return null;\n      return val.map(item => {\n        if ('variable_loader_type' in item) {\n          return new VariableLoaderSerializer().validateDict(item as Record<string, unknown>);\n        }\n        return item as VariableLoader;\n      });\n    }),\n  \n  tool_repository: z.any()\n    .transform((val) => {\n      if (typeof val === 'object' && val !== null && 'tool_repository_type' in val) {\n        return new ConcurrentToolRepositoryConfigSerializer().validateDict(val as Record<string, unknown>);\n      }\n      return val as ConcurrentToolRepository;\n    })\n    .optional()\n    .default(new ConcurrentToolRepositoryConfigSerializer().validateDict({\n      tool_repository_type: ConcurrentToolRepositoryConfigSerializer.default_strategy,\n    })),\n\n  tool_search_strategy: z.any()\n    .transform((val) => {\n      if (typeof val === 'object' && val !== null && 'tool_search_strategy_type' in val) {\n        return new ToolSearchStrategyConfigSerializer().validateDict(val as Record<string, unknown>);\n      }\n      return val as ToolSearchStrategy;\n    })\n    .optional()\n    .default(new ToolSearchStrategyConfigSerializer().validateDict({\n      tool_search_strategy_type: ToolSearchStrategyConfigSerializer.default_strategy,\n    })),\n\n  post_processing: z.array(z.any())\n    .transform((val) => {\n      return val.map(item => {\n        if (typeof item === 'object' && item !== null && 'tool_post_processor_type' in item) {\n          return new ToolPostProcessorConfigSerializer().validateDict(item as Record<string, unknown>);\n        }\n        return item as ToolPostProcessor;\n      });\n    })\n    .optional()\n    .default([]),\n\n  manual_call_templates: z.array(CallTemplateSchema)\n    .transform((val) => {\n      return val.map(item => {\n        if (typeof item === 'object' && item !== null && 'call_template_type' in item) {\n          return new CallTemplateSerializer().validateDict(item as Record<string, unknown>);\n        }\n        return item as CallTemplate;\n      });\n    })\n    .optional()\n    .default([]),\n}).strict();\n\n/**\n * REQUIRED\n * Serializer for UTCP client configurations.\n *\n * Defines the contract for serializers that convert UTCP client configurations to and from\n * dictionaries for storage or transmission. Serializers are responsible for:\n * - Converting UTCP client configurations to dictionaries for storage or transmission\n * - Converting dictionaries back to UTCP client configurations\n * - Ensuring data consistency during serialization and deserialization\n */\nexport class UtcpClientConfigSerializer extends Serializer<UtcpClientConfig> {\n  /**\n   * REQUIRED\n   * Convert a UtcpClientConfig object to a dictionary.\n   *\n   * @param obj The UtcpClientConfig object to convert.\n   * @returns The dictionary converted from the UtcpClientConfig object.\n   */\n  toDict(obj: UtcpClientConfig): Record<string, unknown> {\n    return {\n      variables: obj.variables,\n      load_variables_from: obj.load_variables_from === null ? null : \n        obj.load_variables_from?.map(item => new VariableLoaderSerializer().toDict(item)),\n      tool_repository: new ConcurrentToolRepositoryConfigSerializer().toDict(obj.tool_repository),\n      tool_search_strategy: new ToolSearchStrategyConfigSerializer().toDict(obj.tool_search_strategy),\n      post_processing: obj.post_processing.map(item => new ToolPostProcessorConfigSerializer().toDict(item)),\n      manual_call_templates: obj.manual_call_templates.map(item => new CallTemplateSerializer().toDict(item)),\n    };\n  }\n  \n  /**\n   * REQUIRED\n   * Validate a dictionary and convert it to a UtcpClientConfig object.\n   *\n   * @param data The dictionary to validate and convert.\n   * @returns The UtcpClientConfig object converted from the dictionary.\n   * @throws Error if validation fails\n   */\n  validateDict(data: Record<string, unknown>): UtcpClientConfig {\n    try {\n      return UtcpClientConfigSchema.parse(data) as UtcpClientConfig;\n    } catch (e: any) {\n      throw new Error(`Invalid UtcpClientConfig: ${e.message}\\n${e.stack || ''}`);\n    }\n  }\n}",
      "line_count": 209,
      "word_count": 824,
      "title": "Utcp Client Config.Ts",
      "summary": "// packages/core/src/client/utcp_client_config.ts import { z } from 'zod';",
      "key_terms": [
        "nullable",
        "resolution",
        "comprehensive",
        "null",
        "const",
        "up",
        "packages",
        "REQUIRED",
        "search",
        "convert",
        "record",
        "based",
        "Record",
        "list",
        "uses",
        "Utcp",
        "during",
        "loaders",
        "unknown",
        "ConcurrentToolRepository"
      ],
      "timestamp": "2025-12-24T18:56:17.466750"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\data\\auth.ts",
      "content_type": "code",
      "content": "// packages/core/src/data/auth.ts\nimport { z } from 'zod';\nimport { Serializer } from '../interfaces/serializer';\n\nexport interface Auth {\n  /** Authentication type identifier */\n  auth_type: string;\n}\n\nexport class AuthSerializer extends Serializer<Auth> {\n  private static serializers: Record<string, Serializer<Auth>> = {};\n\n  // No need for the whole plugin registry. Plugins just need to call this to register a new auth type\n  static registerAuth(\n    authType: string,\n    serializer: Serializer<Auth>,\n    override = false\n  ): boolean {\n    if (!override && AuthSerializer.serializers[authType]) {\n      return false;\n    }\n    AuthSerializer.serializers[authType] = serializer;\n    return true;\n  }\n\n  toDict(obj: Auth): Record<string, unknown> {\n    const serializer = AuthSerializer.serializers[obj.auth_type];\n    if (!serializer) {\n      throw new Error(`No serializer found for auth_type: ${obj.auth_type}`);\n    }\n    return serializer.toDict(obj);\n  }\n\n  validateDict(obj: Record<string, unknown>): Auth {\n    const serializer = AuthSerializer.serializers[obj.auth_type as string];\n    if (!serializer) {\n      throw new Error(`Invalid auth_type: ${obj.auth_type}`);\n    }\n    return serializer.validateDict(obj);\n  }\n}\n\nexport const AuthSchema = z\n  .custom<Auth>((obj) => {\n    try {\n      // Use the centralized serializer to validate & return the correct subtype\n      const validated = new AuthSerializer().validateDict(obj as Record<string, unknown>);\n      return validated;\n    } catch (e) {\n      return false; // z.custom treats false as validation failure\n    }\n  }, {\n    message: \"Invalid Auth object\",\n  });",
      "line_count": 54,
      "word_count": 186,
      "title": "Auth.Ts",
      "summary": "// packages/core/src/data/auth.ts import { z } from 'zod';",
      "key_terms": [
        "from",
        "const",
        "packages",
        "serializer",
        "toDict",
        "static",
        "just",
        "Record",
        "extends",
        "Authentication",
        "zod",
        "as",
        "auth",
        "message",
        "unknown",
        "type",
        "private",
        "register",
        "try",
        "boolean"
      ],
      "timestamp": "2025-12-24T18:56:17.514770"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\data\\call_template.ts",
      "content_type": "code",
      "content": "// packages/core/src/data/call_template.ts\nimport { z } from 'zod';\nimport { Auth, AuthSchema } from './auth';\nimport { Serializer } from '../interfaces/serializer';\n\n/**\n * Base interface for all CallTemplates. Each protocol plugin will implement this structure.\n * It provides the common fields every call template must have.\n */\nexport interface CallTemplate {\n  /**\n   * Unique identifier for the CallTemplate/Manual. Recommended to be a human-readable name.\n   */\n  name?: string;\n\n  /**\n   * The transport protocol type used by this call template (e.g., 'http', 'mcp', 'text').\n   */\n  call_template_type: string;\n\n  /**\n   * Optional authentication configuration for the provider.\n   */\n  auth?: Auth;\n\n  /**\n   * Optional list of allowed communication protocol types for tools within this manual.\n   * \n   * Behavior:\n   * - If undefined, null, or empty array → defaults to only allowing the manual's own call_template_type\n   * - If set to a non-empty array → only those protocol types are allowed\n   * \n   * This provides secure-by-default behavior where a manual can only register/call tools\n   * that use its own protocol unless explicitly configured otherwise.\n   */\n  allowed_communication_protocols?: string[];\n\n  [key: string]: any;\n}\n\nexport class CallTemplateSerializer extends Serializer<CallTemplate> {\n  private static serializers: Record<string, Serializer<CallTemplate>> = {};\n\n  // No need for the whole plugin registry. Plugins just need to call this to register a new call template type\n  static registerCallTemplate(\n    callTemplateType: string,\n    serializer: Serializer<CallTemplate>,\n    override = false\n  ): boolean {\n    if (!override && CallTemplateSerializer.serializers[callTemplateType]) {\n      return false;\n    }\n    CallTemplateSerializer.serializers[callTemplateType] = serializer;\n    return true;\n  }\n\n  toDict(obj: CallTemplate): Record<string, unknown> {\n    const serializer = CallTemplateSerializer.serializers[obj.call_template_type];\n    if (!serializer) {\n      throw new Error(`No serializer found for call_template_type: ${obj.call_template_type}`);\n    }\n    return serializer.toDict(obj);\n  }\n\n  validateDict(obj: Record<string, unknown>): CallTemplate {\n    const serializer = CallTemplateSerializer.serializers[obj.call_template_type as string];\n    if (!serializer) {\n      throw new Error(`Invalid call_template_type: ${obj.call_template_type}`);\n    }\n    return serializer.validateDict(obj);\n  }\n}\n\nexport const CallTemplateSchema = z\n  .custom<CallTemplate>((obj) => {\n    try {\n      // Use the centralized serializer to validate & return the correct subtype\n      const validated = new CallTemplateSerializer().validateDict(obj as Record<string, unknown>);\n      return validated;\n    } catch (e) {\n      return false; // z.custom treats false as validation failure\n    }\n  }, {\n    message: \"Invalid CallTemplate object\",\n  });",
      "line_count": 85,
      "word_count": 336,
      "title": "Call Template.Ts",
      "summary": "// packages/core/src/data/call_template.ts import { z } from 'zod';",
      "key_terms": [
        "null",
        "const",
        "packages",
        "If",
        "Record",
        "list",
        "Recommended",
        "unknown",
        "only",
        "private",
        "It",
        "must",
        "found",
        "string",
        "Error",
        "identifier",
        "human",
        "validateDict",
        "if",
        "that"
      ],
      "timestamp": "2025-12-24T18:56:17.546807"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\data\\register_manual_result.ts",
      "content_type": "code",
      "content": "// packages/core/src/data/register_manual_result.ts\nimport { CallTemplate } from './call_template';\nimport { UtcpManual } from './utcp_manual';\n\n/**\n * Result of a manual registration operation.\n */\nexport interface RegisterManualResult {\n  manualCallTemplate: CallTemplate;\n  manual: UtcpManual;\n  success: boolean;\n  errors: string[];\n}",
      "line_count": 13,
      "word_count": 36,
      "title": "Register Manual Result.Ts",
      "summary": "// packages/core/src/data/register_manual_result.ts import { CallTemplate } from './call_template';",
      "key_terms": [
        "from",
        "Result",
        "packages",
        "utcp",
        "Utcp",
        "boolean",
        "ts",
        "string",
        "core",
        "success",
        "RegisterManualResult",
        "of",
        "interface",
        "manual",
        "import",
        "export",
        "CallTemplate",
        "registration",
        "UtcpManual",
        "manualCallTemplate"
      ],
      "timestamp": "2025-12-24T18:56:17.578962"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\data\\tool.ts",
      "content_type": "code",
      "content": "// packages/core/src/data/tool.ts\nimport { z } from 'zod';\nimport { CallTemplate, CallTemplateSchema } from './call_template';\nimport { Serializer } from '../interfaces/serializer';\n\n// Define a recursive type for basic JSON values\n/**\n * A recursive type representing any valid JSON value: string, number, boolean, null, object, or array.\n */\ntype JsonValue = string | number | boolean | null | { [key: string]: JsonValue } | JsonValue[];\n\n// --- JSON Schema Typing and Validation ---\n\n/**\n * Zod type for basic JSON primitive or recursive structure.\n */\nexport const JsonTypeSchema: z.ZodType<JsonValue> = z.lazy(() => z.union([\n  z.string(),\n  z.number(),\n  z.boolean(),\n  z.null(),\n  z.record(z.string(), JsonTypeSchema),\n  z.array(JsonTypeSchema),\n]));\nexport type JsonType = z.infer<typeof JsonTypeSchema>;\n\n\n/**\n * Interface for a JSON Schema definition (based on draft-07).\n * This defines the structure for tool inputs and outputs.\n */\nexport interface JsonSchema {\n  /**\n   * Optional schema identifier.\n   */\n  $schema?: string;\n  /**\n   * Optional schema identifier.\n   */\n  $id?: string;\n  /**\n   * Optional schema title.\n   */\n  title?: string;\n  /**\n   * Optional schema description.\n   */\n  description?: string;\n  /**\n   * The JSON data type (e.g., 'object', 'string', 'number').\n   */\n  type?: 'string' | 'number' | 'integer' | 'boolean' | 'object' | 'array' | 'null' | string[];\n  /**\n   * Defines properties if type is 'object'.\n   */\n  properties?: { [key: string]: JsonSchema };\n  /**\n   * Defines item structure if type is 'array'.\n   */\n  items?: JsonSchema | JsonSchema[];\n  /**\n   * List of required properties if type is 'object'.\n   */\n  required?: string[];\n  /**\n   * List of allowable values.\n   */\n  enum?: JsonType[];\n  /**\n   * The exact required value.\n   */\n  const?: JsonType;\n  /**\n   * A default value for the property.\n   */\n  default?: JsonType;\n  /**\n   * Optional format hint (e.g., 'date-time', 'email').\n   */\n  format?: string;\n  /**\n   * Allows or specifies schema for additional properties.\n   */\n  additionalProperties?: boolean | JsonSchema;\n  /**\n   * Regex pattern for string validation.\n   */\n  pattern?: string;\n  /**\n   * Minimum numeric value.\n   */\n  minimum?: number;\n  /**\n   * Maximum numeric value.\n   */\n  maximum?: number;\n  /**\n   * Minimum string length.\n   */\n  minLength?: number;\n  /**\n   * Maximum string length.\n   */\n  maxLength?: number;\n  [k: string]: unknown;\n}\n\n\n/**\n * Zod schema corresponding to the JsonSchema interface.\n */\nexport const JsonSchemaSchema: z.ZodType<JsonSchema> = z.lazy(() => z.object({\n  $schema: z.string().optional().describe('JSON Schema version URI.'),\n  $id: z.string().optional().describe('A URI for the schema.'),\n  title: z.string().optional().describe('A short explanation about the purpose of the data described by this schema.'),\n  description: z.string().optional().describe('A more lengthy explanation about the purpose of the data described by this schema.'),\n  type: z.union([\n    z.literal('string'), z.literal('number'), z.literal('integer'), z.literal('boolean'),\n    z.literal('object'), z.literal('array'), z.literal('null'), z.array(z.string())\n  ]).optional(),\n  properties: z.record(z.string(), z.lazy(() => JsonSchemaSchema)).optional(),\n  items: z.union([z.lazy(() => JsonSchemaSchema), z.array(z.lazy(() => JsonSchemaSchema))]).optional(),\n  required: z.array(z.string()).optional(),\n  enum: z.array(JsonTypeSchema).optional(),\n  const: JsonTypeSchema.optional(),\n  default: JsonTypeSchema.optional(),\n  format: z.string().optional(),\n  additionalProperties: z.union([z.boolean(), z.lazy(() => JsonSchemaSchema)]).optional(),\n  pattern: z.string().optional(),\n  minimum: z.number().optional(),\n  maximum: z.number().optional(),\n  minLength: z.number().optional(),\n  maxLength: z.number().optional(),\n}).catchall(z.unknown()));\n\n\n// --- Tool Typing and Validation ---\n\n/**\n * Interface for a UTCP Tool.\n * Represents a callable tool with its metadata, input/output schemas,\n * and associated call template. Tools are the fundamental units of\n * functionality in the UTCP ecosystem.\n */\nexport interface Tool {\n  /**\n   * Unique identifier for the tool, typically in format \"manual_name.tool_name\".\n   */\n  name: string;\n  /**\n   * Human-readable description of what the tool does.\n   */\n  description: string;\n  /**\n   * JSON Schema defining the tool's input parameters.\n   */\n  inputs: JsonSchema;\n  /**\n   * JSON Schema defining the tool's return value structure.\n   */\n  outputs: JsonSchema;\n  /**\n   * List of tags for categorization and search.\n   */\n  tags: string[];\n  /**\n   * Optional hint about typical response size in bytes.\n   */\n  average_response_size?: number;\n  /**\n   * CallTemplate configuration for accessing this tool.\n   */\n  tool_call_template: CallTemplate;\n}\n\n/**\n * Zod schema corresponding to the Tool interface.\n */\nexport const ToolSchema: z.ZodType<Tool> = z.object({\n  name: z.string().describe('Unique identifier for the tool, typically in format \"manual_name.tool_name\".'),\n  description: z.string().default('').describe('Human-readable description of what the tool does.'),\n  inputs: JsonSchemaSchema.default({}).describe('JSON Schema defining the tool\\'s input parameters.'),\n  outputs: JsonSchemaSchema.default({}).describe('JSON Schema defining the tool\\'s return value structure.'),\n  tags: z.array(z.string()).default([]).describe('List of tags for categorization and search.'),\n  average_response_size: z.number().optional().describe('Optional hint about typical response size in bytes.'),\n  tool_call_template: CallTemplateSchema.describe('CallTemplate configuration for accessing this tool.'),\n}).strict() as z.ZodType<Tool>;\n\n/**\n * Serializer for JsonSchema objects.\n * Since JsonSchema is a standard format without subtypes, this is a simple passthrough serializer.\n */\nexport class JsonSchemaSerializer extends Serializer<JsonSchema> {\n  toDict(obj: JsonSchema): Record<string, unknown> {\n    return { ...obj };\n  }\n\n  validateDict(obj: Record<string, unknown>): JsonSchema {\n    return JsonSchemaSchema.parse(obj);\n  }\n}\n\n/**\n * Serializer for Tool objects.\n * Handles serialization and deserialization of complete tool definitions.\n */\nexport class ToolSerializer extends Serializer<Tool> {\n  toDict(obj: Tool): Record<string, unknown> {\n    return {\n      name: obj.name,\n      description: obj.description,\n      inputs: obj.inputs,\n      outputs: obj.outputs,\n      tags: obj.tags,\n      ...(obj.average_response_size !== undefined && { average_response_size: obj.average_response_size }),\n      tool_call_template: obj.tool_call_template,\n    };\n  }\n\n  validateDict(obj: Record<string, unknown>): Tool {\n    return ToolSchema.parse(obj);\n  }\n}",
      "line_count": 223,
      "word_count": 761,
      "title": "Tool.Ts",
      "summary": "// packages/core/src/data/tool.ts import { z } from 'zod';",
      "key_terms": [
        "output",
        "typical",
        "const",
        "null",
        "packages",
        "search",
        "number",
        "JsonTypeSchema",
        "pattern",
        "record",
        "Human-readable",
        "based",
        "Record",
        "ToolSerializer",
        "id",
        "format",
        "corresponding",
        "unknown",
        "associated",
        "string"
      ],
      "timestamp": "2025-12-24T18:56:17.611897"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\data\\utcp_manual.ts",
      "content_type": "code",
      "content": "// packages/core/src/data/utcp_manual.ts\nimport { z } from 'zod';\nimport { ToolSchema, Tool } from './tool';\nimport { Serializer } from '../interfaces/serializer';\nimport { LIB_VERSION } from '../version';\n\n/**\n * The default UTCP protocol version used throughout the library.\n * This is replaced at build time with the actual package version.\n * Use this constant when creating UtcpManual objects to ensure version consistency.\n */\nexport const UTCP_PACKAGE_VERSION = LIB_VERSION;\n\n/**\n * Interface for the standard format for tool provider responses during discovery.\n * Represents the complete set of tools available from a provider, along\n * with version information for compatibility checking.\n */\nexport interface UtcpManual {\n  /**\n   * The UTCP protocol version supported by the provider.\n   */\n  utcp_version: string;\n\n  /**\n   * The version of this specific manual/specification.\n   */\n  manual_version: string;\n\n  /**\n   * List of available tools with their complete configurations.\n   */\n  tools: Tool[];\n}\n\n/**\n * The standard format for tool provider responses during discovery.\n * This schema is used for runtime validation and parsing of UTCP manuals.\n */\nexport const UtcpManualSchema: z.ZodType<UtcpManual> = z.object({\n  // Use .optional() to allow missing in input, then .default() to satisfy the interface.\n  utcp_version: z.string().optional().default(UTCP_PACKAGE_VERSION)\n    .describe('UTCP protocol version supported by the provider.'),\n  manual_version: z.string().optional().default('1.0.0')\n    .describe('Version of this specific manual.'),\n  tools: z.array(ToolSchema)\n    .describe('List of available tools with their complete configurations.'),\n}).strict() as z.ZodType<UtcpManual>;\n\n/**\n * Serializer for UtcpManual objects.\n * Handles serialization and deserialization of complete UTCP manual definitions.\n */\nexport class UtcpManualSerializer extends Serializer<UtcpManual> {\n  toDict(obj: UtcpManual): Record<string, unknown> {\n    return {\n      utcp_version: obj.utcp_version,\n      manual_version: obj.manual_version,\n      tools: obj.tools,\n    };\n  }\n\n  validateDict(obj: Record<string, unknown>): UtcpManual {\n    return UtcpManualSchema.parse(obj);\n  }\n}",
      "line_count": 66,
      "word_count": 264,
      "title": "Utcp Manual.Ts",
      "summary": "// packages/core/src/data/utcp_manual.ts import { z } from 'zod';",
      "key_terms": [
        "build",
        "const",
        "packages",
        "Record",
        "format",
        "Utcp",
        "during",
        "available",
        "unknown",
        "string",
        "satisfy",
        "consistency",
        "version",
        "validateDict",
        "Represents",
        "serialization",
        "interface",
        "UtcpManualSerializer",
        "supported",
        "Version"
      ],
      "timestamp": "2025-12-24T18:56:17.645062"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\data\\variable_loader.ts",
      "content_type": "code",
      "content": "// packages/core/src/data/variable_loader.ts\nimport { z } from 'zod';\nimport { Serializer } from '../interfaces/serializer';\n\n/**\n * Base interface for all VariableLoaders.\n * Variable loaders are responsible for loading configuration variables from external sources.\n */\nexport interface VariableLoader {\n  /**\n   * The type identifier for this variable loader (e.g., 'dotenv').\n   */\n  variable_loader_type: string;\n\n  [key: string]: any;\n\n    /**\n     * Retrieves a variable value by key.\n     * @abstract\n     * @param key Variable name to retrieve.\n     * @returns Variable value if found, None otherwise.\n     */\n    get(key: string): Promise<string | null>;\n}\n\n/**\n * Serializer for VariableLoader objects.\n * Uses a registry pattern to delegate to type-specific serializers.\n */\nexport class VariableLoaderSerializer extends Serializer<VariableLoader> {\n  private static serializers: Record<string, Serializer<VariableLoader>> = {};\n\n  /**\n   * Registers a variable loader serializer for a specific type.\n   * @param type The variable_loader_type identifier\n   * @param serializer The serializer instance for this type\n   * @param override Whether to override an existing registration\n   * @returns true if registration succeeded, false if already exists and override is false\n   */\n  static registerVariableLoader(\n    type: string,\n    serializer: Serializer<VariableLoader>,\n    override = false\n  ): boolean {\n    if (!override && VariableLoaderSerializer.serializers[type]) {\n      return false;\n    }\n    VariableLoaderSerializer.serializers[type] = serializer;\n    return true;\n  }\n\n  toDict(obj: VariableLoader): Record<string, unknown> {\n    const serializer = VariableLoaderSerializer.serializers[obj.variable_loader_type];\n    if (!serializer) {\n      throw new Error(`No serializer found for variable_loader_type: ${obj.variable_loader_type}`);\n    }\n    return serializer.toDict(obj);\n  }\n\n  validateDict(obj: Record<string, unknown>): VariableLoader {\n    const serializer = VariableLoaderSerializer.serializers[obj.variable_loader_type as string];\n    if (!serializer) {\n      throw new Error(`Invalid variable_loader_type: ${obj.variable_loader_type}`);\n    }\n    return serializer.validateDict(obj);\n  }\n}\n\n/**\n * Zod schema for VariableLoader using custom validation.\n */\nexport const VariableLoaderSchema = z\n  .custom<VariableLoader>((obj) => {\n    try {\n      const validated = new VariableLoaderSerializer().validateDict(obj as Record<string, unknown>);\n      return validated;\n    } catch (e) {\n      return false;\n    }\n  }, {\n    message: \"Invalid VariableLoader object\",\n  });\n",
      "line_count": 83,
      "word_count": 285,
      "title": "Variable Loader.Ts",
      "summary": "// packages/core/src/data/variable_loader.ts import { z } from 'zod';",
      "key_terms": [
        "null",
        "const",
        "packages",
        "pattern",
        "Record",
        "VariableLoaders",
        "loaders",
        "unknown",
        "private",
        "found",
        "string",
        "Error",
        "sources",
        "identifier",
        "succeeded",
        "using",
        "validateDict",
        "VariableLoaderSchema",
        "if",
        "interface"
      ],
      "timestamp": "2025-12-24T18:56:17.686142"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\data\\auth_implementations\\api_key_auth.ts",
      "content_type": "code",
      "content": "import { Auth } from \"../auth\";\nimport { Serializer } from \"../../interfaces/serializer\";\nimport { z } from \"zod\";\n\nexport interface ApiKeyAuth extends Auth {\n  auth_type: \"api_key\";\n  api_key: string;\n  var_name: string; // header, query param, etc.\n  location: \"header\" | \"query\" | \"cookie\";\n}\n\nexport class ApiKeyAuthSerializer extends Serializer<ApiKeyAuth> {\n  toDict(obj: ApiKeyAuth): { [key: string]: any } {\n    return { ...obj };\n  }\n\n  validateDict(obj: { [key: string]: any }): ApiKeyAuth {\n    return ApiKeyAuthSchema.parse(obj);\n  }\n}\n  \nconst ApiKeyAuthSchema = z.object({\n  auth_type: z.literal(\"api_key\"),\n  api_key: z.string(),\n  var_name: z.string().default(\"X-Api-Key\"),\n  location: z.enum([\"header\", \"query\", \"cookie\"]).default(\"header\"),\n});",
      "line_count": 27,
      "word_count": 88,
      "title": "Api Key Auth.Ts",
      "summary": "import { Auth } from \"../auth\"; import { Serializer } from \"../../interfaces/serializer\";",
      "key_terms": [
        "from",
        "const",
        "any",
        "serializer",
        "toDict",
        "ApiKeyAuthSchema",
        "etc",
        "zod",
        "extends",
        "parse",
        "cookie",
        "auth",
        "enum",
        "default",
        "obj",
        "string",
        "X-Api",
        "ApiKeyAuthSerializer",
        "Key",
        "validateDict"
      ],
      "timestamp": "2025-12-24T18:56:17.713113"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\data\\auth_implementations\\basic_auth.ts",
      "content_type": "code",
      "content": "// packages/core/src/data/auth.ts\nimport { z } from 'zod';\nimport { Serializer } from '../../interfaces/serializer';\nimport { Auth } from '../auth';\n\n/**\n * Interface for Basic authentication details.\n */\nexport interface BasicAuth extends Auth {\n  auth_type: 'basic';\n  username: string;\n  password: string;\n}\n\nexport class BasicAuthSerializer extends Serializer<BasicAuth> {\n  toDict(obj: BasicAuth): { [key: string]: any } {\n    // Just spread the object since it's already validated\n    return { ...obj };\n  }\n\n  validateDict(obj: { [key: string]: any }): BasicAuth {\n      return BasicAuthSchema.parse(obj);\n  }\n}\n\n/**\n * Authentication using HTTP Basic Authentication.\n * Credentials typically contain variable placeholders for substitution.\n */\nconst BasicAuthSchema: z.ZodType<BasicAuth> = z.object({\n  auth_type: z.literal('basic'),\n  username: z.string().describe('The username for basic authentication. Recommended to use injected variables.'),\n  password: z.string().describe('The password for basic authentication. Recommended to use injected variables.'),\n}).strict() as z.ZodType<BasicAuth>;\n",
      "line_count": 35,
      "word_count": 129,
      "title": "Basic Auth.Ts",
      "summary": "// packages/core/src/data/auth.ts import { z } from 'zod';",
      "key_terms": [
        "from",
        "BasicAuthSerializer",
        "src",
        "const",
        "contain",
        "packages",
        "any",
        "serializer",
        "toDict",
        "variables",
        "Interface",
        "injected",
        "zod",
        "extends",
        "Authentication",
        "as",
        "parse",
        "auth",
        "Recommended",
        "substitution"
      ],
      "timestamp": "2025-12-24T18:56:17.738165"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\data\\auth_implementations\\oauth2_auth.ts",
      "content_type": "code",
      "content": "// packages/core/src/data/auth.ts\nimport { z } from 'zod';\nimport { Serializer } from '../../interfaces/serializer';\nimport { Auth } from '../auth';\n\n/**\n * Interface for OAuth2 authentication details (Client Credentials Flow).\n */\nexport interface OAuth2Auth extends Auth {\n  auth_type: 'oauth2';\n  token_url: string;\n  client_id: string;\n  client_secret: string;\n  scope?: string;\n}\n\nexport class OAuth2AuthSerializer extends Serializer<OAuth2Auth> {\n  toDict(obj: OAuth2Auth): { [key: string]: any } {\n    // Just spread the object since it's already validated\n    return { ...obj };\n  }\n\n  validateDict(obj: { [key: string]: any }): OAuth2Auth {\n      return OAuth2AuthSchema.parse(obj);\n  }\n}\n\n/**\n * Authentication using OAuth2 client credentials flow.\n * The client automatically handles token acquisition and refresh.\n */\nconst OAuth2AuthSchema: z.ZodType<OAuth2Auth> = z.object({\n  auth_type: z.literal('oauth2'),\n  token_url: z.string().describe('The URL to fetch the OAuth2 access token from. Recommended to use injected variables.'),\n  client_id: z.string().describe('The OAuth2 client ID. Recommended to use injected variables.'),\n  client_secret: z.string().describe('The OAuth2 client secret. Recommended to use injected variables.'),\n  scope: z.string().optional().describe('Optional scope parameter to limit the access token\\'s permissions.'),\n}).strict() as z.ZodType<OAuth2Auth>;\n",
      "line_count": 39,
      "word_count": 161,
      "title": "Oauth2 Auth.Ts",
      "summary": "// packages/core/src/data/auth.ts import { z } from 'zod';",
      "key_terms": [
        "handles",
        "from",
        "src",
        "refresh",
        "const",
        "any",
        "packages",
        "URL",
        "serializer",
        "toDict",
        "variables",
        "limit",
        "Interface",
        "injected",
        "zod",
        "extends",
        "Authentication",
        "automatically",
        "token",
        "as"
      ],
      "timestamp": "2025-12-24T18:56:17.781915"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\exceptions\\utcp_variable_not_found_error.ts",
      "content_type": "code",
      "content": "export class UtcpVariableNotFoundError extends Error {\n  public variableName: string;\n\n  /**\n   * Initializes the exception with the missing variable name.\n   * \n   * @param variableName The name of the variable that could not be found.\n   */\n  constructor(variableName: string) {\n    super(\n      `Variable '${variableName}' referenced in call template configuration not found. ` +\n      `Please ensure it's defined in client.config.variables, environment variables, or a configured variable loader.`\n    );\n    this.variableName = variableName;\n    this.name = 'UtcpVariableNotFoundError';\n  }\n}",
      "line_count": 17,
      "word_count": 71,
      "title": "Utcp Variable Not Found Error.Ts",
      "summary": "export class UtcpVariableNotFoundError extends Error { public variableName: string;",
      "key_terms": [
        "missing",
        "loader",
        "constructor",
        "variables",
        "config",
        "or",
        "variableName",
        "extends",
        "with",
        "UtcpVariableNotFoundError",
        "Utcp",
        "configuration",
        "it",
        "public",
        "configured",
        "found",
        "string",
        "Error",
        "defined",
        "ensure"
      ],
      "timestamp": "2025-12-24T18:56:17.801796"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\implementations\\default_variable_substitutor.ts",
      "content_type": "code",
      "content": "// packages/core/src/implementations/default_variable_substitutor.ts\nimport { UtcpClientConfig } from '../client/utcp_client_config';\nimport { VariableSubstitutor } from '../interfaces/variable_substitutor';\nimport { UtcpVariableNotFoundError } from '../exceptions/utcp_variable_not_found_error';\n\n/**\n * Default implementation of the VariableSubstitutor interface.\n * Provides a hierarchical variable resolution system that searches for\n * variables in the following order:\n * 1. Configuration variables (exact match from config.variables)\n * 2. Custom variable loaders (in order, from config.load_variables_from)\n * 3. Environment variables (process.env)\n *\n * It supports variable placeholders using ${VAR_NAME} or $VAR_NAME syntax\n * and applies namespacing (e.g., manual__name__VAR_NAME) for isolation,\n * mirroring the Python UTCP SDK's convention.\n */\nexport class DefaultVariableSubstitutor implements VariableSubstitutor {\n\n  /**\n   * Retrieves a variable value from configured sources, respecting namespaces.\n   * \n   * @param key The variable name to look up (without namespace prefix).\n   * @param config The UTCP client configuration.\n   * @param namespace An optional namespace to prepend to the variable name for lookup.\n   * @returns The resolved variable value.\n   * @throws UtcpVariableNotFoundError if the variable cannot be found.\n   */\n  private async _getVariable(key: string, config: UtcpClientConfig, namespace?: string): Promise<string> {\n    // Apply namespacing: namespace.replace(\"_\", \"!\").replace(\"!\", \"__\") + \"_\" + key\n    let effectiveKey = key;\n    if (namespace) {\n      effectiveKey = namespace.replace(/_/g, '!').replace(/!/g, '__') + '_' + key;\n    }\n\n    // --- Search Hierarchy ---\n\n    // 1. Check config.variables (highest precedence)\n    if (config.variables && effectiveKey in config.variables) {\n      return config.variables[effectiveKey];\n    }\n\n    // 2. Check custom variable loaders (in order)\n    if (config.load_variables_from) {\n      for (const varLoader of config.load_variables_from) {\n        const varValue = await varLoader.get(effectiveKey);\n        if (varValue) {\n          return varValue;\n        }\n      }\n    }\n\n    // 3. Check environment variables (lowest precedence)\n    try {\n      const envVar = process.env[effectiveKey];\n      if (envVar) {\n        return envVar;\n      }\n    } catch (e) {\n      // Ignore environment variable access errors\n    }\n\n    throw new UtcpVariableNotFoundError(effectiveKey);\n  }\n\n  /**\n   * Recursively substitutes variables in the given object.\n   * \n   * @param obj The object (can be string, array, or object) containing potential variable references to substitute.\n   * @param config The UTCP client configuration containing variable definitions and loaders.\n   * @param namespace An optional namespace (e.g., manual name) to prefix variable lookups for isolation.\n   * @returns The object with all variable references replaced by their values.\n   * @throws UtcpVariableNotFoundError if a referenced variable cannot be resolved.\n   */\n  public async substitute<T>(obj: T, config: UtcpClientConfig, namespace?: string): Promise<T> {\n    if (namespace && !/^[a-zA-Z0-9_]+$/.test(namespace)) {\n      throw new Error(`Variable namespace '${namespace}' contains invalid characters. Only alphanumeric characters and underscores are allowed.`);\n    }\n\n    if (typeof obj === 'string') {\n      if (obj.includes('$ref')) {\n        return obj;\n      }\n      let currentString: string = obj;\n      const regex = /\\$\\{([a-zA-Z0-9_]+)\\}|\\$([a-zA-Z0-9_]+)/g;\n      let match: RegExpExecArray | null;\n      let lastIndex = 0;\n      const parts: string[] = [];\n\n      regex.lastIndex = 0;\n\n      while ((match = regex.exec(currentString)) !== null) {\n        const varNameInTemplate = match[1] || match[2];\n        const fullMatch = match[0];\n\n        parts.push(currentString.substring(lastIndex, match.index));\n\n        try {\n          const replacement = await this._getVariable(varNameInTemplate, config, namespace);\n          parts.push(replacement);\n        } catch (error: any) {\n          if (error instanceof UtcpVariableNotFoundError) {\n            throw new UtcpVariableNotFoundError(error.variableName);\n          }\n          throw error;\n        }\n\n        lastIndex = match.index + fullMatch.length;\n      }\n      parts.push(currentString.substring(lastIndex));\n\n      return parts.join('') as T;\n    }\n\n    if (Array.isArray(obj)) {\n      return Promise.all(obj.map(item => this.substitute(item, config, namespace))) as Promise<T>;\n    }\n\n    if (obj !== null && typeof obj === 'object') {\n      const newObj: { [key: string]: any } = {};\n      for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          newObj[key] = await this.substitute((obj as any)[key], config, namespace);\n        }\n      }\n      return newObj as T;\n    }\n\n    return obj;\n  }\n\n  /**\n   * Recursively finds all variable references in the given object.\n   *\n   * @param obj The object (can be string, array, or object) to scan for variable references.\n   * @param namespace An optional namespace (e.g., manual name) to prefix variable lookups for isolation.\n   * @returns A list of fully-qualified variable names found in the object.\n   */\n  public findRequiredVariables(obj: any, namespace?: string): string[] {\n    if (namespace && !/^[a-zA-Z0-9_]+$/.test(namespace)) {\n      throw new Error(`Variable namespace '${namespace}' contains invalid characters. Only alphanumeric characters and underscores are allowed.`);\n    }\n\n    const variables: string[] = [];\n    const regex = /\\$\\{([a-zA-Z0-9_]+)\\}|\\$([a-zA-Z0-9_]+)/g;\n\n    if (typeof obj === 'string') {\n      if (obj.includes('$ref')) {\n        return [];\n      }\n\n      let match;\n      while ((match = regex.exec(obj)) !== null) {\n        const varNameInTemplate = match[1] || match[2];\n        \n        // Apply Python SDK's double underscore namespacing:\n        // Replaces underscores in namespace with double underscores, then adds single underscore before variable\n        const effectiveNamespace = namespace ? namespace.replace(/_/g, '__') : undefined;\n        const prefixedVarName = effectiveNamespace ? `${effectiveNamespace}_${varNameInTemplate}` : varNameInTemplate;\n        \n        variables.push(prefixedVarName);\n      }\n    } else if (Array.isArray(obj)) {\n      for (const item of obj) {\n        variables.push(...this.findRequiredVariables(item, namespace));\n      }\n    } else if (obj !== null && typeof obj === 'object') {\n      for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          variables.push(...this.findRequiredVariables(obj[key], namespace));\n        }\n      }\n    }\n\n    return Array.from(new Set(variables));\n  }\n}",
      "line_count": 177,
      "word_count": 751,
      "title": "Default Variable Substitutor.Ts",
      "summary": "// packages/core/src/implementations/default_variable_substitutor.ts import { UtcpClientConfig } from '../client/utcp_client_config';",
      "key_terms": [
        "implementations",
        "double",
        "resolution",
        "null",
        "const",
        "Python",
        "packages",
        "up",
        "isolation",
        "async",
        "error",
        "newObj",
        "list",
        "alphanumeric",
        "index",
        "Utcp",
        "loaders",
        "Apply",
        "private",
        "It"
      ],
      "timestamp": "2025-12-24T18:56:17.850439"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\implementations\\in_mem_concurrent_tool_repository.ts",
      "content_type": "code",
      "content": "// packages/core/src/implementations/in_mem_concurrent_tool_repository.ts\nimport { CallTemplate } from '../data/call_template';\nimport { Tool } from '../data/tool';\nimport { UtcpManual } from '../data/utcp_manual';\nimport { ConcurrentToolRepository } from '../interfaces/concurrent_tool_repository';\nimport { Serializer } from '../interfaces/serializer';\nimport { z } from 'zod';\n\n/**\n * An in-memory implementation of the ConcurrentToolRepository.\n * Stores tools, manuals, and manual call templates in local maps.\n * Uses an `AsyncMutex` to serialize write operations, ensuring data consistency\n * across concurrent asynchronous calls, and returns deep copies to prevent\n * external modification of internal state.\n */\nexport class InMemConcurrentToolRepository implements ConcurrentToolRepository {\n  public readonly tool_repository_type: string = \"in_memory\";\n  private _config: InMemConcurrentToolRepositoryConfig; // Store the config to return in toDict\n\n  private _toolsByName: Map<string, Tool> = new Map();\n  private _manuals: Map<string, UtcpManual> = new Map();\n  private _manualCallTemplates: Map<string, CallTemplate> = new Map();\n  private _writeMutex: AsyncMutex = new AsyncMutex();\n\n  /**\n   * The constructor must accept the config type to match the factory signature, \n   * even if the implementation does not use it.\n   */\n  constructor(config: InMemConcurrentToolRepositoryConfig = { tool_repository_type: 'in_memory' }) {\n    this._config = config;\n    // Intentionally left empty as all state is initialized via field initializers.\n  }\n\n  /**\n   * Converts the repository instance's configuration to a dictionary.\n   */\n    public toDict(): InMemConcurrentToolRepositoryConfig {\n      return this._config;\n  }\n\n  /**\n   * Saves a manual's call template and its associated tools in the repository.\n   * This operation replaces any existing manual with the same name.\n   * @param manualCallTemplate The call template associated with the manual to save.\n   * @param manual The complete UTCP Manual object to save.\n   */\n  public async saveManual(manualCallTemplate: CallTemplate, manual: UtcpManual): Promise<void> {\n    const release = await this._writeMutex.acquire();\n    try {\n      const manualName = manualCallTemplate.name!;\n      const oldManual = this._manuals.get(manualName);\n      if (oldManual) {\n        for (const tool of oldManual.tools) {\n          this._toolsByName.delete(tool.name);\n        }\n      }\n      this._manualCallTemplates.set(manualName, { ...manualCallTemplate });\n      this._manuals.set(manualName, { ...manual, tools: manual.tools.map(t => ({ ...t })) });\n      for (const tool of manual.tools) {\n        this._toolsByName.set(tool.name, { ...tool });\n      }\n    } finally {\n      release();\n    }\n  }\n\n  /**\n   * Removes a manual and its tools from the repository.\n   * @param manualName The name of the manual to remove.\n   * @returns True if the manual was removed, False otherwise.\n   */\n  public async removeManual(manualName: string): Promise<boolean> {\n    const release = await this._writeMutex.acquire();\n    try {\n      const oldManual = this._manuals.get(manualName);\n      if (!oldManual) {\n        return false;\n      }\n\n      for (const tool of oldManual.tools) {\n        this._toolsByName.delete(tool.name);\n      }\n\n      this._manuals.delete(manualName);\n      this._manualCallTemplates.delete(manualName);\n      return true;\n    } finally {\n      release();\n    }\n  }\n\n  /**\n   * Removes a specific tool from the repository.\n   * Note: This also attempts to remove the tool from any associated manual.\n   * @param toolName The full namespaced name of the tool to remove.\n   * @returns True if the tool was removed, False otherwise.\n   */\n  public async removeTool(toolName: string): Promise<boolean> {\n    const release = await this._writeMutex.acquire();\n    try {\n      const toolRemoved = this._toolsByName.delete(toolName);\n      if (!toolRemoved) {\n        return false;\n      }\n\n      const manualName = toolName.split('.')[0];\n      if (manualName) {\n        const manual = this._manuals.get(manualName);\n        if (manual) {\n          manual.tools = manual.tools.filter(t => t.name !== toolName);\n        }\n      }\n      return true;\n    } finally {\n      release();\n    }\n  }\n\n  /**\n   * Retrieves a tool by its full namespaced name.\n   * @param toolName The full namespaced name of the tool to retrieve.\n   * @returns The tool if found, otherwise undefined.\n   */\n  public async getTool(toolName: string): Promise<Tool | undefined> {\n    const tool = this._toolsByName.get(toolName);\n    return tool ? { ...tool } : undefined;\n  }\n\n  /**\n   * Retrieves all tools from the repository.\n   * @returns A list of all registered tools.\n   */\n  public async getTools(): Promise<Tool[]> {\n    return Array.from(this._toolsByName.values()).map(t => ({ ...t }));\n  }\n\n  /**\n   * Retrieves all tools associated with a specific manual.\n   * @param manualName The name of the manual.\n   * @returns A list of tools associated with the manual, or undefined if the manual is not found.\n   */\n  public async getToolsByManual(manualName: string): Promise<Tool[] | undefined> {\n    const manual = this._manuals.get(manualName);\n    return manual ? manual.tools.map(t => ({ ...t })) : undefined;\n  }\n\n  /**\n   * Retrieves a complete UTCP Manual object by its name.\n   * @param manualName The name of the manual to retrieve.\n   * @returns The manual if found, otherwise undefined.\n   */\n  public async getManual(manualName: string): Promise<UtcpManual | undefined> {\n    const manual = this._manuals.get(manualName);\n    return manual ? { ...manual, tools: manual.tools.map(t => ({ ...t })) } : undefined;\n  }\n\n  /**\n   * Retrieves all registered manuals from the repository.\n   * @returns A list of all registered UtcpManual objects.\n   */\n  public async getManuals(): Promise<UtcpManual[]> {\n    return Array.from(this._manuals.values()).map(m => ({ ...m, tools: m.tools.map(t => ({ ...t })) }));\n  }\n\n  /**\n   * Retrieves a manual's CallTemplate by its name.\n   * @param manualCallTemplateName The name of the manual's CallTemplate to retrieve.\n   * @returns The CallTemplate if found, otherwise undefined.\n   */\n  public async getManualCallTemplate(manualCallTemplateName: string): Promise<CallTemplate | undefined> {\n    const template = this._manualCallTemplates.get(manualCallTemplateName);\n    return template ? { ...template } : undefined;\n  }\n\n  /**\n   * Retrieves all registered manual CallTemplates from the repository.\n   * @returns A list of all registered CallTemplateBase objects.\n   */\n  public async getManualCallTemplates(): Promise<CallTemplate[]> {\n    return Array.from(this._manualCallTemplates.values()).map(t => ({ ...t }));\n  }\n}\n\nexport class InMemConcurrentToolRepositorySerializer extends Serializer<InMemConcurrentToolRepository> {\n  toDict(obj: InMemConcurrentToolRepository): { [key: string]: any } {\n    return {\n      tool_repository_type: obj.tool_repository_type\n    }\n  }\n\n  validateDict(data: { [key: string]: any }): InMemConcurrentToolRepository {\n    try {\n      return new InMemConcurrentToolRepository(InMemConcurrentToolRepositoryConfigSchema.parse(data));\n    } catch (e) {\n      if (e instanceof z.ZodError) {\n        throw new Error(`Invalid configuration: ${e.message}`);\n      }\n      throw new Error(\"Unexpected error during validation\");\n    }\n  }\n}\n\n/**\n * A simple asynchronous mutex to serialize write access to shared resources.\n * In a single-threaded JavaScript environment, this primarily ensures that\n * compound asynchronous operations on shared state do not interleave incorrectly.\n */\nclass AsyncMutex {\n  private queue: (() => void)[] = [];\n  private locked: boolean = false;\n\n  /**\n   * Acquires the mutex. If the mutex is already locked, waits until it's released.\n   * @returns A function to call to release the mutex.\n   */\n  async acquire(): Promise<() => void> {\n    if (!this.locked) {\n      this.locked = true;\n      return this._release.bind(this);\n    } else {\n      return new Promise<() => void>(resolve => {\n        this.queue.push(() => {\n          this.locked = true;\n          resolve(this._release.bind(this));\n        });\n      });\n    }\n  }\n\n  /**\n   * Releases the mutex, allowing the next queued operation (if any) to proceed.\n   */\n  private _release(): void {\n    this.locked = false;\n    if (this.queue.length > 0) {\n      const next = this.queue.shift();\n      if (next) {\n        next();\n      }\n    }\n  }\n}\n\n/**\n * Schema for the InMemConcurrentToolRepository configuration.\n */\nconst InMemConcurrentToolRepositoryConfigSchema = z.object({\n  tool_repository_type: z.literal('in_memory'),\n}).passthrough();\n\ntype InMemConcurrentToolRepositoryConfig = z.infer<typeof InMemConcurrentToolRepositoryConfigSchema>;\n",
      "line_count": 252,
      "word_count": 1033,
      "title": "In Mem Concurrent Tool Repository.Ts",
      "summary": "// packages/core/src/implementations/in_mem_concurrent_tool_repository.ts import { CallTemplate } from '../data/call_template';",
      "key_terms": [
        "implementations",
        "const",
        "packages",
        "constructor",
        "async",
        "error",
        "If",
        "list",
        "saveManual",
        "Utcp",
        "signature",
        "manualCallTemplateName",
        "during",
        "same",
        "private",
        "acquire",
        "must",
        "ConcurrentToolRepository",
        "associated",
        "found"
      ],
      "timestamp": "2025-12-24T18:56:17.901181"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\implementations\\tag_search_strategy.ts",
      "content_type": "code",
      "content": "// packages/core/src/implementations/tag_search_strategy.ts\nimport { Tool } from '../data/tool';\nimport { ConcurrentToolRepository } from '../interfaces/concurrent_tool_repository';\nimport { ToolSearchStrategy } from '../interfaces/tool_search_strategy';\nimport { z } from 'zod';\nimport { Serializer } from '../interfaces/serializer';\n\n/**\n * Implements a tool search strategy based on tag and description matching.\n * Tools are scored based on the occurrence of query words in their tags and description.\n */\nexport class TagSearchStrategy implements ToolSearchStrategy {\n  public readonly tool_search_strategy_type: 'tag_and_description_word_match' = 'tag_and_description_word_match';\n  public readonly descriptionWeight: number;\n  public readonly tagWeight: number;\n  private readonly _config: TagSearchStrategyConfig; \n\n   /**\n   * Creates an instance of TagSearchStrategy.\n   *\n   * @param descriptionWeight The weight to apply to words found in the tool's description.\n   * @param tagWeight The weight to apply to words found in the tool's tags.\n   */\n  constructor(config: TagSearchStrategyConfig) {\n    this._config = TagSearchStrategyConfigSchema.parse(config);\n    this.descriptionWeight = this._config.description_weight;\n    this.tagWeight = this._config.tag_weight;\n  }\n\n  /**\n   * Converts the search strategy instance's configuration to a dictionary.\n   */\n  public toDict(): TagSearchStrategyConfig {\n      return this._config;\n  }\n\n  /**\n   * Searches for tools by matching tags and description content against a query.\n   *\n   * @param concurrentToolRepository The repository to search for tools.\n   * @param query The search query string.\n   * @param limit The maximum number of tools to return. If 0, all matched tools are returned.\n   * @param anyOfTagsRequired Optional list of tags where one of them must be present in the tool's tags.\n   * @returns A promise that resolves to a list of tools ordered by relevance.\n   */\n  public async searchTools(\n    concurrentToolRepository: ConcurrentToolRepository,\n    query: string,\n    limit: number = 10,\n    anyOfTagsRequired?: string[]\n  ): Promise<Tool[]> {\n    const queryLower = query.toLowerCase();\n    const queryWords = new Set(queryLower.match(/\\w+/g) || []);\n\n    let tools = await concurrentToolRepository.getTools();\n\n    if (anyOfTagsRequired && anyOfTagsRequired.length > 0) {\n      const requiredTagsLower = new Set(anyOfTagsRequired.map(tag => tag.toLowerCase()));\n      tools = tools.filter(tool =>\n        tool.tags && tool.tags.some(tag => requiredTagsLower.has(tag.toLowerCase()))\n      );\n    }\n\n    const toolScores = tools.map(tool => {\n      let score = 0.0;\n\n      // Check tool name (highest priority)\n      const toolNameLower = tool.name.toLowerCase();\n      // Extract just the tool name without the manual prefix (e.g., \"manual.echo\" -> \"echo\")\n      const toolNameOnly = toolNameLower.includes('.') \n        ? toolNameLower.split('.').pop() || toolNameLower\n        : toolNameLower;\n      \n      // Full match or substring match on tool name\n      if (queryLower === toolNameOnly || queryLower.includes(toolNameOnly) || toolNameOnly.includes(queryLower)) {\n        score += this.tagWeight * 2; // High weight for name matches\n      }\n\n      // Word-by-word match on tool name\n      const toolNameWords = new Set(toolNameOnly.match(/\\w+/g) || []);\n      for (const word of toolNameWords) {\n        if (queryWords.has(word)) {\n          score += this.tagWeight;\n        }\n      }\n\n      if (tool.tags) {\n        for (const tag of tool.tags) {\n          const tagLower = tag.toLowerCase();\n          if (queryLower.includes(tagLower) || tagLower.includes(queryLower)) {\n            score += this.tagWeight;\n          }\n\n          const tagWords = new Set(tagLower.match(/\\w+/g) || []);\n          \n          // Exact word matches\n          for (const word of tagWords) {\n            if (queryWords.has(word)) {\n              score += this.tagWeight * 0.5;\n            }\n          }\n          \n          // Partial/substring word matches (e.g., \"author\" matches \"authors\")\n          for (const queryWord of queryWords) {\n            if (queryWord.length > 2) {\n              for (const tagWord of tagWords) {\n                if (tagWord.length > 2 && (tagWord.includes(queryWord) || queryWord.includes(tagWord))) {\n                  score += this.tagWeight * 0.3; // Lower weight for partial matches in tags\n                  break; // Only count once per query word\n                }\n              }\n            }\n          }\n        }\n      }\n\n      if (tool.description) {\n        const descriptionLower = tool.description.toLowerCase();\n        const descriptionWords = new Set(\n          descriptionLower.match(/\\w+/g) || []\n        );\n        \n        // Exact word matches\n        for (const word of descriptionWords) {\n          if (queryWords.has(word) && word.length > 2) {\n            score += this.descriptionWeight;\n          }\n        }\n        \n        // Partial/substring word matches (e.g., \"author\" matches \"authors\")\n        for (const queryWord of queryWords) {\n          if (queryWord.length > 2) {\n            for (const descWord of descriptionWords) {\n              if (descWord.length > 2 && (descWord.includes(queryWord) || queryWord.includes(descWord))) {\n                score += this.descriptionWeight * 0.5; // Lower weight for partial matches\n                break; // Only count once per query word\n              }\n            }\n          }\n        }\n      }\n\n      return { tool, score };\n    });\n\n    const sortedTools = toolScores\n      .sort((a, b) => b.score - a.score)\n      .map(item => item.tool);\n\n    return limit > 0 ? sortedTools.slice(0, limit) : sortedTools;\n  }\n}\n\n\nexport class TagSearchStrategyConfigSerializer extends Serializer<TagSearchStrategy> {\n  toDict(obj: TagSearchStrategy): { [key: string]: any } {\n    return {\n      tool_search_strategy_type: obj.tool_search_strategy_type,\n      description_weight: obj.descriptionWeight,\n      tag_weight: obj.tagWeight\n    }\n  }\n\n  validateDict(data: { [key: string]: any }): TagSearchStrategy {\n    try {\n      return new TagSearchStrategy(TagSearchStrategyConfigSchema.parse(data));\n    } catch (e) {\n      if (e instanceof z.ZodError) {\n        throw new Error(`Invalid configuration: ${e.message}`);\n      }\n      throw new Error(\"Unexpected error during validation\");\n    }\n  }\n}\n\n/**\n * Schema for the TagSearchStrategy configuration.\n */\nconst TagSearchStrategyConfigSchema = z.object({\n  tool_search_strategy_type: z.literal('tag_and_description_word_match'),\n  description_weight: z.number().optional().default(1),\n  tag_weight: z.number().optional().default(3),\n}).passthrough();\n\ntype TagSearchStrategyConfig = z.infer<typeof TagSearchStrategyConfigSchema>;\n",
      "line_count": 186,
      "word_count": 715,
      "title": "Tag Search Strategy.Ts",
      "summary": "// packages/core/src/implementations/tag_search_strategy.ts import { Tool } from '../data/tool';",
      "key_terms": [
        "implementations",
        "const",
        "packages",
        "constructor",
        "search",
        "number",
        "async",
        "error",
        "If",
        "pop",
        "based",
        "list",
        "TagSearchStrategyConfig",
        "during",
        "private",
        "must",
        "ConcurrentToolRepository",
        "found",
        "High",
        "string"
      ],
      "timestamp": "2025-12-24T18:56:17.945779"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\implementations\\post_processors\\filter_dict_post_processor.ts",
      "content_type": "code",
      "content": "// packages/core/src/implementations/post_processors/filter_dict_post_processor.ts\nimport { z } from 'zod';\nimport { ToolPostProcessor } from '../../interfaces/tool_post_processor';\nimport { Tool } from '../../data/tool';\nimport { CallTemplate } from '../../data/call_template';\nimport { IUtcpClient } from '../../interfaces/utcp_client_interface';\nimport { Serializer } from '../../interfaces/serializer';\n\n/**\n * Implements a tool post-processor that filters dictionary keys from tool results.\n * It can recursively process nested dictionaries and arrays.\n * Filtering can be configured to exclude specific keys, or only include specific keys.\n * Processing can also be conditional based on the tool's or manual's name.\n */\nexport class FilterDictPostProcessor implements ToolPostProcessor {\n  public readonly tool_post_processor_type: 'filter_dict' = 'filter_dict';\n  private readonly excludeKeys?: Set<string>;\n  private readonly onlyIncludeKeys?: Set<string>;\n  private readonly excludeTools?: Set<string>;\n  private readonly onlyIncludeTools?: Set<string>;\n  private readonly excludeManuals?: Set<string>;\n  private readonly onlyIncludeManuals?: Set<string>;\n  private readonly _config: FilterDictPostProcessorConfig; \n\n  constructor(config: FilterDictPostProcessorConfig) {\n    this._config = FilterDictPostProcessorConfigSchema.parse(config);\n    this.excludeKeys = config.exclude_keys ? new Set(config.exclude_keys) : undefined;\n    this.onlyIncludeKeys = config.only_include_keys ? new Set(config.only_include_keys) : undefined;\n    this.excludeTools = config.exclude_tools ? new Set(config.exclude_tools) : undefined;\n    this.onlyIncludeTools = config.only_include_tools ? new Set(config.only_include_tools) : undefined;\n    this.excludeManuals = config.exclude_manuals ? new Set(config.exclude_manuals) : undefined;\n    this.onlyIncludeManuals = config.only_include_manuals ? new Set(config.only_include_manuals) : undefined;\n    \n\n    if (this.excludeKeys && this.onlyIncludeKeys) {\n      console.warn(\"FilterDictPostProcessor configured with both 'exclude_keys' and 'only_include_keys'. 'exclude_keys' will be ignored.\");\n    }\n    if (this.excludeTools && this.onlyIncludeTools) {\n      console.warn(\"FilterDictPostProcessor configured with both 'exclude_tools' and 'only_include_tools'. 'exclude_tools' will be ignored.\");\n    }\n    if (this.excludeManuals && this.onlyIncludeManuals) {\n      console.warn(\"FilterDictPostProcessor configured with both 'exclude_manuals' and 'only_include_manuals'. 'exclude_manuals' will be ignored.\");\n    }\n  }\n\n    /**\n   * Converts the post-processor instance's configuration to a dictionary.\n   */\n    public toDict(): FilterDictPostProcessorConfig {\n      return this._config;\n  }\n\n  /**\n   * Processes the result of a tool call, applying filtering logic.\n   * @param caller The UTCP client instance.\n   * @param tool The Tool object that was called.\n   * @param manualCallTemplate The CallTemplateBase object of the manual that owns the tool.\n   * @param result The raw result returned by the tool's communication protocol.\n   * @returns The processed result.\n   */\n  public postProcess(caller: IUtcpClient, tool: Tool, manualCallTemplate: CallTemplate, result: any): any {\n    if (this.shouldSkipProcessing(tool, manualCallTemplate)) {\n      return result;\n    }\n\n    if (this.onlyIncludeKeys) {\n      return this._filterDictOnlyIncludeKeys(result);\n    }\n    if (this.excludeKeys) {\n      return this._filterDictExcludeKeys(result);\n    }\n    return result;\n  }\n\n  /**\n   * Determines if processing should be skipped based on tool and manual filters.\n   * @param tool The Tool object.\n   * @param manualCallTemplate The CallTemplateBase object of the manual.\n   * @returns True if processing should be skipped, false otherwise.\n   */\n  private shouldSkipProcessing(tool: Tool, manualCallTemplate: CallTemplate): boolean {\n    if (this.onlyIncludeTools && !this.onlyIncludeTools.has(tool.name)) {\n      return true;\n    }\n    if (this.excludeTools && this.excludeTools.has(tool.name)) {\n      return true;\n    }\n    const manualName = manualCallTemplate.name;\n    if (manualName) {\n        if (this.onlyIncludeManuals && !this.onlyIncludeManuals.has(manualName)) {\n            return true;\n        }\n        if (this.excludeManuals && this.excludeManuals.has(manualName)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  /**\n   * Recursively filters a dictionary, keeping only specified keys.\n   * @param data The data to filter.\n   * @returns The filtered data.\n   */\n  private _filterDictOnlyIncludeKeys(data: any): any {\n    if (typeof data !== 'object' || data === null) {\n      return data;\n    }\n\n    if (Array.isArray(data)) {\n      return data.map(item => this._filterDictOnlyIncludeKeys(item)).filter(item => {\n        if (typeof item === 'object' && item !== null) {\n          if (Array.isArray(item)) return item.length > 0;\n          return Object.keys(item).length > 0;\n        }\n        return true;\n      });\n    }\n\n    const newObject: { [key: string]: any } = {};\n    for (const key in data) {\n      if (Object.prototype.hasOwnProperty.call(data, key)) {\n        if (this.onlyIncludeKeys?.has(key)) {\n          newObject[key] = this._filterDictOnlyIncludeKeys(data[key]);\n        } else {\n          const processedValue = this._filterDictOnlyIncludeKeys(data[key]);\n          if (typeof processedValue === 'object' && processedValue !== null) {\n            if (Array.isArray(processedValue) && processedValue.length > 0) {\n              newObject[key] = processedValue;\n            } else if (Object.keys(processedValue).length > 0) {\n              newObject[key] = processedValue;\n            }\n          }\n        }\n      }\n    }\n    return newObject;\n  }\n\n  /**\n   * Recursively filters a dictionary, excluding specified keys.\n   * @param data The data to filter.\n   * @returns The filtered data.\n   */\n  private _filterDictExcludeKeys(data: any): any {\n    if (typeof data !== 'object' || data === null) {\n      return data;\n    }\n\n    if (Array.isArray(data)) {\n      return data.map(item => this._filterDictExcludeKeys(item)).filter(item => {\n        if (typeof item === 'object' && item !== null) {\n          if (Array.isArray(item)) return item.length > 0;\n          return Object.keys(item).length > 0;\n        }\n        return true;\n      });\n    }\n\n    const newObject: { [key: string]: any } = {};\n    for (const key in data) {\n      if (Object.prototype.hasOwnProperty.call(data, key)) {\n        if (!this.excludeKeys?.has(key)) {\n          newObject[key] = this._filterDictExcludeKeys(data[key]);\n        }\n      }\n    }\n    return newObject;\n  }\n}\n\n/**\n * Schema for the FilterDictPostProcessor configuration.\n */\nconst FilterDictPostProcessorConfigSchema = z.object({\n  tool_post_processor_type: z.literal('filter_dict'),\n  exclude_keys: z.array(z.string()).optional(),\n  only_include_keys: z.array(z.string()).optional(),\n  exclude_tools: z.array(z.string()).optional(),\n  only_include_tools: z.array(z.string()).optional(),\n  exclude_manuals: z.array(z.string()).optional(),\n  only_include_manuals: z.array(z.string()).optional(),\n}).passthrough();\n\ntype FilterDictPostProcessorConfig = z.infer<typeof FilterDictPostProcessorConfigSchema>;\n\nexport class FilterDictPostProcessorSerializer extends Serializer<FilterDictPostProcessor> {\n  toDict(obj: FilterDictPostProcessor): { [key: string]: any } {\n    const filterDictConfig = obj.toDict()\n    return {\n      tool_post_processor_type: filterDictConfig.tool_post_processor_type,\n      exclude_keys: filterDictConfig.exclude_keys,\n      only_include_keys: filterDictConfig.only_include_keys,\n      exclude_tools: filterDictConfig.exclude_tools,\n      only_include_tools: filterDictConfig.only_include_tools,\n      exclude_manuals: filterDictConfig.exclude_manuals,\n      only_include_manuals: filterDictConfig.only_include_manuals,\n    };\n  }\n\n  validateDict(data: { [key: string]: any }): FilterDictPostProcessor {\n    try {\n      return new FilterDictPostProcessor(FilterDictPostProcessorConfigSchema.parse(data));\n    } catch (e) {\n      if (e instanceof z.ZodError) {\n        throw new Error(`Invalid configuration: ${e.message}`);\n      }\n      throw new Error(\"Unexpected error during validation\");\n    }\n  }\n}",
      "line_count": 211,
      "word_count": 790,
      "title": "Filter Dict Post Processor.Ts",
      "summary": "// packages/core/src/implementations/post_processors/filter_dict_post_processor.ts import { z } from 'zod';",
      "key_terms": [
        "implementations",
        "null",
        "const",
        "packages",
        "exclude",
        "constructor",
        "error",
        "based",
        "Utcp",
        "during",
        "only",
        "nested",
        "private",
        "It",
        "specified",
        "filterDictConfig",
        "string",
        "Error",
        "keeping",
        "passthrough"
      ],
      "timestamp": "2025-12-24T18:56:17.977390"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\implementations\\post_processors\\limit_strings_post_processor.ts",
      "content_type": "code",
      "content": "// packages/core/src/implementations/post_processors/limit_strings_post_processor.ts\nimport { z } from 'zod';\nimport { ToolPostProcessor } from '../../interfaces/tool_post_processor';\nimport { Tool } from '../../data/tool';\nimport { CallTemplate } from '../../data/call_template';\nimport { IUtcpClient } from '../../interfaces/utcp_client_interface';\nimport { Serializer } from '../../interfaces/serializer';\n\n/**\n * Implements a tool post-processor that truncates string values within a tool's result.\n * It recursively processes nested objects and arrays, limiting the length of any string encountered.\n * Processing can be conditional based on the tool's or manual's name.\n */\nexport class LimitStringsPostProcessor implements ToolPostProcessor {\n  public readonly tool_post_processor_type: 'limit_strings' = 'limit_strings';\n  private readonly limit: number;\n  private readonly excludeTools?: Set<string>;\n  private readonly onlyIncludeTools?: Set<string>;\n  private readonly excludeManuals?: Set<string>;\n  private readonly onlyIncludeManuals?: Set<string>;\n  private readonly _config: LimitStringsPostProcessorConfig; \n\n  constructor(config: LimitStringsPostProcessorConfig) {\n    this._config = LimitStringsPostProcessorConfigSchema.parse(config);\n    this.limit = config.limit;\n    this.excludeTools = config.exclude_tools ? new Set(config.exclude_tools) : undefined;\n    this.onlyIncludeTools = config.only_include_tools ? new Set(config.only_include_tools) : undefined;\n    this.excludeManuals = config.exclude_manuals ? new Set(config.exclude_manuals) : undefined;\n    this.onlyIncludeManuals = config.only_include_manuals ? new Set(config.only_include_manuals) : undefined;\n\n    if (this.excludeTools && this.onlyIncludeTools) {\n      console.warn(\"LimitStringsPostProcessor configured with both 'exclude_tools' and 'only_include_tools'. 'exclude_tools' will be ignored.\");\n    }\n    if (this.excludeManuals && this.onlyIncludeManuals) {\n      console.warn(\"LimitStringsPostProcessor configured with both 'exclude_manuals' and 'only_include_manuals'. 'exclude_manuals' will be ignored.\");\n    }\n  }\n\n    /**\n   * Converts the post-processor instance's configuration to a dictionary.\n   */\n    public toDict(): LimitStringsPostProcessorConfig {\n      return this._config;\n  }\n\n  /**\n   * Processes the result of a tool call, truncating string values if applicable.\n   * @param caller The UTCP client instance.\n   * @param tool The Tool object that was called.\n   * @param manualCallTemplate The CallTemplateBase object of the manual that owns the tool.\n   * @param result The raw result returned by the tool's communication protocol.\n   * @returns The processed result.\n   */\n  public postProcess(caller: IUtcpClient, tool: Tool, manualCallTemplate: CallTemplate, result: any): any {\n    if (this.shouldSkipProcessing(tool, manualCallTemplate)) {\n      return result;\n    }\n    return this._processObject(result);\n  }\n\n  /**\n   * Determines if processing should be skipped based on tool and manual filters.\n   * @param tool The Tool object.\n   * @param manualCallTemplate The CallTemplateBase object of the manual.\n   * @returns True if processing should be skipped, false otherwise.\n   */\n  private shouldSkipProcessing(tool: Tool, manualCallTemplate: CallTemplate): boolean {\n    if (this.onlyIncludeTools && !this.onlyIncludeTools.has(tool.name)) {\n      return true;\n    }\n    if (this.excludeTools && this.excludeTools.has(tool.name)) {\n      return true;\n    }\n    const manualName = manualCallTemplate.name;\n    if (manualName) {\n        if (this.onlyIncludeManuals && !this.onlyIncludeManuals.has(manualName)) {\n            return true;\n        }\n        if (this.excludeManuals && this.excludeManuals.has(manualName)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  /**\n   * Recursively processes an object, truncating strings.\n   * @param obj The object to process.\n   * @returns The processed object.\n   */\n  private _processObject(obj: any): any {\n    if (typeof obj === 'string') {\n      return obj.length > this.limit ? obj.substring(0, this.limit) : obj;\n    }\n    if (Array.isArray(obj)) {\n      return obj.map(item => this._processObject(item));\n    }\n    if (typeof obj === 'object' && obj !== null) {\n      const newObj: { [key: string]: any } = {};\n      for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          newObj[key] = this._processObject(obj[key]);\n        }\n      }\n      return newObj;\n    }\n    return obj;\n  }\n}\n\n/**\n * Schema for the LimitStringsPostProcessor configuration.\n */\nconst LimitStringsPostProcessorConfigSchema = z.object({\n  tool_post_processor_type: z.literal('limit_strings'),\n  limit: z.number().int().positive().default(10000), \n  exclude_tools: z.array(z.string()).optional(),\n  only_include_tools: z.array(z.string()).optional(),\n  exclude_manuals: z.array(z.string()).optional(),\n  only_include_manuals: z.array(z.string()).optional(),\n}).passthrough();\n\ntype LimitStringsPostProcessorConfig = z.infer<typeof LimitStringsPostProcessorConfigSchema>;\n\nexport class LimitStringsPostProcessorSerializer extends Serializer<LimitStringsPostProcessor> {\n  toDict(obj: LimitStringsPostProcessor): { [key: string]: any } {\n    const limitStringsConfig = obj.toDict()\n    return {\n      tool_post_processor_type: limitStringsConfig.tool_post_processor_type,\n      limit: limitStringsConfig.limit,\n      exclude_tools: limitStringsConfig.exclude_tools,\n      only_include_tools: limitStringsConfig.only_include_tools,\n      exclude_manuals: limitStringsConfig.exclude_manuals,\n      only_include_manuals: limitStringsConfig.only_include_manuals,\n    };\n  }\n\n  validateDict(data: { [key: string]: any }): LimitStringsPostProcessor {\n    try {\n      return new LimitStringsPostProcessor(LimitStringsPostProcessorConfigSchema.parse(data));\n    } catch (e) {\n      if (e instanceof z.ZodError) {\n        throw new Error(`Invalid configuration: ${e.message}`);\n      }\n      throw new Error(\"Unexpected error during validation\");\n    }\n  }\n}\n",
      "line_count": 149,
      "word_count": 574,
      "title": "Limit Strings Post Processor.Ts",
      "summary": "// packages/core/src/implementations/post_processors/limit_strings_post_processor.ts import { z } from 'zod';",
      "key_terms": [
        "implementations",
        "LimitStringsPostProcessorConfigSchema",
        "positive",
        "null",
        "const",
        "packages",
        "constructor",
        "number",
        "error",
        "limiting",
        "newObj",
        "based",
        "encountered",
        "Utcp",
        "during",
        "nested",
        "private",
        "It",
        "string",
        "Error"
      ],
      "timestamp": "2025-12-24T18:56:18.025192"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\interfaces\\communication_protocol.ts",
      "content_type": "code",
      "content": "// packages/core/src/interfaces/communication_protocol.ts\nimport { CallTemplate } from '../data/call_template';\nimport { RegisterManualResult } from '../data/register_manual_result';\nimport { IUtcpClient } from './utcp_client_interface';\n\n/**\n * Abstract interface for UTCP client transport implementations (Communication Protocols).\n *\n * Defines the contract that all transport implementations must follow to\n * integrate with the UTCP client. Each transport handles communication\n * with a specific type of provider (HTTP, CLI, WebSocket, etc.).\n */\nexport abstract class CommunicationProtocol {\n\n  /**\n   * Mapping of communication protocol types to their respective implementations.\n   */\n  static communicationProtocols: { [type: string]: CommunicationProtocol } = {};\n\n  /**\n   * Registers a manual and its tools.\n   *\n   * Connects to the provider and retrieves the list of tools it offers.\n   * This may involve making discovery requests, parsing configuration files,\n   * or initializing connections depending on the provider type.\n   *\n   * @param caller The UTCP client that is calling this method. (Type will be properly defined in UtcpClient).\n   * @param manualCallTemplate The call template of the manual to register.\n   * @returns A RegisterManualResult object containing the call template and manual.\n   */\n  abstract registerManual(caller: IUtcpClient, manualCallTemplate: CallTemplate): Promise<RegisterManualResult>;\n\n  /**\n   * Deregisters a manual and its tools.\n   *\n   * Cleanly disconnects from the provider and releases any associated\n   * resources such as connections, processes, or file handles.\n   *\n   * @param caller The UTCP client that is calling this method.\n   * @param manualCallTemplate The call template of the manual to deregister.\n   */\n  abstract deregisterManual(caller: IUtcpClient, manualCallTemplate: CallTemplate): Promise<void>;\n\n  /**\n   * Executes a tool call through this transport.\n   *\n   * Sends a tool invocation request to the provider using the appropriate\n   * protocol and returns the result. Handles serialization of arguments\n   * and deserialization of responses according to the transport type.\n   *\n   * @param caller The UTCP client that is calling this method.\n   * @param toolName Name of the tool to call (may include provider prefix).\n   * @param toolArgs Dictionary of arguments to pass to the tool.\n   * @param toolCallTemplate Call template of the tool to call.\n   * @returns The tool's response.\n   */\n  abstract callTool(caller: IUtcpClient, toolName: string, toolArgs: Record<string, any>, toolCallTemplate: CallTemplate): Promise<any>;\n\n  /**\n   * Executes a tool call through this transport streamingly.\n   *\n   * Sends a tool invocation request to the provider using the appropriate\n   * protocol and returns an async generator for streaming results.\n   *\n   * @param caller The UTCP client that is calling this method.\n   * @param toolName Name of the tool to call.\n   * @param toolArgs Arguments to pass to the tool.\n   * @param toolCallTemplate Call template of the tool to call.\n   * @returns An async generator that yields chunks of the tool's response.\n   */\n  abstract callToolStreaming(caller: IUtcpClient, toolName: string, toolArgs: Record<string, any>, toolCallTemplate: CallTemplate): AsyncGenerator<any, void, unknown>;\n\n  /**\n   * Closes any persistent connections or resources held by the communication protocol.\n   * This is a cleanup method that should be called when the client is shut down.\n   */\n  async close(): Promise<void> {}\n}",
      "line_count": 78,
      "word_count": 477,
      "title": "Communication Protocol.Ts",
      "summary": "// packages/core/src/interfaces/communication_protocol.ts import { CallTemplate } from '../data/call_template';",
      "key_terms": [
        "implementations",
        "close",
        "packages",
        "Closes",
        "async",
        "etc",
        "Type",
        "through",
        "Record",
        "list",
        "WebSocket",
        "cleanup",
        "Utcp",
        "unknown",
        "must",
        "associated",
        "string",
        "toolName",
        "RegisterManualResult",
        "using"
      ],
      "timestamp": "2025-12-24T18:56:18.056730"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\interfaces\\concurrent_tool_repository.ts",
      "content_type": "code",
      "content": "// packages/core/src/interfaces/concurrent_tool_repository.ts\nimport { CallTemplate } from '../data/call_template';\nimport { Tool } from '../data/tool';\nimport { UtcpManual } from '../data/utcp_manual';\nimport { Serializer } from './serializer';\nimport z from 'zod';\n\n\n/**\n * Defines the contract for tool repositories that store and manage UTCP tools\n * and their associated call templates.\n *\n * Repositories are responsible for:\n * - Persisting call template configurations and their associated tools.\n * - Providing efficient lookup and retrieval operations.\n * - Managing relationships between call templates and tools.\n * - Ensuring data consistency across concurrent asynchronous calls.\n */\nexport interface ConcurrentToolRepository {\n  /**\n   * A string identifying the type of this tool repository (e.g., 'in_memory', 'database').\n   * This is used for configuration and plugin lookup.\n   */\n  tool_repository_type: string;\n\n  /**\n   * Saves a manual's call template and its associated tools in the repository.\n   * This operation replaces any existing manual with the same name.\n   *\n   * @param manualCallTemplate The call template associated with the manual to save.\n   * @param manual The complete UTCP Manual object to save.\n   * @returns A Promise that resolves when the operation is complete.\n   */\n  saveManual(manualCallTemplate: CallTemplate, manual: UtcpManual): Promise<void>;\n\n  /**\n   * Removes a manual and its tools from the repository.\n   *\n   * @param manualName The name of the manual (which corresponds to the CallTemplate name) to remove.\n   * @returns A Promise resolving to true if the manual was removed, False otherwise.\n   */\n  removeManual(manualName: string): Promise<boolean>;\n\n  /**\n   * Removes a specific tool from the repository.\n   *\n   * @param toolName The full namespaced name of the tool to remove (e.g., \"my_manual.my_tool\").\n   * @returns A Promise resolving to true if the tool was removed, False otherwise.\n   */\n  removeTool(toolName: string): Promise<boolean>;\n\n  /**\n   * Retrieves a tool by its full namespaced name.\n   *\n   * @param toolName The full namespaced name of the tool to retrieve.\n   * @returns A Promise resolving to the tool if found, otherwise undefined.\n   */\n  getTool(toolName: string): Promise<Tool | undefined>;\n\n  /**\n   * Retrieves all tools from the repository.\n   *\n   * @returns A Promise resolving to a list of all registered tools.\n   */\n  getTools(): Promise<Tool[]>;\n\n  /**\n   * Retrieves all tools associated with a specific manual.\n   *\n   * @param manualName The name of the manual.\n   * @returns A Promise resolving to a list of tools associated with the manual, or undefined if the manual is not found.\n   */\n  getToolsByManual(manualName: string): Promise<Tool[] | undefined>;\n\n  /**\n   * Retrieves a complete UTCP Manual object by its name.\n   *\n   * @param manualName The name of the manual to retrieve.\n   * @returns A Promise resolving to the manual if found, otherwise undefined.\n   */\n  getManual(manualName: string): Promise<UtcpManual | undefined>;\n\n  /**\n   * Retrieves all registered manuals from the repository.\n   *\n   * @returns A Promise resolving to a list of all registered UtcpManual objects.\n   */\n  getManuals(): Promise<UtcpManual[]>;\n\n  /**\n   * Retrieves a manual's CallTemplate by its name.\n   *\n   * @param manualCallTemplateName The name of the manual's CallTemplate to retrieve.\n   * @returns A Promise resolving to the CallTemplate if found, otherwise undefined.\n   */\n  getManualCallTemplate(manualCallTemplateName: string): Promise<CallTemplate | undefined>;\n\n  /**\n   * Retrieves all registered manual CallTemplates from the repository.\n   *\n   * @returns A Promise resolving to a list of all registered CallTemplateBase objects.\n   */\n  getManualCallTemplates(): Promise<CallTemplate[]>;\n}\n\nexport class ConcurrentToolRepositoryConfigSerializer extends Serializer<ConcurrentToolRepository> {\n  private static implementations: Record<string, Serializer<ConcurrentToolRepository>> = {};\n  static default_strategy = \"in_memory\";\n\n  // No need for the whole plugin registry. Plugins just need to call this to register a new repository\n  static registerRepository(type: string, serializer: Serializer<ConcurrentToolRepository>, override = false): boolean {\n    if (!override && ConcurrentToolRepositoryConfigSerializer.implementations[type]) {\n      return false;\n    }\n    ConcurrentToolRepositoryConfigSerializer.implementations[type] = serializer;\n    return true;\n  }\n\n  toDict(obj: ConcurrentToolRepository): Record<string, unknown> {\n    const serializer = ConcurrentToolRepositoryConfigSerializer.implementations[obj.tool_repository_type];\n    if (!serializer) throw new Error(`No serializer for type: ${obj.tool_repository_type}`);\n    return serializer.toDict(obj);\n  }\n\n  validateDict(data: Record<string, unknown>): ConcurrentToolRepository {\n    const serializer = ConcurrentToolRepositoryConfigSerializer.implementations[data[\"tool_repository_type\"] as string];\n    if (!serializer) throw new Error(`Invalid tool repository type: ${data[\"tool_repository_type\"]}`);\n    return serializer.validateDict(data);\n  }\n}\n\nexport const ConcurrentToolRepositorySchema = z\n  .custom<ConcurrentToolRepository>((obj) => {\n    try {\n      // Use the centralized serializer to validate & return the correct subtype\n      const validated = new ConcurrentToolRepositoryConfigSerializer().validateDict(obj as Record<string, unknown>);\n      return validated;\n    } catch (e) {\n      return false; // z.custom treats false as validation failure\n    }\n  }, {\n    message: \"Invalid ConcurrentToolRepository object\",\n  });",
      "line_count": 143,
      "word_count": 679,
      "title": "Concurrent Tool Repository.Ts",
      "summary": "// packages/core/src/interfaces/concurrent_tool_repository.ts import { CallTemplate } from '../data/call_template';",
      "key_terms": [
        "implementations",
        "const",
        "packages",
        "Record",
        "saveManual",
        "list",
        "Utcp",
        "manualCallTemplateName",
        "same",
        "unknown",
        "private",
        "ConcurrentToolRepository",
        "associated",
        "found",
        "string",
        "Error",
        "toolName",
        "consistency",
        "validateDict",
        "if"
      ],
      "timestamp": "2025-12-24T18:56:18.103840"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\interfaces\\index.ts",
      "content_type": "code",
      "content": "// packages/core/src/interfaces/index.ts\nexport * from './communication_protocol';\nexport * from './concurrent_tool_repository';\nexport * from './tool_post_processor';\nexport * from './tool_search_strategy';\nexport * from './utcp_client_interface';\nexport * from './serializer';\nexport * from './variable_substitutor';",
      "line_count": 8,
      "word_count": 30,
      "title": "Index.Ts",
      "summary": "// packages/core/src/interfaces/index.ts export * from './communication_protocol';",
      "key_terms": [
        "utcp",
        "from",
        "protocol",
        "packages",
        "interface",
        "serializer",
        "ts",
        "core",
        "export",
        "interfaces",
        "src",
        "index"
      ],
      "timestamp": "2025-12-24T18:56:18.135752"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\interfaces\\serializer.ts",
      "content_type": "code",
      "content": "let ensurePluginsInitialized: (() => void) | null = null;\n\nexport function setPluginInitializer(fn: () => void): void {\n  ensurePluginsInitialized = fn;\n}\n\nexport abstract class Serializer<T> {\n  constructor() {\n    // Use lazy initialization to avoid circular dependency during module loading\n    if (ensurePluginsInitialized) {\n      ensurePluginsInitialized();\n    }\n  }\n\n  abstract toDict(obj: T): { [key: string]: any };\n\n  abstract validateDict(obj: { [key: string]: any }): T;\n\n  copy(obj: T): T {\n    return this.validateDict(this.toDict(obj));\n  }\n}",
      "line_count": 22,
      "word_count": 69,
      "title": "Serializer.Ts",
      "summary": "let ensurePluginsInitialized: (() => void) | null = null; export function setPluginInitializer(fn: () => void): void {",
      "key_terms": [
        "null",
        "any",
        "constructor",
        "toDict",
        "setPluginInitializer",
        "module",
        "during",
        "abstract",
        "lazy",
        "obj",
        "Use",
        "string",
        "ensurePluginsInitialized",
        "validateDict",
        "let",
        "if",
        "circular",
        "avoid",
        "dependency",
        "return"
      ],
      "timestamp": "2025-12-24T18:56:18.169310"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\interfaces\\tool_post_processor.ts",
      "content_type": "code",
      "content": "// packages/core/src/interfaces/tool_post_processor.ts\nimport { Tool } from '../data/tool';\nimport { CallTemplate } from '../data/call_template';\nimport { IUtcpClient } from './utcp_client_interface';\nimport { Serializer } from './serializer';\nimport z from 'zod';\n\n/**\n * Defines the contract for tool post-processors that can modify the result of a tool call.\n * Implementations can apply transformations, filtering, or other logic to the raw tool output.\n * Post-processors are configured in the UtcpClientConfig and executed in order after a successful tool call.\n */\nexport interface ToolPostProcessor {\n  /**\n   * A string identifying the type of this tool post-processor (e.g., 'filter_dict', 'limit_strings').\n   * This is used for configuration and plugin lookup.\n   */\n  tool_post_processor_type: string;\n\n  /**\n   * Processes the result of a tool call.\n   *\n   * @param caller The UTCP client instance that initiated the tool call.\n   * @param tool The Tool object that was called.\n   * @param manualCallTemplate The CallTemplateBase object of the manual that owns the tool.\n   * @param result The raw result returned by the tool's communication protocol (can be a final result or a chunk from a stream).\n   * @returns The processed result, which is then passed to the next processor in the chain or returned to the caller.\n   */\n  postProcess(caller: IUtcpClient, tool: Tool, manualCallTemplate: CallTemplate, result: any): any;\n}\n\nexport class ToolPostProcessorConfigSerializer extends Serializer<ToolPostProcessor> {\n  private static implementations: Record<string, Serializer<ToolPostProcessor>> = {};\n\n  // No need for the whole plugin registry. Plugins just need to call this to register a new post-processor\n  static registerPostProcessor(type: string, serializer: Serializer<ToolPostProcessor>, override = false): boolean {\n    if (!override && ToolPostProcessorConfigSerializer.implementations[type]) {\n      return false;\n    }\n    ToolPostProcessorConfigSerializer.implementations[type] = serializer;\n    return true;\n  }\n\n  toDict(obj: ToolPostProcessor): Record<string, unknown> {\n    const serializer = ToolPostProcessorConfigSerializer.implementations[obj.tool_post_processor_type];\n    if (!serializer) throw new Error(`No serializer for type: ${obj.tool_post_processor_type}`);\n    return serializer.toDict(obj);\n  }\n\n  validateDict(data: Record<string, unknown>): ToolPostProcessor {\n    const serializer = ToolPostProcessorConfigSerializer.implementations[data[\"tool_post_processor_type\"] as string];\n    if (!serializer) throw new Error(`Invalid tool post-processor type: ${data[\"tool_post_processor_type\"]}`);\n    return serializer.validateDict(data);\n  }\n}\n\nexport const ToolPostProcessorSchema = z\n  .custom<ToolPostProcessor>((obj) => {\n    try {\n      // Use the centralized serializer to validate & return the correct subtype\n      const validated = new ToolPostProcessorConfigSerializer().validateDict(obj as Record<string, unknown>);\n      return validated;\n    } catch (e) {\n      return false; // z.custom treats false as validation failure\n    }\n  }, {\n    message: \"Invalid ToolPostProcessor object\",\n  });",
      "line_count": 68,
      "word_count": 361,
      "title": "Tool Post Processor.Ts",
      "summary": "// packages/core/src/interfaces/tool_post_processor.ts import { Tool } from '../data/tool';",
      "key_terms": [
        "implementations",
        "output",
        "const",
        "packages",
        "Record",
        "Utcp",
        "unknown",
        "private",
        "other",
        "string",
        "Error",
        "ToolPostProcessorSchema",
        "validateDict",
        "if",
        "that",
        "interface",
        "correct",
        "failure",
        "post-processors",
        "registerPostProcessor"
      ],
      "timestamp": "2025-12-24T18:56:18.221833"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\interfaces\\tool_search_strategy.ts",
      "content_type": "code",
      "content": "// packages/core/src/interfaces/tool_search_strategy.ts\nimport { Tool } from '../data/tool';\nimport { ConcurrentToolRepository } from './concurrent_tool_repository';\nimport { Serializer } from './serializer';\nimport z from 'zod';\n\n\n/**\n * Defines the contract for tool search strategies that can be plugged into\n * the UTCP client. Implementations provide algorithms for searching and ranking tools.\n */\nexport interface ToolSearchStrategy {\n  /**\n   * A string identifying the type of this tool search strategy (e.g., 'tag_and_description_word_match', 'in_mem_embeddings').\n   * This is used for configuration and plugin lookup.\n   */\n  tool_search_strategy_type: string;\n\n  /**\n   * Searches for tools relevant to the query within a given tool repository.\n   *\n   * @param toolRepository The repository to search within.\n   * @param query The search query string. Format depends on the strategy (e.g., keywords, natural language).\n   * @param limit Maximum number of tools to return. Use 0 for no limit.\n   * @param anyOfTagsRequired Optional list of tags where one of them must be present in the tool's tags.\n   * @returns A Promise resolving to a list of Tool objects ranked by relevance.\n   */\n  searchTools(\n    toolRepository: ConcurrentToolRepository,\n    query: string,\n    limit?: number,\n    anyOfTagsRequired?: string[]\n  ): Promise<Tool[]>;\n}\n\nexport class ToolSearchStrategyConfigSerializer extends Serializer<ToolSearchStrategy> {\n  private static implementations: Record<string, Serializer<ToolSearchStrategy>> = {};\n  static default_strategy = \"tag_and_description_word_match\";\n\n  // No need for the whole plugin registry. Plugins just need to call this to register a new strategy\n  static registerStrategy(type: string, serializer: Serializer<ToolSearchStrategy>, override = false): boolean  {\n    if (!override && ToolSearchStrategyConfigSerializer.implementations[type]) {\n      return false;\n    }\n    ToolSearchStrategyConfigSerializer.implementations[type] = serializer;\n    return true;\n  }\n\n  toDict(obj: ToolSearchStrategy): Record<string, unknown> {\n    const serializer = ToolSearchStrategyConfigSerializer.implementations[obj.tool_search_strategy_type];\n    if (!serializer) throw new Error(`No serializer for type: ${obj.tool_search_strategy_type}`);\n    return serializer.toDict(obj);\n  }\n\n  validateDict(data: Record<string, unknown>): ToolSearchStrategy {\n    const serializer = ToolSearchStrategyConfigSerializer.implementations[data[\"tool_search_strategy_type\"] as string];\n    if (!serializer) throw new Error(`Invalid tool search strategy type: ${data[\"tool_search_strategy_type\"]}`);\n    return serializer.validateDict(data);\n  }\n}\n\nexport const ToolSearchStrategySchema = z\n  .custom<ToolSearchStrategy>((obj) => {\n    try {\n      // Use the centralized serializer to validate & return the correct subtype\n      const validated = new ToolSearchStrategyConfigSerializer().validateDict(obj as Record<string, unknown>);\n      return validated;\n    } catch (e) {\n      return false; // z.custom treats false as validation failure\n    }\n  }, {\n    message: \"Invalid ToolSearchStrategy object\",\n  });",
      "line_count": 73,
      "word_count": 339,
      "title": "Tool Search Strategy.Ts",
      "summary": "// packages/core/src/interfaces/tool_search_strategy.ts import { Tool } from '../data/tool';",
      "key_terms": [
        "implementations",
        "const",
        "packages",
        "search",
        "number",
        "Record",
        "list",
        "unknown",
        "private",
        "must",
        "ConcurrentToolRepository",
        "natural",
        "string",
        "Error",
        "validateDict",
        "if",
        "that",
        "interface",
        "correct",
        "failure"
      ],
      "timestamp": "2025-12-24T18:56:18.270684"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\interfaces\\utcp_client_interface.ts",
      "content_type": "code",
      "content": "// packages/core/src/interfaces/utcp_client_interface.ts\nimport { UtcpClientConfig } from \"../client/utcp_client_config\";\nimport { CallTemplate } from \"../data/call_template\";\nimport { Tool } from \"../data/tool\";\nimport { RegisterManualResult } from \"../data/register_manual_result\";\n\n/**\n * REQUIRED\n * Abstract interface for UTCP client implementations.\n * \n * Defines the core contract for UTCP clients, including CallTemplate management,\n * tool execution, search capabilities, and variable handling. This interface\n * allows for different client implementations while maintaining consistency.\n */\nexport interface IUtcpClient {\n  /**\n   * The client's complete and immutable configuration object.\n   */\n  readonly config: UtcpClientConfig;\n\n  /**\n   * The root directory for the client to resolve relative paths from.\n   */\n  readonly root_dir: string | null;\n\n  /**\n   * REQUIRED\n   * Register a tool CallTemplate and its tools.\n   *\n   * @param manualCallTemplate The CallTemplate to register.\n   * @returns A Promise resolving to a RegisterManualResult object containing the registered CallTemplate and its tools.\n   */\n  registerManual(manualCallTemplate: CallTemplate): Promise<RegisterManualResult>;\n\n  /**\n   * REQUIRED\n   * Register multiple tool CallTemplates and their tools.\n   *\n   * @param manualCallTemplates List of CallTemplates to register.\n   * @returns A Promise resolving to a list of RegisterManualResult objects containing the registered CallTemplates and their tools. Order is not preserved.\n   */\n  registerManuals(manualCallTemplates: CallTemplate[]): Promise<RegisterManualResult[]>;\n\n  /**\n   * REQUIRED\n   * Deregister a tool CallTemplate.\n   *\n   * @param manualCallTemplateName The name of the CallTemplate to deregister.\n   * @returns A Promise resolving to true if the CallTemplate was deregistered, false otherwise.\n   */\n  deregisterManual(manualCallTemplateName: string): Promise<boolean>;\n\n  /**\n   * REQUIRED\n   * Call a tool.\n   *\n   * @param toolName The name of the tool to call.\n   * @param toolArgs The arguments to pass to the tool.\n   * @returns A Promise resolving to the result of the tool call.\n   */\n  callTool(toolName: string, toolArgs: Record<string, any>): Promise<any>;\n\n  /**\n   * REQUIRED\n   * Call a tool streamingly.\n   *\n   * @param toolName The name of the tool to call.\n   * @param toolArgs The arguments to pass to the tool.\n   * @returns An async generator that yields the result of the tool call.\n   */\n  callToolStreaming(toolName: string, toolArgs: Record<string, any>): AsyncGenerator<any, void, unknown>;\n\n  /**\n   * REQUIRED\n   * Search for tools relevant to the query.\n   *\n   * @param query The search query.\n   * @param limit The maximum number of tools to return. 0 for no limit.\n   * @param anyOfTagsRequired Optional list of tags where one of them must be present in the tool's tags\n   * @returns A Promise resolving to a list of tools that match the search query.\n   */\n  searchTools(query: string, limit?: number, anyOfTagsRequired?: string[]): Promise<Tool[]>;\n\n  /**\n   * REQUIRED\n   * Gets the required namespaced variables for a manual CallTemplate and its discovered tools.\n   *\n   * @param manualCallTemplate The CallTemplate instance of the manual.\n   * @returns A Promise resolving to a list of required, fully-qualified variable names.\n   */\n  getRequiredVariablesForManualAndTools(manualCallTemplate: CallTemplate): Promise<string[]>;\n\n  /**\n   * REQUIRED\n   * Gets the required namespaced variables for an already registered tool.\n   *\n   * @param toolName The full namespaced name of the registered tool (e.g., 'manual_name.tool_name').\n   * @returns A Promise resolving to a list of required, fully-qualified variable names.\n   */\n  getRequiredVariablesForRegisteredTool(toolName: string): Promise<string[]>;\n}",
      "line_count": 101,
      "word_count": 487,
      "title": "Utcp Client Interface.Ts",
      "summary": "// packages/core/src/interfaces/utcp_client_interface.ts import { UtcpClientConfig } from \"../client/utcp_client_config\";",
      "key_terms": [
        "implementations",
        "null",
        "packages",
        "paths",
        "REQUIRED",
        "search",
        "async",
        "number",
        "Record",
        "list",
        "Utcp",
        "manualCallTemplateName",
        "unknown",
        "must",
        "qualified",
        "string",
        "multiple",
        "toolName",
        "RegisterManualResult",
        "consistency"
      ],
      "timestamp": "2025-12-24T18:56:18.307829"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\interfaces\\variable_substitutor.ts",
      "content_type": "code",
      "content": "// packages/core/src/interfaces/variable_substitutor.ts\nimport { UtcpClientConfig } from '../client/utcp_client_config';\n\n/**\n * Defines the contract for variable substitution implementations.\n * Implementations are responsible for replacing placeholders in configuration data\n * with actual values from various sources (e.g., config, environment variables).\n */\nexport interface VariableSubstitutor {\n  /**\n   * Recursively substitutes variables in the given object.\n   *\n   * @param obj The object (can be string, array, or object) containing potential variable references to substitute.\n   * @param config The UTCP client configuration containing variable definitions and loaders.\n   * @param namespace An optional namespace (e.g., manual name) to prefix variable lookups for isolation.\n   * @returns The object with all variable references replaced by their values.\n   * @throws UtcpVariableNotFoundError if a referenced variable cannot be resolved.\n   */\n  substitute<T>(obj: T, config: UtcpClientConfig, namespace?: string): Promise<T>;\n\n  /**\n   * Recursively finds all variable references in the given object.\n   *\n   * @param obj The object (can be string, array, or object) to scan for variable references.\n   * @param namespace An optional namespace (e.g., manual name) to prefix variable lookups for isolation.\n   * @returns A list of fully-qualified variable names found in the object.\n   */\n  findRequiredVariables(obj: any, namespace?: string): string[];\n}",
      "line_count": 29,
      "word_count": 189,
      "title": "Variable Substitutor.Ts",
      "summary": "// packages/core/src/interfaces/variable_substitutor.ts import { UtcpClientConfig } from '../client/utcp_client_config';",
      "key_terms": [
        "implementations",
        "packages",
        "isolation",
        "list",
        "Utcp",
        "loaders",
        "substitute",
        "found",
        "qualified",
        "string",
        "VariableSubstitutor",
        "sources",
        "if",
        "interface",
        "object",
        "replaced",
        "Defines",
        "definitions",
        "any",
        "or"
      ],
      "timestamp": "2025-12-24T18:56:18.342580"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\plugins\\plugin_loader.ts",
      "content_type": "code",
      "content": "// Core Auth\nimport { AuthSerializer } from '../data/auth';\nimport { ApiKeyAuthSerializer } from '../data/auth_implementations/api_key_auth';\nimport { BasicAuthSerializer } from '../data/auth_implementations/basic_auth';\nimport { OAuth2AuthSerializer } from '../data/auth_implementations/oauth2_auth';\nimport { setPluginInitializer } from '../interfaces/serializer';\n\n// Core Tool Repository\nimport { InMemConcurrentToolRepositorySerializer } from '../implementations/in_mem_concurrent_tool_repository';\nimport { ConcurrentToolRepositoryConfigSerializer } from '../interfaces/concurrent_tool_repository';\n\n// Core Search Strategy\nimport { TagSearchStrategyConfigSerializer } from '../implementations/tag_search_strategy';\nimport { ToolSearchStrategyConfigSerializer } from '../interfaces/tool_search_strategy';\n\n// Core Post Processors\nimport { FilterDictPostProcessorSerializer } from '../implementations/post_processors/filter_dict_post_processor';\nimport { LimitStringsPostProcessorSerializer } from '../implementations/post_processors/limit_strings_post_processor';\nimport { ToolPostProcessorConfigSerializer } from '../interfaces/tool_post_processor';\n\nlet corePluginsInitialized = false;\nlet initializing = false;\n\n// Register the initialization function with Serializer to break circular dependency\nsetPluginInitializer(() => ensureCorePluginsInitialized());\n\nfunction _registerCorePlugins(): void {\n  // Register Core Auth Serializers\n  AuthSerializer.registerAuth('api_key', new ApiKeyAuthSerializer());\n  AuthSerializer.registerAuth('basic', new BasicAuthSerializer());\n  AuthSerializer.registerAuth('oauth2', new OAuth2AuthSerializer());\n\n  // Register Tool Repository Serializers\n  ConcurrentToolRepositoryConfigSerializer.registerRepository('in_memory', new InMemConcurrentToolRepositorySerializer());\n\n  // Register Tool Search Strategy Serializers\n  ToolSearchStrategyConfigSerializer.registerStrategy('tag_and_description_word_match', new TagSearchStrategyConfigSerializer());\n  \n  // Register Tool Post-Processor Serializers\n  ToolPostProcessorConfigSerializer.registerPostProcessor('filter_dict', new FilterDictPostProcessorSerializer());\n  ToolPostProcessorConfigSerializer.registerPostProcessor('limit_strings', new LimitStringsPostProcessorSerializer());\n}\n\n/**\n * Ensures that all core UTCP plugins (auth serializers, default repository, \n * search strategy, and post-processors) are registered with the plugin registry.\n * \n * This function is called automatically when needed and should not be called manually.\n * \n * Note: Optional plugins like HTTP, MCP, Text, File, etc. are NOT auto-registered.\n * Users must explicitly import the plugins they need:\n * \n * @example\n * // Browser application\n * import { UtcpClient } from '@utcp/sdk';\n * import '@utcp/http';     // Auto-registers HTTP protocol\n * import '@utcp/text';     // Auto-registers text content protocol\n * \n * @example\n * // Node.js application\n * import { UtcpClient } from '@utcp/sdk';\n * import '@utcp/http';\n * import '@utcp/mcp';\n * import '@utcp/file';\n * import '@utcp/dotenv-loader';\n */\nexport function ensureCorePluginsInitialized(): void {\n  if (!corePluginsInitialized && !initializing) {\n    initializing = true;\n    _registerCorePlugins();\n    corePluginsInitialized = true;\n    initializing = false;\n  }\n}",
      "line_count": 74,
      "word_count": 295,
      "title": "Plugin Loader.Ts",
      "summary": "// Core Auth import { AuthSerializer } from '../data/auth';",
      "key_terms": [
        "implementations",
        "search",
        "File",
        "etc",
        "Utcp",
        "must",
        "registers",
        "ApiKeyAuthSerializer",
        "Browser",
        "application",
        "let",
        "if",
        "that",
        "interface",
        "circular",
        "basic",
        "post-processors",
        "registerPostProcessor",
        "Note",
        "true"
      ],
      "timestamp": "2025-12-24T18:56:18.374338"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\core\\src\\utils\\platform.ts",
      "content_type": "code",
      "content": "// Platform detection utility to determine if we're in Node.js or browser\nexport const isNode = typeof process !== 'undefined' && \n                      process.versions != null && \n                      process.versions.node != null;\n\nexport const isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n",
      "line_count": 7,
      "word_count": 41,
      "title": "Platform.Ts",
      "summary": "// Platform detection utility to determine if we're in Node.js or browser export const isNode = typeof process !== 'undefined' &&",
      "key_terms": [
        "browser",
        "process",
        "versions",
        "we",
        "const",
        "null",
        "node",
        "or",
        "utility",
        "re",
        "Platform",
        "if",
        "determine",
        "typeof",
        "export",
        "isBrowser",
        "js",
        "to",
        "window",
        "document"
      ],
      "timestamp": "2025-12-24T18:56:18.408242"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\direct-call\\package.json",
      "content_type": "configuration",
      "content": "{\n  \"name\": \"@utcp/direct-call\",\n  \"version\": \"1.1.0\",\n  \"description\": \"Direct callable functions plugin for UTCP\",\n  \"main\": \"dist/index.cjs\",\n  \"module\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"type\": \"module\",\n  \"license\": \"MPL-2.0\",\n  \"author\": \"UTCP Contributors\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/universal-tool-calling-protocol/typescript-utcp.git\",\n    \"directory\": \"packages/direct-call\"\n  },\n  \"keywords\": [\n    \"utcp\",\n    \"universal-tool-calling-protocol\",\n    \"tools\",\n    \"api\",\n    \"typescript\",\n    \"tool calling\",\n    \"direct-call\",\n    \"callable\",\n    \"agent\",\n    \"ai\",\n    \"llm\"\n  ],\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"scripts\": {\n    \"build\": \"tsup\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\",\n      \"require\": \"./dist/index.cjs\",\n      \"default\": \"./dist/index.js\"\n    }\n  },\n  \"dependencies\": {\n    \"@utcp/sdk\": \"^1.1.0\"\n  },\n  \"devDependencies\": {\n    \"bun-types\": \"latest\",\n    \"typescript\": \"^5.0.0\",\n    \"@types/bun\": \"latest\"\n  }\n}\n",
      "line_count": 55,
      "word_count": 92,
      "title": "Package.Json",
      "summary": "\"name\": \"@utcp/direct-call\", \"version\": \"1.1.0\",",
      "key_terms": [
        "build",
        "packages",
        "calling-protocol",
        "scripts",
        "universal",
        "module",
        "utcp",
        "index",
        "calling",
        "callable",
        "MPL",
        "Direct",
        "tool",
        "dependencies",
        "type",
        "url",
        "github",
        "public",
        "protocol",
        "for"
      ],
      "timestamp": "2025-12-24T18:56:18.425815"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\direct-call\\README.md",
      "content_type": "documentation",
      "content": "# @utcp/direct-call\n\nDirect callable functions plugin for UTCP (Universal Tool Calling Protocol).\n\nThis plugin allows you to register and call JavaScript/TypeScript functions directly as UTCP tools, without the need for external APIs or file-based configurations.\n\n## Features\n\n- **Direct Function Calls**: Register JavaScript/TypeScript functions as UTCP tools\n- **Simple Registration**: Use `addFunctionToUtcpDirectCall()` to register functions at the global level\n- **Type-Safe**: Full TypeScript support with proper type definitions\n- **Streaming Support**: Built-in support for streaming responses\n\n## Installation\n\n```bash\nnpm install @utcp/direct-call\n```\n\n## Usage\n\n**Important:** When UTCP calls your registered functions, it spreads the toolArgs object properties as separate parameters. For example, if toolArgs is `{ name: 'Alice', age: 30 }`, your function will be called as `yourFunction('Alice', 30)`, not `yourFunction({ name: 'Alice', age: 30 })`.\n\n### Using `addFunctionToUtcpDirectCall`\n\n```typescript\nimport { addFunctionToUtcpDirectCall } from '@utcp/direct-call';\nimport { UtcpManual } from '@utcp/sdk';\n\n// Register a function that returns a UTCP manual\nconst getMyManual = addFunctionToUtcpDirectCall('myManual', async (): Promise<UtcpManual> => {\n  return {\n    utcp_version: '1.0.0',\n    manual_version: '1.0.0',\n    tools: [\n      {\n        name: 'exampleTool',\n        description: 'An example tool',\n        inputs: { type: 'object', properties: {} },\n        outputs: { type: 'object', properties: {} },\n        tags: [],\n        tool_call_template: {\n          call_template_type: 'direct-call',\n          callable_name: 'exampleTool'\n        }\n      }\n    ]\n  };\n});\n\n// Register a tool function\nconst myTool = addFunctionToUtcpDirectCall('exampleTool', async (...args: any[]): Promise<any> => {\n  return { result: 'Hello from direct call!' };\n});\n\n// You can also use named functions\n// Note: Parameters are spread from the toolArgs object\nasync function greet(name: string) {\n  return `Hello, ${name}!`;\n}\naddFunctionToUtcpDirectCall('greet', greet);\n```\n\n### Manual Registration\n\n```typescript\nimport { DirectCommunicationProtocol } from '@utcp/direct-call';\nimport { UtcpManual } from '@utcp/sdk';\n\nconst protocol = new DirectCommunicationProtocol();\n\n// Register a callable for returning manuals\nprotocol.registerCallable('myManual', async () => {\n  return {\n    utcp_version: '1.0.0',\n    manual_version: '1.0.0',\n    tools: []\n  } as UtcpManual;\n});\n\n// Register a callable for tool execution\nprotocol.registerCallable('myTool', async (...args: any[]) => {\n  return { result: 'Success!' };\n});\n```\n\n## License\n\nMPL-2.0\n",
      "line_count": 90,
      "word_count": 323,
      "title": "@utcp/direct-call",
      "summary": "Direct callable functions plugin for UTCP (Universal Tool Calling Protocol). This plugin allows you to register and call JavaScript/TypeScript functions directly as UTCP tools, without the need for ex...",
      "key_terms": [
        "Important",
        "const",
        "async",
        "Success",
        "named",
        "Type",
        "based",
        "Built",
        "Utcp",
        "global",
        "Built-in",
        "string",
        "You",
        "getMyManual",
        "Calling",
        "parameters",
        "if",
        "that",
        "Features",
        "Hello"
      ],
      "timestamp": "2025-12-24T18:56:18.453907"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\direct-call\\tsconfig.json",
      "content_type": "configuration",
      "content": "// packages/direct-call/tsconfig.json\n{\n  \"extends\": \"../../tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"composite\": true\n  },\n  \"include\": [\n    \"src/**/*\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"**/*.test.ts\",\n    \"**/*.spec.ts\"\n  ],\n  \"references\": [\n    { \"path\": \"../core\" }\n  ]\n}",
      "line_count": 21,
      "word_count": 33,
      "title": "Tsconfig.Json",
      "summary": "// packages/direct-call/tsconfig.json \"extends\": \"../../tsconfig.json\",",
      "key_terms": [
        "packages",
        "composite",
        "exclude",
        "extends",
        "outDir",
        "test",
        "rootDir",
        "spec",
        "ts",
        "core",
        "path",
        "references",
        "direct-call",
        "dist",
        "call",
        "true",
        "include",
        "tsconfig",
        "json",
        "compilerOptions"
      ],
      "timestamp": "2025-12-24T18:56:18.492742"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\direct-call\\tsup.config.ts",
      "content_type": "code",
      "content": "import { defineConfig } from 'tsup';\n\nexport default defineConfig({\n  entry: ['src/index.ts'],\n  format: ['esm', 'cjs'],\n  dts: {\n    compilerOptions: {\n      composite: false,\n      paths: {},\n    },\n  },\n  splitting: false,\n  sourcemap: true,\n  clean: true,\n  outDir: 'dist',\n  external: ['@utcp/sdk'],\n});\n",
      "line_count": 18,
      "word_count": 35,
      "title": "Tsup.Config.Ts",
      "summary": "import { defineConfig } from 'tsup'; export default defineConfig({",
      "key_terms": [
        "from",
        "sourcemap",
        "composite",
        "paths",
        "entry",
        "clean",
        "utcp",
        "outDir",
        "index",
        "format",
        "default",
        "ts",
        "cjs",
        "false",
        "import",
        "export",
        "sdk",
        "dist",
        "splitting",
        "tsup"
      ],
      "timestamp": "2025-12-24T18:56:18.494344"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\direct-call\\src\\decorator.ts",
      "content_type": "code",
      "content": "// packages/direct-call/src/decorator.ts\nimport { CommunicationProtocol, ensureCorePluginsInitialized } from '@utcp/sdk';\nimport { DirectCommunicationProtocol, Callable } from './direct_communication_protocol';\n\n/**\n * Get the singleton instance of DirectCommunicationProtocol from the registry.\n * If it doesn't exist, this will return undefined.\n */\nfunction getDirectProtocol(): DirectCommunicationProtocol | undefined {\n  ensureCorePluginsInitialized();\n  const protocol = CommunicationProtocol.communicationProtocols['direct-call'];\n  if (protocol && protocol instanceof DirectCommunicationProtocol) {\n    return protocol;\n  }\n  return undefined;\n}\n\n/**\n * Register a function as a callable in the DirectCommunicationProtocol.\n * This function can be called at the global level with any function.\n * \n * Note: The toolArgs object properties are spread as separate parameters when calling your function.\n * For example, if toolArgs is { name: 'Alice', age: 30 }, your function will be called with\n * callable('Alice', 30) - NOT callable({ name: 'Alice', age: 30 }).\n * \n * @param callableName The name to register the function under.\n * @param callable The function to register.\n * \n * @example\n * ```typescript\n * // Register a tool function with separate parameters\n * const myTool = addFunctionToUtcpDirectCall('myTool', async (message: string, count: number) => {\n *   return { result: message.repeat(count) };\n * });\n * \n * // Or with a named function\n * async function greet(name: string) {\n *   return `Hello, ${name}!`;\n * }\n * addFunctionToUtcpDirectCall('greet', greet);\n * ```\n */\nexport function addFunctionToUtcpDirectCall<T extends Callable>(callableName: string, callable: T): T {\n  const protocol = getDirectProtocol();\n  if (protocol) {\n    protocol.registerCallable(callableName, callable);\n  } else {\n    // If protocol isn't registered yet, queue it for registration\n    // This will be handled when the protocol is initialized\n    if (!pendingRegistrations.has(callableName)) {\n      pendingRegistrations.set(callableName, callable);\n    }\n  }\n  return callable;\n}\n\n/**\n * Queue of pending callable registrations.\n * These will be registered when the protocol is initialized.\n */\nconst pendingRegistrations = new Map<string, Callable>();\n\n/**\n * Register all pending callables with the DirectCommunicationProtocol.\n * This is called automatically when the plugin is registered.\n */\nexport function registerPendingCallables(): void {\n  const protocol = getDirectProtocol();\n  if (protocol && pendingRegistrations.size > 0) {\n    for (const [name, callable] of pendingRegistrations.entries()) {\n      protocol.registerCallable(name, callable);\n    }\n    pendingRegistrations.clear();\n  }\n}\n\n/**\n * Manually register a callable function.\n * This is an alternative to using addFunctionToUtcpDirectCall.\n * \n * Note: The toolArgs object properties are spread as separate parameters when calling your function.\n * \n * @param name The name to register the callable under.\n * @param callable The function to register.\n * \n * @example\n * ```typescript\n * registerCallable('myTool', async (message: string, value: number) => {\n *   return { result: `${message}: ${value}` };\n * });\n * ```\n */\nexport function registerCallable(name: string, callable: Callable): void {\n  const protocol = getDirectProtocol();\n  if (protocol) {\n    protocol.registerCallable(name, callable);\n  } else {\n    throw new Error('DirectCommunicationProtocol is not registered. Did you import @utcp/direct-call?');\n  }\n}\n\n/**\n * Manually unregister a callable function.\n * \n * @param name The name of the callable to unregister.\n * \n * @example\n * ```typescript\n * unregisterCallable('myTool');\n * ```\n */\nexport function unregisterCallable(name: string): void {\n  const protocol = getDirectProtocol();\n  if (protocol) {\n    protocol.unregisterCallable(name);\n  } else {\n    throw new Error('DirectCommunicationProtocol is not registered. Did you import @utcp/direct-call?');\n  }\n}\n",
      "line_count": 120,
      "word_count": 497,
      "title": "Decorator.Ts",
      "summary": "// packages/direct-call/src/decorator.ts import { CommunicationProtocol, ensureCorePluginsInitialized } from '@utcp/sdk';",
      "key_terms": [
        "unregisterCallable",
        "const",
        "packages",
        "repeat",
        "clear",
        "async",
        "number",
        "singleton",
        "named",
        "If",
        "Queue",
        "Utcp",
        "global",
        "string",
        "Error",
        "has",
        "using",
        "parameters",
        "alternative",
        "if"
      ],
      "timestamp": "2025-12-24T18:56:18.533392"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\direct-call\\src\\direct_call_template.ts",
      "content_type": "code",
      "content": "// packages/direct-call/src/direct_call_template.ts\nimport { z } from 'zod';\nimport { CallTemplate, Serializer } from '@utcp/sdk';\n\n/**\n * Call template for direct callable functions.\n *\n * Allows registering and calling JavaScript/TypeScript functions directly\n * as UTCP tools without the need for external APIs or file-based configurations.\n *\n * Attributes:\n *     call_template_type: Always \"direct-call\" for direct callable templates.\n *     callable_name: The name of the callable function to invoke.\n *     auth: Not applicable for direct calls - always undefined.\n */\nexport interface DirectCallTemplate extends CallTemplate {\n  call_template_type: 'direct-call';\n  callable_name: string;\n  auth?: undefined;\n  allowed_communication_protocols?: string[];\n}\n\n/**\n * Zod schema for DirectCallTemplate.\n */\nexport const DirectCallTemplateSchema: z.ZodType<DirectCallTemplate> = z.object({\n  name: z.string().optional(),\n  call_template_type: z.literal('direct-call'),\n  callable_name: z.string().describe('The name of the callable function to invoke.'),\n  auth: z.undefined().optional(),\n  allowed_communication_protocols: z.array(z.string()).optional().describe('Optional list of allowed communication protocol types for tools within this manual.'),\n}).strict() as z.ZodType<DirectCallTemplate>;\n\n/**\n * Serializer for DirectCallTemplate.\n */\nexport class DirectCallTemplateSerializer extends Serializer<DirectCallTemplate> {\n  /**\n   * Convert a DirectCallTemplate to a dictionary.\n   */\n  toDict(obj: DirectCallTemplate): Record<string, unknown> {\n    return {\n      name: obj.name,\n      call_template_type: obj.call_template_type,\n      callable_name: obj.callable_name,\n      auth: obj.auth,\n      allowed_communication_protocols: obj.allowed_communication_protocols,\n    };\n  }\n\n  /**\n   * Validate and convert a dictionary to a DirectCallTemplate.\n   */\n  validateDict(obj: Record<string, unknown>): DirectCallTemplate {\n    try {\n      return DirectCallTemplateSchema.parse(obj);\n    } catch (e: any) {\n      throw new Error(`Invalid DirectCallTemplate: ${e.message}\\n${e.stack || ''}`);\n    }\n  }\n}\n",
      "line_count": 62,
      "word_count": 211,
      "title": "Direct Call Template.Ts",
      "summary": "// packages/direct-call/src/direct_call_template.ts import { z } from 'zod';",
      "key_terms": [
        "const",
        "packages",
        "DirectCallTemplateSchema",
        "convert",
        "based",
        "Record",
        "list",
        "unknown",
        "string",
        "Error",
        "validateDict",
        "interface",
        "Invalid",
        "applicable",
        "strict",
        "APIs",
        "object",
        "function",
        "undefined",
        "call"
      ],
      "timestamp": "2025-12-24T18:56:18.571128"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\direct-call\\src\\direct_communication_protocol.ts",
      "content_type": "code",
      "content": "/**\n * Direct call communication protocol for UTCP client.\n *\n * This protocol allows direct invocation of JavaScript/TypeScript functions\n * as UTCP tools without the need for external APIs or file-based configurations.\n */\n// packages/direct-call/src/direct_communication_protocol.ts\nimport { \n  CommunicationProtocol, \n  RegisterManualResult, \n  CallTemplate, \n  UtcpManual, \n  UtcpManualSerializer,\n  IUtcpClient \n} from '@utcp/sdk';\nimport { DirectCallTemplate, DirectCallTemplateSchema } from './direct_call_template';\n\n/**\n * Type definition for callable functions.\n * Callables can be sync or async functions that accept arguments and return any value.\n */\nexport type Callable = (...args: any[]) => any | Promise<any>;\n\n/**\n * Communication protocol for direct callable functions.\n */\nexport class DirectCommunicationProtocol implements CommunicationProtocol {\n  /**\n   * Map of callable functions indexed by their callable_name.\n   */\n  private callables: Map<string, Callable> = new Map();\n\n  private _log_info(message: string): void {\n    console.log(`[DirectCommunicationProtocol] ${message}`);\n  }\n\n  private _log_error(message: string): void {\n    console.error(`[DirectCommunicationProtocol Error] ${message}`);\n  }\n\n  /**\n   * Register a callable function.\n   * \n   * @param name The name to register the callable under.\n   * @param callable The function to register.\n   */\n  public registerCallable(name: string, callable: Callable): void {\n    this.callables.set(name, callable);\n    this._log_info(`Registered callable: ${name}`);\n  }\n\n  /**\n   * Unregister a callable function.\n   * \n   * @param name The name of the callable to unregister.\n   */\n  public unregisterCallable(name: string): void {\n    this.callables.delete(name);\n    this._log_info(`Unregistered callable: ${name}`);\n  }\n\n  /**\n   * Get a callable function by name.\n   * \n   * @param name The name of the callable to retrieve.\n   * @returns The callable function or undefined if not found.\n   */\n  public getCallable(name: string): Callable | undefined {\n    return this.callables.get(name);\n  }\n\n  /**\n   * Register a manual by calling the specified callable and expecting a UtcpManual as return.\n   */\n  public async registerManual(caller: IUtcpClient, manualCallTemplate: CallTemplate): Promise<RegisterManualResult> {\n    if (!(manualCallTemplate as any).callable_name) {\n      throw new Error('DirectCommunicationProtocol requires a DirectCallTemplate');\n    }\n\n    const directCallTemplate = DirectCallTemplateSchema.parse(manualCallTemplate);\n    const callableName = directCallTemplate.callable_name;\n\n    this._log_info(`Registering manual from callable '${callableName}'`);\n\n    try {\n      const callable = this.callables.get(callableName);\n      if (!callable) {\n        throw new Error(`Callable '${callableName}' not found. Did you register it?`);\n      }\n\n      // Call the callable and expect a UtcpManual as return\n      const result = await Promise.resolve(callable());\n      \n      // Validate that the result is a valid UtcpManual\n      const utcpManual = new UtcpManualSerializer().validateDict(result);\n\n      this._log_info(`Loaded ${utcpManual.tools.length} tools from callable '${callableName}'`);\n      return {\n        manualCallTemplate,\n        manual: utcpManual,\n        success: true,\n        errors: [],\n      };\n    } catch (error: any) {\n      this._log_error(`Failed to register manual from callable '${callableName}': ${error.stack || error.message}`);\n      return {\n        manualCallTemplate,\n        manual: new UtcpManualSerializer().validateDict({ tools: [] }),\n        success: false,\n        errors: [error.stack || error.message],\n      };\n    }\n  }\n\n  /**\n   * Deregister a manual (no-op for direct calls).\n   */\n  public async deregisterManual(caller: IUtcpClient, manualCallTemplate: CallTemplate): Promise<void> {\n    this._log_info(`Deregistering manual '${manualCallTemplate.name}' (no-op)`);\n  }\n\n  /**\n   * Call a tool by invoking the specified callable with the provided arguments.\n   */\n  public async callTool(caller: IUtcpClient, toolName: string, toolArgs: Record<string, any>, toolCallTemplate: CallTemplate): Promise<any> {\n    if (!(toolCallTemplate as any).callable_name) {\n      throw new Error('DirectCommunicationProtocol requires a DirectCallTemplate for tool calls');\n    }\n\n    const directCallTemplate = DirectCallTemplateSchema.parse(toolCallTemplate);\n    const callableName = directCallTemplate.callable_name;\n\n    this._log_info(`Calling tool '${toolName}' via callable '${callableName}'`);\n\n    try {\n      const callable = this.callables.get(callableName);\n      if (!callable) {\n        throw new Error(`Callable '${callableName}' not found for tool '${toolName}'`);\n      }\n\n      // Call the callable with the tool arguments spread as separate parameters\n      const result = await Promise.resolve(callable(...Object.values(toolArgs)));\n      return result;\n    } catch (error: any) {\n      this._log_error(`Failed to call tool '${toolName}' via callable '${callableName}': ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Streaming variant: calls the callable and yields the result.\n   * If the callable returns an async generator, yields each chunk.\n   * Otherwise, yields the full result as a single chunk.\n   */\n  public async *callToolStreaming(caller: IUtcpClient, toolName: string, toolArgs: Record<string, any>, toolCallTemplate: CallTemplate): AsyncGenerator<any, void, unknown> {\n    if (!(toolCallTemplate as any).callable_name) {\n      throw new Error('DirectCommunicationProtocol requires a DirectCallTemplate for tool calls');\n    }\n\n    const directCallTemplate = DirectCallTemplateSchema.parse(toolCallTemplate);\n    const callableName = directCallTemplate.callable_name;\n\n    this._log_info(`Calling tool '${toolName}' (streaming) via callable '${callableName}'`);\n\n    try {\n      const callable = this.callables.get(callableName);\n      if (!callable) {\n        throw new Error(`Callable '${callableName}' not found for tool '${toolName}'`);\n      }\n\n      // Call the callable with the tool arguments spread as separate parameters\n      const result = await Promise.resolve(callable(...Object.values(toolArgs)));\n\n      // Check if the result is an async generator\n      if (result && typeof result[Symbol.asyncIterator] === 'function') {\n        // Yield each chunk from the async generator\n        for await (const chunk of result) {\n          yield chunk;\n        }\n      } else {\n        // Yield the full result as a single chunk\n        yield result;\n      }\n    } catch (error: any) {\n      this._log_error(`Failed to call tool '${toolName}' (streaming) via callable '${callableName}': ${error.message}`);\n      throw error;\n    }\n  }\n\n  public async close(): Promise<void> {\n    this._log_info('Direct Call Communication Protocol closed.');\n    this.callables.clear();\n  }\n}\n",
      "line_count": 195,
      "word_count": 722,
      "title": "Direct Communication Protocol.Ts",
      "summary": "* Direct call communication protocol for UTCP client. * This protocol allows direct invocation of JavaScript/TypeScript functions",
      "key_terms": [
        "unregisterCallable",
        "close",
        "const",
        "packages",
        "DirectCallTemplateSchema",
        "async",
        "clear",
        "utcpManual",
        "error",
        "If",
        "Type",
        "each",
        "based",
        "Record",
        "Utcp",
        "unknown",
        "private",
        "specified",
        "yield",
        "found"
      ],
      "timestamp": "2025-12-24T18:56:18.612745"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\direct-call\\src\\index.ts",
      "content_type": "code",
      "content": "/**\n * Direct Call Communication Protocol plugin for UTCP.\n */\n// packages/direct-call/src/index.ts\nimport { CommunicationProtocol, CallTemplateSerializer, ensureCorePluginsInitialized } from '@utcp/sdk';\nimport { DirectCallTemplateSerializer } from './direct_call_template';\nimport { DirectCommunicationProtocol } from './direct_communication_protocol';\nimport { registerPendingCallables } from './decorator';\n\n/**\n * Registers the Direct Call protocol's CallTemplate serializer\n * and its CommunicationProtocol implementation.\n * This function is called automatically when the package is imported.\n */\nexport function register(override: boolean = false): void {\n  // Ensure core plugins are initialized first\n  ensureCorePluginsInitialized();\n  \n  // Register the CallTemplate serializer\n  CallTemplateSerializer.registerCallTemplate('direct-call', new DirectCallTemplateSerializer(), override);\n  \n  // Register the CommunicationProtocol instance\n  CommunicationProtocol.communicationProtocols['direct-call'] = new DirectCommunicationProtocol();\n  \n  // Register any pending callables that were decorated before the protocol was initialized\n  registerPendingCallables();\n}\n\n// Automatically register Direct Call plugin on import\nregister();\n\n// Export all public APIs\nexport * from './direct_call_template';\nexport * from './direct_communication_protocol';\nexport * from './decorator';\n",
      "line_count": 36,
      "word_count": 139,
      "title": "Index.Ts",
      "summary": "* Direct Call Communication Protocol plugin for UTCP. // packages/direct-call/src/index.ts",
      "key_terms": [
        "from",
        "Call",
        "src",
        "any",
        "communicationProtocols",
        "packages",
        "decorator",
        "serializer",
        "ensureCorePluginsInitialized",
        "initialized",
        "callables",
        "was",
        "is",
        "automatically",
        "utcp",
        "index",
        "Ensure",
        "Direct",
        "Automatically",
        "register"
      ],
      "timestamp": "2025-12-24T18:56:18.646915"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\direct-call\\tests\\example.test.ts",
      "content_type": "code",
      "content": "/**\n * Example test file demonstrating usage of the direct-call plugin.\n */\nimport { describe, test, expect, beforeAll } from 'bun:test';\nimport { UtcpClient, CommunicationProtocol } from '@utcp/sdk';\nimport { addFunctionToUtcpDirectCall, registerCallable, DirectCallTemplate } from '../src';\nimport type { UtcpManual } from '@utcp/sdk';\n\n// Example: Using addFunctionToUtcpDirectCall to register a function that returns a manual\nconst getTestManual = addFunctionToUtcpDirectCall('testManual', async (): Promise<UtcpManual> => {\n  return {\n    utcp_version: '1.0.0',\n    manual_version: '1.0.0',\n    tools: [\n      {\n        name: 'greet',\n        description: 'Greets a person',\n        inputs: {\n          type: 'object',\n          properties: {\n            name: { type: 'string', description: 'Name to greet' }\n          },\n          required: ['name']\n        },\n        outputs: {\n          type: 'string',\n          description: 'Greeting message'\n        },\n        tags: [],\n        tool_call_template: {\n          call_template_type: 'direct-call',\n          callable_name: 'greet'\n        }\n      },\n      {\n        name: 'add',\n        description: 'Adds two numbers',\n        inputs: {\n          type: 'object',\n          properties: {\n            a: { type: 'number' },\n            b: { type: 'number' }\n          },\n          required: ['a', 'b']\n        },\n        outputs: {\n          type: 'number',\n          description: 'Sum of the two numbers'\n        },\n        tags: [],\n        tool_call_template: {\n          call_template_type: 'direct-call',\n          callable_name: 'add'\n        }\n      }\n    ]\n  };\n});\n\n// Example: Using addFunctionToUtcpDirectCall to register tool functions\nconst greetTool = addFunctionToUtcpDirectCall('greet', async (name: string): Promise<string> => {\n  return `Hello, ${name}!`;\n});\n\nconst addTool = addFunctionToUtcpDirectCall('add', async (a: number, b: number): Promise<number> => {\n  return a + b;\n});\n\ndescribe('Direct Call Plugin', () => {\n  let client: UtcpClient;\n\n  beforeAll(async () => {\n    client = await UtcpClient.create(process.cwd());\n  });\n\n  test('should register manual from callable', async () => {\n    const callTemplate: DirectCallTemplate = {\n      name: 'testManual',\n      call_template_type: 'direct-call',\n      callable_name: 'testManual'\n    };\n\n    const result = await client.registerManual(callTemplate);\n    \n    expect(result.success).toBe(true);\n    expect(result.manual).toBeDefined();\n    expect(result.manual.tools.length).toBe(2);\n  });\n\n  test('should call tool via client - greet', async () => {\n    // After registering the manual, tools are available by their full name\n    const result = await client.callTool('testManual.greet', { name: 'Alice' });\n    \n    expect(result).toBe('Hello, Alice!');\n  });\n\n  test('should call tool via client - add', async () => {\n    // After registering the manual, tools are available by their full name\n    const result = await client.callTool('testManual.add', { a: 5, b: 3 });\n    \n    expect(result).toBe(8);\n  });\n\n  test('should call protocol directly via call template', async () => {\n    // Register a callable manually\n    registerCallable('manualTool', async (value: number) => {\n      return value * 2;\n    });\n\n    const callTemplate: DirectCallTemplate = {\n      name: 'manualTool',\n      call_template_type: 'direct-call',\n      callable_name: 'manualTool'\n    };\n\n    // Get the protocol and call it directly\n    const protocol = CommunicationProtocol.communicationProtocols['direct-call'];\n    const result = await protocol.callTool(client, 'manualTool', { value: 21 }, callTemplate);\n    \n    expect(result).toBe(42);\n  });\n\n  test('should handle streaming', async () => {\n    // Register a streaming callable\n    registerCallable('streamingTool', async function* (count: number) {\n      for (let i = 0; i < count; i++) {\n        yield i;\n      }\n    });\n\n    const callTemplate: DirectCallTemplate = {\n      name: 'streamingTool',\n      call_template_type: 'direct-call',\n      callable_name: 'streamingTool'\n    };\n\n    const chunks: number[] = [];\n    // Get the protocol and call streaming directly\n    const protocol = CommunicationProtocol.communicationProtocols['direct-call'];\n    for await (const chunk of protocol.callToolStreaming(client, 'streamingTool', { count: 5 }, callTemplate)) {\n      chunks.push(chunk);\n    }\n    \n    expect(chunks).toEqual([0, 1, 2, 3, 4]);\n  });\n});\n",
      "line_count": 147,
      "word_count": 473,
      "title": "Example.Test.Ts",
      "summary": "* Example test file demonstrating usage of the direct-call plugin. import { describe, test, expect, beforeAll } from 'bun:test';",
      "key_terms": [
        "const",
        "async",
        "number",
        "After",
        "Utcp",
        "testManual",
        "callTemplate",
        "available",
        "yield",
        "usage",
        "string",
        "beforeAll",
        "let",
        "that",
        "Greets",
        "toEqual",
        "Hello",
        "streaming",
        "true",
        "object"
      ],
      "timestamp": "2025-12-24T18:56:18.679868"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\dotenv-loader\\package.json",
      "content_type": "configuration",
      "content": "{\n  \"name\": \"@utcp/dotenv-loader\",\n  \"version\": \"1.1.0\",\n  \"description\": \"DotEnv Variable Loader plugin for UTCP\",\n  \"main\": \"dist/index.cjs\",\n  \"module\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"type\": \"module\",\n  \"license\": \"MPL-2.0\",\n  \"author\": \"UTCP Contributors\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/universal-tool-calling-protocol/typescript-utcp.git\",\n    \"directory\": \"packages/dotenv-loader\"\n  },\n  \"keywords\": [\n    \"utcp\",\n    \"dotenv\",\n    \"environment\",\n    \"variables\",\n    \"configuration\"\n  ],\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"scripts\": {\n    \"prebuild\": \"rm -rf dist || rmdir /s /q dist || true\",\n    \"build\": \"tsup\"\n  },\n  \"files\": [\n    \"dist\",\n    \"README.md\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\",\n      \"require\": \"./dist/index.cjs\",\n      \"default\": \"./dist/index.js\"\n    }\n  },\n  \"dependencies\": {\n    \"dotenv\": \"^17.2.1\",\n    \"zod\": \"^3.23.8\"\n  },\n  \"peerDependencies\": {\n    \"@utcp/sdk\": \"^1.1.0\"\n  },\n  \"devDependencies\": {\n    \"bun-types\": \"latest\",\n    \"typescript\": \"^5.0.0\"\n  }\n}\n",
      "line_count": 54,
      "word_count": 102,
      "title": "Package.Json",
      "summary": "\"name\": \"@utcp/dotenv-loader\", \"version\": \"1.1.0\",",
      "key_terms": [
        "loader",
        "build",
        "packages",
        "calling-protocol",
        "variables",
        "scripts",
        "universal",
        "md",
        "module",
        "zod",
        "utcp",
        "index",
        "calling",
        "MPL",
        "tool",
        "configuration",
        "dependencies",
        "type",
        "github",
        "public"
      ],
      "timestamp": "2025-12-24T18:56:18.708428"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\dotenv-loader\\README.md",
      "content_type": "documentation",
      "content": "# @utcp/dotenv-loader\n\nDotEnv Variable Loader plugin for the Universal Tool Calling Protocol (UTCP).\n\n## Overview\n\nThis plugin provides support for loading environment variables from `.env` files in UTCP applications. It's useful for Node.js environments where you want to manage configuration through environment files.\n\n## Installation\n\n```bash\nnpm install @utcp/dotenv-loader\n```\n\n## Usage\n\nThe plugin automatically registers itself when imported:\n\n```typescript\nimport '@utcp/dotenv-loader';\nimport { UtcpClient } from '@utcp/sdk';\n\n// Now you can use dotenv variable loaders in your UTCP configuration\nconst config = {\n  load_variables_from: [\n    {\n      variable_loader_type: 'dotenv',\n      env_file_path: '.env'\n    }\n  ]\n};\n\nconst client = await UtcpClient.create(process.cwd(), config);\n```\n\n## Configuration\n\nThe DotEnv Variable Loader accepts the following configuration:\n\n- `variable_loader_type`: Must be set to `'dotenv'`\n- `env_file_path`: Path to the `.env` file (relative to the root directory)\n\n## Features\n\n- **Automatic Registration**: Plugin registers itself on import\n- **Dynamic Loading**: Reads .env file on every variable access\n- **Silent Failure**: Returns `null` if file doesn't exist or can't be read\n- **Standard .env Format**: Supports standard dotenv file format\n\n## Example .env File\n\n```env\nAPI_KEY=your-api-key-here\nDATABASE_URL=postgresql://localhost:5432/mydb\nDEBUG=true\n```\n\n## Note\n\nThis plugin requires Node.js as it uses the `fs` module. It's not suitable for browser environments. For browser applications, use inline variable configuration instead.\n\n## License\n\nMPL-2.0\n",
      "line_count": 65,
      "word_count": 210,
      "title": "@utcp/dotenv-loader",
      "summary": "DotEnv Variable Loader plugin for the Universal Tool Calling Protocol (UTCP). This plugin provides support for loading environment variables from `.env` files in UTCP applications. It's useful for Nod...",
      "key_terms": [
        "null",
        "const",
        "File",
        "localhost",
        "through",
        "format",
        "uses",
        "Reads",
        "loaders",
        "Utcp",
        "It",
        "registers",
        "Calling",
        "if",
        "Features",
        "Must",
        "Note",
        "true",
        "Variable",
        "files"
      ],
      "timestamp": "2025-12-24T18:56:18.740043"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\dotenv-loader\\tsconfig.json",
      "content_type": "configuration",
      "content": "{\n  \"extends\": \"../../tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"composite\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\", \"tests\"],\n  \"references\": [\n    { \"path\": \"../core\" }\n  ]\n}\n",
      "line_count": 14,
      "word_count": 26,
      "title": "Tsconfig.Json",
      "summary": "\"extends\": \"../../tsconfig.json\", \"compilerOptions\": {",
      "key_terms": [
        "rootDir",
        "src",
        "composite",
        "exclude",
        "include",
        "references",
        "tsconfig",
        "path",
        "json",
        "core",
        "extends",
        "compilerOptions",
        "tests",
        "dist",
        "outDir",
        "true"
      ],
      "timestamp": "2025-12-24T18:56:18.756026"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\dotenv-loader\\tsup.config.ts",
      "content_type": "code",
      "content": "import { defineConfig } from 'tsup';\n\nexport default defineConfig({\n  entry: ['src/index.ts'],\n  format: ['esm', 'cjs'],\n  dts: {\n    compilerOptions: {\n      composite: false,\n      paths: {},\n    },\n  },\n  splitting: false,\n  sourcemap: true,\n  clean: true,\n  outDir: 'dist',\n  external: ['@utcp/sdk', 'dotenv', 'zod'],\n});\n",
      "line_count": 18,
      "word_count": 37,
      "title": "Tsup.Config.Ts",
      "summary": "import { defineConfig } from 'tsup'; export default defineConfig({",
      "key_terms": [
        "from",
        "sourcemap",
        "composite",
        "paths",
        "entry",
        "zod",
        "clean",
        "utcp",
        "outDir",
        "index",
        "format",
        "default",
        "ts",
        "cjs",
        "false",
        "dotenv",
        "import",
        "export",
        "sdk",
        "dist"
      ],
      "timestamp": "2025-12-24T18:56:18.772687"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\dotenv-loader\\src\\dotenv_variable_loader.ts",
      "content_type": "code",
      "content": "// packages/dotenv-loader/src/dotenv_variable_loader.ts\nimport { z } from 'zod';\nimport { VariableLoader, Serializer } from '@utcp/sdk';\nimport { promises as fs } from 'fs';\nimport { parse as parseDotEnv } from 'dotenv';\nimport * as path from 'path';\n\n/**\n * Configuration schema for DotEnv variable loader.\n * Loads variables from a .env file.\n */\nconst DotEnvVariableLoaderConfigSchema = z.object({\n  variable_loader_type: z.literal('dotenv'),\n  env_file_path: z.string().describe('Path to the .env file to load variables from.'),\n}).passthrough();\n\ntype DotEnvVariableLoaderConfig = z.infer<typeof DotEnvVariableLoaderConfigSchema>;\n\n/**\n * Variable loader that loads environment variables from a .env file.\n * The file is read on every get() call to support change detection.\n */\nexport class DotEnvVariableLoader implements VariableLoader {\n  variable_loader_type: 'dotenv' = 'dotenv';\n  env_file_path: string;\n\n  constructor(env_file_path: string) {\n    this.env_file_path = env_file_path;\n  }\n\n  /**\n   * Retrieves a variable value from the .env file.\n   * The file is read on every call to support runtime changes.\n   * @param key Variable name to retrieve.\n   * @returns Variable value if found, null otherwise.\n   */\n  async get(key: string): Promise<string | null> {\n    try {\n      const envFilePath = path.resolve(process.cwd(), this.env_file_path);\n      const envContent = await fs.readFile(envFilePath, 'utf-8');\n      const envVars = parseDotEnv(envContent);\n      return envVars[key] ?? null;\n    } catch (e: any) {\n      // Silently return null if file doesn't exist or can't be read\n      return null;\n    }\n  }\n}\n\n/**\n * Serializer for DotEnvVariableLoader objects.\n */\nexport class DotEnvVariableLoaderSerializer extends Serializer<DotEnvVariableLoader> {\n  toDict(obj: DotEnvVariableLoader): Record<string, unknown> {\n    return {\n      variable_loader_type: obj.variable_loader_type,\n      env_file_path: obj.env_file_path,\n    };\n  }\n\n  validateDict(obj: Record<string, unknown>): DotEnvVariableLoader {\n    try {\n      const validated = new DotEnvVariableLoader(DotEnvVariableLoaderConfigSchema.parse(obj).env_file_path);\n      return validated;\n    } catch (e) {\n      if (e instanceof z.ZodError) {\n        throw new Error(`Invalid DotEnvVariableLoader configuration: ${e.message}`);\n      }\n      throw new Error(\"Unexpected error during validation\");\n    }\n  }\n}\n",
      "line_count": 73,
      "word_count": 273,
      "title": "Dotenv Variable Loader.Ts",
      "summary": "// packages/dotenv-loader/src/dotenv_variable_loader.ts import { z } from 'zod';",
      "key_terms": [
        "null",
        "const",
        "packages",
        "constructor",
        "async",
        "error",
        "envContent",
        "Record",
        "during",
        "unknown",
        "found",
        "string",
        "Error",
        "passthrough",
        "path",
        "validateDict",
        "if",
        "that",
        "Unexpected",
        "load"
      ],
      "timestamp": "2025-12-24T18:56:18.815124"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\dotenv-loader\\src\\index.ts",
      "content_type": "code",
      "content": "/**\n * DotEnv Variable Loader plugin for UTCP.\n * Provides support for loading environment variables from .env files.\n */\n// packages/dotenv-loader/src/index.ts\nimport { VariableLoaderSerializer, ensureCorePluginsInitialized } from '@utcp/sdk';\nimport { DotEnvVariableLoaderSerializer } from './dotenv_variable_loader';\n\n/**\n * Registers the DotEnv Variable Loader with the UTCP plugin system.\n * This function is called automatically when the package is imported.\n * @param override Whether to override an existing registration\n */\nexport function register(override: boolean = false): void {\n  // Ensure core plugins are initialized first\n  ensureCorePluginsInitialized();\n  \n  // Register the DotEnv Variable Loader serializer\n  VariableLoaderSerializer.registerVariableLoader('dotenv', new DotEnvVariableLoaderSerializer(), override);\n}\n\n// Automatically register DotEnv loader plugin on import\nregister();\n\n// Export all public APIs\nexport * from './dotenv_variable_loader';\n",
      "line_count": 27,
      "word_count": 113,
      "title": "Index.Ts",
      "summary": "* DotEnv Variable Loader plugin for UTCP. * Provides support for loading environment variables from .env files.",
      "key_terms": [
        "from",
        "loader",
        "packages",
        "env",
        "serializer",
        "ensureCorePluginsInitialized",
        "variables",
        "initialized",
        "VariableLoaderSerializer",
        "support",
        "is",
        "automatically",
        "utcp",
        "index",
        "registerVariableLoader",
        "with",
        "Ensure",
        "Automatically",
        "register",
        "public"
      ],
      "timestamp": "2025-12-24T18:56:18.835560"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\file\\package.json",
      "content_type": "configuration",
      "content": "{\n  \"name\": \"@utcp/file\",\n  \"version\": \"1.1.0\",\n  \"description\": \"File system protocol for UTCP - reads UTCP manuals from local files (Node.js only)\",\n  \"main\": \"dist/index.cjs\",\n  \"module\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"type\": \"module\",\n  \"license\": \"MPL-2.0\",\n  \"author\": \"UTCP Contributors\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/universal-tool-calling-protocol/typescript-utcp.git\",\n    \"directory\": \"packages/file\"\n  },\n  \"keywords\": [\n    \"utcp\",\n    \"universal-tool-calling-protocol\",\n    \"tools\",\n    \"api\",\n    \"typescript\",\n    \"tool calling\",\n    \"file\",\n    \"agent\",\n    \"ai\",\n    \"llm\"\n  ],\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"scripts\": {\n    \"build\": \"tsup\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\",\n      \"require\": \"./dist/index.cjs\",\n      \"default\": \"./dist/index.js\"\n    }\n  },\n  \"dependencies\": {\n    \"@utcp/sdk\": \"^1.1.0\",\n    \"@utcp/http\": \"^1.1.0\",\n    \"js-yaml\": \"^4.1.0\"\n  },\n  \"devDependencies\": {\n    \"bun-types\": \"latest\",\n    \"typescript\": \"^5.0.0\",\n    \"@types/bun\": \"latest\"\n  }\n}\n",
      "line_count": 56,
      "word_count": 103,
      "title": "Package.Json",
      "summary": "\"name\": \"@utcp/file\", \"version\": \"1.1.0\",",
      "key_terms": [
        "from",
        "build",
        "packages",
        "calling-protocol",
        "File",
        "scripts",
        "universal",
        "yaml",
        "module",
        "utcp",
        "index",
        "calling",
        "MPL",
        "file",
        "js-yaml",
        "tool",
        "only",
        "dependencies",
        "type",
        "url"
      ],
      "timestamp": "2025-12-24T18:56:18.867445"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\file\\README.md",
      "content_type": "documentation",
      "content": "# @utcp/file: File System Communication Protocol Plugin for UTCP\n\nThe `@utcp/file` package provides a straightforward communication protocol for the Universal Tool Calling Protocol (UTCP) client to interact with local files. It's primarily used for loading static UTCP Manuals or OpenAPI specifications directly from local JSON or YAML files, without needing a network request. **Node.js only** - requires file system access.\n\n## Features\n\n*   **File `CallTemplate`**: Defines the configuration for file-based tool definitions (`FileCallTemplate`), specifying the `file_path` to the local manual or spec. Authentication is explicitly `undefined` as file access typically relies on local permissions.\n*   **`FileCommunicationProtocol`**: Implements the `CommunicationProtocol` interface for file-based interactions:\n    *   **Tool Discovery**: Reads and parses local JSON or YAML files. It can directly interpret UTCP Manuals or automatically convert OpenAPI (v2/v3) specifications into UTCP `Tool` definitions (by utilizing the `OpenApiConverter` from `@utcp/http`).\n    *   **Tool Execution**: When a tool associated with a `FileCallTemplate` is \"called\", the protocol simply returns the raw content of the configured `file_path` as a string. This is useful for retrieving static data, configuration snippets, or even full documentation embedded as a tool.\n    *   **Stateless**: This protocol does not maintain any persistent connections or external resources, making it very lightweight.\n    *   **Path Resolution**: Resolves relative file paths using the `UtcpClient`'s configured root directory (`_rootPath`), ensuring flexibility in project structure.\n\n## Installation\n\n```bash\nbun add @utcp/file @utcp/sdk\n\n# Or using npm\nnpm install @utcp/file @utcp/sdk\n```\n\nNote: `@utcp/sdk` is a peer dependency. `@utcp/http` and `js-yaml` dependencies are included automatically for OpenAPI conversion and YAML parsing.\n\n## Usage\n\nThe File plugin registers automatically when you import it—no manual registration needed. Simply import from `@utcp/file` to enable file system support.\n\n```typescript\n// From your application's entry point\n\nimport { UtcpClient } from '@utcp/sdk';\nimport { FileCallTemplateSerializer } from '@utcp/file';\nimport * as path from 'path';\nimport * as fs from 'fs/promises'; // For creating dummy files\n\nasync function main() {\n  // Create a dummy UTCP manual file for demonstration\n  const manualContent = {\n    \"utcp_version\": \"1.0.0\",\n    \"manual_version\": \"1.0.0\",\n    \"tools\": [\n      {\n        \"name\": \"read_static_data\",\n        \"description\": \"Reads static data from a local file.\",\n        \"inputs\": {},\n        \"outputs\": { \"type\": \"string\", \"description\": \"The content of the file.\" },\n        \"tags\": [\"file\", \"static\"],\n        \"tool_call_template\": {\n          \"name\": \"static_file_reader\",\n          \"call_template_type\": \"file\",\n          \"file_path\": \"./config/static_data.txt\" // The file path for the tool's content\n        }\n      },\n      {\n        \"name\": \"describe_project\",\n        \"description\": \"Provides a description of the project from a local markdown file.\",\n        \"inputs\": {},\n        \"outputs\": { \"type\": \"string\" },\n        \"tags\": [\"documentation\"],\n        \"tool_call_template\": {\n          \"name\": \"project_readme_reader\",\n          \"call_template_type\": \"file\",\n          \"file_path\": \"./README.md\" // Example: reads the project's README\n        }\n      }\n    ]\n  };\n  const configDirPath = path.resolve(process.cwd(), './config');\n  await fs.mkdir(configDirPath, { recursive: true });\n\n  const dummyManualPath = path.resolve(configDirPath, './my_local_manual.json');\n  await fs.writeFile(dummyManualPath, JSON.stringify(manualContent, null, 2));\n\n  const staticDataPath = path.resolve(configDirPath, './static_data.txt');\n  await fs.writeFile(staticDataPath, 'Hello from UTCP File Plugin static data!');\n\n  // Define a CallTemplate to load the local UTCP manual from the 'config' directory\n  const serializer = new FileCallTemplateSerializer();\n  const fileCallTemplate = serializer.validateDict({\n    name: 'local_manual_loader',\n    call_template_type: 'file',\n    file_path: './config/my_local_manual.json', // Path relative to client's root_path\n  });\n\n  const client = await UtcpClient.create(process.cwd(), {\n    manual_call_templates: [fileCallTemplate] // Register the file manual at client startup\n  });\n\n  console.log('File Plugin active. Searching for tools...');\n\n  // Example: Call 'read_static_data' tool. This will return the content of 'static_data.txt'.\n  try {\n    const staticDataReaderTool = await client.searchTools('read static data');\n    if (staticDataReaderTool.length > 0) {\n      const result = await client.callTool(staticDataReaderTool.name, {});\n      console.log('Result from \"read_static_data\" tool:', result);\n    }\n  } catch (error) {\n    console.error('Error calling \"read_static_data\" tool:', error);\n  }\n\n  // Example: Call 'describe_project' tool. This will return the content of the project's README.md.\n  try {\n    const projectDescTool = await client.searchTools('project description');\n    if (projectDescTool.length > 0) {\n      const result = await client.callTool(projectDescTool.name, {});\n      console.log('Result from \"describe_project\" tool (first 100 chars):', String(result).substring(0, 100) + '...');\n    }\n  } catch (error) {\n    console.error('Error calling \"describe_project\" tool:', error);\n  } finally {\n    // Clean up dummy files\n    await fs.unlink(dummyManualPath);\n    await fs.unlink(staticDataPath);\n    await fs.rmdir(configDirPath); // Remove the config directory\n  }\n\n  await client.close(); // No-op for file protocol, but good practice\n}\n\nmain().catch(console.error);\n```\n\n## Comparison with @utcp/text\n\n| Feature | @utcp/file | @utcp/text |\n|---------|------------|-----------|\n| Browser compatible | ❌ No | ✅ Yes |\n| Node.js compatible | ✅ Yes | ✅ Yes |\n| File system access | ✅ Yes | ❌ No |\n| Direct content | ❌ No | ✅ Yes |\n| Use case | Server-side file reading | Web apps, inline content |\n\n## Development\n\nRefer to the root `README.md` for monorepo development and testing instructions.\n",
      "line_count": 138,
      "word_count": 727,
      "title": "@utcp/file: File System Communication Protocol Plugin for UTCP",
      "summary": "The `@utcp/file` package provides a straightforward communication protocol for the Universal Tool Calling Protocol (UTCP) client to interact with local files. It's primarily used for loading static UT...",
      "key_terms": [
        "reading",
        "close",
        "project",
        "const",
        "Result",
        "maintain",
        "paths",
        "entry",
        "async",
        "File",
        "error",
        "chars",
        "convert",
        "yaml",
        "md",
        "based",
        "Refer",
        "compatible",
        "unlink",
        "Utcp"
      ],
      "timestamp": "2025-12-24T18:56:18.899424"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\file\\tsconfig.json",
      "content_type": "configuration",
      "content": "// packages/file/tsconfig.json\n{\n  \"extends\": \"../../tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"composite\": true\n  },\n  \"include\": [\n    \"src/**/*\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"**/*.test.ts\",\n    \"**/*.spec.ts\"\n  ],\n  \"references\": [\n    { \"path\": \"../core\" },\n    { \"path\": \"../http\" } \n  ]\n}",
      "line_count": 22,
      "word_count": 37,
      "title": "Tsconfig.Json",
      "summary": "// packages/file/tsconfig.json \"extends\": \"../../tsconfig.json\",",
      "key_terms": [
        "packages",
        "composite",
        "exclude",
        "extends",
        "outDir",
        "file",
        "test",
        "rootDir",
        "spec",
        "ts",
        "core",
        "path",
        "references",
        "dist",
        "http",
        "true",
        "include",
        "tsconfig",
        "json",
        "compilerOptions"
      ],
      "timestamp": "2025-12-24T18:56:18.932168"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\file\\tsup.config.ts",
      "content_type": "code",
      "content": "import { defineConfig } from 'tsup';\n\nexport default defineConfig({\n  entry: ['src/index.ts'],\n  format: ['esm', 'cjs'],\n  dts: {\n    compilerOptions: {\n      composite: false,\n      paths: {},\n    },\n  },\n  splitting: false,\n  sourcemap: true,\n  clean: true,\n  outDir: 'dist',\n  external: ['@utcp/sdk', '@utcp/http', 'js-yaml'],\n});\n",
      "line_count": 18,
      "word_count": 37,
      "title": "Tsup.Config.Ts",
      "summary": "import { defineConfig } from 'tsup'; export default defineConfig({",
      "key_terms": [
        "from",
        "sourcemap",
        "composite",
        "paths",
        "entry",
        "yaml",
        "clean",
        "utcp",
        "outDir",
        "index",
        "format",
        "js-yaml",
        "default",
        "ts",
        "cjs",
        "false",
        "import",
        "export",
        "sdk",
        "js"
      ],
      "timestamp": "2025-12-24T18:56:18.947353"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\file\\src\\file_call_template.ts",
      "content_type": "code",
      "content": "// packages/file/src/file_call_template.ts\nimport { z } from 'zod';\nimport { CallTemplate } from '@utcp/sdk';\nimport { Auth, AuthSchema, AuthSerializer } from '@utcp/sdk';\nimport { Serializer } from '@utcp/sdk';\n\n/**\n * REQUIRED\n * Call template for file-based manuals and tools.\n *\n * Reads UTCP manuals or tool definitions from local JSON/YAML files.\n * Useful for static tool configurations or environments where manuals are distributed as files.\n * For direct text content, use @utcp/text instead.\n *\n * Attributes:\n *     call_template_type: Always \"file\" for file call templates.\n *     file_path: Path to the file containing the UTCP manual or tool definitions (required).\n *     auth: Always undefined - file call templates don't support authentication for file access.\n *     auth_tools: Optional authentication to apply to generated tools from OpenAPI specs.\n */\nexport interface FileCallTemplate extends CallTemplate {\n  call_template_type: 'file';\n  file_path: string;\n  auth?: undefined;\n  auth_tools?: Auth | null;\n  allowed_communication_protocols?: string[];\n}\n\n/**\n * Zod schema for FileCallTemplate.\n */\nexport const FileCallTemplateSchema: z.ZodType<FileCallTemplate> = z.object({\n  name: z.string().optional(),\n  call_template_type: z.literal('file'),\n  file_path: z.string().describe('The path to the file containing the UTCP manual or tool definitions.'),\n  auth: z.undefined().optional(),\n  auth_tools: AuthSchema.nullable().optional().transform((val) => {\n    if (val === null || val === undefined) return null;\n    if (typeof val === 'object' && 'auth_type' in val) {\n      return new AuthSerializer().validateDict(val as any);\n    }\n    return val as Auth;\n  }).describe('Authentication to apply to generated tools from OpenAPI specs.'),\n  allowed_communication_protocols: z.array(z.string()).optional().describe('Optional list of allowed communication protocol types for tools within this manual.'),\n}).strict() as z.ZodType<FileCallTemplate>;\n\n/**\n * REQUIRED\n * Serializer for FileCallTemplate.\n */\nexport class FileCallTemplateSerializer extends Serializer<FileCallTemplate> {\n  /**\n   * REQUIRED\n   * Convert a FileCallTemplate to a dictionary.\n   */\n  toDict(obj: FileCallTemplate): Record<string, unknown> {\n    return {\n      name: obj.name,\n      call_template_type: obj.call_template_type,\n      file_path: obj.file_path,\n      auth: obj.auth,\n      auth_tools: obj.auth_tools ? new AuthSerializer().toDict(obj.auth_tools) : null,\n      allowed_communication_protocols: obj.allowed_communication_protocols,\n    };\n  }\n\n  /**\n   * REQUIRED\n   * Validate and convert a dictionary to a FileCallTemplate.\n   */\n  validateDict(obj: Record<string, unknown>): FileCallTemplate {\n    try {\n      return FileCallTemplateSchema.parse(obj);\n    } catch (e: any) {\n      throw new Error(`Invalid FileCallTemplate: ${e.message}\\n${e.stack || ''}`);\n    }\n  }\n}\n",
      "line_count": 79,
      "word_count": 323,
      "title": "File Call Template.Ts",
      "summary": "// packages/file/src/file_call_template.ts import { z } from 'zod';",
      "key_terms": [
        "nullable",
        "null",
        "const",
        "packages",
        "REQUIRED",
        "convert",
        "based",
        "Record",
        "list",
        "Reads",
        "unknown",
        "string",
        "Error",
        "distributed",
        "path",
        "validateDict",
        "if",
        "interface",
        "Invalid",
        "strict"
      ],
      "timestamp": "2025-12-24T18:56:18.979151"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\file\\src\\file_communication_protocol.ts",
      "content_type": "code",
      "content": "/**\n * File communication protocol for UTCP client.\n *\n * This protocol reads UTCP manuals (or OpenAPI specs) from local files to register\n * tools. It does not maintain any persistent connections.\n * For direct text content, use @utcp/text instead.\n */\n// packages/file/src/file_communication_protocol.ts\nimport { promises as fs } from 'fs';\nimport * as path from 'path';\nimport * as yaml from 'js-yaml';\nimport { CommunicationProtocol, RegisterManualResult, CallTemplate, UtcpManual, UtcpManualSerializer, IUtcpClient } from '@utcp/sdk';\nimport { OpenApiConverter } from '@utcp/http';\nimport { FileCallTemplate, FileCallTemplateSchema } from './file_call_template';\n\n/**\n * REQUIRED\n * Communication protocol for file-based UTCP manuals and tools.\n */\nexport class FileCommunicationProtocol implements CommunicationProtocol {\n  private _log_info(message: string): void {\n    console.log(`[FileCommunicationProtocol] ${message}`);\n  }\n\n  private _log_error(message: string): void {\n    console.error(`[FileCommunicationProtocol Error] ${message}`);\n  }\n\n  /**\n   * REQUIRED\n   * Register a file manual and return its tools as a UtcpManual.\n   */\n  public async registerManual(caller: IUtcpClient, manualCallTemplate: CallTemplate): Promise<RegisterManualResult> {\n    const fileCallTemplate = FileCallTemplateSchema.parse(manualCallTemplate);\n\n    try {\n      let filePath = path.resolve(fileCallTemplate.file_path);\n      if (!path.isAbsolute(fileCallTemplate.file_path) && caller.root_dir) {\n        filePath = path.resolve(caller.root_dir, fileCallTemplate.file_path);\n      }\n      \n      this._log_info(`Reading manual from '${filePath}'`);\n\n      // Check if file exists\n      try {\n        await fs.access(filePath);\n      } catch (err: any) {\n        throw new Error(`ENOENT: no such file or directory, open '${filePath}'`);\n      }\n\n      const content = await fs.readFile(filePath, 'utf-8');\n      const fileExt = path.extname(filePath).toLowerCase();\n      let data: any;\n\n      // Parse based on extension\n      if (fileExt === '.yaml' || fileExt === '.yml') {\n        data = yaml.load(content);\n      } else {\n        // Try JSON\n        data = JSON.parse(content);\n      }\n\n      let utcpManual: UtcpManual;\n      if (data && typeof data === 'object' && (data.openapi || data.swagger || data.paths)) {\n        this._log_info('Detected OpenAPI specification. Converting to UTCP manual.');\n        const converter = new OpenApiConverter(data, {\n          specUrl: `file://${filePath}`,\n          callTemplateName: fileCallTemplate.name,\n          authTools: fileCallTemplate.auth_tools || undefined,\n        });\n        utcpManual = converter.convert();\n      } else {\n        // Try to validate as UTCP manual directly\n        utcpManual = new UtcpManualSerializer().validateDict(data);\n      }\n\n      this._log_info(`Loaded ${utcpManual.tools.length} tools from ${filePath}`);\n      return {\n        manualCallTemplate,\n        manual: utcpManual,\n        success: true,\n        errors: [],\n      };\n    } catch (error: any) {\n      const source = fileCallTemplate.file_path || 'unknown';\n      this._log_error(`Failed to parse manual from '${source}': ${error.stack || error.message}`);\n      return {\n        manualCallTemplate,\n        manual: new UtcpManualSerializer().validateDict({ tools: [] }),\n        success: false,\n        errors: [error.stack || error.message],\n      };\n    }\n  }\n\n  /**\n   * REQUIRED\n   * Deregister a file manual (no-op).\n   */\n  public async deregisterManual(caller: IUtcpClient, manualCallTemplate: CallTemplate): Promise<void> {\n    this._log_info(`Deregistering file manual '${manualCallTemplate.name}' (no-op)`);\n  }\n\n  /**\n   * REQUIRED\n   * Call a tool: for file templates, return content from the file path.\n   */\n  public async callTool(caller: IUtcpClient, toolName: string, toolArgs: Record<string, any>, toolCallTemplate: CallTemplate): Promise<any> {\n    const fileCallTemplate = FileCallTemplateSchema.parse(toolCallTemplate);\n\n    let filePath = path.resolve(fileCallTemplate.file_path);\n    if (!path.isAbsolute(fileCallTemplate.file_path) && caller.root_dir) {\n      filePath = path.resolve(caller.root_dir, fileCallTemplate.file_path);\n    }\n\n    this._log_info(`Reading content from '${filePath}' for tool '${toolName}'`);\n\n    try {\n      const content = await fs.readFile(filePath, 'utf-8');\n      return content;\n    } catch (error: any) {\n      if (error.code === 'ENOENT') {\n        this._log_error(`File not found for tool '${toolName}': ${filePath}`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * REQUIRED\n   * Streaming variant: yields the full content as a single chunk.\n   */\n  public async *callToolStreaming(caller: IUtcpClient, toolName: string, toolArgs: Record<string, any>, toolCallTemplate: CallTemplate): AsyncGenerator<any, void, unknown> {\n    const result = await this.callTool(caller, toolName, toolArgs, toolCallTemplate);\n    yield result;\n  }\n\n  public async close(): Promise<void> {\n    this._log_info('File Communication Protocol closed (no-op).');\n  }\n}\n",
      "line_count": 142,
      "word_count": 511,
      "title": "File Communication Protocol.Ts",
      "summary": "* File communication protocol for UTCP client. * This protocol reads UTCP manuals (or OpenAPI specs) from local files to register",
      "key_terms": [
        "open",
        "close",
        "const",
        "packages",
        "maintain",
        "paths",
        "REQUIRED",
        "async",
        "utcpManual",
        "error",
        "File",
        "convert",
        "yaml",
        "extension",
        "Reading",
        "based",
        "Record",
        "Utcp",
        "unknown",
        "private"
      ],
      "timestamp": "2025-12-24T18:56:19.010865"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\file\\src\\index.ts",
      "content_type": "code",
      "content": "/**\n * File Communication Protocol plugin for UTCP.\n */\n// packages/file/src/index.ts\nimport { CommunicationProtocol, CallTemplateSerializer, ensureCorePluginsInitialized } from '@utcp/sdk';\nimport { FileCallTemplateSerializer } from './file_call_template';\nimport { FileCommunicationProtocol } from './file_communication_protocol';\n\n/**\n * Registers the File protocol's CallTemplate serializer\n * and its CommunicationProtocol implementation.\n * This function is called automatically when the package is imported.\n */\nexport function register(override: boolean = false): void {\n  // Ensure core plugins are initialized first\n  ensureCorePluginsInitialized();\n  \n  // Register the CallTemplate serializer\n  CallTemplateSerializer.registerCallTemplate('file', new FileCallTemplateSerializer(), override);\n  \n  // Register the CommunicationProtocol instance\n  CommunicationProtocol.communicationProtocols['file'] = new FileCommunicationProtocol();\n}\n\n// Automatically register File plugin on import\nregister();\n\n// Export all public APIs\nexport * from './file_call_template';\nexport * from './file_communication_protocol';",
      "line_count": 30,
      "word_count": 112,
      "title": "Index.Ts",
      "summary": "* File Communication Protocol plugin for UTCP. // packages/file/src/index.ts",
      "key_terms": [
        "from",
        "communicationProtocols",
        "packages",
        "serializer",
        "ensureCorePluginsInitialized",
        "initialized",
        "File",
        "is",
        "automatically",
        "utcp",
        "index",
        "file",
        "Ensure",
        "Automatically",
        "register",
        "and",
        "public",
        "protocol",
        "boolean",
        "for"
      ],
      "timestamp": "2025-12-24T18:56:19.042686"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\file\\tests\\file_communication_protocol.test.ts",
      "content_type": "code",
      "content": "// packages/file/tests/file_communication_protocol.test.ts\nimport { test, expect, describe, afterEach } from \"bun:test\";\nimport { unlink, writeFile } from 'fs/promises';\nimport path from 'path';\n// Import from package indices to trigger auto-registration\nimport { FileCommunicationProtocol, FileCallTemplate } from \"@utcp/file\";\nimport \"@utcp/http\"; // Needed for OpenAPI conversion\nimport { IUtcpClient, ApiKeyAuth } from \"@utcp/sdk\";\n\nconst tempFiles: string[] = [];\nconst mockClient = {} as IUtcpClient;\n\nafterEach(async () => {\n  for (const file of tempFiles) {\n    try {\n      await unlink(file);\n    } catch (e) { }\n  }\n  tempFiles.length = 0;\n});\n\nconst createTempFile = async (fileName: string, content: string): Promise<string> => {\n  const filePath = path.join(import.meta.dir, fileName);\n  await writeFile(filePath, content, 'utf-8');\n  tempFiles.push(filePath);\n  return filePath;\n};\n\ndescribe(\"FileCommunicationProtocol\", () => {\n  const protocol = new FileCommunicationProtocol();\n\n  const sampleUtcpManual = {\n    utcp_version: \"1.0.1\",\n    manual_version: \"1.0.0\",\n    tools: [\n      {\n        name: \"test.tool\",\n        description: \"A test tool.\",\n        tool_call_template: {\n          name: \"test_manual\",\n          call_template_type: \"file\",\n          file_path: \"./dummy.json\"\n        }\n      }\n    ]\n  };\n\n  const sampleOpenApiSpec = {\n    openapi: \"3.0.0\",\n    info: { title: \"Test API\", version: \"1.0.0\" },\n    paths: {\n      \"/test\": {\n        get: {\n          operationId: \"getTest\",\n          summary: \"A test endpoint.\",\n          responses: { \"200\": { description: \"OK\" } }\n        }\n      }\n    }\n  };\n\n  describe(\"registerManual\", () => {\n    test(\"should correctly load a UTCP manual from a JSON file\", async () => {\n      const filePath = await createTempFile(\"manual.json\", JSON.stringify(sampleUtcpManual));\n      const callTemplate: FileCallTemplate = {\n        name: \"test_manual\",\n        call_template_type: 'file',\n        file_path: filePath\n      };\n\n      const result = await protocol.registerManual(mockClient, callTemplate);\n\n      expect(result.success).toBe(true);\n      expect(result.errors).toEqual([]);\n      expect(result.manual.tools).toHaveLength(1);\n      expect(result.manual.tools[0]?.name).toBe(\"test.tool\");\n    });\n\n    test(\"should correctly load and convert an OpenAPI spec from a YAML file\", async () => {\n      const yaml = await import(\"js-yaml\");\n      const filePath = await createTempFile(\"openapi.yaml\", yaml.dump(sampleOpenApiSpec));\n      const callTemplate: FileCallTemplate = {\n        name: \"openapi_manual\",\n        call_template_type: 'file',\n        file_path: filePath\n      };\n\n      const result = await protocol.registerManual(mockClient, callTemplate);\n\n      expect(result.success).toBe(true);\n      expect(result.manual.tools).toHaveLength(1);\n      expect(result.manual.tools[0]?.name).toBe(\"getTest\");\n    });\n\n    test(\"should return a failure result for a non-existent file\", async () => {\n      const callTemplate: FileCallTemplate = {\n        name: \"nonexistent_manual\",\n        call_template_type: 'file',\n        file_path: \"/path/to/nonexistent/file.json\"\n      };\n\n      const result = await protocol.registerManual(mockClient, callTemplate);\n\n      expect(result.success).toBe(false);\n      expect(result.errors.length).toBeGreaterThan(0);\n      expect(result.errors[0]).toContain(\"no such file or directory\");\n    });\n\n    test(\"should return a failure result for a malformed JSON file\", async () => {\n      const filePath = await createTempFile(\"malformed.json\", \"{ not json }\");\n      const callTemplate: FileCallTemplate = {\n        name: \"malformed_manual\",\n        call_template_type: 'file',\n        file_path: filePath\n      };\n\n      const result = await protocol.registerManual(mockClient, callTemplate);\n\n      expect(result.success).toBe(false);\n      expect(result.errors.length).toBeGreaterThan(0);\n      expect(result.errors[0]).toMatch(/JSON/i);\n    });\n\n    test(\"should correctly load and convert an OpenAPI spec from a JSON file\", async () => {\n      const filePath = await createTempFile(\"openapi.json\", JSON.stringify(sampleOpenApiSpec));\n      const callTemplate: FileCallTemplate = {\n        name: \"openapi_json_manual\",\n        call_template_type: 'file',\n        file_path: filePath\n      };\n\n      const result = await protocol.registerManual(mockClient, callTemplate);\n\n      expect(result.success).toBe(true);\n      expect(result.manual.tools).toHaveLength(1);\n      expect(result.manual.tools[0]?.name).toContain(\"getTest\");\n    });\n\n    test(\"should support auth_tools parameter for OpenAPI conversion\", async () => {\n      const filePath = await createTempFile(\"openapi_auth.json\", JSON.stringify(sampleOpenApiSpec));\n      const callTemplate: FileCallTemplate = {\n        name: \"openapi_with_auth\",\n        call_template_type: 'file',\n        file_path: filePath,\n        auth_tools: {\n          auth_type: 'api_key',\n          var_name: 'X-API-Key',\n          api_key: '${API_KEY}',\n          location: 'header'\n        } as ApiKeyAuth\n      };\n\n      const result = await protocol.registerManual(mockClient, callTemplate);\n\n      expect(result.success).toBe(true);\n      expect(result.manual.tools).toHaveLength(1);\n    });\n\n    test(\"should fail validation when file_path is not provided\", async () => {\n      const callTemplate = {\n        name: \"invalid_manual\",\n        call_template_type: 'file'\n      } as any;\n\n      await expect(async () => {\n        await protocol.registerManual(mockClient, callTemplate);\n      }).toThrow();\n    });\n  });\n\n  describe(\"callTool\", () => {\n    test(\"should return the raw content of the specified file\", async () => {\n      const fileContent = \"This is the raw content of the file.\";\n      const filePath = await createTempFile(\"content.txt\", fileContent);\n      const callTemplate: FileCallTemplate = {\n        name: \"file_content_tool\",\n        call_template_type: 'file',\n        file_path: filePath\n      };\n\n      const result = await protocol.callTool(mockClient, \"any.tool\", {}, callTemplate);\n      expect(result).toBe(fileContent);\n    });\n\n    test(\"should throw an error if the file does not exist\", async () => {\n      const callTemplate: FileCallTemplate = {\n        name: \"nonexistent_file_tool\",\n        call_template_type: 'file',\n        file_path: \"/path/to/nonexistent/file.txt\"\n      };\n\n      const action = async () => await protocol.callTool(mockClient, \"any.tool\", {}, callTemplate);\n      await expect(action()).rejects.toThrow(/no such file or directory/);\n    });\n\n    test(\"should throw an error when file_path is not provided\", async () => {\n      const callTemplate = {\n        name: \"invalid_tool\",\n        call_template_type: 'file'\n      } as any;\n\n      await expect(async () => {\n        await protocol.callTool(mockClient, \"any.tool\", {}, callTemplate);\n      }).toThrow();\n    });\n  });\n\n  describe(\"callToolStreaming\", () => {\n    test(\"should yield the file content as a single chunk\", async () => {\n      const fileContent = JSON.stringify({ data: \"stream content\" });\n      const filePath = await createTempFile(\"stream.json\", fileContent);\n      const callTemplate: FileCallTemplate = {\n        name: \"streaming_file_tool\",\n        call_template_type: 'file',\n        file_path: filePath\n      };\n\n      const stream = protocol.callToolStreaming(mockClient, \"any.tool\", {}, callTemplate);\n\n      const chunks = [];\n      for await (const chunk of stream) {\n        chunks.push(chunk);\n      }\n\n      expect(chunks).toHaveLength(1);\n      expect(chunks[0]).toBe(fileContent);\n    });\n  });\n});",
      "line_count": 229,
      "word_count": 700,
      "title": "File Communication Protocol.Test.Ts",
      "summary": "// packages/file/tests/file_communication_protocol.test.ts import { test, expect, describe, afterEach } from \"bun:test\";",
      "key_terms": [
        "trigger",
        "const",
        "packages",
        "paths",
        "async",
        "yaml",
        "error",
        "convert",
        "sampleOpenApiSpec",
        "info",
        "unlink",
        "Utcp",
        "callTemplate",
        "specified",
        "yield",
        "Test",
        "string",
        "toBeGreaterThan",
        "version",
        "path"
      ],
      "timestamp": "2025-12-24T18:56:19.084890"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\http\\jsconfig.json",
      "content_type": "configuration",
      "content": "{\n  \"compilerOptions\": {\n    // Environment setup & latest features\n    \"lib\": [\"ESNext\"],\n    \"target\": \"ESNext\",\n    \"module\": \"Preserve\",\n    \"moduleDetection\": \"force\",\n    \"jsx\": \"react-jsx\",\n    \"allowJs\": true,\n\n    // Bundler mode\n    \"moduleResolution\": \"bundler\",\n    \"allowImportingTsExtensions\": true,\n    \"verbatimModuleSyntax\": true,\n    \"noEmit\": true,\n\n    // Best practices\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"noUncheckedIndexedAccess\": true,\n    \"noImplicitOverride\": true,\n\n    // Some stricter flags (disabled by default)\n    \"noUnusedLocals\": false,\n    \"noUnusedParameters\": false,\n    \"noPropertyAccessFromIndexSignature\": false\n  }\n}\n",
      "line_count": 30,
      "word_count": 60,
      "title": "Jsconfig.Json",
      "summary": "\"compilerOptions\": { // Environment setup & latest features",
      "key_terms": [
        "verbatimModuleSyntax",
        "disabled",
        "Some",
        "lib",
        "react",
        "module",
        "skipLibCheck",
        "flags",
        "force",
        "target",
        "mode",
        "default",
        "noEmit",
        "noUnusedLocals",
        "react-jsx",
        "practices",
        "moduleDetection",
        "false",
        "by",
        "Bundler"
      ],
      "timestamp": "2025-12-24T18:56:19.105869"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\http\\package.json",
      "content_type": "configuration",
      "content": "{\n  \"name\": \"@utcp/http\",\n  \"version\": \"1.1.0\",\n  \"description\": \"HTTP utilities for UTCP\",\n  \"main\": \"dist/index.cjs\",\n  \"module\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"type\": \"module\",\n  \"license\": \"MPL-2.0\",\n  \"author\": \"UTCP Contributors\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/universal-tool-calling-protocol/typescript-utcp.git\",\n    \"directory\": \"packages/http\"\n  },\n  \"keywords\": [\n    \"utcp\",\n    \"universal-tool-calling-protocol\",\n    \"tools\",\n    \"api\",\n    \"typescript\",\n    \"tool calling\",\n    \"http\",\n    \"agent\",\n    \"ai\",\n    \"llm\"\n  ],\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"scripts\": {\n    \"build\": \"tsup\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\",\n      \"require\": \"./dist/index.cjs\",\n      \"default\": \"./dist/index.js\"\n    }\n  },\n  \"dependencies\": {\n    \"@utcp/sdk\": \"^1.1.0\",\n    \"axios\": \"^1.11.0\",\n    \"js-yaml\": \"^4.1.0\"\n  },\n  \"devDependencies\": {\n    \"bun-types\": \"latest\",\n    \"typescript\": \"^5.0.0\",\n    \"@types/bun\": \"latest\"\n  }\n}\n",
      "line_count": 56,
      "word_count": 93,
      "title": "Package.Json",
      "summary": "\"name\": \"@utcp/http\", \"version\": \"1.1.0\",",
      "key_terms": [
        "build",
        "packages",
        "calling-protocol",
        "yaml",
        "scripts",
        "universal",
        "module",
        "utcp",
        "index",
        "calling",
        "MPL",
        "js-yaml",
        "tool",
        "utilities",
        "dependencies",
        "type",
        "url",
        "github",
        "public",
        "protocol"
      ],
      "timestamp": "2025-12-24T18:56:19.125864"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\http\\README.md",
      "content_type": "documentation",
      "content": "# @utcp/http\n\nHTTP-Based Communication Protocols for UTCP\n\n## Overview\n\nThe `@utcp/http` package provides comprehensive HTTP-based protocol support for the Universal Tool Calling Protocol (UTCP). It includes **three distinct protocols**:\n\n1. **HTTP** - Standard RESTful HTTP/HTTPS requests\n2. **Streamable HTTP** - HTTP with chunked transfer encoding for streaming large responses\n3. **SSE** - Server-Sent Events for real-time event streaming\n\nAll protocols support multiple authentication methods, URL path parameters, custom headers, and automatic OpenAPI specification conversion.\n\n## Features\n\n### 1. HTTP CallTemplate\n\nStandard HTTP requests for RESTful APIs:\n\n```typescript\ninterface HttpCallTemplate {\n  name: string;\n  call_template_type: 'http';\n  http_method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';\n  url: string;\n  headers?: Record<string, string>;\n  body_field?: string;\n  content_type?: string;\n  timeout?: number;\n  auth?: ApiKeyAuth | BasicAuth | OAuth2Auth;\n}\n```\n\n### 2. Streamable HTTP CallTemplate\n\nHTTP streaming with chunked transfer encoding for large responses:\n\n```typescript\ninterface StreamableHttpCallTemplate {\n  name: string;\n  call_template_type: 'streamable_http';\n  url: string;\n  http_method: 'GET' | 'POST';\n  content_type?: string;\n  chunk_size?: number;        // Default: 4096 bytes\n  timeout?: number;           // Default: 60000ms\n  headers?: Record<string, string>;\n  body_field?: string;\n  header_fields?: string[];\n  auth?: ApiKeyAuth | BasicAuth | OAuth2Auth;\n}\n```\n\n### 3. SSE CallTemplate\n\nServer-Sent Events for real-time streaming:\n\n```typescript\ninterface SseCallTemplate {\n  name: string;\n  call_template_type: 'sse';\n  url: string;\n  event_type?: string;        // Filter specific event types\n  reconnect?: boolean;        // Auto-reconnect on disconnect\n  retry_timeout?: number;     // Reconnection timeout (ms)\n  headers?: Record<string, string>;\n  body_field?: string;\n  header_fields?: string[];\n  auth?: ApiKeyAuth | BasicAuth | OAuth2Auth;\n}\n```\n\n### HTTP Communication Protocol\n\n*   **Tool Discovery**: Automatically registers tools from:\n    *   Remote UTCP Manuals\n    *   OpenAPI 2.0 (Swagger) specifications\n    *   OpenAPI 3.x specifications\n    *   Both JSON and YAML formats\n\n*   **Tool Execution**:\n    *   All HTTP methods: GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS\n    *   URL path parameter substitution: `${param_name}` or `{param_name}`\n    *   Query parameter handling\n    *   Request body mapping via `body_field`\n    *   Custom headers with variable substitution\n\n*   **Authentication Support**:\n    *   **API Key**: Header, query parameter, or cookie-based\n    *   **Basic Auth**: Username/password authentication\n    *   **OAuth2**: Client credentials flow with automatic token caching and refresh\n\n*   **Security**:\n    *   Enforces HTTPS or localhost connections\n    *   Prevents Man-in-the-Middle (MITM) attacks\n    *   OAuth2 token caching to minimize token requests\n\n### OpenAPI Converter\n\nAutomatically converts OpenAPI specifications to UTCP tools:\n*   Parses OpenAPI 2.0 and 3.x specifications\n*   Generates tool definitions with proper schemas\n*   Extracts authentication requirements\n*   Creates placeholder variables for API keys\n\n## Protocol Comparison\n\n### When to Use Each Protocol\n\n| Protocol | Use Case | Response Type | Best For |\n|----------|----------|---------------|----------|\n| **HTTP** | Standard RESTful APIs | Complete response | Most APIs, CRUD operations, single requests |\n| **Streamable HTTP** | Large data downloads | Chunked streaming | Large files, datasets, progressive data |\n| **SSE** | Real-time updates | Event stream | Live updates, notifications, real-time feeds |\n\n### Key Differences\n\n**HTTP**\n- ✅ Simple request-response model\n- ✅ Complete data in single response\n- ✅ All HTTP methods supported\n- ❌ Not suitable for large responses\n- ❌ No real-time updates\n\n**Streamable HTTP**\n- ✅ Efficient for large responses\n- ✅ Progressive data processing\n- ✅ Reduced memory usage\n- ⚠️ Only GET/POST methods\n- ❌ No bidirectional communication\n\n**SSE**\n- ✅ Real-time event streaming\n- ✅ Automatic reconnection\n- ✅ Event type filtering\n- ✅ Server push updates\n- ❌ Unidirectional (server → client only)\n\n## Installation\n\n```bash\nnpm install @utcp/http @utcp/sdk\n\n# Or with bun\nbun add @utcp/http @utcp/sdk\n```\n\n**Dependencies:**\n- `@utcp/sdk` - Core UTCP SDK (peer dependency)\n- `axios` - HTTP client\n- `js-yaml` - YAML parsing for OpenAPI specs\n\n## Quick Start\n\n### Automatic Registration\n\nAll three HTTP-based protocols (`http`, `streamable_http`, `sse`) are **automatically registered** when you import the UtcpClient. No manual setup required!\n\n### Basic HTTP Usage\n\n```typescript\nimport { UtcpClient } from '@utcp/sdk';\nimport { HttpCallTemplateSerializer } from '@utcp/http';\n\nasync function main() {\n  const serializer = new HttpCallTemplateSerializer();\n  const weatherTemplate = serializer.validateDict({\n    name: 'weather_api',\n    call_template_type: 'http',\n    http_method: 'GET',\n    url: 'https://api.weatherapi.com/v1/current.json',\n    headers: {\n      'X-API-Key': '${API_KEY}'\n    }\n  });\n\n  const client = await UtcpClient.create(process.cwd(), {\n    variables: {\n      // Namespaced variables for security\n      'weather__api_API_KEY': process.env.WEATHER_API_KEY || ''\n    },\n    manual_call_templates: [weatherTemplate]\n  });\n\n  // Call the API\n  const weather = await client.callTool('weather_api.get_current', {\n    q: 'London'\n  });\n  \n  console.log('Weather:', weather);\n  await client.close();\n}\n```\n\n### With OpenAPI Specification\n\nAutomatically discover tools from an OpenAPI spec:\n\n```typescript\nimport { UtcpClient } from '@utcp/sdk';\nimport { HttpCallTemplateSerializer } from '@utcp/http';\n\nconst serializer = new HttpCallTemplateSerializer();\nconst petstoreTemplate = serializer.validateDict({\n  name: 'petstore_api',\n  call_template_type: 'http',\n  http_method: 'GET',\n  url: 'https://petstore.swagger.io/v2/swagger.json',\n  // Tools will be auto-discovered from the OpenAPI spec\n});\n\nconst client = await UtcpClient.create(process.cwd(), {\n  manual_call_templates: [petstoreTemplate]\n});\n\n// Search for discovered tools\nconst tools = await client.searchTools('pet');\nconsole.log('Available tools:', tools.map(t => t.name));\n\n// Call a discovered tool\nconst pets = await client.callTool('petstore_api.findPetsByStatus', {\n  status: 'available'\n});\n```\n\n### Streamable HTTP Usage\n\nStream large responses using chunked transfer encoding:\n\n```typescript\nimport { UtcpClient } from '@utcp/sdk';\nimport { StreamableHttpCallTemplateSerializer } from '@utcp/http';\n\nconst serializer = new StreamableHttpCallTemplateSerializer();\nconst streamTemplate = serializer.validateDict({\n  name: 'large_data_api',\n  call_template_type: 'streamable_http',\n  http_method: 'GET',\n  url: 'https://api.example.com/large-dataset',\n  chunk_size: 8192,  // 8KB chunks\n  timeout: 120000,   // 2 minutes\n  headers: {\n    'Accept': 'application/octet-stream'\n  }\n});\n\nconst client = await UtcpClient.create(process.cwd(), {\n  manual_call_templates: [streamTemplate]\n});\n\n// Stream the response\nconst stream = await client.callToolStreaming('large_data_api.get_dataset', {\n  filter: 'recent'\n});\n\nfor await (const chunk of stream) {\n  console.log('Received chunk:', chunk.length, 'bytes');\n  // Process chunk...\n}\n```\n\n### SSE (Server-Sent Events) Usage\n\nReal-time event streaming from servers:\n\n```typescript\nimport { UtcpClient } from '@utcp/sdk';\nimport { SseCallTemplateSerializer } from '@utcp/http';\n\nconst serializer = new SseCallTemplateSerializer();\nconst sseTemplate = serializer.validateDict({\n  name: 'events_api',\n  call_template_type: 'sse',\n  url: 'https://api.example.com/events',\n  event_type: 'notification',  // Filter to specific event type\n  reconnect: true,              // Auto-reconnect on disconnect\n  retry_timeout: 5000,          // Retry after 5 seconds\n  headers: {\n    'Authorization': 'Bearer ${API_KEY}'\n  }\n});\n\nconst client = await UtcpClient.create(process.cwd(), {\n  variables: {\n    'events__api_API_KEY': process.env.SSE_API_KEY || ''\n  },\n  manual_call_templates: [sseTemplate]\n});\n\n// Stream real-time events\nconst eventStream = await client.callToolStreaming('events_api.stream_events', {\n  channel: 'updates'\n});\n\nfor await (const event of eventStream) {\n  console.log('Event received:', event);\n  // Handle event...\n}\n```\n\n### Authentication Examples\n\n#### API Key Authentication\n\n```typescript\nimport { HttpCallTemplateSerializer } from '@utcp/http';\n\nconst serializer = new HttpCallTemplateSerializer();\nconst callTemplate = serializer.validateDict({\n  name: 'api_with_key',\n  call_template_type: 'http',\n  http_method: 'GET',\n  url: 'https://api.example.com/data',\n  auth: {\n    auth_type: 'api_key',\n    var_name: 'X-API-Key',\n    api_key_value: '${API_KEY}',\n    in: 'header' // or 'query' or 'cookie'\n  }\n});\n```\n\n#### Basic Authentication\n\n```typescript\nconst serializer = new HttpCallTemplateSerializer();\nconst callTemplate = serializer.validateDict({\n  name: 'api_with_basic',\n  call_template_type: 'http',\n  http_method: 'GET',\n  url: 'https://api.example.com/data',\n  auth: {\n    auth_type: 'basic',\n    username: '${USERNAME}',\n    password: '${PASSWORD}'\n  }\n});\n```\n\n#### OAuth2 Client Credentials\n\n```typescript\nconst serializer = new HttpCallTemplateSerializer();\nconst callTemplate = serializer.validateDict({\n  name: 'api_with_oauth',\n  call_template_type: 'http',\n  http_method: 'GET',\n  url: 'https://api.example.com/data',\n  auth: {\n    auth_type: 'oauth2',\n    token_url: 'https://auth.example.com/oauth/token',\n    client_id: '${CLIENT_ID}',\n    client_secret: '${CLIENT_SECRET}',\n    scope: 'read write'\n  }\n});\n```\n\n### Path Parameters\n\nUse `${param}` or `{param}` syntax for path parameters:\n\n```typescript\nconst serializer = new HttpCallTemplateSerializer();\nconst callTemplate = serializer.validateDict({\n  name: 'github_api',\n  call_template_type: 'http',\n  http_method: 'GET',\n  url: 'https://api.github.com/users/${username}',\n});\n\n// Call with arguments\nawait client.callTool('github_api.get_user', {\n  username: 'octocat'\n});\n// Resolves to: https://api.github.com/users/octocat\n```\n\n### Request Body\n\nFor POST/PUT/PATCH requests, use `body_field`:\n\n```typescript\nconst serializer = new HttpCallTemplateSerializer();\nconst callTemplate = serializer.validateDict({\n  name: 'create_resource',\n  call_template_type: 'http',\n  http_method: 'POST',\n  url: 'https://api.example.com/resources',\n  body_field: 'data',\n  content_type: 'application/json',\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\n\n// Call with body\nawait client.callTool('create_resource.post', {\n  data: {\n    name: 'My Resource',\n    value: 42\n  }\n});\n```\n\n## Use Case Examples\n\n### HTTP: GitHub API Integration\n\n```typescript\nconst serializer = new HttpCallTemplateSerializer();\nconst githubTemplate = serializer.validateDict({\n  name: 'github_api',\n  call_template_type: 'http',\n  http_method: 'GET',\n  url: 'https://api.github.com/repos/${owner}/${repo}/issues',\n  headers: { 'Authorization': 'Bearer ${TOKEN}' }\n});\n\nconst client = await UtcpClient.create(process.cwd(), {\n  variables: { 'github__api_TOKEN': process.env.GITHUB_TOKEN || '' },\n  manual_call_templates: [githubTemplate]\n});\n\nconst issues = await client.callTool('github_api.get_issues', {\n  owner: 'utcp', repo: 'typescript-utcp'\n});\n```\n\n### Streamable HTTP: Large File Download\n\n```typescript\nconst serializer = new StreamableHttpCallTemplateSerializer();\nconst cdnTemplate = serializer.validateDict({\n  name: 'cdn',\n  call_template_type: 'streamable_http',\n  http_method: 'GET',\n  url: 'https://cdn.example.com/large-file.zip',\n  chunk_size: 16384\n});\n\nconst client = await UtcpClient.create(process.cwd(), {\n  manual_call_templates: [cdnTemplate]\n});\n\nconst stream = await client.callToolStreaming('cdn.download', {});\nfor await (const chunk of stream) {\n  // Write chunk to file or process incrementally\n  fs.appendFileSync('output.zip', chunk);\n}\n```\n\n### SSE: Stock Price Updates\n\n```typescript\nconst serializer = new SseCallTemplateSerializer();\nconst stockTemplate = serializer.validateDict({\n  name: 'stock_api',\n  call_template_type: 'sse',\n  url: 'https://api.stocks.com/stream',\n  event_type: 'price_update',\n  reconnect: true\n});\n\nconst client = await UtcpClient.create(process.cwd(), {\n  manual_call_templates: [stockTemplate]\n});\n\nconst priceStream = await client.callToolStreaming('stock_api.watch', {\n  symbol: 'AAPL'\n});\n\nfor await (const update of priceStream) {\n  console.log('Price update:', update.price, 'at', update.timestamp);\n}\n```\n\n## Advanced Features\n\n### Custom Headers with Variables\n\n```typescript\nconst serializer = new HttpCallTemplateSerializer();\nconst callTemplate = serializer.validateDict({\n  name: 'custom_api',\n  call_template_type: 'http',\n  http_method: 'GET',\n  url: 'https://api.example.com/data',\n  headers: {\n    'Authorization': 'Bearer ${TOKEN}',\n    'X-Request-ID': '${REQUEST_ID}',\n    'User-Agent': 'UTCP-Client/1.0'\n  }\n});\n```\n\n### Timeout Configuration\n\n```typescript\nconst serializer = new HttpCallTemplateSerializer();\nconst callTemplate = serializer.validateDict({\n  name: 'slow_api',\n  call_template_type: 'http',\n  http_method: 'GET',\n  url: 'https://api.example.com/slow-endpoint',\n  timeout: 60000 // 60 seconds\n});\n```\n\n### Variable Namespacing\n\nAll variables are automatically namespaced by manual name for security:\n\n```typescript\nconst client = await UtcpClient.create(process.cwd(), {\n  variables: {\n    // For manual \"github_api\", variables must be prefixed\n    'github__api_TOKEN': 'github-token-123',\n    'gitlab__api_TOKEN': 'gitlab-token-456'\n  },\n  manual_call_templates: [\n    {\n      name: 'github_api',\n      // ...\n      headers: {\n        // Resolves to \"github__api_TOKEN\"\n        'Authorization': 'Bearer ${TOKEN}'\n      }\n    }\n  ]\n});\n```\n\n## OpenAPI Conversion\n\nThe `OpenApiConverter` automatically:\n\n1. **Parses OpenAPI specs** (2.0 and 3.x)\n2. **Extracts endpoints** as individual tools\n3. **Generates schemas** for inputs and outputs\n4. **Detects authentication** requirements\n5. **Creates placeholder variables** for API keys\n\n```typescript\nimport { OpenApiConverter } from '@utcp/http';\n\nconst converter = new OpenApiConverter('https://api.example.com/openapi.json');\nconst manual = await converter.convert();\n\nconsole.log('Discovered tools:', manual.tools.length);\n```\n\n## Security Features\n\n### HTTPS Enforcement\n\nThe HTTP protocol enforces HTTPS or localhost connections by default to prevent MITM attacks:\n\n```typescript\n// ✅ Allowed\n'https://api.example.com'\n'http://localhost:8080'\n'http://127.0.0.1:3000'\n\n// ❌ Rejected\n'http://api.example.com'  // Non-localhost HTTP\n```\n\n### OAuth2 Token Caching\n\nOAuth2 tokens are automatically cached by `client_id` to minimize token requests:\n\n- Tokens are cached until expiration\n- Automatic refresh when expired\n- Tries both body and auth header methods\n\n## Error Handling\n\n```typescript\ntry {\n  const result = await client.callTool('api_manual.endpoint', args);\n} catch (error) {\n  if (error.message.includes('401')) {\n    console.error('Authentication failed');\n  } else if (error.message.includes('404')) {\n    console.error('Endpoint not found');\n  } else {\n    console.error('Request failed:', error);\n  }\n}\n```\n\n## TypeScript Support\n\nFull TypeScript support with exported types for all three protocols:\n\n```typescript\nimport {\n  // HTTP Protocol\n  HttpCallTemplate,\n  HttpCommunicationProtocol,\n  \n  // Streamable HTTP Protocol\n  StreamableHttpCallTemplate,\n  StreamableHttpCommunicationProtocol,\n  \n  // SSE Protocol\n  SseCallTemplate,\n  SseCommunicationProtocol,\n  \n  // OpenAPI Converter\n  OpenApiConverter,\n  \n  // Authentication Types\n  ApiKeyAuth,\n  BasicAuth,\n  OAuth2Auth\n} from '@utcp/http';\n```\n\n## Testing\n\n```bash\n# Run HTTP protocol tests\nbun test packages/http/tests/\n```\n\n## Related Packages\n\n- `@utcp/sdk` - Core UTCP SDK\n- `@utcp/mcp` - MCP protocol support\n- `@utcp/text` - File-based tools\n- `@utcp/cli` - Command-line tools\n\n## Contributing\n\nSee the root repository for contribution guidelines.\n\n## License\n\nMozilla Public License Version 2.0",
      "line_count": 642,
      "word_count": 1773,
      "title": "@utcp/http",
      "summary": "HTTP-Based Communication Protocols for UTCP The `@utcp/http` package provides comprehensive HTTP-based protocol support for the Universal Tool Calling Protocol (UTCP). It includes **three distinct pro...",
      "key_terms": [
        "comprehensive",
        "close",
        "const",
        "packages",
        "localhost",
        "convert",
        "Type",
        "Record",
        "cookie",
        "callTemplate",
        "Efficient",
        "multiple",
        "Creates",
        "model",
        "if",
        "pets",
        "Features",
        "interface",
        "sse",
        "supported"
      ],
      "timestamp": "2025-12-24T18:56:19.191329"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\http\\tsconfig.json",
      "content_type": "configuration",
      "content": "// packages/http/tsconfig.json\n{\n  \"extends\": \"../../tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"composite\": true\n  },\n  \"include\": [\n    \"src/**/*\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"**/*.test.ts\",\n    \"**/*.spec.ts\"\n  ],\n  \"references\": [\n    { \"path\": \"../core\" }\n  ]\n}",
      "line_count": 21,
      "word_count": 33,
      "title": "Tsconfig.Json",
      "summary": "// packages/http/tsconfig.json \"extends\": \"../../tsconfig.json\",",
      "key_terms": [
        "packages",
        "composite",
        "exclude",
        "extends",
        "outDir",
        "test",
        "rootDir",
        "spec",
        "ts",
        "core",
        "path",
        "references",
        "dist",
        "http",
        "true",
        "include",
        "tsconfig",
        "json",
        "compilerOptions",
        "src"
      ],
      "timestamp": "2025-12-24T18:56:19.201339"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\http\\tsup.config.ts",
      "content_type": "code",
      "content": "import { defineConfig } from 'tsup';\n\nexport default defineConfig({\n  entry: ['src/index.ts'],\n  format: ['esm', 'cjs'],\n  dts: {\n    compilerOptions: {\n      composite: false,\n      paths: {},\n    },\n  },\n  splitting: false,\n  sourcemap: true,\n  clean: true,\n  outDir: 'dist',\n  external: ['@utcp/sdk', 'axios', 'js-yaml'],\n});\n",
      "line_count": 18,
      "word_count": 37,
      "title": "Tsup.Config.Ts",
      "summary": "import { defineConfig } from 'tsup'; export default defineConfig({",
      "key_terms": [
        "from",
        "sourcemap",
        "composite",
        "paths",
        "entry",
        "yaml",
        "clean",
        "utcp",
        "outDir",
        "index",
        "format",
        "js-yaml",
        "default",
        "axios",
        "ts",
        "cjs",
        "false",
        "import",
        "export",
        "sdk"
      ],
      "timestamp": "2025-12-24T18:56:19.226877"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\http\\src\\http_call_template.ts",
      "content_type": "code",
      "content": "// packages/http/src/http_call_template.ts\nimport { z } from 'zod';\nimport { Auth, AuthSchema, AuthSerializer } from '@utcp/sdk';\nimport { CallTemplate } from '@utcp/sdk';\nimport { Serializer } from '@utcp/sdk';\n\n/**\n * REQUIRED\n * Provider configuration for HTTP-based tools.\n *\n * Supports RESTful HTTP/HTTPS APIs with various HTTP methods, authentication,\n * custom headers, and flexible request/response handling. Supports URL path\n * parameters using {parameter_name} syntax.\n */\n\nexport interface HttpCallTemplate extends CallTemplate {\n  call_template_type: 'http';\n  http_method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n  url: string;\n  content_type: string;\n  headers?: Record<string, string>;\n  body_field?: string;\n  header_fields?: string[];\n  auth_tools?: Auth | null;\n  allowed_communication_protocols?: string[];\n}\n\n/**\n * HTTP Call Template schema for RESTful HTTP/HTTPS API tools.\n * Extends the base CallTemplate and defines HTTP-specific configuration.\n */\nexport const HttpCallTemplateSchema: z.ZodType<HttpCallTemplate> = z.object({\n  name: z.string().optional(),\n  call_template_type: z.literal('http'),\n  http_method: z.enum(['GET', 'POST', 'PUT', 'DELETE', 'PATCH']).default('GET'),\n  url: z.string().describe('The base URL for the HTTP endpoint. Supports path parameters like \"https://api.example.com/users/{user_id}\".'),\n  content_type: z.string().default('application/json').describe('The Content-Type header for requests.'),\n  auth: AuthSchema.optional().describe('Optional authentication configuration.'),\n  headers: z.record(z.string(), z.string()).optional().describe('Optional static headers to include in all requests.'),\n  body_field: z.string().optional().default('body').describe('The name of the single input field to be sent as the request body.'),\n  header_fields: z.array(z.string()).optional().describe('List of input fields to be sent as request headers.'),\n  auth_tools: AuthSchema.nullable().optional().transform((val) => {\n    if (val === null || val === undefined) return null;\n    if (typeof val === 'object' && 'auth_type' in val) {\n      return new AuthSerializer().validateDict(val as any);\n    }\n    return val as Auth;\n  }).describe('Authentication configuration for generated tools'),\n  allowed_communication_protocols: z.array(z.string()).optional().describe('Optional list of allowed communication protocol types for tools within this manual.'),\n}) as z.ZodType<HttpCallTemplate>;\n\n/**\n * REQUIRED\n * Serializer for HttpCallTemplate.\n */\nexport class HttpCallTemplateSerializer extends Serializer<HttpCallTemplate> {\n  toDict(obj: HttpCallTemplate): Record<string, unknown> {\n    return {\n      name: obj.name,\n      call_template_type: obj.call_template_type,\n      http_method: obj.http_method,\n      url: obj.url,\n      content_type: obj.content_type,\n      auth: obj.auth,\n      auth_tools: obj.auth_tools ? new AuthSerializer().toDict(obj.auth_tools) : null,\n      headers: obj.headers,\n      body_field: obj.body_field,\n      header_fields: obj.header_fields,\n      allowed_communication_protocols: obj.allowed_communication_protocols,\n    };\n  }\n\n  validateDict(obj: Record<string, unknown>): HttpCallTemplate {\n    try {\n      return HttpCallTemplateSchema.parse(obj);\n    } catch (e: any) {\n      throw new Error(`Invalid HttpCallTemplate: ${e.message}\\n${e.stack || ''}`);\n    }\n  }\n}",
      "line_count": 80,
      "word_count": 325,
      "title": "Http Call Template.Ts",
      "summary": "// packages/http/src/http_call_template.ts import { z } from 'zod';",
      "key_terms": [
        "nullable",
        "null",
        "const",
        "packages",
        "REQUIRED",
        "headers",
        "Type",
        "record",
        "based",
        "Record",
        "list",
        "unknown",
        "RESTful",
        "string",
        "Error",
        "application",
        "using",
        "parameters",
        "validateDict",
        "Extends"
      ],
      "timestamp": "2025-12-24T18:56:19.249128"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\http\\src\\http_communication_protocol.ts",
      "content_type": "code",
      "content": "// packages/http/src/http_communication_protocol.ts\nimport axios, { AxiosInstance, AxiosRequestConfig, Method } from 'axios';\nimport * as yaml from 'js-yaml';\nimport { CommunicationProtocol } from '@utcp/sdk';\nimport { RegisterManualResult } from '@utcp/sdk';\nimport { CallTemplate } from '@utcp/sdk';\nimport { Tool } from '@utcp/sdk';\nimport { UtcpManualSchema } from '@utcp/sdk';\nimport { ApiKeyAuth } from '@utcp/sdk'; \nimport { BasicAuth } from '@utcp/sdk';\nimport { OAuth2Auth } from '@utcp/sdk';\nimport { IUtcpClient } from '@utcp/sdk'; \nimport { HttpCallTemplateSchema, HttpCallTemplate } from './http_call_template';\nimport { OpenApiConverter } from './openapi_converter';\n\n/**\n * HTTP communication protocol implementation for UTCP client.\n *\n * Handles communication with HTTP-based tool providers, supporting various\n * authentication methods, URL path parameters, and automatic tool discovery.\n * Enforces security by requiring HTTPS or localhost connections.\n */\nexport class HttpCommunicationProtocol implements CommunicationProtocol {\n  private _oauthTokens: Map<string, { accessToken: string; expiresAt: number }> = new Map();\n  private _axiosInstance: AxiosInstance;\n\n  constructor() {\n    this._axiosInstance = axios.create({\n      timeout: 30000,\n    });\n  }\n\n  private _logInfo(message: string): void {\n    console.log(`[HttpCommunicationProtocol] ${message}`);\n  }\n\n  private _logError(message: string, error?: any): void {\n    console.error(`[HttpCommunicationProtocol Error] ${message}`, error);\n  }\n\n  /**\n   * Registers a manual and its tools from an HTTP provider.\n   * Supports UTCP Manuals directly or OpenAPI specifications which are converted.\n   *\n   * @param caller The UTCP client instance.\n   * @param manualCallTemplate The HTTP call template for discovery.\n   * @returns A RegisterManualResult object.\n   */\n  public async registerManual(caller: IUtcpClient, manualCallTemplate: CallTemplate): Promise<RegisterManualResult> {\n    const httpCallTemplate = HttpCallTemplateSchema.parse(manualCallTemplate);\n\n    try {\n      const url = httpCallTemplate.url;\n\n      if (!url.startsWith('https://') && !url.startsWith('http://localhost') && !url.startsWith('http://127.0.0.1')) {\n        throw new Error(\n          `Security error: URL must use HTTPS or start with 'http://localhost' or 'http://127.0.0.1'. Got: ${url}. ` +\n          \"Non-secure URLs are vulnerable to man-in-the-middle attacks.\"\n        );\n      }\n\n      this._logInfo(`Discovering tools from '${httpCallTemplate.name}' (HTTP) at ${url}`);\n\n      const requestConfig: AxiosRequestConfig = {\n        method: httpCallTemplate.http_method as Method,\n        url: url,\n        headers: { ...httpCallTemplate.headers },\n        params: {},\n        data: undefined,\n        auth: undefined,\n        timeout: 10000\n      };\n\n      await this._applyAuthToRequestConfig(httpCallTemplate, requestConfig);\n      const response = await this._axiosInstance.request(requestConfig);\n      const contentType = response.headers['content-type'] || '';\n      let responseData: any;\n\n      if (contentType.includes('yaml') || url.endsWith('.yaml') || url.endsWith('.yml')) {\n        responseData = yaml.load(response.data);\n      } else {\n        responseData = response.data;\n      }\n\n      let utcpManual;\n      if (responseData && responseData.utcp_version && Array.isArray(responseData.tools)) {\n        this._logInfo(`Detected UTCP manual from '${httpCallTemplate.name}'.`);\n        utcpManual = UtcpManualSchema.parse(responseData);\n      } else if (responseData && (responseData.openapi || responseData.swagger || responseData.paths)) {\n        this._logInfo(`Assuming OpenAPI spec from '${httpCallTemplate.name}'. Converting to UTCP manual.`);\n        const converter = new OpenApiConverter(responseData, {\n          specUrl: httpCallTemplate.url,\n          callTemplateName: httpCallTemplate.name\n        });\n        utcpManual = converter.convert();\n      } else {\n        throw new Error(\"Response is neither a valid UTCP Manual nor an OpenAPI Specification.\");\n      }\n\n      const toolsInManual: Tool[] = utcpManual.tools;\n      if (toolsInManual.length > 0) {\n        this._logInfo(`Found ${toolsInManual.length} tools.`);\n      }\n\n      return {\n        manualCallTemplate: httpCallTemplate,\n        manual: utcpManual,\n        success: true,\n        errors: []\n      };\n\n    } catch (error: any) {\n      this._logError(`Error discovering tools from HTTP provider '${httpCallTemplate.name}':`, error);\n      return {\n        manualCallTemplate: httpCallTemplate,\n        manual: UtcpManualSchema.parse({ tools: [] }),\n        success: false,\n        errors: [axios.isAxiosError(error) ? error.message : String(error)]\n      };\n    }\n  }\n\n  /**\n   * Deregisters an HTTP manual. This is a no-op for stateless HTTP communication.\n   * @param caller The UTCP client instance.\n   * @param manualCallTemplate The HTTP call template to deregister.\n   */\n  public async deregisterManual(caller: IUtcpClient, manualCallTemplate: CallTemplate): Promise<void> {\n    this._logInfo(`Deregistering HTTP manual '${manualCallTemplate.name}' (no-op).`);\n    return Promise.resolve();\n  }\n\n  /**\n   * Executes a tool call through the HTTP protocol.\n   *\n   * @param caller The UTCP client instance.\n   * @param toolName Name of the tool to call.\n   * @param toolArgs Dictionary of arguments to pass to the tool.\n   * @param toolCallTemplate The HTTP call template for the tool.\n   * @returns The tool's response.\n   */\n  public async callTool(caller: IUtcpClient, toolName: string, toolArgs: Record<string, any>, toolCallTemplate: CallTemplate): Promise<any> {\n    const httpCallTemplate = HttpCallTemplateSchema.parse(toolCallTemplate);\n\n    const requestHeaders: Record<string, string> = { ...httpCallTemplate.headers };\n    let bodyContent: any = undefined;\n    const remainingArgs = { ...toolArgs };\n    const queryParams: Record<string, any> = {};\n\n    if (httpCallTemplate.header_fields) {\n      for (const fieldName of httpCallTemplate.header_fields) {\n        if (fieldName in remainingArgs) {\n          requestHeaders[fieldName] = String(remainingArgs[fieldName]);\n          delete remainingArgs[fieldName];\n        }\n      }\n    }\n\n    if (httpCallTemplate.body_field && httpCallTemplate.body_field in remainingArgs) {\n      bodyContent = remainingArgs[httpCallTemplate.body_field];\n      delete remainingArgs[httpCallTemplate.body_field];\n    }\n\n    const url = this._buildUrlWithPathParams(httpCallTemplate.url, remainingArgs);\n\n    Object.assign(queryParams, remainingArgs);\n\n    const requestConfig: AxiosRequestConfig = {\n      method: httpCallTemplate.http_method as Method,\n      url: url,\n      headers: requestHeaders,\n      params: queryParams,\n      data: bodyContent,\n      auth: undefined,\n      timeout: httpCallTemplate.timeout\n    };\n\n    await this._applyAuthToRequestConfig(httpCallTemplate, requestConfig);\n\n    try {\n      if (bodyContent !== undefined && !('Content-Type' in (requestConfig.headers || {}))) {\n        requestConfig.headers = {\n          ...(requestConfig.headers || {}),\n          'Content-Type': httpCallTemplate.content_type,\n        };\n      }\n\n      this._logInfo(`Executing HTTP tool '${toolName}' with URL: ${requestConfig.url} and method: ${requestConfig.method}`);\n      const response = await this._axiosInstance.request(requestConfig);\n\n      const contentType = response.headers['content-type'] || '';\n      if (contentType.includes('yaml') || url.endsWith('.yaml') || url.endsWith('.yml')) {\n        return yaml.load(response.data);\n      }\n      return response.data;\n    } catch (error: any) {\n      this._logError(`Error calling HTTP tool '${toolName}':`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Executes a tool call through this transport streamingly.\n   * For standard HTTP, this typically means fetching the full response and yielding it as a single chunk.\n   * Real streaming for protocols like SSE or HTTP chunked transfer would be in their specific implementations.\n   *\n   * @param caller The UTCP client instance.\n   * @param toolName Name of the tool to call.\n   * @param toolArgs Dictionary of arguments to pass to the tool.\n   * @param toolCallTemplate The HTTP call template for the tool.\n   * @returns An async generator that yields chunks of the tool's response.\n   */\n  public async *callToolStreaming(caller: IUtcpClient, toolName: string, toolArgs: Record<string, any>, toolCallTemplate: CallTemplate): AsyncGenerator<any, void, unknown> {\n    this._logInfo(`HTTP protocol does not inherently support streaming for '${toolName}'. Fetching full response.`);\n    const result = await this.callTool(caller, toolName, toolArgs, toolCallTemplate);\n    yield result;\n  }\n\n  /**\n   * Closes any persistent connections or resources held by the communication protocol.\n   * For stateless HTTP, this clears OAuth tokens.\n   */\n  public async close(): Promise<void> {\n    this._oauthTokens.clear();\n    this._logInfo(\"HTTP Communication Protocol closed. OAuth tokens cleared.\");\n    return Promise.resolve();\n  }\n\n  /**\n   * Applies authentication details from the HttpCallTemplate to the Axios request configuration.\n   * This modifies `requestConfig.headers`, `requestConfig.params`, `requestConfig.auth`, and returns cookies.\n   *\n   * @param httpCallTemplate The CallTemplate containing authentication details.\n   * @param requestConfig The Axios request configuration to modify.\n   * @returns A Promise that resolves to an object containing any cookies to be set.\n   */\n  private async _applyAuthToRequestConfig(httpCallTemplate: HttpCallTemplate, requestConfig: AxiosRequestConfig): Promise<Record<string, string>> {\n    const cookies: Record<string, string> = {};\n\n    if (httpCallTemplate.auth) {\n      if (httpCallTemplate.auth.auth_type === 'api_key') {\n        const apiKeyAuth = httpCallTemplate.auth as ApiKeyAuth;\n        if (!apiKeyAuth.api_key) {\n          throw new Error(\"API key for ApiKeyAuth is empty.\");\n        }\n        // Default to 'header' if location is not specified\n        const location = apiKeyAuth.location || 'header';\n        if (location === 'header') {\n          requestConfig.headers = { ...requestConfig.headers, [apiKeyAuth.var_name]: apiKeyAuth.api_key };\n        } else if (location === 'query') {\n          requestConfig.params = { ...requestConfig.params, [apiKeyAuth.var_name]: apiKeyAuth.api_key };\n        } else if (location === 'cookie') {\n          cookies[apiKeyAuth.var_name] = apiKeyAuth.api_key;\n        }\n      } else if (httpCallTemplate.auth.auth_type === 'basic') {\n        const basicAuth = httpCallTemplate.auth as BasicAuth;\n        requestConfig.auth = {\n          username: basicAuth.username,\n          password: basicAuth.password\n        };\n      } else if (httpCallTemplate.auth.auth_type === 'oauth2') {\n        const oauth2Auth = httpCallTemplate.auth as OAuth2Auth;\n        const token = await this._handleOAuth2(oauth2Auth);\n        requestConfig.headers = { ...requestConfig.headers, 'Authorization': `Bearer ${token}` };\n      }\n    }\n    return cookies;\n  }\n\n  /**\n   * Handles OAuth2 client credentials flow, trying both body and auth header methods.\n   * Caches tokens and automatically refreshes if expired.\n   *\n   * @param authDetails The OAuth2 authentication details.\n   * @returns The access token.\n   * @throws Error if token cannot be fetched.\n   */\n  private async _handleOAuth2(authDetails: OAuth2Auth): Promise<string> {\n    const clientId = authDetails.client_id;\n\n    const cachedToken = this._oauthTokens.get(clientId);\n    if (cachedToken && cachedToken.expiresAt > Date.now()) {\n      return cachedToken.accessToken;\n    }\n\n    this._logInfo(`Fetching new OAuth2 token for client: '${clientId}'`);\n    const tokenFetchPromises: Promise<string>[] = [];\n\n    // Method 1: Send credentials in the request body\n    tokenFetchPromises.push(\n      (async () => {\n        try {\n          const bodyData = new URLSearchParams({\n            'grant_type': 'client_credentials',\n            'client_id': authDetails.client_id,\n            'client_secret': authDetails.client_secret,\n            'scope': authDetails.scope || ''\n          });\n          const response = await this._axiosInstance.post(\n            authDetails.token_url,\n            bodyData.toString(),\n            { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }\n          );\n          if (!response.data.access_token) {\n            throw new Error(\"Access token not found in response.\");\n          }\n          const expiresAt = Date.now() + (response.data.expires_in * 1000 || 3600 * 1000);\n          this._oauthTokens.set(clientId, { accessToken: response.data.access_token, expiresAt });\n          this._logInfo(`OAuth2 token fetched via body for client: '${clientId}'.`);\n          return response.data.access_token;\n        } catch (error: any) {\n          this._logError(`OAuth2 with credentials in body failed for '${clientId}':`, error);\n          throw error;\n        }\n      })()\n    );\n\n    // Method 2: Send credentials as Basic Auth header\n    tokenFetchPromises.push(\n      (async () => {\n        try {\n          const bodyData = new URLSearchParams({\n            'grant_type': 'client_credentials',\n            'scope': authDetails.scope || ''\n          });\n          const response = await this._axiosInstance.post(\n            authDetails.token_url,\n            bodyData.toString(),\n            {\n              auth: { username: authDetails.client_id, password: authDetails.client_secret },\n              headers: { 'Content-Type': 'application/x-www-form-urlencoded' }\n            }\n          );\n          if (!response.data.access_token) {\n            throw new Error(\"Access token not found in response.\");\n          }\n          const expiresAt = Date.now() + (response.data.expires_in * 1000 || 3600 * 1000);\n          this._oauthTokens.set(clientId, { accessToken: response.data.access_token, expiresAt });\n          this._logInfo(`OAuth2 token fetched via Basic Auth header for client: '${clientId}'.`);\n          return response.data.access_token;\n        } catch (error: any) {\n          this._logError(`OAuth2 with Basic Auth header failed for '${clientId}':`, error);\n          throw error;\n        }\n      })()\n    );\n\n    // Try both methods, and resolve if any succeed\n    try {\n      return await Promise.any(tokenFetchPromises);\n    } catch (aggregateError: any) {\n      const errorMessages = aggregateError.errors ? aggregateError.errors.map((e: Error) => e.message).join('; ') : String(aggregateError);\n      throw new Error(`Failed to fetch OAuth2 token for client '${clientId}' after trying all methods. Details: ${errorMessages}`);\n    }\n  }\n\n  /**\n   * Builds a URL by substituting path parameters from the provided arguments.\n   * Used arguments are removed from the `args` object.\n   *\n   * @param urlTemplate The URL template with path parameters in `{param_name}` format.\n   * @param args The dictionary of arguments; modified to remove path parameters.\n   * @returns The URL with path parameters substituted.\n   * @throws Error if a required path parameter is missing.\n   */\n  private _buildUrlWithPathParams(urlTemplate: string, args: Record<string, any>): string {\n    let url = urlTemplate;\n    const pathParams = urlTemplate.match(/\\{([^}]+)\\}/g) || [];\n\n    for (const param of pathParams) {\n      const paramName = param.slice(1, -1);\n      if (paramName in args) {\n        // URL-encode the parameter value to prevent path injection\n        url = url.replace(param, encodeURIComponent(String(args[paramName])));\n        delete args[paramName];\n      } else {\n        throw new Error(`Missing required path parameter: ${paramName}`);\n      }\n    }\n\n    const remainingParams = url.match(/\\{([^}]+)\\}/g);\n    if (remainingParams && remainingParams.length > 0) {\n      throw new Error(`Missing required path parameters in URL template: ${remainingParams.join(', ')}`);\n    }\n\n    return url;\n  }\n}",
      "line_count": 388,
      "word_count": 1617,
      "title": "Http Communication Protocol.Ts",
      "summary": "// packages/http/src/http_communication_protocol.ts import axios, { AxiosInstance, AxiosRequestConfig, Method } from 'axios';",
      "key_terms": [
        "close",
        "const",
        "packages",
        "clear",
        "Closes",
        "localhost",
        "convert",
        "Type",
        "Record",
        "cookie",
        "providers",
        "yield",
        "Found",
        "apiKeyAuth",
        "toolName",
        "if",
        "that",
        "Details",
        "no-op",
        "basic"
      ],
      "timestamp": "2025-12-24T18:56:19.312062"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\http\\src\\index.ts",
      "content_type": "code",
      "content": "/**\n * HTTP Communication Protocol plugin for UTCP.\n * Includes HTTP, Streamable HTTP, and SSE (Server-Sent Events) protocols.\n */\n// packages/http/src/index.ts\nimport { CommunicationProtocol, CallTemplateSerializer, ensureCorePluginsInitialized } from '@utcp/sdk';\nimport { HttpCallTemplateSerializer } from './http_call_template';\nimport { StreamableHttpCallTemplateSerializer } from './streamable_http_call_template';\nimport { SseCallTemplateSerializer } from './sse_call_template';\nimport { HttpCommunicationProtocol } from './http_communication_protocol';\nimport { StreamableHttpCommunicationProtocol } from './streamable_http_communication_protocol';\nimport { SseCommunicationProtocol } from './sse_communication_protocol';\n\n/**\n * Registers all HTTP-based protocol CallTemplate serializers\n * and their CommunicationProtocol implementations.\n * This function is called automatically when the package is imported.\n */\nexport function register(override: boolean = false): void {\n  // Ensure core plugins (including auth serializers) are initialized first\n  ensureCorePluginsInitialized();\n  // Register HTTP\n  CallTemplateSerializer.registerCallTemplate('http', new HttpCallTemplateSerializer(), override);\n  CommunicationProtocol.communicationProtocols['http'] = new HttpCommunicationProtocol();\n  \n  // Register Streamable HTTP\n  CallTemplateSerializer.registerCallTemplate('streamable_http', new StreamableHttpCallTemplateSerializer(), override);\n  CommunicationProtocol.communicationProtocols['streamable_http'] = new StreamableHttpCommunicationProtocol();\n  \n  // Register SSE (Server-Sent Events)\n  CallTemplateSerializer.registerCallTemplate('sse', new SseCallTemplateSerializer(), override);\n  CommunicationProtocol.communicationProtocols['sse'] = new SseCommunicationProtocol();\n}\n\n// Automatically register HTTP plugins on import\nregister();\n\nexport * from './http_call_template';\nexport * from './http_communication_protocol';\nexport * from './streamable_http_call_template';\nexport * from './streamable_http_communication_protocol';\nexport * from './sse_call_template';\nexport * from './sse_communication_protocol';\nexport { OpenApiConverter } from './openapi_converter';\nexport type { OpenApiConverterOptions } from './openapi_converter';",
      "line_count": 45,
      "word_count": 191,
      "title": "Index.Ts",
      "summary": "* HTTP Communication Protocol plugin for UTCP. * Includes HTTP, Streamable HTTP, and SSE (Server-Sent Events) protocols.",
      "key_terms": [
        "implementations",
        "packages",
        "based",
        "index",
        "sse",
        "function",
        "communicationProtocols",
        "HTTP-based",
        "Ensure",
        "type",
        "when",
        "their",
        "CommunicationProtocol",
        "are",
        "Sent",
        "Protocol",
        "OpenApiConverterOptions",
        "OpenApiConverter",
        "SseCallTemplateSerializer",
        "imported"
      ],
      "timestamp": "2025-12-24T18:56:19.343620"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\http\\src\\openapi_converter.ts",
      "content_type": "code",
      "content": "/**\n * OpenAPI specification converter for UTCP tool generation.\n *\n * This module provides functionality to convert OpenAPI specifications (both 2.0\n * and 3.0) into UTCP tool definitions. It handles schema resolution, authentication\n * mapping, and proper tool creation from REST API specifications.\n *\n * Key Features:\n *     - OpenAPI 2.0 and 3.0 specification support.\n *     - Automatic JSON reference ($ref) resolution.\n *     - Authentication scheme mapping (API key, Basic, OAuth2).\n *     - Input/output schema extraction from OpenAPI schemas.\n *     - URL path parameter handling.\n *     - Request body and header field mapping.\n *     - Call template name generation from specification metadata.\n *\n * The converter creates UTCP tools that can be used to interact with REST APIs\n * defined by OpenAPI specifications, providing a bridge between OpenAPI and UTCP.\n */\n// packages/http/src/openapi_converter.ts\nimport { Tool, JsonSchemaSchema, JsonSchema } from '@utcp/sdk';\nimport { UtcpManual, UtcpManualSerializer } from '@utcp/sdk';\nimport { Auth } from '@utcp/sdk';\nimport { ApiKeyAuth } from '@utcp/sdk';\nimport { BasicAuth } from '@utcp/sdk';\nimport { OAuth2Auth } from '@utcp/sdk';\nimport { HttpCallTemplate } from './http_call_template';\n\n/**\n * Options for the OpenAPI converter.\n */\nexport interface OpenApiConverterOptions {\n  specUrl?: string;\n  callTemplateName?: string;\n  authTools?: Auth;\n  baseUrl?: string;\n}\n\n/**\n * REQUIRED\n * Converts OpenAPI specifications into UTCP tool definitions.\n *\n * Processes OpenAPI 2.0 and 3.0 specifications to generate equivalent UTCP\n * tools, handling schema resolution, authentication mapping, and proper\n * HTTP call_template configuration. Each operation in the OpenAPI spec becomes\n * a UTCP tool with appropriate input/output schemas.\n */\nexport class OpenApiConverter {\n  private spec: Record<string, any>;\n  private spec_url: string | undefined;\n  private base_url: string | undefined;\n  private auth_tools: Auth | undefined;\n  private placeholder_counter: number = 0;\n  private call_template_name: string;\n\n  /**\n   * Initializes the OpenAPI converter.\n   *\n   * @param openapi_spec Parsed OpenAPI specification as a dictionary.\n   * @param options Optional settings including spec_url, call_template_name, auth_tools, and baseUrl.\n   *     - specUrl: URL where the specification was retrieved from.\n   *     - callTemplateName: Custom name for the call_template if spec title not provided.\n   *     - authTools: Optional auth configuration for generated tools.\n   *     - baseUrl: Optional base URL override for all API endpoints.\n   */\n  constructor(openapi_spec: Record<string, any>, options?: OpenApiConverterOptions) {\n    this.spec = openapi_spec;\n    this.spec_url = options?.specUrl;\n    this.base_url = options?.baseUrl;\n    this.auth_tools = options?.authTools;\n    this.placeholder_counter = 0;\n\n    let callTemplateName = options?.callTemplateName;\n    if (!callTemplateName) {\n      callTemplateName = 'openapi_call_template_' + this._generateUuid();\n    }\n    const title = openapi_spec.info?.title || callTemplateName;\n    // Replace characters that are invalid for identifiers\n    const invalidChars = \" -.,!?'\\\"\\\\/() []{}#@$%^&*+=~`|;:<>\";\n    this.call_template_name = Array.from(String(title)).map(c => invalidChars.includes(c) ? '_' : c).join('');\n  }\n\n  private _generateUuid(): string {\n    // Simple UUID hex generator without dashes\n    return 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'.replace(/x/g, () => {\n      return Math.floor(Math.random() * 16).toString(16);\n    });\n  }\n\n  private _incrementPlaceholderCounter(): number {\n    this.placeholder_counter++;\n    return this.placeholder_counter;\n  }\n\n  private _getPlaceholder(baseName: string): string {\n    return `\\$\\{${baseName.toUpperCase()}_${this.placeholder_counter}\\}`;\n  }\n\n  /**\n   * Parses the OpenAPI specification and returns a UtcpManual.\n   * @returns A UTCP manual containing tools derived from the OpenAPI specification.\n   */\n  /**\n   * REQUIRED\n   * Converts the loaded OpenAPI specification into a UtcpManual.\n   */\n  public convert(): UtcpManual {\n    this.placeholder_counter = 0;\n    const tools: Tool[] = [];\n    let baseUrl = '/';\n\n    // 1. Explicit baseUrl option (highest priority)\n    if (this.base_url) {\n      baseUrl = this.base_url;\n    }\n    // 2. OpenAPI 3.0 servers field\n    else if (this.spec.servers && Array.isArray(this.spec.servers) && this.spec.servers.length > 0 && this.spec.servers[0].url) {\n      baseUrl = this.spec.servers[0].url;\n    }\n    // 3. OpenAPI 2.0 host and basePath fields\n    else if (this.spec.host) {\n      const scheme = this.spec.schemes?.[0] || 'https';\n      const basePath = this.spec.basePath || '';\n      baseUrl = `${scheme}://${this.spec.host}${basePath}`;\n    }\n    // 4. Fallback to spec_url ONLY if it's an HTTP/HTTPS URL\n    else if (this.spec_url && (this.spec_url.startsWith('http://') || this.spec_url.startsWith('https://'))) {\n      try {\n        const parsedUrl = new URL(this.spec_url);\n        baseUrl = `${parsedUrl.protocol}//${parsedUrl.host}`;\n      } catch (e) {\n        console.error(`[OpenApiConverter] Invalid spec_url provided: ${this.spec_url}`);\n      }\n    } else {\n      console.warn(\"[OpenApiConverter] No server info found in OpenAPI spec. Using fallback base URL: '/'. Tools may not work correctly without a valid base URL.\");\n    }\n\n    const paths = this.spec.paths || {};\n    for (const [path, pathItem] of Object.entries(paths)) {\n      for (const [method, operation] of Object.entries(pathItem as Record<string, any>)) {\n        if (['get', 'post', 'put', 'delete', 'patch'].includes(method.toLowerCase())) {\n          const tool = this._createTool(path, method, operation, baseUrl);\n          if (tool) {\n            tools.push(tool);\n          }\n        }\n      }\n    }\n\n    // Use the serializer to leverage default values for utcp_version and manual_version\n    return new UtcpManualSerializer().validateDict({ tools });\n  }\n\n  /**\n   * Resolves a local JSON reference within the OpenAPI spec.\n   * @param ref The reference string (e.g., '#/components/schemas/Pet').\n   * @returns The resolved schema object.\n   */\n  private _resolveRef(ref: string): Record<string, any> {\n    if (!ref.startsWith('#/')) {\n      // External or non-local references are not fully supported by this simple resolver.\n      // For a robust implementation, external fetches would be needed.\n      return { $ref: ref }; // Return the ref itself to indicate it's unresolved\n    }\n\n    const parts = ref.substring(2).split('/');\n    let node: any = this.spec;\n\n    for (const part of parts) {\n      // Decode URI components in case the part contains slashes or other special characters\n      const decodedPart = decodeURIComponent(part);\n      if (node[decodedPart] === undefined) {\n        // Reference not found, return the ref to prevent crashing\n        return { $ref: ref };\n      }\n      node = node[decodedPart];\n    }\n\n    return node;\n  }\n\n  /**\n   * Recursively resolves all $refs in a schema object, preventing infinite loops.\n   * @param schema The schema object that may contain references.\n   * @param visitedRefs A set of references already visited to detect cycles.\n   * @returns The resolved schema with all references replaced by their actual values.\n   */\n  private _resolveSchema(schema: any, visitedRefs: Set<string> = new Set()): any {\n    if (schema === null || typeof schema !== 'object') {\n      return schema;\n    }\n\n    if (Array.isArray(schema)) {\n      return schema.map(item => this._resolveSchema(item, visitedRefs));\n    }\n\n    if ('$ref' in schema && typeof schema.$ref === 'string') {\n      const ref = schema.$ref;\n      if (visitedRefs.has(ref)) {\n        // Cycle detected, return the reference itself to break the loop\n        return { $ref: ref };\n      }\n      visitedRefs.add(ref);\n      const resolvedRef = this._resolveRef(ref);\n      // Recursively resolve the content of the resolved reference\n      return this._resolveSchema(resolvedRef, visitedRefs);\n    }\n\n    const newSchema: Record<string, any> = {};\n    for (const [key, value] of Object.entries(schema)) {\n      newSchema[key] = this._resolveSchema(value, visitedRefs);\n    }\n\n    return newSchema;\n  }\n\n  /**\n   * Creates a Tool object from an OpenAPI operation.\n   * @param path The API path.\n   * @param method The HTTP method (GET, POST, etc.).\n   * @param operation The operation definition from OpenAPI.\n   * @param baseUrl The base URL for the API.\n   * @returns A Tool object or null if operationId is not defined.\n   */\n  private _createTool(\n    path: string,\n    method: string,\n    operation: Record<string, any>,\n    baseUrl: string\n  ): Tool | null {\n    const operationId = operation.operationId;\n    if (!operationId) {\n      return null;\n    }\n\n    const description = operation.summary || operation.description || '';\n    const tags = operation.tags || [];\n\n    const { inputs, headerFields, bodyField } = this._extractInputs(path, operation);\n    const outputs = this._extractOutputs(operation);\n    const auth = this._extractAuth(operation);\n    const fullUrl = `${baseUrl.replace(/\\/$/, '')}/${path.replace(/^\\/+/, '')}`;\n\n    const callTemplate: HttpCallTemplate = {\n      name: this.call_template_name,\n      call_template_type: 'http',\n      http_method: method.toUpperCase() as 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH',\n      url: fullUrl,\n      body_field: bodyField ?? undefined,\n      header_fields: headerFields.length > 0 ? headerFields : undefined,\n      auth,\n      content_type: 'application/json',\n      timeout: 30\n    };\n\n    return {\n      name: operationId,\n      description,\n      inputs: JsonSchemaSchema.parse(inputs),\n      outputs: JsonSchemaSchema.parse(outputs),\n      tags,\n      tool_call_template: callTemplate\n    };\n  }\n\n  /**\n   * Extracts the input schema, header fields, and body field from an OpenAPI operation.\n   * - Merges path-level and operation-level parameters.\n   * - Resolves $ref for parameters.\n   * - Supports OpenAPI 2.0 body parameters and 3.0 requestBody.\n   * @param path The API path.\n   * @param operation The OpenAPI operation object.\n   * @returns An object containing the inputs schema, a list of header field names, and the body field name (if any).\n   */\n  private _extractInputs(path: string, operation: Record<string, any>): { inputs: JsonSchema; headerFields: string[]; bodyField: string | null } {\n    const properties: Record<string, JsonSchema> = {};\n    const required: string[] = [];\n    const headerFields: string[] = [];\n    let bodyField: string | null = null;\n\n    // Merge path-level and operation-level parameters\n    const pathItem = this.spec.paths?.[path] || {};\n    const allParams = [...(pathItem.parameters || []), ...(operation.parameters || [])];\n\n    for (const param of allParams) {\n      const resolvedParam = this._resolveSchema(param);\n      const paramName = resolvedParam.name;\n      if (!paramName) continue;\n\n      if (resolvedParam.in === 'header') {\n        headerFields.push(paramName);\n      }\n\n      // OpenAPI 2.0 body parameter (deprecated in 3.0, but still possible)\n      if (resolvedParam.in === 'body') {\n        bodyField = 'body';\n        const jsonSchema = this._resolveSchema(resolvedParam.schema || {});\n        properties[bodyField] = {\n          description: resolvedParam.description || 'Request body',\n          ...jsonSchema,\n        };\n        if (resolvedParam.required) {\n          required.push(bodyField);\n        }\n        continue;\n      }\n\n      // Other parameters (query, path, header, cookie)\n      const schema = this._resolveSchema(resolvedParam.schema || {});\n      // For OpenAPI 2.0, non-body parameters might have type/items directly on the parameter object\n      if (!schema.type && resolvedParam.type) schema.type = resolvedParam.type;\n      if (!schema.items && resolvedParam.items) schema.items = resolvedParam.items;\n      if (!schema.enum && resolvedParam.enum) schema.enum = resolvedParam.enum;\n\n\n      properties[paramName] = {\n        description: resolvedParam.description || '',\n        ...schema,\n      };\n      if (resolvedParam.required) {\n        required.push(paramName);\n      }\n    }\n\n    // Handle request body (OpenAPI 3.0 equivalent of 'body' parameter)\n    const requestBody = operation.requestBody;\n    if (requestBody) {\n      const resolvedBody = this._resolveSchema(requestBody);\n      const content = resolvedBody.content || {};\n      const jsonSchema = content['application/json']?.schema || content['application/x-www-form-urlencoded']?.schema;\n\n      if (jsonSchema) {\n        bodyField = 'body';\n        properties[bodyField] = {\n          description: resolvedBody.description || 'Request body',\n          ...this._resolveSchema(jsonSchema),\n        };\n        if (resolvedBody.required) {\n          required.push(bodyField);\n        }\n      }\n    }\n\n    const inputs: JsonSchema = {\n      type: 'object',\n      properties,\n      required: required.length > 0 ? required : undefined\n    };\n\n    return { inputs, headerFields, bodyField };\n  }\n\n  /**\n   * Extracts the output schema from an OpenAPI operation, resolving refs.\n   * @param operation The OpenAPI operation object.\n   * @returns The output schema.\n   */\n  private _extractOutputs(operation: Record<string, any>): JsonSchema {\n    const responses = operation.responses || {};\n    // Prioritize 200/201 responses, then fall back to 'default'\n    const successResponse = responses['200'] || responses['201'] || responses['default'];\n\n    if (!successResponse) {\n      return {};\n    }\n\n    const resolvedResponse = this._resolveSchema(successResponse);\n    let jsonSchema: any = null;\n\n    if ('content' in resolvedResponse) { // OpenAPI 3.0\n      const content = resolvedResponse.content || {};\n      jsonSchema = content['application/json']?.schema || content['text/plain']?.schema;\n      if (!jsonSchema && Object.keys(content).length > 0) {\n        // Fallback to first content type's schema, with a type guard\n        const firstContentTypeValue = Object.values(content)[0];\n        if (typeof firstContentTypeValue === 'object' && firstContentTypeValue !== null && 'schema' in firstContentTypeValue) {\n          jsonSchema = (firstContentTypeValue as { schema: any }).schema;\n        }\n      }\n    } else if ('schema' in resolvedResponse) { // OpenAPI 2.0\n      jsonSchema = resolvedResponse.schema;\n    }\n\n    if (!jsonSchema) {\n      return {};\n    }\n\n    const resolvedJsonSchema = this._resolveSchema(jsonSchema);\n    const schemaArgs: JsonSchema = {\n      type: resolvedJsonSchema.type || 'object',\n      properties: resolvedJsonSchema.properties || undefined,\n      required: resolvedJsonSchema.required || undefined,\n      description: resolvedJsonSchema.description || undefined,\n      title: resolvedJsonSchema.title || undefined,\n      items: resolvedJsonSchema.items || undefined,\n      enum: resolvedJsonSchema.enum || undefined,\n      minimum: resolvedJsonSchema.minimum || undefined,\n      maximum: resolvedJsonSchema.maximum || undefined,\n      format: resolvedJsonSchema.format || undefined,\n    };\n\n    return schemaArgs;\n  }\n\n  /**\n   * Extracts authentication information from OpenAPI operation and global security schemes.\n   * Uses auth_tools configuration when compatible with OpenAPI auth requirements.\n   * Supports both OpenAPI 2.0 and 3.0 security schemes.\n   * @param operation The OpenAPI operation object.\n   * @returns An Auth object or undefined if no authentication is specified.\n   */\n  private _extractAuth(operation: Record<string, any>): Auth | undefined {\n    // First check for operation-level security requirements\n    let securityRequirements = operation.security || [];\n    \n    // If no operation-level security, check global security requirements\n    if (!securityRequirements.length) {\n      securityRequirements = this.spec.security || [];\n    }\n    \n    // If no security requirements, return undefined (endpoint is public)\n    if (!securityRequirements.length) {\n      return undefined;\n    }\n    \n    // Generate auth from OpenAPI security schemes - support both OpenAPI 2.0 and 3.0\n    const securitySchemes = this._getSecuritySchemes();\n    \n    // Process the first security requirement (most common case)\n    // Each security requirement is a dict with scheme name as key\n    for (const securityReq of securityRequirements) {\n      for (const schemeName of Object.keys(securityReq)) {\n        if (schemeName in securitySchemes) {\n          const scheme = securitySchemes[schemeName];\n          const openapiAuth = this._createAuthFromScheme(scheme, schemeName);\n          \n          // If compatible with auth_tools, use actual values from manual call template\n          if (this._isAuthCompatible(openapiAuth, this.auth_tools)) {\n            return this.auth_tools;\n          } else {\n            return openapiAuth;  // Use placeholder from OpenAPI scheme\n          }\n        }\n      }\n    }\n    \n    return undefined;\n  }\n\n  /**\n   * Checks if auth_tools configuration is compatible with OpenAPI auth requirements.\n   * \n   * @param openapiAuth Auth generated from OpenAPI security scheme\n   * @param authTools Auth configuration from manual call template\n   * @returns True if compatible and auth_tools should be used, False otherwise\n   */\n  private _isAuthCompatible(openapiAuth: Auth | undefined, authTools: Auth | undefined): boolean {\n    if (!openapiAuth || !authTools) {\n      return false;\n    }\n    \n    // Must be same auth type\n    if (openapiAuth.auth_type !== authTools.auth_type) {\n      return false;\n    }\n    \n    // For API Key auth, check header name and location compatibility\n    if ('var_name' in openapiAuth && 'var_name' in authTools) {\n      const openapiVar = (openapiAuth as any).var_name?.toLowerCase() || '';\n      const toolsVar = (authTools as any).var_name?.toLowerCase() || '';\n      \n      if (openapiVar !== toolsVar) {\n        return false;\n      }\n      \n      if ('location' in openapiAuth && 'location' in authTools) {\n        if ((openapiAuth as any).location !== (authTools as any).location) {\n          return false;\n        }\n      }\n    }\n    \n    return true;\n  }\n\n  /**\n   * Gets security schemes supporting both OpenAPI 2.0 and 3.0.\n   * @returns A record of security schemes.\n   */\n  private _getSecuritySchemes(): Record<string, any> {\n    // OpenAPI 3.0 format\n    if ('components' in this.spec) {\n      return this.spec.components?.securitySchemes || {};\n    }\n    // OpenAPI 2.0 format\n    return this.spec.securityDefinitions || {};\n  }\n\n  /**\n   * Creates an Auth object from an OpenAPI security scheme.\n   * @param scheme The security scheme object.\n   * @param schemeName The name of the security scheme.\n   * @returns An Auth object or undefined if the scheme is not supported.\n   */\n  private _createAuthFromScheme(scheme: Record<string, any>, schemeName: string): Auth | undefined {\n    const schemeType = (scheme.type || '').toLowerCase();\n\n    if (schemeType === 'apikey') {\n      // For API key auth, use the parameter name from the OpenAPI spec\n      const location = (scheme.in || 'header') as 'header' | 'query' | 'cookie';\n      const paramName = scheme.name || 'Authorization';\n      // Use the current counter value for the placeholder\n      const apiKeyPlaceholder = this._getPlaceholder('API_KEY');\n      // Increment the counter after using it\n      this._incrementPlaceholderCounter();\n      return {\n        auth_type: 'api_key',\n        api_key: apiKeyPlaceholder,\n        var_name: paramName,\n        location,\n      } as ApiKeyAuth;\n    }\n\n    if (schemeType === 'basic') {\n      // OpenAPI 2.0 format: type: basic\n      // Use the current counter value for both placeholders\n      const usernamePlaceholder = this._getPlaceholder('USERNAME');\n      const passwordPlaceholder = this._getPlaceholder('PASSWORD');\n      // Increment the counter after using it\n      this._incrementPlaceholderCounter();\n      return {\n        auth_type: 'basic',\n        username: usernamePlaceholder,\n        password: passwordPlaceholder,\n      } as BasicAuth;\n    }\n\n    if (schemeType === 'http') {\n      // OpenAPI 3.0 format: type: http with scheme\n      const httpScheme = (scheme.scheme || '').toLowerCase();\n      if (httpScheme === 'basic') {\n        // For basic auth, use conventional environment variable names\n        // Use the current counter value for both placeholders\n        const usernamePlaceholder = this._getPlaceholder('USERNAME');\n        const passwordPlaceholder = this._getPlaceholder('PASSWORD');\n        // Increment the counter after using it\n        this._incrementPlaceholderCounter();\n        return {\n          auth_type: 'basic',\n          username: usernamePlaceholder,\n          password: passwordPlaceholder,\n        } as BasicAuth;\n      } else if (httpScheme === 'bearer') {\n        // Treat bearer tokens as API keys\n        // Use the current counter value for the placeholder\n        const apiKeyPlaceholder = this._getPlaceholder('API_KEY');\n        // Increment the counter after using it\n        this._incrementPlaceholderCounter();\n        return {\n          auth_type: 'api_key',\n          api_key: `Bearer ${apiKeyPlaceholder}`,\n          var_name: 'Authorization',\n          location: 'header',\n        } as ApiKeyAuth;\n      }\n    }\n\n    if (schemeType === 'oauth2') {\n      // Handle both OpenAPI 2.0 and 3.0 OAuth2 formats\n      const flows = scheme.flows || {};\n      \n      // OpenAPI 3.0 format\n      if (Object.keys(flows).length > 0) {\n        for (const [flowType, flowConfig] of Object.entries(flows)) {\n          // Support both old and new flow names\n          if (['authorizationCode', 'accessCode', 'clientCredentials', 'application'].includes(flowType)) {\n            const tokenUrl = (flowConfig as Record<string, any>).tokenUrl;\n            if (tokenUrl) {\n              // Use the current counter value for both placeholders\n              const clientIdPlaceholder = this._getPlaceholder('CLIENT_ID');\n              const clientSecretPlaceholder = this._getPlaceholder('CLIENT_SECRET');\n              // Increment the counter after using it\n              this._incrementPlaceholderCounter();\n              const scopes = (flowConfig as Record<string, any>).scopes || {};\n              return {\n                auth_type: 'oauth2',\n                token_url: tokenUrl,\n                client_id: clientIdPlaceholder,\n                client_secret: clientSecretPlaceholder,\n                scope: Object.keys(scopes).length > 0 ? Object.keys(scopes).join(' ') : undefined,\n              } as OAuth2Auth;\n            }\n          }\n        }\n      }\n      \n      // OpenAPI 2.0 format fallback\n      const tokenUrl = scheme.tokenUrl;\n      if (tokenUrl) {\n        const clientIdPlaceholder = this._getPlaceholder('CLIENT_ID');\n        const clientSecretPlaceholder = this._getPlaceholder('CLIENT_SECRET');\n        this._incrementPlaceholderCounter();\n        const scopes = scheme.scopes || {};\n        return {\n          auth_type: 'oauth2',\n          token_url: tokenUrl,\n          client_id: clientIdPlaceholder,\n          client_secret: clientSecretPlaceholder,\n          scope: Object.keys(scopes).length > 0 ? Object.keys(scopes).join(' ') : undefined,\n        } as OAuth2Auth;\n      }\n    }\n\n    return undefined;\n  }\n}",
      "line_count": 616,
      "word_count": 2582,
      "title": "Openapi Converter.Ts",
      "summary": "* OpenAPI specification converter for UTCP tool generation. * This module provides functionality to convert OpenAPI specifications (both 2.0",
      "key_terms": [
        "const",
        "contain",
        "packages",
        "etc",
        "schemeName",
        "convert",
        "conventional",
        "Record",
        "list",
        "parsedUrl",
        "cookie",
        "callTemplate",
        "global",
        "baseUrl",
        "Creates",
        "if",
        "that",
        "Features",
        "interface",
        "supported"
      ],
      "timestamp": "2025-12-24T18:56:19.398560"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\http\\src\\sse_call_template.ts",
      "content_type": "code",
      "content": "// packages/http/src/sse_call_template.ts\nimport { z } from 'zod';\nimport { Auth, AuthSchema } from '@utcp/sdk';\nimport { CallTemplate } from '@utcp/sdk';\nimport { Serializer } from '@utcp/sdk';\n\n/**\n * REQUIRED\n * Provider configuration for Server-Sent Events (SSE) tools.\n *\n * Enables real-time streaming of events from server to client using the\n * Server-Sent Events protocol. Supports automatic reconnection and\n * event type filtering. All tool arguments not mapped to URL body, headers\n * or query pattern parameters are passed as query parameters using '?arg_name={arg_value}'.\n *\n * Attributes:\n *     call_template_type: Always \"sse\" for SSE providers.\n *     url: The SSE endpoint URL to connect to.\n *     event_type: Optional filter for specific event types. If None, all events are received.\n *     reconnect: Whether to automatically reconnect on connection loss.\n *     retry_timeout: Timeout in milliseconds before attempting reconnection.\n *     auth: Optional authentication configuration.\n *     headers: Optional static headers for the initial connection.\n *     body_field: Optional tool argument name to map to request body during connection.\n *     header_fields: List of tool argument names to map to HTTP headers during connection.\n */\nexport interface SseCallTemplate extends CallTemplate {\n  call_template_type: 'sse';\n  url: string;\n  event_type?: string | null;\n  reconnect: boolean;\n  retry_timeout: number;\n  headers?: Record<string, string>;\n  body_field?: string | null;\n  header_fields?: string[] | null;\n  allowed_communication_protocols?: string[];\n}\n\n/**\n * SSE Call Template schema.\n */\nexport const SseCallTemplateSchema: z.ZodType<SseCallTemplate> = z.object({\n  name: z.string().optional(),\n  call_template_type: z.literal('sse'),\n  url: z.string().describe('The SSE endpoint URL to connect to.'),\n  event_type: z.string().nullable().optional().describe('Optional filter for specific event types. If null, all events are received.'),\n  reconnect: z.boolean().default(true).describe('Whether to automatically reconnect on connection loss.'),\n  retry_timeout: z.number().default(30000).describe('Timeout in milliseconds before attempting reconnection.'),\n  auth: AuthSchema.optional().describe('Optional authentication configuration.'),\n  headers: z.record(z.string(), z.string()).optional().describe('Optional static headers for the initial connection.'),\n  body_field: z.string().nullable().optional().describe('The name of the single input field to be sent as the request body.'),\n  header_fields: z.array(z.string()).nullable().optional().describe('List of input fields to be sent as request headers for the initial connection.'),\n  allowed_communication_protocols: z.array(z.string()).optional().describe('Optional list of allowed communication protocol types for tools within this manual.'),\n}) as z.ZodType<SseCallTemplate>;\n\n/**\n * REQUIRED\n * Serializer for SseCallTemplate.\n */\nexport class SseCallTemplateSerializer extends Serializer<SseCallTemplate> {\n  /**\n   * REQUIRED\n   * Convert SseCallTemplate to dictionary.\n   */\n  toDict(obj: SseCallTemplate): Record<string, unknown> {\n    return {\n      name: obj.name,\n      call_template_type: obj.call_template_type,\n      url: obj.url,\n      event_type: obj.event_type,\n      reconnect: obj.reconnect,\n      retry_timeout: obj.retry_timeout,\n      auth: obj.auth,\n      headers: obj.headers,\n      body_field: obj.body_field,\n      header_fields: obj.header_fields,\n      allowed_communication_protocols: obj.allowed_communication_protocols,\n    };\n  }\n\n  /**\n   * REQUIRED\n   * Validate dictionary and convert to SseCallTemplate.\n   */\n  validateDict(obj: Record<string, unknown>): SseCallTemplate {\n    try {\n      return SseCallTemplateSchema.parse(obj);\n    } catch (e: any) {\n      throw new Error(`Invalid SseCallTemplate: ${e.message}\\n${e.stack || ''}`);\n    }\n  }\n}\n",
      "line_count": 93,
      "word_count": 409,
      "title": "Sse Call Template.Ts",
      "summary": "// packages/http/src/sse_call_template.ts import { z } from 'zod';",
      "key_terms": [
        "Timeout",
        "nullable",
        "null",
        "const",
        "packages",
        "REQUIRED",
        "number",
        "headers",
        "If",
        "pattern",
        "record",
        "convert",
        "Record",
        "list",
        "during",
        "unknown",
        "connect",
        "providers",
        "received",
        "string"
      ],
      "timestamp": "2025-12-24T18:56:19.437325"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\http\\src\\sse_communication_protocol.ts",
      "content_type": "code",
      "content": "/**\n * Server-Sent Events (SSE) Communication Protocol for UTCP.\n * \n * Handles Server-Sent Events based tool providers with streaming capabilities.\n */\n// packages/http/src/sse_communication_protocol.ts\nimport { CommunicationProtocol } from '@utcp/sdk';\nimport { RegisterManualResult } from '@utcp/sdk';\nimport { CallTemplate } from '@utcp/sdk';\nimport { UtcpManual, UtcpManualSerializer } from '@utcp/sdk';\nimport { ApiKeyAuth } from '@utcp/sdk';\nimport { BasicAuth } from '@utcp/sdk';\nimport { OAuth2Auth } from '@utcp/sdk';\nimport { IUtcpClient } from '@utcp/sdk';\nimport { SseCallTemplate } from './sse_call_template';\n\n/**\n * REQUIRED\n * SSE communication protocol implementation for UTCP client.\n * \n * Handles Server-Sent Events based tool providers with streaming capabilities.\n */\nexport class SseCommunicationProtocol implements CommunicationProtocol {\n  private oauthTokens: Map<string, { access_token: string; expires_at?: number }> = new Map();\n\n  private _logInfo(message: string): void {\n    console.log(`[SseCommunicationProtocol] ${message}`);\n  }\n\n  private _logError(message: string): void {\n    console.error(`[SseCommunicationProtocol] ${message}`);\n  }\n\n  private _applyAuth(\n    provider: SseCallTemplate,\n    headers: Record<string, string>,\n    queryParams: Record<string, any>\n  ): { auth?: { username: string; password: string }; cookies: Record<string, string> } {\n    let auth: { username: string; password: string } | undefined;\n    const cookies: Record<string, string> = {};\n\n    if (provider.auth) {\n      if ('api_key' in provider.auth) {\n        const apiKeyAuth = provider.auth as ApiKeyAuth;\n        if (apiKeyAuth.api_key) {\n          // Default to 'header' if location is not specified\n          const location = apiKeyAuth.location || 'header';\n          if (location === 'header') {\n            headers[apiKeyAuth.var_name] = apiKeyAuth.api_key;\n          } else if (location === 'query') {\n            queryParams[apiKeyAuth.var_name] = apiKeyAuth.api_key;\n          } else if (location === 'cookie') {\n            cookies[apiKeyAuth.var_name] = apiKeyAuth.api_key;\n          }\n        } else {\n          this._logError('API key not found for ApiKeyAuth.');\n          throw new Error('API key for ApiKeyAuth not found.');\n        }\n      } else if ('username' in provider.auth && 'password' in provider.auth) {\n        const basicAuth = provider.auth as BasicAuth;\n        auth = { username: basicAuth.username, password: basicAuth.password };\n      } else if ('token_url' in provider.auth) {\n        // OAuth2 will be handled separately\n      }\n    }\n\n    return { auth, cookies };\n  }\n\n  /**\n   * REQUIRED\n   * Register a manual and its tools from an SSE provider.\n   */\n  async registerManual(\n    caller: IUtcpClient,\n    manualCallTemplate: CallTemplate\n  ): Promise<RegisterManualResult> {\n    if ((manualCallTemplate as any).call_template_type !== 'sse') {\n      throw new Error('SseCommunicationProtocol can only be used with SseCallTemplate');\n    }\n\n    const provider = manualCallTemplate as SseCallTemplate;\n    const url = provider.url;\n\n    // Security check: Enforce HTTPS or localhost to prevent MITM attacks\n    if (\n      !url.startsWith('https://') &&\n      !url.startsWith('http://localhost') &&\n      !url.startsWith('http://127.0.0.1')\n    ) {\n      throw new Error(\n        `Security error: URL must use HTTPS or start with 'http://localhost' or 'http://127.0.0.1'. Got: ${url}. ` +\n          'Non-secure URLs are vulnerable to man-in-the-middle attacks.'\n      );\n    }\n\n    this._logInfo(`Discovering tools from '${provider.name}' (SSE) at ${url}`);\n\n    try {\n      const requestHeaders: Record<string, string> = provider.headers ? { ...provider.headers } : {};\n      const queryParams: Record<string, any> = {};\n      const { auth, cookies } = this._applyAuth(provider, requestHeaders, queryParams);\n\n      // Build URL with query parameters\n      const urlObj = new URL(url);\n      Object.entries(queryParams).forEach(([key, value]) => {\n        urlObj.searchParams.append(key, String(value));\n      });\n\n      // SSE requires Accept: text/event-stream\n      requestHeaders['Accept'] = 'text/event-stream';\n\n      // Build fetch options\n      const fetchOptions: RequestInit = {\n        method: 'GET',\n        headers: requestHeaders,\n      };\n\n      // Add basic auth if present\n      if (auth) {\n        const credentials = Buffer.from(`${auth.username}:${auth.password}`).toString('base64');\n        fetchOptions.headers = {\n          ...fetchOptions.headers as Record<string, string>,\n          'Authorization': `Basic ${credentials}`,\n        };\n      }\n\n      // Make discovery request\n      const response = await fetch(urlObj.toString(), fetchOptions);\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      // For SSE discovery, we expect the first event to contain the manual\n      // This is a simplified implementation\n      const responseText = await response.text();\n      const utcpManual = new UtcpManualSerializer().validateDict(JSON.parse(responseText));\n\n      this._logInfo(`Discovered ${utcpManual.tools.length} tools from '${provider.name}'`);\n\n      return {\n        manualCallTemplate: provider,\n        manual: utcpManual,\n        success: true,\n        errors: [],\n      };\n    } catch (error: any) {\n      this._logError(`Error discovering tools from '${provider.name}': ${error.message}`);\n      return {\n        manualCallTemplate: provider,\n        manual: new UtcpManualSerializer().validateDict({ tools: [] }),\n        success: false,\n        errors: [error.message || String(error)],\n      };\n    }\n  }\n\n  /**\n   * REQUIRED\n   * Deregister a manual (no-op for SSE).\n   */\n  async deregisterManual(caller: IUtcpClient, manualCallTemplate: CallTemplate): Promise<void> {\n    // No-op for SSE\n  }\n\n  /**\n   * REQUIRED\n   * Call a tool using SSE (non-streaming).\n   */\n  async callTool(\n    caller: IUtcpClient,\n    toolName: string,\n    toolArgs: Record<string, any>,\n    toolCallTemplate: CallTemplate\n  ): Promise<any> {\n    // For SSE, we collect all events and return them\n    const events: string[] = [];\n    for await (const event of this.callToolStreaming(caller, toolName, toolArgs, toolCallTemplate)) {\n      events.push(event);\n    }\n    return events;\n  }\n\n  /**\n   * REQUIRED\n   * Call a tool using SSE streaming.\n   * Returns an async generator that yields SSE events.\n   */\n  async *callToolStreaming(\n    caller: IUtcpClient,\n    toolName: string,\n    toolArgs: Record<string, any>,\n    toolCallTemplate: CallTemplate\n  ): AsyncGenerator<any, void, unknown> {\n    const provider = toolCallTemplate as SseCallTemplate;\n\n    // TODO: Implement actual SSE call logic\n    // This would involve connecting to the SSE endpoint and streaming events\n    this._logInfo(`Calling SSE tool '${toolName}' with args: ${JSON.stringify(toolArgs)}`);\n    \n    // Placeholder implementation\n    yield `SSE event for tool: ${toolName}`;\n  }\n\n  /**\n   * REQUIRED\n   * Close all active connections and clear internal state.\n   */\n  async close(): Promise<void> {\n    this._logInfo('Closing SseCommunicationProtocol.');\n    this.oauthTokens.clear();\n  }\n}\n",
      "line_count": 215,
      "word_count": 772,
      "title": "Sse Communication Protocol.Ts",
      "summary": "* Server-Sent Events (SSE) Communication Protocol for UTCP. * Handles Server-Sent Events based tool providers with streaming capabilities.",
      "key_terms": [
        "toString",
        "close",
        "const",
        "contain",
        "packages",
        "we",
        "clear",
        "REQUIRED",
        "number",
        "async",
        "error",
        "headers",
        "localhost",
        "utcpManual",
        "vulnerable",
        "based",
        "Record",
        "check",
        "cookie",
        "Implement"
      ],
      "timestamp": "2025-12-24T18:56:19.487046"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\http\\src\\streamable_http_call_template.ts",
      "content_type": "code",
      "content": "// packages/http/src/streamable_http_call_template.ts\nimport { z } from 'zod';\nimport { Auth, AuthSchema } from '@utcp/sdk';\nimport { CallTemplate } from '@utcp/sdk';\nimport { Serializer } from '@utcp/sdk';\n\n/**\n * REQUIRED\n * Provider configuration for HTTP streaming tools.\n *\n * Uses HTTP Chunked Transfer Encoding to enable streaming of large responses\n * or real-time data. Useful for tools that return large datasets or provide\n * progressive results. All tool arguments not mapped to URL body, headers\n * or query pattern parameters are passed as query parameters using '?arg_name={arg_value}'.\n *\n * Attributes:\n *     call_template_type: Always \"streamable_http\" for HTTP streaming providers.\n *     url: The streaming HTTP endpoint URL. Supports path parameters.\n *     http_method: The HTTP method to use (GET or POST).\n *     content_type: The Content-Type header for requests.\n *     chunk_size: Size of each chunk in bytes for reading the stream.\n *     timeout: Request timeout in milliseconds.\n *     headers: Optional static headers to include in requests.\n *     auth: Optional authentication configuration.\n *     body_field: Optional tool argument name to map to HTTP request body.\n *     header_fields: List of tool argument names to map to HTTP request headers.\n */\nexport interface StreamableHttpCallTemplate extends CallTemplate {\n  call_template_type: 'streamable_http';\n  url: string;\n  http_method: 'GET' | 'POST';\n  content_type: string;\n  chunk_size: number;\n  timeout: number;\n  headers?: Record<string, string>;\n  body_field?: string | null;\n  header_fields?: string[] | null;\n  allowed_communication_protocols?: string[];\n}\n\n/**\n * Streamable HTTP Call Template schema.\n */\nexport const StreamableHttpCallTemplateSchema: z.ZodType<StreamableHttpCallTemplate> = z.object({\n  name: z.string().optional(),\n  call_template_type: z.literal('streamable_http'),\n  url: z.string().describe('The streaming HTTP endpoint URL. Supports path parameters.'),\n  http_method: z.enum(['GET', 'POST']).default('GET'),\n  content_type: z.string().default('application/octet-stream').describe('The Content-Type header for requests.'),\n  chunk_size: z.number().default(4096).describe('Size of each chunk in bytes for reading the stream.'),\n  timeout: z.number().default(60000).describe('Request timeout in milliseconds.'),\n  auth: AuthSchema.optional().describe('Optional authentication configuration.'),\n  headers: z.record(z.string(), z.string()).optional().describe('Optional static headers to include in requests.'),\n  body_field: z.string().nullable().optional().describe('The name of the single input field to be sent as the request body.'),\n  header_fields: z.array(z.string()).nullable().optional().describe('List of input fields to be sent as request headers.'),\n  allowed_communication_protocols: z.array(z.string()).optional().describe('Optional list of allowed communication protocol types for tools within this manual.'),\n}) as z.ZodType<StreamableHttpCallTemplate>;\n\n/**\n * REQUIRED\n * Serializer for StreamableHttpCallTemplate.\n */\nexport class StreamableHttpCallTemplateSerializer extends Serializer<StreamableHttpCallTemplate> {\n  /**\n   * REQUIRED\n   * Convert StreamableHttpCallTemplate to dictionary.\n   */\n  toDict(obj: StreamableHttpCallTemplate): Record<string, unknown> {\n    return {\n      name: obj.name,\n      call_template_type: obj.call_template_type,\n      url: obj.url,\n      http_method: obj.http_method,\n      content_type: obj.content_type,\n      chunk_size: obj.chunk_size,\n      timeout: obj.timeout,\n      auth: obj.auth,\n      headers: obj.headers,\n      body_field: obj.body_field,\n      header_fields: obj.header_fields,\n      allowed_communication_protocols: obj.allowed_communication_protocols,\n    };\n  }\n\n  /**\n   * REQUIRED\n   * Validate dictionary and convert to StreamableHttpCallTemplate.\n   */\n  validateDict(obj: Record<string, unknown>): StreamableHttpCallTemplate {\n    try {\n      return StreamableHttpCallTemplateSchema.parse(obj);\n    } catch (e: any) {\n      throw new Error(`Invalid StreamableHttpCallTemplate: ${e.message}\\n${e.stack || ''}`);\n    }\n  }\n}\n",
      "line_count": 97,
      "word_count": 415,
      "title": "Streamable Http Call Template.Ts",
      "summary": "// packages/http/src/streamable_http_call_template.ts import { z } from 'zod';",
      "key_terms": [
        "nullable",
        "reading",
        "null",
        "const",
        "packages",
        "REQUIRED",
        "number",
        "each",
        "headers",
        "pattern",
        "record",
        "convert",
        "Type",
        "Record",
        "list",
        "unknown",
        "providers",
        "string",
        "Error",
        "Transfer"
      ],
      "timestamp": "2025-12-24T18:56:19.537770"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\http\\src\\streamable_http_communication_protocol.ts",
      "content_type": "code",
      "content": "/**\n * Streamable HTTP Communication Protocol for UTCP.\n * \n * Handles HTTP streaming with chunked transfer encoding for real-time data.\n */\n// packages/http/src/streamable_http_communication_protocol.ts\nimport { CommunicationProtocol } from '@utcp/sdk';\nimport { RegisterManualResult } from '@utcp/sdk';\nimport { CallTemplate } from '@utcp/sdk';\nimport { UtcpManual, UtcpManualSerializer } from '@utcp/sdk';\nimport { ApiKeyAuth } from '@utcp/sdk';\nimport { BasicAuth } from '@utcp/sdk';\nimport { OAuth2Auth } from '@utcp/sdk';\nimport { IUtcpClient } from '@utcp/sdk';\nimport { StreamableHttpCallTemplate } from './streamable_http_call_template';\n\n/**\n * REQUIRED\n * Streamable HTTP communication protocol implementation for UTCP client.\n * \n * Handles HTTP streaming with chunked transfer encoding for real-time data.\n */\nexport class StreamableHttpCommunicationProtocol implements CommunicationProtocol {\n  private oauthTokens: Map<string, { access_token: string; expires_at?: number }> = new Map();\n\n  private _logInfo(message: string): void {\n    console.log(`[StreamableHttpCommunicationProtocol] ${message}`);\n  }\n\n  private _logError(message: string): void {\n    console.error(`[StreamableHttpCommunicationProtocol] ${message}`);\n  }\n\n  private _applyAuth(\n    provider: StreamableHttpCallTemplate,\n    headers: Record<string, string>,\n    queryParams: Record<string, any>\n  ): { auth?: { username: string; password: string }; cookies: Record<string, string> } {\n    let auth: { username: string; password: string } | undefined;\n    const cookies: Record<string, string> = {};\n\n    if (provider.auth) {\n      if ('api_key' in provider.auth) {\n        const apiKeyAuth = provider.auth as ApiKeyAuth;\n        if (apiKeyAuth.api_key) {\n          // Default to 'header' if location is not specified\n          const location = apiKeyAuth.location || 'header';\n          if (location === 'header') {\n            headers[apiKeyAuth.var_name] = apiKeyAuth.api_key;\n          } else if (location === 'query') {\n            queryParams[apiKeyAuth.var_name] = apiKeyAuth.api_key;\n          } else if (location === 'cookie') {\n            cookies[apiKeyAuth.var_name] = apiKeyAuth.api_key;\n          }\n        } else {\n          this._logError('API key not found for ApiKeyAuth.');\n          throw new Error('API key for ApiKeyAuth not found.');\n        }\n      } else if ('username' in provider.auth && 'password' in provider.auth) {\n        const basicAuth = provider.auth as BasicAuth;\n        auth = { username: basicAuth.username, password: basicAuth.password };\n      } else if ('token_url' in provider.auth) {\n        // OAuth2 will be handled separately\n      }\n    }\n\n    return { auth, cookies };\n  }\n\n  /**\n   * REQUIRED\n   * Register a manual and its tools from a StreamableHttp provider.\n   */\n  async registerManual(\n    caller: IUtcpClient,\n    manualCallTemplate: CallTemplate\n  ): Promise<RegisterManualResult> {\n    if ((manualCallTemplate as any).call_template_type !== 'streamable_http') {\n      throw new Error('StreamableHttpCommunicationProtocol can only be used with StreamableHttpCallTemplate');\n    }\n\n    const provider = manualCallTemplate as StreamableHttpCallTemplate;\n    const url = provider.url;\n\n    // Security check: Enforce HTTPS or localhost to prevent MITM attacks\n    if (\n      !url.startsWith('https://') &&\n      !url.startsWith('http://localhost') &&\n      !url.startsWith('http://127.0.0.1')\n    ) {\n      throw new Error(\n        `Security error: URL must use HTTPS or start with 'http://localhost' or 'http://127.0.0.1'. Got: ${url}. ` +\n          'Non-secure URLs are vulnerable to man-in-the-middle attacks.'\n      );\n    }\n\n    this._logInfo(`Discovering tools from '${provider.name}' (HTTP Stream) at ${url}`);\n\n    try {\n      const requestHeaders: Record<string, string> = provider.headers ? { ...provider.headers } : {};\n      const queryParams: Record<string, any> = {};\n      const { auth, cookies } = this._applyAuth(provider, requestHeaders, queryParams);\n\n      // Build URL with query parameters\n      const urlObj = new URL(url);\n      Object.entries(queryParams).forEach(([key, value]) => {\n        urlObj.searchParams.append(key, String(value));\n      });\n\n      // Build fetch options\n      const fetchOptions: RequestInit = {\n        method: provider.http_method || 'GET',\n        headers: requestHeaders,\n      };\n\n      // Add basic auth if present\n      if (auth) {\n        const credentials = Buffer.from(`${auth.username}:${auth.password}`).toString('base64');\n        fetchOptions.headers = {\n          ...fetchOptions.headers as Record<string, string>,\n          'Authorization': `Basic ${credentials}`,\n        };\n      }\n\n      // Make discovery request\n      const response = await fetch(urlObj.toString(), fetchOptions);\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      // Read response body\n      const responseText = await response.text();\n      const utcpManual = new UtcpManualSerializer().validateDict(JSON.parse(responseText));\n\n      this._logInfo(`Discovered ${utcpManual.tools.length} tools from '${provider.name}'`);\n\n      return {\n        manualCallTemplate: provider,\n        manual: utcpManual,\n        success: true,\n        errors: [],\n      };\n    } catch (error: any) {\n      this._logError(`Error discovering tools from '${provider.name}': ${error.message}`);\n      return {\n        manualCallTemplate: provider,\n        manual: new UtcpManualSerializer().validateDict({ tools: [] }),\n        success: false,\n        errors: [error.message || String(error)],\n      };\n    }\n  }\n\n  /**\n   * REQUIRED\n   * Deregister a manual (no-op for HTTP streaming).\n   */\n  async deregisterManual(caller: IUtcpClient, manualCallTemplate: CallTemplate): Promise<void> {\n    // No-op for HTTP streaming\n  }\n\n  /**\n   * REQUIRED\n   * Call a tool using HTTP (non-streaming).\n   */\n  async callTool(\n    caller: IUtcpClient,\n    toolName: string,\n    toolArgs: Record<string, any>,\n    toolCallTemplate: CallTemplate\n  ): Promise<any> {\n    // For streamable HTTP, we collect all chunks and return the complete result\n    const chunks: string[] = [];\n    for await (const chunk of this.callToolStreaming(caller, toolName, toolArgs, toolCallTemplate)) {\n      chunks.push(chunk);\n    }\n    return chunks.join('');\n  }\n\n  /**\n   * REQUIRED\n   * Call a tool using HTTP streaming.\n   * Returns an async generator that yields chunks of data.\n   */\n  async *callToolStreaming(\n    caller: IUtcpClient,\n    toolName: string,\n    toolArgs: Record<string, any>,\n    toolCallTemplate: CallTemplate\n  ): AsyncGenerator<any, void, unknown> {\n    const provider = toolCallTemplate as StreamableHttpCallTemplate;\n\n    // TODO: Implement actual streaming call logic\n    // This would involve making an HTTP request and streaming the response in chunks\n    this._logInfo(`Calling streaming tool '${toolName}' with args: ${JSON.stringify(toolArgs)}`);\n    \n    // Placeholder implementation\n    yield `Streaming response for tool: ${toolName}`;\n  }\n\n  /**\n   * REQUIRED\n   * Close all active connections and clear internal state.\n   */\n  async close(): Promise<void> {\n    this._logInfo('Closing StreamableHttpCommunicationProtocol.');\n    this.oauthTokens.clear();\n  }\n}\n",
      "line_count": 211,
      "word_count": 762,
      "title": "Streamable Http Communication Protocol.Ts",
      "summary": "* Streamable HTTP Communication Protocol for UTCP. * Handles HTTP streaming with chunked transfer encoding for real-time data.",
      "key_terms": [
        "toString",
        "close",
        "const",
        "we",
        "packages",
        "clear",
        "REQUIRED",
        "number",
        "async",
        "error",
        "headers",
        "localhost",
        "utcpManual",
        "vulnerable",
        "Read",
        "Record",
        "check",
        "cookie",
        "Implement",
        "Utcp"
      ],
      "timestamp": "2025-12-24T18:56:19.598169"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\http\\tests\\http_communication_protocol.test.ts",
      "content_type": "code",
      "content": "// packages/http/tests/http_communication_protocol.test.ts\nimport { test, expect, describe, beforeAll, afterAll } from \"bun:test\";\nimport express, { Express } from 'express';\nimport { Server } from 'http';\n// Import from package index to trigger auto-registration\nimport { HttpCommunicationProtocol, HttpCallTemplate } from \"@utcp/http\";\nimport { ApiKeyAuth, BasicAuth, OAuth2Auth } from \"@utcp/sdk\";\nimport { IUtcpClient } from \"@utcp/sdk\";\n\n// --- Test Server Setup ---\nlet app: Express;\nlet server: Server;\nlet serverPort: number;\n\nconst mockClient = {} as IUtcpClient;\n\nbeforeAll(async () => {\n  app = express();\n  app.use(express.json());\n\n  app.get(\"/utcp\", (req, res) => {\n    res.json({\n      utcp_version: \"1.0.1\",\n      manual_version: \"1.0.0\",\n      tools: [{\n        name: \"test_tool\",\n        description: \"A simple test tool\",\n        tool_call_template: {\n          name: \"test_server\",\n          call_template_type: 'http',\n          url: `http://localhost:${serverPort}/tool`,\n          http_method: 'POST',\n        }\n      }]\n    });\n  });\n\n  app.post(\"/tool\", (req, res) => {\n    if (req.headers['x-api-key'] && req.headers['x-api-key'] !== 'test-key') {\n      return res.status(401).json({ error: \"Invalid API Key\" });\n    }\n    const authHeader = req.headers.authorization;\n    if (authHeader?.startsWith(\"Basic \") && authHeader !== `Basic ${btoa(\"user:pass\")}`) {\n      return res.status(401).json({ error: \"Invalid Basic Auth Credentials\" });\n    }\n    if (authHeader?.startsWith(\"Bearer \") && authHeader !== \"Bearer test-token\") {\n      return res.status(401).json({ error: \"Invalid Bearer Token\" });\n    }\n\n    res.json({ result: \"success\", received_body: req.body });\n  });\n\n  app.get(\"/tool/:param1/:param2\", (req, res) => {\n    res.json({ result: \"path_success\", params: req.params, query: req.query });\n  });\n\n  app.post(\"/token\", (req, res) => {\n    res.json({ access_token: \"test-token\", expires_in: 3600 });\n  });\n\n  app.get(\"/error\", (req, res) => {\n    res.status(500).json({ error: \"Internal Server Error\" });\n  });\n\n  await new Promise<void>((resolve) => {\n    server = app.listen(0, () => {\n      serverPort = (server.address() as any).port;\n      console.log(`HTTP test server running on port ${serverPort}`);\n      resolve();\n    });\n  });\n});\n\nafterAll(() => {\n  return new Promise<void>((resolve) => {\n    server.close(() => {\n      console.log(\"HTTP test server stopped.\");\n      resolve();\n    });\n  });\n});\n\n\n// --- Test Suite ---\ndescribe(\"HttpCommunicationProtocol\", () => {\n  const protocol = new HttpCommunicationProtocol();\n\n  describe(\"registerManual\", () => {\n    test(\"should discover tools from a valid UTCP manual endpoint\", async () => {\n      const callTemplate: HttpCallTemplate = {\n        name: \"test_server\",\n        call_template_type: \"http\",\n        url: `http://localhost:${serverPort}/utcp`,\n        http_method: \"GET\",\n      };\n\n      const result = await protocol.registerManual(mockClient, callTemplate);\n      expect(result.success).toBe(true);\n      expect(result.manual.tools).toHaveLength(1);\n      expect(result.manual.tools[0]?.name).toBe(\"test_tool\");\n    });\n\n    test(\"should handle server errors during discovery\", async () => {\n      const callTemplate: HttpCallTemplate = {\n        name: \"error_server\",\n        call_template_type: \"http\",\n        url: `http://localhost:${serverPort}/error`,\n        http_method: \"GET\",\n      };\n\n      const result = await protocol.registerManual(mockClient, callTemplate);\n      expect(result.success).toBe(false);\n      expect(result.errors.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe(\"callTool\", () => {\n    test(\"should execute a POST tool with a body\", async () => {\n      const callTemplate: HttpCallTemplate = {\n        name: \"test_server\",\n        call_template_type: \"http\",\n        url: `http://localhost:${serverPort}/tool`,\n        http_method: \"POST\",\n        body_field: \"data\"\n      };\n\n      const result = await protocol.callTool(mockClient, \"test.tool\", { data: { value: 123 } }, callTemplate);\n      expect(result).toEqual({ result: \"success\", received_body: { value: 123 } });\n    });\n\n    test(\"should correctly handle path and query parameters\", async () => {\n      const callTemplate: HttpCallTemplate = {\n        name: \"path_test\",\n        call_template_type: \"http\",\n        url: `http://localhost:${serverPort}/tool/{param1}/{param2}`,\n        http_method: \"GET\",\n      };\n\n      const result = await protocol.callTool(\n        mockClient,\n        \"test.tool\",\n        { param1: \"foo\", param2: \"bar\", query1: \"baz\" },\n        callTemplate\n      );\n      expect(result).toEqual({ result: \"path_success\", params: { param1: \"foo\", param2: \"bar\" }, query: { query1: \"baz\" } });\n    });\n\n    test(\"should handle ApiKeyAuth in headers\", async () => {\n      const auth: ApiKeyAuth = { auth_type: 'api_key', api_key: 'test-key', var_name: 'X-Api-Key', location: 'header' };\n      const callTemplate: HttpCallTemplate = {\n        name: \"test_server\",\n        call_template_type: \"http\",\n        url: `http://localhost:${serverPort}/tool`,\n        http_method: \"POST\",\n        auth: auth\n      };\n      const result = await protocol.callTool(mockClient, \"test.tool\", {}, callTemplate);\n      expect(result.result).toBe(\"success\");\n    });\n\n    test(\"should handle BasicAuth\", async () => {\n      const auth: BasicAuth = { auth_type: 'basic', username: 'user', password: 'pass' };\n      const callTemplate: HttpCallTemplate = {\n        name: \"test_server\",\n        call_template_type: \"http\",\n        url: `http://localhost:${serverPort}/tool`,\n        http_method: \"POST\",\n        auth: auth\n      };\n      const result = await protocol.callTool(mockClient, \"test.tool\", {}, callTemplate);\n      expect(result.result).toBe(\"success\");\n    });\n\n    test(\"should handle OAuth2Auth\", async () => {\n      const auth: OAuth2Auth = {\n        auth_type: 'oauth2',\n        token_url: `http://localhost:${serverPort}/token`,\n        client_id: 'test-client',\n        client_secret: 'test-secret',\n      };\n      const callTemplate: HttpCallTemplate = {\n        name: \"test_server\",\n        call_template_type: \"http\",\n        url: `http://localhost:${serverPort}/tool`,\n        http_method: \"POST\",\n        auth: auth\n      };\n      const result = await protocol.callTool(mockClient, \"test.tool\", {}, callTemplate);\n      expect(result.result).toBe(\"success\");\n    });\n  });\n});",
      "line_count": 192,
      "word_count": 613,
      "title": "Http Communication Protocol.Test.Ts",
      "summary": "// packages/http/tests/http_communication_protocol.test.ts import { test, expect, describe, beforeAll, afterAll } from \"bun:test\";",
      "key_terms": [
        "trigger",
        "close",
        "const",
        "packages",
        "async",
        "number",
        "localhost",
        "headers",
        "error",
        "Setup",
        "token",
        "index",
        "afterAll",
        "Utcp",
        "during",
        "callTemplate",
        "Test",
        "req",
        "Error",
        "beforeAll"
      ],
      "timestamp": "2025-12-24T18:56:19.646061"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\mcp\\package.json",
      "content_type": "configuration",
      "content": "{\n  \"name\": \"@utcp/mcp\",\n  \"version\": \"1.1.1\",\n  \"description\": \"Model Context Protocol integration for UTCP\",\n  \"main\": \"dist/index.cjs\",\n  \"module\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"type\": \"module\",\n  \"license\": \"MPL-2.0\",\n  \"author\": \"UTCP Contributors\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/universal-tool-calling-protocol/typescript-utcp.git\",\n    \"directory\": \"packages/mcp\"\n  },\n  \"keywords\": [\n    \"utcp\",\n    \"universal-tool-calling-protocol\",\n    \"tools\",\n    \"api\",\n    \"typescript\",\n    \"tool calling\",\n    \"mcp\",\n    \"agent\",\n    \"ai\",\n    \"llm\",\n    \"modelcontextprotocol\"\n  ],\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\",\n      \"require\": \"./dist/index.cjs\",\n      \"default\": \"./dist/index.js\"\n    }\n  },\n  \"scripts\": {\n    \"build\": \"tsup\"\n  },\n  \"dependencies\": {\n    \"@apidevtools/json-schema-ref-parser\": \"^15.1.2\",\n    \"@modelcontextprotocol/sdk\": \"^1.17.4\",\n    \"@utcp/sdk\": \"^1.1.0\",\n    \"axios\": \"^1.11.0\"\n  },\n  \"devDependencies\": {\n    \"@types/bun\": \"latest\",\n    \"@types/json-schema\": \"^7.0.15\",\n    \"bun-types\": \"latest\",\n    \"typescript\": \"^5.9.2\",\n    \"zod-to-json-schema\": \"^3.24.6\"\n  }\n}\n",
      "line_count": 60,
      "word_count": 102,
      "title": "Package.Json",
      "summary": "\"name\": \"@utcp/mcp\", \"version\": \"1.1.1\",",
      "key_terms": [
        "integration",
        "build",
        "Model",
        "packages",
        "schema",
        "ref",
        "Context",
        "scripts",
        "universal",
        "calling-protocol",
        "module",
        "zod",
        "utcp",
        "index",
        "calling",
        "MPL",
        "ref-parser",
        "tool",
        "dependencies",
        "type"
      ],
      "timestamp": "2025-12-24T18:56:19.661825"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\mcp\\README.md",
      "content_type": "documentation",
      "content": "# @utcp/mcp: Model Context Protocol (MCP) Communication Protocol Plugin for UTCP\n\nThe `@utcp/mcp` package enables the `UtcpClient` to interact with tools defined and served via the Model Context Protocol (MCP). This plugin provides interoperability with existing MCP servers, supporting both `stdio` (local process) and `http` (streamable HTTP) transports, with enhanced session management and resilience.\n\n## Features\n\n*   **Automatic Plugin Registration**: Registers automatically when imported—no manual setup required.\n*   **FastMCP 2.0+ Compatibility**: Automatically resolves JSON Schema `$defs` references, ensuring compatibility with modern MCP servers built on FastMCP 2.0+.\n*   **MCP `CallTemplate`**: Defines the configuration for connecting to one or more MCP servers (`McpCallTemplate`), including:\n    *   Transport type (`stdio` or `http`)\n    *   Optional OAuth2 authentication for HTTP-based servers\n    *   `register_resources_as_tools`: Flag to expose MCP server resources as callable tools\n    *   Environment variables support for stdio servers\n*   **`McpCommunicationProtocol`**: Implements the `CommunicationProtocol` interface for MCP interactions:\n    *   **Persistent Session Management**: Establishes and reuses client sessions with MCP servers (via subprocess for stdio, or HTTP client for remote), drastically improving performance and reducing overhead for repeated tool calls.\n    *   **Automatic Session Recovery**: Intelligently detects and recovers from transient connection issues (e.g., network errors, broken pipes, crashed subprocesses) by automatically re-establishing sessions and retrying operations.\n    *   **Tool Discovery**: Connects to configured MCP servers and retrieves their list of tools using the MCP SDK's `listTools()` command, mapping them to UTCP `Tool` definitions.\n    *   **Tool Execution**: Invokes tools on MCP servers using the MCP SDK's `callTool()`, translating arguments and processing raw MCP results into a unified format.\n    *   **Transport Support**: Seamlessly handles both `stdio` (spawning a local process) and `http` (connecting to a remote streamable HTTP MCP server) via the `@modelcontextprotocol/sdk` client.\n    *   **Authentication Support**: Supports `OAuth2Auth` for HTTP-based MCP servers, including token caching and automatic refresh.\n    *   **Result Processing**: Intelligently adapts raw MCP tool results (which can contain `structured_output`, `text` content, or `json` content) into a more usable format for the UTCP client.\n\n## Installation\n\n```bash\nbun add @utcp/mcp @utcp/sdk\n\n# Or using npm\nnpm install @utcp/mcp @utcp/sdk\n```\n\nNote: `@utcp/sdk` is a peer dependency. The MCP SDK dependencies (`@modelcontextprotocol/sdk` and `axios`) are included automatically.\n\n## Usage\n\nThe MCP plugin registers automatically when you import it—no manual registration needed. Simply import from `@utcp/mcp` to enable MCP support.\n\n```typescript\n// From your application's entry point\n\nimport { UtcpClient } from '@utcp/sdk';\nimport { McpCallTemplateSerializer } from '@utcp/mcp';\nimport * as path from 'path';\n\nasync function main() {\n  // Path to your mock MCP server script (e.g., from tests/mock_mcp_server.ts)\n  const mockMcpStdioServerPath = path.resolve(__dirname, '../../packages/mcp/tests/mock_mcp_server.ts');\n  const mockMcpHttpServerPath = path.resolve(__dirname, '../../packages/mcp/tests/mock_http_mcp_server.ts');\n\n  // Define a CallTemplate to connect to MCP servers\n  const serializer = new McpCallTemplateSerializer();\n  const mcpCallTemplate = serializer.validateDict({\n    name: 'my_mcp_servers', // A single manual can manage multiple MCP servers\n    call_template_type: 'mcp',\n    config: {\n      mcpServers: {\n        'local-stdio-server': { // Name for your stdio server\n          transport: 'stdio',\n          command: 'bun', // Command to run the server script\n          args: ['run', mockMcpStdioServerPath], // Arguments to the command\n          cwd: path.dirname(mockMcpStdioServerPath), // Optional: working directory for the subprocess\n          env: { // Optional: environment variables for the subprocess\n            MY_ENV_VAR: 'value',\n            API_KEY: '${MY_API_KEY}' // Can use variable substitution\n          }\n        },\n        'remote-http-server': { // Name for your HTTP server\n          transport: 'http',\n          url: 'http://localhost:9999/mcp', // URL of your MCP HTTP server\n          headers: { // Optional: custom HTTP headers\n            'X-Custom-Header': 'value'\n          },\n          timeout: 30, // Optional: HTTP request timeout in seconds (default: 30)\n          sse_read_timeout: 300, // Optional: SSE read timeout in seconds (default: 300)\n          terminate_on_close: true // Optional: terminate connection on close (default: true)\n        },\n        // Example with OAuth2 (uncomment and configure if needed)\n        // 'secure-http-server': {\n        //   transport: 'http',\n        //   url: 'https://secure.mcp.example.com/mcp',\n        // },\n      },\n    },\n    // Top-level auth applies to HTTP transports if specified.\n    // auth: { auth_type: 'oauth2', token_url: '...', client_id: '${SECURE_MCP_CLIENT_ID}', client_secret: '${SECURE_MCP_CLIENT_SECRET}' },\n    \n    // Optional: Register MCP resources as callable tools (default: false)\n    register_resources_as_tools: false\n  });\n\n  const client = await UtcpClient.create(process.cwd(), {\n    manual_call_templates: [mcpCallTemplate], // Register the MCP manual at client startup\n    variables: {\n      my__mcp__servers_MY_API_KEY: 'your-api-key-value', // Namespaced variable\n      // my__mcp__servers_SECURE_MCP_CLIENT_ID: 'your-client-id',\n      // my__mcp__servers_SECURE_MCP_CLIENT_SECRET: 'your-client-secret'\n    }\n  });\n\n  console.log('MCP Plugin active. Discovering tools...');\n\n  // Example: Search for tools on the MCP server\n  const stdioTools = await client.searchTools('stdio'); // Will find tools prefixed with 'local-stdio-server'\n  console.log('Found MCP (stdio) tools:', stdioTools.map(t => t.name));\n\n  const httpTools = await client.searchTools('http'); // Will find tools prefixed with 'remote-http-server'\n  console.log('Found MCP (http) tools:', httpTools.map(t => t.name));\n\n  // Example: Call a 'echo' tool on the stdio server (expecting structured JSON)\n  try {\n    const echoResult = await client.callTool('my_mcp_servers.local-stdio-server.echo', { message: 'Hello from stdio!' });\n    console.log('MCP stdio echo tool result:', echoResult);\n  } catch (error) {\n    console.error('Error calling MCP stdio echo tool:', error);\n  }\n\n  // Example: Call an 'add' tool on the http server (expecting a primitive number)\n  try {\n    const addResult = await client.callTool('my_mcp_servers.remote-http-server.add', { a: 10, b: 20 });\n    console.log('MCP http add tool result:', addResult);\n  } catch (error) {\n    console.error('Error calling MCP http add tool:', error);\n  }\n\n  await client.close(); // Important: Cleans up all active MCP client sessions and subprocesses\n}\n\nmain().catch(console.error);\n```\n\n## Advanced Configuration\n\n### Environment Variables for Stdio Servers\n\nYou can pass environment variables to stdio-based MCP servers using the `env` field. These support UTCP variable substitution:\n\n```typescript\n{\n  transport: 'stdio',\n  command: 'node',\n  args: ['server.js'],\n  env: {\n    API_KEY: '${MY_API_KEY}',  // Will resolve from namespaced variable\n    LOG_LEVEL: 'debug',\n    NODE_ENV: 'production'\n  }\n}\n\n// When creating the client, use namespaced variables:\nconst client = await UtcpClient.create(process.cwd(), {\n  manual_call_templates: [mcpTemplate],\n  variables: {\n    my__manual__name_MY_API_KEY: 'your-api-key'  // Note: manual_name -> my__manual__name_\n  }\n});\n```\n\n### HTTP Server Configuration\n\nHTTP-based MCP servers support additional configuration options:\n\n```typescript\n{\n  transport: 'http',\n  url: 'https://mcp-server.example.com/mcp',\n  headers: {\n    'X-Custom-Header': 'value',\n    'User-Agent': 'MyApp/1.0'\n  },\n  timeout: 60,              // Request timeout in seconds\n  sse_read_timeout: 600,    // SSE read timeout in seconds\n  terminate_on_close: true  // Terminate connection when client closes\n}\n```\n\n### OAuth2 Authentication\n\nFor HTTP servers requiring authentication, use the top-level `auth` field:\n\n```typescript\nconst serializer = new McpCallTemplateSerializer();\nconst secureTemplate = serializer.validateDict({\n  name: 'secure_mcp_servers',\n  call_template_type: 'mcp',\n  config: { /* ... */ },\n  auth: {\n    auth_type: 'oauth2',\n    token_url: 'https://auth.example.com/oauth/token',\n    client_id: '${MCP_CLIENT_ID}',\n    client_secret: '${MCP_CLIENT_SECRET}',\n    scope: 'mcp.tools.read mcp.tools.execute'\n  }\n});\n\n// Configure client with namespaced variables\nconst client = await UtcpClient.create(process.cwd(), {\n  manual_call_templates: [secureTemplate],\n  variables: {\n    secure__mcp__servers_MCP_CLIENT_ID: 'your-client-id',\n    secure__mcp__servers_MCP_CLIENT_SECRET: 'your-client-secret'\n  }\n});\n```\n\nThe plugin automatically handles token caching and refresh.\n\n### Resource Registration\n\nMCP servers can expose resources (files, data sources, etc.) alongside tools. To register these resources as callable tools, set `register_resources_as_tools` to `true`:\n\n```typescript\n{\n  name: 'my_mcp_servers',\n  call_template_type: 'mcp',\n  config: { /* ... */ },\n  register_resources_as_tools: true  // Exposes server resources as tools\n}\n```\n\n## FastMCP Compatibility\n\nStarting with version 1.0.17, this plugin automatically handles JSON Schema `$defs` references used by FastMCP 2.0+ servers. This resolves the issue where tool discovery would fail with:\n\n```\nMissingRefError: can't resolve reference #/$defs/...\n```\n\n**How it works:**\n- When tools are discovered from MCP servers, their input and output schemas are automatically dereferenced\n- `$defs` references are resolved and inlined into the schema\n- This process is transparent and requires no configuration changes\n- If dereferencing fails for any reason, the original schema is used as a fallback\n\nThis ensures seamless integration with:\n- `basic-memory` and other FastMCP-based servers\n- Any MCP server using modern JSON Schema draft-2020-12 features\n- Legacy MCP servers (which continue to work as before)\n\n## Tool Naming Convention\n\nTools discovered from MCP servers follow the naming pattern:\n\n```\n{manual_name}.{server_name}.{tool_name}\n```\n\nFor example:\n- Manual name: `my_mcp_servers`\n- Server name: `local-stdio-server`\n- Tool name: `echo`\n- **Full tool name**: `my_mcp_servers.local-stdio-server.echo`\n\n## Session Management\n\nThe MCP plugin maintains persistent sessions with each configured server:\n\n- **Session Reuse**: Connections are established once and reused for multiple tool calls, significantly improving performance.\n- **Automatic Recovery**: If a session fails (network error, subprocess crash, etc.), the plugin automatically:\n  1. Detects the failure\n  2. Cleans up the broken session\n  3. Establishes a new session\n  4. Retries the operation once\n\nThis resilience mechanism handles common transient issues without requiring manual intervention.\n\n## Error Handling\n\nThe plugin provides comprehensive error handling:\n\n- Connection failures are logged and retried once\n- Invalid tool names produce descriptive error messages\n- OAuth2 token fetch failures include detailed error context\n- MCP server errors are properly propagated to the caller\n\n## API Reference\n\n### McpCallTemplate\n\n```typescript\ninterface McpCallTemplate {\n  name?: string;\n  call_template_type: 'mcp';\n  config: McpConfig;\n  auth?: OAuth2Auth;\n  register_resources_as_tools?: boolean;\n}\n```\n\n### McpStdioServer\n\n```typescript\ninterface McpStdioServer {\n  transport: 'stdio';\n  command: string;\n  args?: string[];\n  cwd?: string;\n  env?: Record<string, string>;\n}\n```\n\n### McpHttpServer\n\n```typescript\ninterface McpHttpServer {\n  transport: 'http';\n  url: string;\n  headers?: Record<string, string>;\n  timeout?: number;              // Default: 30 seconds\n  sse_read_timeout?: number;     // Default: 300 seconds\n  terminate_on_close?: boolean;  // Default: true\n}\n```\n\n## Best Practices\n\n1. **Close clients properly**: Always call `await client.close()` to clean up MCP sessions and subprocesses.\n2. **Use variable substitution**: Store sensitive credentials in environment variables and reference them with `${VAR_NAME}`.\n3. **Configure timeouts**: Adjust `timeout` and `sse_read_timeout` based on your server's response characteristics.\n4. **Server naming**: Use descriptive server names as they become part of the tool naming hierarchy.\n5. **Error handling**: Wrap tool calls in try-catch blocks for robust error handling.\n\n## License\n\nThis package is part of the UTCP project. See the main repository for license information.",
      "line_count": 324,
      "word_count": 1512,
      "title": "@utcp/mcp: Model Context Protocol (MCP) Communication Protocol Plugin for UTCP",
      "summary": "The `@utcp/mcp` package enables the `UtcpClient` to interact with tools defined and served via the Model Context Protocol (MCP). This plugin provides interoperability with existing MCP servers, suppor...",
      "key_terms": [
        "drastically",
        "close",
        "const",
        "sessions",
        "Model",
        "Session",
        "transient",
        "contain",
        "packages",
        "localhost",
        "Important",
        "etc",
        "Record",
        "list",
        "Found",
        "multiple",
        "your-client",
        "if",
        "Features",
        "interface"
      ],
      "timestamp": "2025-12-24T18:56:19.709624"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\mcp\\tsconfig.json",
      "content_type": "configuration",
      "content": "// packages/http/tsconfig.json\n{\n  \"extends\": \"../../tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"composite\": true\n  },\n  \"include\": [\n    \"src/**/*\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"**/*.test.ts\",\n    \"**/*.spec.ts\"\n  ],\n  \"references\": [\n    { \"path\": \"../core\" }\n  ]\n}",
      "line_count": 21,
      "word_count": 33,
      "title": "Tsconfig.Json",
      "summary": "// packages/http/tsconfig.json \"extends\": \"../../tsconfig.json\",",
      "key_terms": [
        "packages",
        "composite",
        "exclude",
        "extends",
        "outDir",
        "test",
        "rootDir",
        "spec",
        "ts",
        "core",
        "path",
        "references",
        "dist",
        "http",
        "true",
        "include",
        "tsconfig",
        "json",
        "compilerOptions",
        "src"
      ],
      "timestamp": "2025-12-24T18:56:19.709624"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\mcp\\tsup.config.ts",
      "content_type": "code",
      "content": "import { defineConfig } from 'tsup';\n\nexport default defineConfig({\n  entry: ['src/index.ts'],\n  format: ['esm', 'cjs'],\n  dts: {\n    compilerOptions: {\n      composite: false,\n      paths: {},\n    },\n  },\n  splitting: false,\n  sourcemap: true,\n  clean: true,\n  outDir: 'dist',\n  external: ['@utcp/sdk', '@modelcontextprotocol/sdk', 'axios'],\n});\n",
      "line_count": 18,
      "word_count": 37,
      "title": "Tsup.Config.Ts",
      "summary": "import { defineConfig } from 'tsup'; export default defineConfig({",
      "key_terms": [
        "from",
        "sourcemap",
        "composite",
        "paths",
        "entry",
        "clean",
        "utcp",
        "outDir",
        "index",
        "format",
        "protocol",
        "default",
        "axios",
        "ts",
        "cjs",
        "false",
        "modelcontextprotocol",
        "import",
        "export",
        "sdk"
      ],
      "timestamp": "2025-12-24T18:56:19.740928"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\mcp\\src\\index.ts",
      "content_type": "code",
      "content": "/**\n * MCP Communication Protocol plugin for UTCP.\n */\n// packages/mcp/src/index.ts\nimport { CommunicationProtocol, CallTemplateSerializer } from '@utcp/sdk';\nimport { McpCallTemplateSerializer } from './mcp_call_template';\nimport { McpCommunicationProtocol } from './mcp_communication_protocol';\n\n/**\n * Registers the MCP protocol's CallTemplate serializer\n * and its CommunicationProtocol implementation.\n * This function is called automatically when the package is imported.\n */\nexport function register(override: boolean = false): void {\n  CallTemplateSerializer.registerCallTemplate('mcp', new McpCallTemplateSerializer(), override);\n  CommunicationProtocol.communicationProtocols['mcp'] = new McpCommunicationProtocol();\n}\n\n// Automatically register MCP plugin on import\nregister();\n\nexport * from './mcp_call_template';\nexport * from './mcp_communication_protocol';",
      "line_count": 23,
      "word_count": 88,
      "title": "Index.Ts",
      "summary": "* MCP Communication Protocol plugin for UTCP. // packages/mcp/src/index.ts",
      "key_terms": [
        "from",
        "communicationProtocols",
        "packages",
        "serializer",
        "is",
        "automatically",
        "McpCommunicationProtocol",
        "index",
        "utcp",
        "Automatically",
        "register",
        "and",
        "protocol",
        "boolean",
        "for",
        "when",
        "ts",
        "package",
        "This",
        "CommunicationProtocol"
      ],
      "timestamp": "2025-12-24T18:56:19.756744"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\mcp\\src\\mcp_call_template.ts",
      "content_type": "code",
      "content": "// packages/mcp/src/mcp_call_template.ts\nimport { z } from 'zod';\nimport { CallTemplate } from '@utcp/sdk';\nimport { OAuth2Auth } from '@utcp/sdk';\nimport { AuthSchema } from '@utcp/sdk';\nimport { Serializer } from '@utcp/sdk';\n\n/**\n * Type alias for MCP server configurations.\n *\n * Union type for all supported MCP server transport configurations,\n * including both stdio and HTTP-based servers.\n */\n\n/**\n * Interface for MCP Stdio Server parameters.\n * Used for local process communication with an MCP server.\n */\nexport interface McpStdioServer {\n  transport: 'stdio';\n  command: string;\n  args: string[];\n  cwd?: string;\n  env: Record<string, string>;\n  timeout: number;\n}\n\n/**\n * Schema for MCP Stdio Server parameters.\n */\nexport const McpStdioServerSchema: z.ZodType<McpStdioServer> = z.object({\n  transport: z.literal('stdio'),\n  command: z.string().describe('The command to execute the MCP server.'),\n  args: z.array(z.string()).optional().default([]).describe('Arguments to pass to the command.'),\n  cwd: z.string().optional().describe('Working directory for the command.'),\n  env: z.record(z.string(), z.string()).optional().default({}).describe('Environment variables for the command.'),\n  timeout: z.number().optional().default(30).describe('Timeout for MCP operations in seconds.'),\n}) as z.ZodType<McpStdioServer>;\n\n\n/**\n * Interface for MCP HTTP Server parameters.\n * Used for remote HTTP communication with an MCP server.\n */\nexport interface McpHttpServer {\n  transport: 'http';\n  url: string;\n  headers?: Record<string, string>;\n  timeout: number;\n  sse_read_timeout: number;\n  terminate_on_close: boolean;\n}\n\n/**\n * MCP HTTP Server schema for MCP servers connected via streamable HTTP.\n */\nexport const McpHttpServerSchema: z.ZodType<McpHttpServer> = z.object({\n  transport: z.literal('http'),\n  url: z.string().describe('The URL of the MCP HTTP server endpoint.'),\n  headers: z.record(z.string(), z.string()).optional().describe('Optional HTTP headers for the connection.'),\n  timeout: z.number().optional().default(30).describe('Timeout for HTTP requests in seconds.'),\n  sse_read_timeout: z.number().optional().default(300).describe('Read timeout for SSE connections in seconds (e.g., for `streamable-http` MCP servers).'),\n  terminate_on_close: z.boolean().optional().default(true).describe('Whether to terminate the HTTP connection on client close.'),\n}) as z.ZodType<McpHttpServer>;\n\n\n/**\n * Type alias for a discriminated union of all supported MCP server transport configurations.\n */\nexport type McpServerConfig = McpStdioServer | McpHttpServer;\n\n/**\n * A discriminated union of all supported MCP server transport configurations.\n */\nexport const McpServerConfigSchema = z.discriminatedUnion('transport', [\n  McpStdioServerSchema as z.ZodObject<any, any, any, McpStdioServer, any>,\n  McpHttpServerSchema as z.ZodObject<any, any, any, McpHttpServer, any>,  \n]);\n\n/**\n * REQUIRED\n * Implementing this class is not required!!!\n * The McpCallTemplate just needs to support a MCP compliant server configuration.\n *\n * Configuration container for multiple MCP servers.\n *\n * Holds a collection of named MCP server configurations, allowing\n * a single MCP provider to manage multiple server connections.\n *\n * Attributes:\n *     mcpServers: Dictionary mapping server names to their configurations.\n */\nexport interface McpConfig {\n  mcpServers: Record<string, any>;\n}\n\n/**\n * Configuration for multiple MCP servers under one provider.\n * Accepts any structure to match MCP official configuration format.\n */\nexport const McpConfigSchema = z.object({\n  mcpServers: z.record(z.string(), z.any()).describe('Dictionary mapping server names to their configurations.'),\n});\n\n/**\n * REQUIRED\n * Provider configuration for Model Context Protocol (MCP) tools.\n *\n * Enables communication with MCP servers that provide structured tool\n * interfaces. Supports both stdio (local process) and HTTP (remote)\n * transport methods.\n *\n * Attributes:\n *     call_template_type: Always \"mcp\" for MCP providers.\n *     config: Configuration object containing MCP server definitions.\n *         This follows the same format as the official MCP server configuration.\n *     auth: Optional OAuth2 authentication for HTTP-based MCP servers.\n *     register_resources_as_tools: Whether to register MCP resources as callable tools.\n *         When True, server resources are exposed as tools that can be called.\n *         Default is False.\n */\nexport interface McpCallTemplate extends CallTemplate {\n  name?: string;\n  call_template_type: 'mcp';\n  config: McpConfig;\n  auth?: OAuth2Auth;\n  register_resources_as_tools?: boolean;\n  allowed_communication_protocols?: string[];\n}\n\n/**\n * MCP Call Template schema for Model Context Protocol tools.\n * Enables communication with MCP servers.\n */\nexport const McpCallTemplateSchema: z.ZodType<McpCallTemplate> = z.object({\n  name: z.string().optional(),\n  call_template_type: z.literal('mcp'),\n  config: McpConfigSchema.describe('Configuration object containing MCP server definitions. Follows the same format as the official MCP server configuration.'),\n  auth: AuthSchema.nullable().optional().describe('Optional OAuth2 authentication for HTTP-based MCP servers.'),\n  register_resources_as_tools: z.boolean().default(false).describe('Whether to register MCP resources as callable tools. When True, server resources are exposed as tools that can be called.'),\n  allowed_communication_protocols: z.array(z.string()).optional().describe('Optional list of allowed communication protocol types for tools within this manual.'),\n}) as z.ZodType<McpCallTemplate>;\n\n/**\n * REQUIRED\n * Serializer for McpCallTemplate.\n */\nexport class McpCallTemplateSerializer extends Serializer<McpCallTemplate> {\n  /**\n   * REQUIRED\n   * Convert McpCallTemplate to dictionary.\n   */\n  toDict(obj: McpCallTemplate): Record<string, unknown> {\n    return {\n      name: obj.name,\n      call_template_type: obj.call_template_type,\n      config: obj.config,\n      auth: obj.auth,\n      register_resources_as_tools: obj.register_resources_as_tools,\n      allowed_communication_protocols: obj.allowed_communication_protocols,\n    };\n  }\n\n  /**\n   * REQUIRED\n   * Validate and convert dictionary to McpCallTemplate.\n   */\n  validateDict(obj: Record<string, unknown>): McpCallTemplate {\n    try {\n      return McpCallTemplateSchema.parse(obj);\n    } catch (e: any) {\n      throw new Error(`Invalid McpCallTemplate: ${e.message}\\n${e.stack || ''}`);\n    }\n  }\n}",
      "line_count": 175,
      "word_count": 716,
      "title": "Mcp Call Template.Ts",
      "summary": "// packages/mcp/src/mcp_call_template.ts import { z } from 'zod';",
      "key_terms": [
        "Timeout",
        "nullable",
        "close",
        "const",
        "packages",
        "Model",
        "REQUIRED",
        "number",
        "Follows",
        "headers",
        "named",
        "convert",
        "record",
        "Type",
        "Read",
        "based",
        "Record",
        "list",
        "format",
        "Holds"
      ],
      "timestamp": "2025-12-24T18:56:19.804966"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\mcp\\src\\mcp_communication_protocol.ts",
      "content_type": "code",
      "content": "// packages/mcp/src/mcp_communication_protocol.ts\nimport { Client as McpClient } from '@modelcontextprotocol/sdk/client/index.js';\nimport { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';\nimport { StreamableHTTPClientTransport, StreamableHTTPClientTransportOptions } from '@modelcontextprotocol/sdk/client/streamableHttp.js';\nimport axios, { AxiosInstance } from 'axios';\nimport { CommunicationProtocol } from '@utcp/sdk';\nimport { RegisterManualResult } from '@utcp/sdk';\nimport { CallTemplate } from '@utcp/sdk';\nimport { UtcpManualSchema } from '@utcp/sdk';\nimport { Tool, JsonSchema } from '@utcp/sdk';\nimport { OAuth2Auth } from '@utcp/sdk';\nimport { IUtcpClient } from '@utcp/sdk'; \nimport { McpCallTemplateSchema, McpHttpServer, McpServerConfig, McpStdioServer } from './mcp_call_template';\nimport { Transport } from '@modelcontextprotocol/sdk/shared/transport.js';\nimport $RefParser from '@apidevtools/json-schema-ref-parser';\n\n// Define a simple type for the tool objects returned by MCP's listTools\ninterface McpToolResponse {\n  name: string;\n  description?: string;\n  inputSchema: unknown;\n  outputSchema: unknown;\n}\n\n// Type guard to check if an object is a valid MCP tools response\nfunction isMcpToolsResponse(data: unknown): data is { tools: McpToolResponse[] } {\n  return (\n    typeof data === 'object' &&\n    data !== null &&\n    'tools' in data &&\n    Array.isArray((data as any).tools)\n  );\n}\n\n/**\n * MCP communication protocol implementation for the UTCP client.\n *\n * This implementation connects to MCP servers via stdio or HTTP, managing\n * persistent sessions to enhance performance and stability. It includes\n * logic for session reuse and automatic recovery from connection errors.\n */\nexport class McpCommunicationProtocol implements CommunicationProtocol {\n  private _oauthTokens: Map<string, { accessToken: string; expiresAt: number }> = new Map();\n  private _axiosInstance: AxiosInstance;\n  private _mcpSessions: Map<string, McpClient> = new Map();\n\n  constructor() {\n    this._axiosInstance = axios.create({ timeout: 30000 });\n  }\n\n  private _logInfo(message: string): void {\n    console.log(`[McpCommunicationProtocol] ${message}`);\n  }\n\n  private _logError(message: string, error?: any): void {\n    console.error(`[McpCommunicationProtocol Error] ${message}`, error);\n  }\n\n  /**\n   * Dereferences a JSON Schema by resolving all $refs and $defs.\n   * This fixes the issue with FastMCP 2.0+ servers that use $defs references.\n   * \n   * @param schema - The schema to dereference\n   * @returns The dereferenced schema with all references inlined\n   */\n  private async _dereferenceSchema(schema: unknown): Promise<JsonSchema> {\n    if (!schema || typeof schema !== 'object') {\n      return schema as JsonSchema;\n    }\n    \n    try {\n      // Check if schema contains $defs or $ref\n      const schemaStr = JSON.stringify(schema);\n      if (!schemaStr.includes('$defs') && !schemaStr.includes('$ref')) {\n        // No refs to resolve, return as-is\n        return schema as JsonSchema;\n      }\n      \n      // Dereference the schema (inlines all $refs and $defs)\n      const dereferenced = await $RefParser.dereference(schema as any);\n      return dereferenced as JsonSchema;\n    } catch (error: any) {\n      // If dereferencing fails, log a warning and return the original schema\n      this._logError(`Failed to dereference schema, using original:`, error.message);\n      return schema as JsonSchema;\n    }\n  }\n\n  private async _cleanupSession(sessionKey: string): Promise<void> {\n    const session = this._mcpSessions.get(sessionKey);\n    if (session) {\n      try {\n        await session.close();\n        this._logInfo(`Closed MCP session for '${sessionKey}'.`);\n      } catch (e: any) {\n        this._logError(`Error closing session for '${sessionKey}':`, e.message);\n      } finally {\n        this._mcpSessions.delete(sessionKey);\n      }\n    }\n  }\n\n  private async _getOrCreateSession(\n    serverName: string,\n    serverConfig: McpServerConfig,\n    auth?: OAuth2Auth\n  ): Promise<McpClient> {\n    const sessionKey = `${serverName}:${serverConfig.transport}`;\n\n    // Check if we have an existing session\n    if (this._mcpSessions.has(sessionKey)) {\n      const existingSession = this._mcpSessions.get(sessionKey)!;\n      this._logInfo(`Reusing existing MCP session for '${sessionKey}'.`);\n      return existingSession;\n    }\n\n    this._logInfo(`Creating new MCP session for '${sessionKey}'...`);\n    let transport: Transport;\n\n    if (serverConfig.transport === 'stdio') {\n      const stdioConfig = serverConfig as McpStdioServer;\n\n      const combinedEnv: Record<string, string> = {\n        ...(process.env as Record<string, string>),\n        ...(stdioConfig.env || {}),\n      };\n\n      transport = new StdioClientTransport({\n        command: stdioConfig.command,\n        args: stdioConfig.args || [],\n        cwd: stdioConfig.cwd,\n        env: combinedEnv,\n      });\n\n    } else if (serverConfig.transport === 'http') {\n      const httpConfig = serverConfig as McpHttpServer;\n      let authHeader: Record<string, string> = {};\n      if (auth) {\n        const token = await this._handleOAuth2(auth);\n        authHeader['Authorization'] = `Bearer ${token}`;\n      }\n\n      const transportOptions: StreamableHTTPClientTransportOptions = {\n        requestInit: { headers: { ...(httpConfig.headers || {}), ...authHeader } }\n      };\n      transport = new StreamableHTTPClientTransport(new URL(httpConfig.url), transportOptions);\n\n    } else {\n      throw new Error(`Unsupported MCP transport: '${(serverConfig as any).transport}'`);\n    }\n\n    const mcpClient = new McpClient({ name: `utcp-mcp-client-${sessionKey}`, version: '1.0.1' });\n    try {\n      await mcpClient.connect(transport);\n      this._mcpSessions.set(sessionKey, mcpClient);\n    } catch (e: any) {\n      // If connection fails, don't cache the broken client\n      this._logError(`Failed to connect MCP client for '${sessionKey}':`, e.message);\n      throw e;\n    }\n    \n    return mcpClient;\n  }\n  \n  private async _withSession<T>(\n    serverName: string,\n    serverConfig: McpServerConfig,\n    auth: OAuth2Auth | undefined,\n    operation: (client: McpClient) => Promise<T>\n  ): Promise<T> {\n    const sessionKey = `${serverName}:${serverConfig.transport}`;\n    // Use configured timeout (in seconds) or default to 30s\n    const timeoutMs = (serverConfig.timeout ?? 30) * 1000;\n    try {\n      const client = await this._getOrCreateSession(serverName, serverConfig, auth);\n      return await Promise.race([\n        operation(client),\n        new Promise<T>((_, reject) => setTimeout(() => reject(new Error(`MCP operation on '${sessionKey}' timed out after ${timeoutMs / 1000}s.`)), timeoutMs))\n      ]);\n    } catch (e: any) {\n      this._logError(`MCP operation on '${sessionKey}' failed:`, e.message);\n\n      const errorMsg = String((e as any)?.message ?? e).toLowerCase();\n      // Check for connection errors or \"already initialized\" errors\n      if (errorMsg.includes('closed') || errorMsg.includes('disconnected') ||\n          errorMsg.includes('econnreset') || errorMsg.includes('etimedout') ||\n          errorMsg.includes('already initialized')) {\n        this._logInfo(`Connection/initialization error detected on '${sessionKey}'. Cleaning up and retrying once...`);\n        await this._cleanupSession(sessionKey);\n        const newClient = await this._getOrCreateSession(serverName, serverConfig, auth);\n        return await Promise.race([operation(newClient), new Promise<T>((_, reject) => setTimeout(() => reject(new Error(`MCP operation on '${sessionKey}' timed out after ${timeoutMs / 1000}s.`)), timeoutMs))]);\n      }\n\n      throw e;\n    }\n  }\n\n  public async registerManual(caller: IUtcpClient, manualCallTemplate: CallTemplate): Promise<RegisterManualResult> {\n    this._logInfo(`Registering MCP manual '${manualCallTemplate.name}' by discovering tools.`);\n    const mcpCallTemplate = McpCallTemplateSchema.parse(manualCallTemplate);\n\n    if (!mcpCallTemplate.config?.mcpServers || Object.keys(mcpCallTemplate.config.mcpServers).length === 0) {\n      const errorMsg = \"MCP call template has no servers configured.\";\n      this._logError(errorMsg);\n      return { manualCallTemplate: mcpCallTemplate, manual: UtcpManualSchema.parse({ tools: [] }), success: false, errors: [errorMsg] };\n    }\n\n    const allTools: Tool[] = [];\n    const allErrors: string[] = [];\n\n    for (const [serverName, serverConfig] of Object.entries(mcpCallTemplate.config.mcpServers)) {\n      try {\n        this._logInfo(`Discovering tools from MCP server '${serverName}'...`);\n        const mcpToolsResult = await this._withSession(serverName, serverConfig, mcpCallTemplate.auth,\n          (client) => client.listTools()\n        );\n\n        if (!isMcpToolsResponse(mcpToolsResult)) {\n          throw new Error(\"Invalid response format from listTools\");\n        }\n\n        // Dereference schemas to resolve $defs references (fixes FastMCP 2.0+ compatibility)\n        const utcpToolsPromises = mcpToolsResult.tools.map(async (mcpTool: McpToolResponse) => {\n          const [dereferencedInputs, dereferencedOutputs] = await Promise.all([\n            this._dereferenceSchema(mcpTool.inputSchema),\n            this._dereferenceSchema(mcpTool.outputSchema)\n          ]);\n          \n          return {\n            name: `${mcpCallTemplate.name}.${serverName}.${mcpTool.name}`,\n            description: mcpTool.description || '',\n            inputs: dereferencedInputs,\n            outputs: dereferencedOutputs,\n            tags: [],\n            tool_call_template: mcpCallTemplate,\n          };\n        });\n        \n        const utcpTools = await Promise.all(utcpToolsPromises);\n        allTools.push(...utcpTools);\n        this._logInfo(`Discovered ${utcpTools.length} tools from server '${serverName}'.`);\n\n      } catch (e: any) {\n        this._logError(`Failed to discover tools from MCP server '${serverName}':`, e);\n        allErrors.push(`Server '${serverName}': ${e.message}`);\n      }\n    }\n\n    return {\n      manualCallTemplate: mcpCallTemplate,\n      manual: UtcpManualSchema.parse({ tools: allTools }),\n      success: allErrors.length === 0,\n      errors: allErrors,\n    };\n  }\n\n  public async deregisterManual(caller: IUtcpClient, manualCallTemplate: CallTemplate): Promise<void> {\n    const mcpCallTemplate = McpCallTemplateSchema.parse(manualCallTemplate);\n    this._logInfo(`Deregistering MCP manual '${mcpCallTemplate.name}'.`);\n    if (mcpCallTemplate.config?.mcpServers) {\n      for (const serverName of Object.keys(mcpCallTemplate.config.mcpServers)) {\n        await this._cleanupSession(`${serverName}:stdio`);\n        await this._cleanupSession(`${serverName}:http`);\n      }\n    }\n  }\n\n  public async callTool(caller: IUtcpClient, toolName: string, toolArgs: Record<string, any>, toolCallTemplate: CallTemplate): Promise<any> {\n    const mcpCallTemplate = McpCallTemplateSchema.parse(toolCallTemplate);\n    if (!mcpCallTemplate.config?.mcpServers) {\n      throw new Error(`No MCP server configuration for tool '${toolName}'.`);\n    }\n\n    // Tool name format is: manualName.serverName.toolName\n    // Strip the manual name prefix to get serverName.toolName\n    const manualPrefix = `${mcpCallTemplate.name}.`;\n    let toolNameWithoutManual = toolName;\n    if (toolName.startsWith(manualPrefix)) {\n      toolNameWithoutManual = toolName.substring(manualPrefix.length);\n    }\n\n    const [serverName, ...restOfToolName] = toolNameWithoutManual.split('.');\n    const actualToolName = restOfToolName.join('.');\n\n    if (!serverName || !actualToolName) {\n      throw new Error(`Invalid MCP tool name format: '${toolName}'. Expected 'manualName.serverName.toolName'.`);\n    }\n\n    const serverConfig = mcpCallTemplate.config.mcpServers[serverName];\n    if (!serverConfig) {\n      throw new Error(`Configuration for MCP server '${serverName}' not found in manual '${mcpCallTemplate.name}'.`);\n    }\n\n    this._logInfo(`Calling tool '${actualToolName}' on MCP server '${serverName}'...`);\n    const result = await this._withSession(serverName, serverConfig, mcpCallTemplate.auth,\n      (client) => client.callTool({ name: actualToolName, arguments: toolArgs })\n    );\n\n    return this._processMcpToolResult(result);\n  }\n\n  public async *callToolStreaming(caller: IUtcpClient, toolName: string, toolArgs: Record<string, any>, toolCallTemplate: CallTemplate): AsyncGenerator<any, void, unknown> {\n    this._logInfo(`MCP protocol does not support streaming for '${toolName}'. Fetching full response as a single chunk.`);\n    const result = await this.callTool(caller, toolName, toolArgs, toolCallTemplate);\n    yield result;\n  }\n\n  public async close(): Promise<void> {\n    this._logInfo(\"Closing all active MCP sessions.\");\n    const cleanupPromises = Array.from(this._mcpSessions.keys()).map(key => this._cleanupSession(key));\n    await Promise.all(cleanupPromises);\n    this._oauthTokens.clear();\n    this._logInfo(\"MCP Communication Protocol closed and all resources cleaned up.\");\n  }\n  \n  private _processMcpToolResult(result: any): any {\n    if (result && typeof result === 'object') {\n      if ('structured_output' in result) {\n        return result.structured_output;\n      }\n      if (Array.isArray(result.content)) {\n        const processedList = result.content.map((item: any) => {\n          if (item && item.type === 'text' && typeof item.text === 'string') {\n            return this._parseTextContent(item.text);\n          }\n          return item;\n        });\n        return processedList.length === 1 ? processedList[0] : processedList;\n      }\n    }\n    return result;\n  }\n\n  private _parseTextContent(text: string): any {\n    try {\n      return JSON.parse(text);\n    } catch {\n      const num = Number(text);\n      if (!isNaN(num) && isFinite(num)) {\n        return num;\n      }\n      return text;\n    }\n  }\n  \n  private async _handleOAuth2(authDetails: OAuth2Auth): Promise<string> {\n    const clientId = authDetails.client_id;\n    const cachedToken = this._oauthTokens.get(clientId);\n    if (cachedToken && cachedToken.expiresAt > Date.now()) {\n      return cachedToken.accessToken;\n    }\n\n    this._logInfo(`Fetching new OAuth2 token for client: '${clientId}'`);\n\n    try {\n      const token = await Promise.any([\n        (async () => {\n          const bodyData = new URLSearchParams({\n            'grant_type': 'client_credentials', 'client_id': authDetails.client_id,\n            'client_secret': authDetails.client_secret, 'scope': authDetails.scope || ''\n          });\n          const response = await this._axiosInstance.post(authDetails.token_url, bodyData.toString(), { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } });\n          if (!response.data.access_token) throw new Error(\"Access token not found in response.\");\n          const expiresAt = Date.now() + ((response.data.expires_in || 3600) * 1000);\n          this._oauthTokens.set(clientId, { accessToken: response.data.access_token, expiresAt });\n          return response.data.access_token;\n        })(),\n        (async () => {\n          const bodyData = new URLSearchParams({ 'grant_type': 'client_credentials', 'scope': authDetails.scope || '' });\n          const response = await this._axiosInstance.post(authDetails.token_url, bodyData.toString(), {\n            auth: { username: authDetails.client_id, password: authDetails.client_secret },\n            headers: { 'Content-Type': 'application/x-www-form-urlencoded' }\n          });\n          if (!response.data.access_token) throw new Error(\"Access token not found in response.\");\n          const expiresAt = Date.now() + ((response.data.expires_in || 3600) * 1000);\n          this._oauthTokens.set(clientId, { accessToken: response.data.access_token, expiresAt });\n          return response.data.access_token;\n        })()\n      ]);\n      return token;\n    } catch (aggregateError: any) {\n      const errorMessages = aggregateError.errors?.map((e: Error) => e.message).join('; ') || String(aggregateError);\n      throw new Error(`Failed to fetch OAuth2 token for client '${clientId}': ${errorMessages}`);\n    }\n  }\n}",
      "line_count": 386,
      "word_count": 1517,
      "title": "Mcp Communication Protocol.Ts",
      "summary": "// packages/mcp/src/mcp_communication_protocol.ts import { Client as McpClient } from '@modelcontextprotocol/sdk/client/index.js';",
      "key_terms": [
        "close",
        "const",
        "sessions",
        "packages",
        "restOfToolName",
        "clear",
        "Type",
        "Record",
        "utcpTools",
        "McpClient",
        "yield",
        "reject",
        "toolName",
        "enhance",
        "utcpToolsPromises",
        "if",
        "that",
        "interface",
        "utcp-mcp",
        "timed"
      ],
      "timestamp": "2025-12-24T18:56:19.852583"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\mcp\\tests\\mcp_communication_protocol.test.ts",
      "content_type": "code",
      "content": "// packages/mcp/tests/mcp_communication_protocol.test.ts\nimport { test, expect, beforeAll, afterAll, describe } from \"bun:test\";\nimport { Subprocess } from \"bun\";\nimport path from \"path\";\nimport { McpCommunicationProtocol, McpCallTemplate } from \"../src/index\";\nimport { IUtcpClient } from \"@utcp/sdk\";\n\nconst HTTP_PORT = 9999;\nlet stdioServerProcess: Subprocess | null = null;\nlet httpServerProcess: Subprocess | null = null;\n\nconst mockClient = {} as IUtcpClient;\n\n// Emergency cleanup handler if tests are interrupted\nconst cleanupProcesses = () => {\n  const isWindows = process.platform === \"win32\";\n  \n  if (stdioServerProcess && stdioServerProcess.pid) {\n    try {\n      if (isWindows) {\n        Bun.spawnSync([\"taskkill\", \"/F\", \"/T\", \"/PID\", stdioServerProcess.pid.toString()]);\n      } else {\n        stdioServerProcess.kill(9);\n      }\n    } catch (e) {\n      // Ignore errors\n    }\n  }\n  \n  if (httpServerProcess && httpServerProcess.pid) {\n    try {\n      if (isWindows) {\n        Bun.spawnSync([\"taskkill\", \"/F\", \"/T\", \"/PID\", httpServerProcess.pid.toString()]);\n      } else {\n        httpServerProcess.kill(9);\n      }\n    } catch (e) {\n      // Ignore errors\n    }\n  }\n};\n\n// Register cleanup on process exit\nprocess.on('exit', cleanupProcesses);\nprocess.on('SIGINT', () => {\n  cleanupProcesses();\n  process.exit(130);\n});\nprocess.on('SIGTERM', () => {\n  cleanupProcesses();\n  process.exit(143);\n});\n\nconst awaitServerReady = async (stream: ReadableStream<Uint8Array>, readyMessage: string, timeout = 20000) => {\n  const reader = stream.getReader();\n  const start = Date.now();\n  let output = \"\";\n\n  try {\n    while (Date.now() - start < timeout) {\n      const { done, value } = await reader.read();\n      if (done) break;\n      const chunk = new TextDecoder().decode(value);\n      output += chunk;\n      if (output.includes(readyMessage)) {\n        console.log(`Server ready message found: \"${readyMessage}\"`);\n        return;\n      }\n    }\n  } finally {\n    reader.releaseLock();\n  }\n  throw new Error(`Server did not emit ready message \"${readyMessage}\" in time. Full output:\\n${output}`);\n};\n\nbeforeAll(async () => {\n  console.log(\"Starting mock MCP servers for testing...\");\n\n  const stdioServerPath = path.resolve(import.meta.dir, \"mock_mcp_server.ts\");\n  stdioServerProcess = Bun.spawn([\"bun\", \"run\", stdioServerPath], {\n    stdout: \"pipe\",\n    stderr: \"inherit\",\n    windowsHide: true,\n  });\n  console.log(`Spawned stdio server with PID: ${stdioServerProcess.pid}`);\n  await awaitServerReady(stdioServerProcess.stdout, \"Mock STDIN MCP Server is running.\");\n\n  const httpServerPath = path.resolve(import.meta.dir, \"mock_http_mcp_server.ts\");\n  httpServerProcess = Bun.spawn([\"bun\", \"run\", httpServerPath], {\n    stdout: \"pipe\",\n    stderr: \"inherit\",\n    windowsHide: true,\n  });\n  console.log(`Spawned http server with PID: ${httpServerProcess.pid}`);\n  await awaitServerReady(httpServerProcess.stdout, `Mock HTTP MCP Server listening on port ${HTTP_PORT}`);\n\n  console.log(\"Both mock servers are ready.\");\n}, 25000);\n\nafterAll(async () => {\n  console.log(\"Stopping mock MCP servers...\");\n  \n  const isWindows = process.platform === \"win32\";\n  \n  // Force kill processes to ensure cleanup\n  if (stdioServerProcess && stdioServerProcess.pid) {\n    if (isWindows) {\n      // On Windows, use taskkill to kill the entire process tree\n      try {\n        Bun.spawnSync([\"taskkill\", \"/F\", \"/T\", \"/PID\", stdioServerProcess.pid.toString()]);\n      } catch (e) {\n        // Ignore errors if process already terminated\n      }\n    } else {\n      stdioServerProcess.kill();\n      await new Promise(resolve => setTimeout(resolve, 100));\n      if (!stdioServerProcess.killed) {\n        stdioServerProcess.kill(9);\n      }\n    }\n  }\n  \n  if (httpServerProcess && httpServerProcess.pid) {\n    if (isWindows) {\n      // On Windows, use taskkill to kill the entire process tree\n      try {\n        Bun.spawnSync([\"taskkill\", \"/F\", \"/T\", \"/PID\", httpServerProcess.pid.toString()]);\n      } catch (e) {\n        // Ignore errors if process already terminated\n      }\n    } else {\n      httpServerProcess.kill();\n      await new Promise(resolve => setTimeout(resolve, 100));\n      if (!httpServerProcess.killed) {\n        httpServerProcess.kill(9);\n      }\n    }\n  }\n  \n  // Extra safety: wait a bit for ports to be released\n  await new Promise(resolve => setTimeout(resolve, 300));\n  console.log(\"Mock servers stopped.\");\n});\n\ndescribe(\"McpCommunicationProtocol\", () => {\n\n  describe(\"Stdio Transport\", () => {\n    const stdioServerPath = path.resolve(import.meta.dir, \"mock_mcp_server.ts\");\n    const callTemplate: McpCallTemplate = {\n      name: \"mock_stdio_manual\",\n      call_template_type: \"mcp\",\n      config: {\n        mcpServers: {\n          mock_stdio_server: {\n            transport: 'stdio',\n            command: 'bun',\n            args: ['run', stdioServerPath],\n            cwd: path.dirname(stdioServerPath)\n          }\n        }\n      }\n    };\n\n    test(\"should register manual and discover tools from stdio server\", async () => {\n      const protocol = new McpCommunicationProtocol();\n      try {\n        const result = await protocol.registerManual(mockClient, callTemplate);\n        expect(result.success).toBe(true);\n        expect(result.manual.tools.length).toBeGreaterThan(0);\n        expect(result.manual.tools.some(t => t?.name === \"mock_stdio_manual.mock_stdio_server.echo\")).toBe(true);\n      } finally {\n        await protocol.close();\n      }\n    });\n\n    test(\"should call a tool with structured output via stdio\", async () => {\n      const protocol = new McpCommunicationProtocol();\n      try {\n        const result = await protocol.callTool(mockClient, \"mock_stdio_server.echo\", { message: \"hello stdio\" }, callTemplate);\n        expect(result).toEqual({ reply: \"you said: hello stdio\" });\n      } finally {\n        await protocol.close();\n      }\n    });\n\n    test(\"should call a tool with primitive output via stdio\", async () => {\n      const protocol = new McpCommunicationProtocol();\n      try {\n        const result = await protocol.callTool(mockClient, \"mock_stdio_server.add\", { a: 10, b: 5 }, callTemplate);\n        expect(result).toBe(15);\n      } finally {\n        await protocol.close();\n      }\n    });\n  });\n\n  describe(\"HTTP Transport\", () => {\n    const protocol = new McpCommunicationProtocol();\n    \n    // For HTTP transport, we can reuse sessions since they're stateful on the server.\n    // Only close once after all tests are done.\n    afterAll(async () => {\n      await protocol.close();\n    });\n\n    const callTemplate: McpCallTemplate = {\n      name: \"mock_http_manual\",\n      call_template_type: \"mcp\",\n      config: {\n        mcpServers: {\n          mock_http_server: {\n            transport: 'http',\n            url: `http://localhost:${HTTP_PORT}/mcp`,\n          }\n        }\n      }\n    };\n\n    test(\"should register manual and discover tools from http server\", async () => {\n      const result = await protocol.registerManual(mockClient, callTemplate);\n      expect(result.success).toBe(true);\n      expect(result.manual.tools).toHaveLength(2);\n      expect(result.manual.tools[0]?.name).toBe(\"mock_http_manual.mock_http_server.echo\");\n      expect(result.manual.tools[1]?.name).toBe(\"mock_http_manual.mock_http_server.add\");\n    });\n\n    test(\"should call a tool with structured output via http\", async () => {\n      // This test will now reuse the session created in the previous test\n      const result = await protocol.callTool(mockClient, \"mock_http_server.echo\", { message: \"hello http\" }, callTemplate);\n      expect(result).toEqual({ reply: \"you said: hello http\" });\n    }, 10000);\n\n    test(\"should call a tool with primitive output via http\", async () => {\n      const result = await protocol.callTool(mockClient, \"mock_http_server.add\", { a: 20, b: 5 }, callTemplate);\n      expect(result).toBe(25);\n    }, 10000);\n    \n    test(\"should throw an error if tool name is not namespaced correctly\", async () => {\n        await expect(\n            protocol.callTool(mockClient, \"nonexistent_tool\", {}, callTemplate)\n        ).rejects.toThrow(\"Invalid MCP tool name format: 'nonexistent_tool'. Expected 'manualName.serverName.toolName'.\");\n    }, 10000);\n\n    test(\"should throw an error if server name from tool is not in config\", async () => {\n        await expect(\n            protocol.callTool(mockClient, \"unknown_server.some_tool\", {}, callTemplate)\n        ).rejects.toThrow(\"Configuration for MCP server 'unknown_server' not found in manual 'mock_http_manual'.\");\n    }, 10000);\n  });\n});",
      "line_count": 250,
      "word_count": 879,
      "title": "Mcp Communication Protocol.Test.Ts",
      "summary": "// packages/mcp/tests/mcp_communication_protocol.test.ts import { test, expect, beforeAll, afterAll, describe } from \"bun:test\";",
      "key_terms": [
        "toString",
        "output",
        "close",
        "const",
        "sessions",
        "packages",
        "null",
        "we",
        "async",
        "localhost",
        "error",
        "getReader",
        "wait",
        "cleanupProcesses",
        "index",
        "cleanup",
        "afterAll",
        "format",
        "callTemplate",
        "Bun"
      ],
      "timestamp": "2025-12-24T18:56:19.887985"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\mcp\\tests\\mock_http_mcp_server.d.ts",
      "content_type": "code",
      "content": "export {};\n",
      "line_count": 2,
      "word_count": 2,
      "title": "Mock Http Mcp Server.D.Ts",
      "summary": "",
      "key_terms": [
        "export"
      ],
      "timestamp": "2025-12-24T18:56:19.887985"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\mcp\\tests\\mock_http_mcp_server.js",
      "content_type": "code",
      "content": "// packages/mcp/tests/mock_http_mcp_server.ts\nimport http from \"node:http\";\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StreamableHTTPServerTransport } from \"@modelcontextprotocol/sdk/server/streamableHttp.js\";\nimport { z } from \"zod\";\nconst HTTP_PORT = 9999;\nconst server = new McpServer({ name: \"mock-http-server\", version: \"1.0.0\" });\nserver.registerTool(\"echo\", {\n    title: \"Echo Tool\",\n    description: \"Echoes back the input message. Useful for testing HTTP connectivity.\",\n    inputSchema: { message: z.string() },\n}, async (input) => {\n    const result = { reply: `you said: ${input.message}` };\n    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n});\nserver.registerTool(\"add\", {\n    title: \"Add Tool\",\n    description: \"Adds two numbers together via HTTP. A basic arithmetic operation.\",\n    inputSchema: { a: z.number(), b: z.number() },\n}, async (input) => {\n    const result = input.a + input.b;\n    return { content: [{ type: \"text\", text: String(result) }] };\n});\nconst transportOptions = {\n    sessionIdGenerator: () => crypto.randomUUID(),\n};\nconst transport = new StreamableHTTPServerTransport(transportOptions);\nconst httpServer = http.createServer((req, res) => {\n    if (req.url === \"/mcp\") {\n        transport.handleRequest(req, res);\n    }\n    else {\n        res.writeHead(404, { \"Content-Type\": \"text/plain\" });\n        res.end(\"Not Found\");\n    }\n});\n// Graceful shutdown handling\nprocess.on('SIGTERM', () => {\n    console.log('SIGTERM received, closing HTTP server...');\n    httpServer.close(() => {\n        console.log('HTTP server closed');\n        process.exit(0);\n    });\n});\nprocess.on('SIGINT', () => {\n    console.log('SIGINT received, closing HTTP server...');\n    httpServer.close(() => {\n        console.log('HTTP server closed');\n        process.exit(0);\n    });\n});\n(async () => {\n    await server.connect(transport);\n    httpServer.listen(HTTP_PORT, () => {\n        console.log(`Mock HTTP MCP Server listening on port ${HTTP_PORT}`);\n    });\n})();\n",
      "line_count": 58,
      "word_count": 229,
      "title": "Mock Http Mcp Server.Js",
      "summary": "// packages/mcp/tests/mock_http_mcp_server.ts import http from \"node:http\";",
      "key_terms": [
        "close",
        "const",
        "packages",
        "async",
        "number",
        "transportOptions",
        "Type",
        "said",
        "connect",
        "reply",
        "Found",
        "req",
        "received",
        "string",
        "version",
        "if",
        "httpServer",
        "basic",
        "exit",
        "description"
      ],
      "timestamp": "2025-12-24T18:56:19.934091"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\mcp\\tests\\mock_http_mcp_server.ts",
      "content_type": "code",
      "content": "// packages/mcp/tests/mock_http_mcp_server.ts\nimport http from \"node:http\";\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StreamableHTTPServerTransport, StreamableHTTPServerTransportOptions } from \"@modelcontextprotocol/sdk/server/streamableHttp.js\";\nimport { z } from \"zod\";\n\nconst HTTP_PORT = 9999;\nconst server = new McpServer({ name: \"mock-http-server\", version: \"1.0.0\" });\n\nserver.registerTool(\"echo\", {\n  title: \"Echo Tool\",\n  description: \"Echoes back the input message. Useful for testing HTTP connectivity.\",\n  inputSchema: { message: z.string() },\n}, async (input) => {\n  const result = { reply: `you said: ${input.message}` };\n  return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n});\n\nserver.registerTool(\"add\", {\n  title: \"Add Tool\",\n  description: \"Adds two numbers together via HTTP. A basic arithmetic operation.\",\n  inputSchema: { a: z.number(), b: z.number() },\n}, async (input) => {\n  const result = input.a + input.b;\n  return { content: [{ type: \"text\", text: String(result) }] };\n});\n\nconst transportOptions: StreamableHTTPServerTransportOptions = {\n  sessionIdGenerator: () => crypto.randomUUID(),\n};\nconst transport = new StreamableHTTPServerTransport(transportOptions);\n\nconst httpServer = http.createServer((req, res) => {\n  if (req.url === \"/mcp\") {\n      transport.handleRequest(req, res);\n  } else {\n      res.writeHead(404, { \"Content-Type\": \"text/plain\" });\n      res.end(\"Not Found\");\n  }\n});\n\n// Graceful shutdown handling\nprocess.on('SIGTERM', () => {\n  console.log('SIGTERM received, closing HTTP server...');\n  httpServer.close(() => {\n    console.log('HTTP server closed');\n    process.exit(0);\n  });\n});\n\nprocess.on('SIGINT', () => {\n  console.log('SIGINT received, closing HTTP server...');\n  httpServer.close(() => {\n    console.log('HTTP server closed');\n    process.exit(0);\n  });\n});\n\n(async () => {\n  await server.connect(transport);\n  httpServer.listen(HTTP_PORT, () => {\n    console.log(`Mock HTTP MCP Server listening on port ${HTTP_PORT}`);\n  });\n})();",
      "line_count": 64,
      "word_count": 231,
      "title": "Mock Http Mcp Server.Ts",
      "summary": "// packages/mcp/tests/mock_http_mcp_server.ts import http from \"node:http\";",
      "key_terms": [
        "close",
        "const",
        "packages",
        "async",
        "number",
        "transportOptions",
        "Type",
        "said",
        "connect",
        "reply",
        "Found",
        "req",
        "received",
        "string",
        "version",
        "if",
        "httpServer",
        "basic",
        "exit",
        "StreamableHTTPServerTransportOptions"
      ],
      "timestamp": "2025-12-24T18:56:19.964167"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\mcp\\tests\\mock_mcp_server.d.ts",
      "content_type": "code",
      "content": "export {};\n",
      "line_count": 2,
      "word_count": 2,
      "title": "Mock Mcp Server.D.Ts",
      "summary": "",
      "key_terms": [
        "export"
      ],
      "timestamp": "2025-12-24T18:56:19.964167"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\mcp\\tests\\mock_mcp_server.js",
      "content_type": "code",
      "content": "// packages/mcp/tests/mock_mcp_server.ts\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\nconst server = new McpServer({ name: \"mock-stdio-server\", version: \"1.0.0\" });\nserver.registerTool(\"echo\", {\n    title: \"Echo Tool\",\n    description: \"Echoes back the input message. Useful for testing connectivity.\",\n    inputSchema: { message: z.string() },\n}, async (input) => {\n    const result = { reply: `you said: ${input.message}` };\n    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n});\nserver.registerTool(\"add\", {\n    title: \"Add Tool\",\n    description: \"Adds two numbers together. A basic arithmetic operation.\",\n    inputSchema: { a: z.number(), b: z.number() },\n}, async (input) => {\n    const result = input.a + input.b;\n    return { content: [{ type: \"text\", text: String(result) }] };\n});\nconst transport = new StdioServerTransport();\n(async () => {\n    await server.connect(transport);\n    console.log(\"Mock STDIN MCP Server is running.\");\n})();\n",
      "line_count": 27,
      "word_count": 136,
      "title": "Mock Mcp Server.Js",
      "summary": "// packages/mcp/tests/mock_mcp_server.ts import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";",
      "key_terms": [
        "from",
        "const",
        "Add",
        "packages",
        "registerTool",
        "async",
        "number",
        "STDIN",
        "inputSchema",
        "together",
        "zod",
        "is",
        "Tool",
        "mock",
        "message",
        "back",
        "type",
        "said",
        "connect",
        "reply"
      ],
      "timestamp": "2025-12-24T18:56:20.011964"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\mcp\\tests\\mock_mcp_server.ts",
      "content_type": "code",
      "content": "// packages/mcp/tests/mock_mcp_server.ts\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({ name: \"mock-stdio-server\", version: \"1.0.0\" });\n\nserver.registerTool(\"echo\", {\n  title: \"Echo Tool\",\n  description: \"Echoes back the input message. Useful for testing connectivity.\",\n  inputSchema: { message: z.string() },\n}, async (input) => {\n  const result = { reply: `you said: ${input.message}` };\n  return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n});\n\nserver.registerTool(\"add\", {\n  title: \"Add Tool\",\n  description: \"Adds two numbers together. A basic arithmetic operation.\",\n  inputSchema: { a: z.number(), b: z.number() },\n}, async (input) => {\n  const result = input.a + input.b;\n  return { content: [{ type: \"text\", text: String(result) }] };\n});\n\nconst transport = new StdioServerTransport();\n(async () => {\n  await server.connect(transport);\n  console.log(\"Mock STDIN MCP Server is running.\");\n})(); ",
      "line_count": 30,
      "word_count": 136,
      "title": "Mock Mcp Server.Ts",
      "summary": "// packages/mcp/tests/mock_mcp_server.ts import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";",
      "key_terms": [
        "from",
        "const",
        "Add",
        "packages",
        "registerTool",
        "async",
        "number",
        "STDIN",
        "inputSchema",
        "together",
        "zod",
        "is",
        "Tool",
        "mock",
        "message",
        "back",
        "type",
        "said",
        "connect",
        "reply"
      ],
      "timestamp": "2025-12-24T18:56:20.043387"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\text\\package.json",
      "content_type": "configuration",
      "content": "{\n  \"name\": \"@utcp/text\",\n  \"version\": \"1.1.0\",\n  \"description\": \"Text content protocol for UTCP - handles direct text content (browser-compatible)\",\n  \"main\": \"dist/index.cjs\",\n  \"module\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"type\": \"module\",\n  \"license\": \"MPL-2.0\",\n  \"author\": \"UTCP Contributors\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/universal-tool-calling-protocol/typescript-utcp.git\",\n    \"directory\": \"packages/text\"\n  },\n  \"keywords\": [\n    \"utcp\",\n    \"text\",\n    \"content\",\n    \"browser\",\n    \"tool calling\"\n  ],\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"scripts\": {\n    \"build\": \"tsup\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\",\n      \"require\": \"./dist/index.cjs\",\n      \"default\": \"./dist/index.js\"\n    }\n  },\n  \"dependencies\": {\n    \"@utcp/http\": \"^1.1.0\",\n    \"@utcp/sdk\": \"^1.1.0\",\n    \"js-yaml\": \"^4.1.0\"\n  },\n  \"devDependencies\": {\n    \"bun-types\": \"latest\",\n    \"typescript\": \"^5.0.0\"\n  }\n}\n",
      "line_count": 50,
      "word_count": 93,
      "title": "Package.Json",
      "summary": "\"name\": \"@utcp/text\", \"version\": \"1.1.0\",",
      "key_terms": [
        "browser",
        "handles",
        "Text",
        "build",
        "packages",
        "calling-protocol",
        "yaml",
        "scripts",
        "universal",
        "browser-compatible",
        "module",
        "utcp",
        "index",
        "compatible",
        "calling",
        "MPL",
        "js-yaml",
        "tool",
        "dependencies",
        "type"
      ],
      "timestamp": "2025-12-24T18:56:20.075286"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\text\\README.md",
      "content_type": "documentation",
      "content": "# @utcp/text\n\nText Content Communication Protocol plugin for the Universal Tool Calling Protocol (UTCP).\n\n## Overview\n\nThis plugin provides support for loading UTCP manuals and tool definitions from direct text/string content. Unlike `@utcp/file` which reads from files, this plugin is **browser-compatible** and works in any JavaScript environment.\n\n## Installation\n\n```bash\nnpm install @utcp/text\n```\n\n## Usage\n\nThe plugin automatically registers itself when imported:\n\n```typescript\nimport '@utcp/text';\nimport { UtcpClient } from '@utcp/sdk';\n\nconst utcpManualContent = JSON.stringify({\n  tools: [\n    {\n      name: 'my_tool',\n      description: 'A sample tool',\n      inputs: { type: 'object', properties: {} },\n      outputs: { type: 'object', properties: {} }\n    }\n  ]\n});\n\nconst client = await UtcpClient.create();\nawait client.registerCallTemplate({\n  call_template_type: 'text',\n  name: 'my-manual',\n  content: utcpManualContent\n});\n```\n\n## Features\n\n- **Browser-Compatible**: No file system dependencies\n- **Multiple Formats**: Supports both JSON and YAML content\n- **OpenAPI Conversion**: Automatically converts OpenAPI specs to UTCP manuals\n- **Type-Safe**: Full TypeScript support with Zod validation\n\n## Text Call Template\n\nThe text call template accepts the following configuration:\n\n- `call_template_type`: Must be set to `'text'`\n- `name`: Unique identifier for this manual\n- `content`: String content containing the UTCP manual or OpenAPI spec (required)\n- `auth_tools`: Optional authentication to apply to tools from OpenAPI specs\n\n## Example: OpenAPI Spec\n\n```typescript\nimport '@utcp/text';\nimport { UtcpClient } from '@utcp/sdk';\n\nconst openApiSpec = `\nopenapi: 3.0.0\ninfo:\n  title: My API\n  version: 1.0.0\npaths:\n  /users:\n    get:\n      summary: Get users\n      responses:\n        '200':\n          description: Success\n`;\n\nconst client = await UtcpClient.create();\nawait client.registerCallTemplate({\n  call_template_type: 'text',\n  name: 'my-api',\n  content: openApiSpec\n});\n```\n\n## Browser Usage\n\nPerfect for web applications:\n\n```typescript\nimport '@utcp/text';\nimport { UtcpClient } from '@utcp/sdk';\n\n// Load from API or inline\nconst response = await fetch('/api/utcp-manual');\nconst manualContent = await response.text();\n\nconst client = await UtcpClient.create();\nawait client.registerCallTemplate({\n  call_template_type: 'text',\n  name: 'remote-manual',\n  content: manualContent\n});\n```\n\n## Comparison with @utcp/file\n\n| Feature | @utcp/text | @utcp/file |\n|---------|-------------|-----------|\n| Browser compatible | ✅ Yes | ❌ No |\n| Node.js compatible | ✅ Yes | ✅ Yes |\n| File system access | ❌ No | ✅ Yes |\n| Direct content | ✅ Yes | ❌ No |\n| Use case | Web apps, inline content | Server-side file reading |\n\n## License\n\nMPL-2.0\n",
      "line_count": 119,
      "word_count": 368,
      "title": "@utcp/text",
      "summary": "Text Content Communication Protocol plugin for the Universal Tool Calling Protocol (UTCP). This plugin provides support for loading UTCP manuals and tool definitions from direct text/string content. U...",
      "key_terms": [
        "Unlike",
        "reading",
        "const",
        "paths",
        "Success",
        "File",
        "Type",
        "my-api",
        "info",
        "compatible",
        "Utcp",
        "dependencies",
        "Conversion",
        "string",
        "registers",
        "identifier",
        "Browser",
        "version",
        "Calling",
        "Features"
      ],
      "timestamp": "2025-12-24T18:56:20.112968"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\text\\tsconfig.json",
      "content_type": "configuration",
      "content": "{\n  \"extends\": \"../../tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"composite\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"],\n  \"references\": [\n    { \"path\": \"../core\" },\n    { \"path\": \"../http\" }\n  ]\n}\n",
      "line_count": 15,
      "word_count": 29,
      "title": "Tsconfig.Json",
      "summary": "\"extends\": \"../../tsconfig.json\", \"compilerOptions\": {",
      "key_terms": [
        "rootDir",
        "composite",
        "exclude",
        "include",
        "references",
        "tsconfig",
        "path",
        "json",
        "core",
        "extends",
        "compilerOptions",
        "dist",
        "src",
        "outDir",
        "http",
        "true"
      ],
      "timestamp": "2025-12-24T18:56:20.123096"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\text\\tsup.config.ts",
      "content_type": "code",
      "content": "import { defineConfig } from 'tsup';\n\nexport default defineConfig({\n  entry: ['src/index.ts'],\n  format: ['esm', 'cjs'],\n  dts: {\n    compilerOptions: {\n      composite: false,\n      paths: {},\n    },\n  },\n  splitting: false,\n  sourcemap: true,\n  clean: true,\n  outDir: 'dist',\n  external: ['@utcp/sdk', '@utcp/http', 'js-yaml'],\n});\n",
      "line_count": 18,
      "word_count": 37,
      "title": "Tsup.Config.Ts",
      "summary": "import { defineConfig } from 'tsup'; export default defineConfig({",
      "key_terms": [
        "from",
        "sourcemap",
        "composite",
        "paths",
        "entry",
        "yaml",
        "clean",
        "utcp",
        "outDir",
        "index",
        "format",
        "js-yaml",
        "default",
        "ts",
        "cjs",
        "false",
        "import",
        "export",
        "sdk",
        "js"
      ],
      "timestamp": "2025-12-24T18:56:20.135904"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\text\\src\\index.ts",
      "content_type": "code",
      "content": "/**\n * Text Content Communication Protocol plugin for UTCP.\n * Handles direct text content (browser-compatible).\n */\n// packages/text/src/index.ts\nimport { CommunicationProtocol, CallTemplateSerializer, ensureCorePluginsInitialized } from '@utcp/sdk';\nimport { TextCallTemplateSerializer } from './text_call_template';\nimport { TextCommunicationProtocol } from './text_communication_protocol';\n\n/**\n * Registers the Text protocol's CallTemplate serializer\n * and its CommunicationProtocol implementation.\n * This function is called automatically when the package is imported.\n */\nexport function register(override: boolean = false): void {\n  // Ensure core plugins are initialized first\n  ensureCorePluginsInitialized();\n  \n  // Register the CallTemplate serializer\n  CallTemplateSerializer.registerCallTemplate('text', new TextCallTemplateSerializer(), override);\n  \n  // Register the CommunicationProtocol instance\n  CommunicationProtocol.communicationProtocols['text'] = new TextCommunicationProtocol();\n}\n\n// Automatically register Text plugin on import\nregister();\n\n// Export all public APIs\nexport * from './text_call_template';\nexport * from './text_communication_protocol';\n",
      "line_count": 32,
      "word_count": 119,
      "title": "Index.Ts",
      "summary": "* Text Content Communication Protocol plugin for UTCP. * Handles direct text content (browser-compatible).",
      "key_terms": [
        "browser",
        "Text",
        "from",
        "communicationProtocols",
        "packages",
        "serializer",
        "ensureCorePluginsInitialized",
        "initialized",
        "browser-compatible",
        "is",
        "automatically",
        "utcp",
        "index",
        "compatible",
        "Ensure",
        "Automatically",
        "register",
        "and",
        "public",
        "protocol"
      ],
      "timestamp": "2025-12-24T18:56:20.170641"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\text\\src\\text_call_template.ts",
      "content_type": "code",
      "content": "// packages/text/src/text_call_template.ts\nimport { z } from 'zod';\nimport { CallTemplate, Auth, AuthSchema, AuthSerializer } from '@utcp/sdk';\nimport { Serializer } from '@utcp/sdk';\n\n/**\n * Text call template for UTCP client.\n *\n * This template allows passing UTCP manuals or tool definitions directly as text content.\n * It supports both JSON and YAML formats and can convert OpenAPI specifications to UTCP manuals.\n *\n * Attributes:\n *     call_template_type: Always \"text\" for text call templates.\n *     content: Direct text content of the UTCP manual or tool definitions (required).\n *     base_url: Optional base URL for API endpoints when converting OpenAPI specs. Overrides spec's server configuration.\n *     auth: Always undefined - text call templates don't support authentication.\n *     auth_tools: Optional authentication to apply to generated tools from OpenAPI specs.\n */\nexport interface TextCallTemplate extends CallTemplate {\n  call_template_type: 'text';\n  content: string;\n  base_url?: string;\n  auth?: undefined;\n  auth_tools?: Auth | null;\n  allowed_communication_protocols?: string[];\n}\n\n/**\n * Zod schema for TextCallTemplate.\n */\nexport const TextCallTemplateSchema: z.ZodType<TextCallTemplate> = z.object({\n  name: z.string().optional(),\n  call_template_type: z.literal('text'),\n  content: z.string().describe('Direct text content of the UTCP manual or tool definitions'),\n  base_url: z.string().optional().describe('Optional base URL for API endpoints when converting OpenAPI specs'),\n  auth: z.undefined().optional(),\n  auth_tools: AuthSchema.nullable().optional().transform((val) => {\n    if (val === null || val === undefined) return null;\n    if (typeof val === 'object' && 'auth_type' in val) {\n      return new AuthSerializer().validateDict(val as any);\n    }\n    return val as Auth;\n  }).describe('Optional authentication to apply to generated tools from OpenAPI specs'),\n  allowed_communication_protocols: z.array(z.string()).optional().describe('Optional list of allowed communication protocol types for tools within this manual.'),\n}).strict() as z.ZodType<TextCallTemplate>;\n\n/**\n * Serializer for TextCallTemplate objects.\n */\nexport class TextCallTemplateSerializer extends Serializer<TextCallTemplate> {\n  toDict(obj: TextCallTemplate): Record<string, unknown> {\n    return {\n      name: obj.name,\n      call_template_type: obj.call_template_type,\n      content: obj.content,\n      base_url: obj.base_url,\n      auth: obj.auth,\n      auth_tools: obj.auth_tools ? new AuthSerializer().toDict(obj.auth_tools) : null,\n      allowed_communication_protocols: obj.allowed_communication_protocols,\n    };\n  }\n\n  validateDict(obj: Record<string, unknown>): TextCallTemplate {\n    try {\n      return TextCallTemplateSchema.parse(obj);\n    } catch (e: any) {\n      throw new Error(`Invalid TextCallTemplate: ${e.message}\\n${e.stack || ''}`);\n    }\n  }\n}\n",
      "line_count": 71,
      "word_count": 313,
      "title": "Text Call Template.Ts",
      "summary": "// packages/text/src/text_call_template.ts import { z } from 'zod';",
      "key_terms": [
        "nullable",
        "null",
        "const",
        "packages",
        "convert",
        "Record",
        "list",
        "unknown",
        "It",
        "string",
        "Error",
        "validateDict",
        "if",
        "interface",
        "Invalid",
        "strict",
        "object",
        "undefined",
        "definitions",
        "TextCallTemplateSerializer"
      ],
      "timestamp": "2025-12-24T18:56:20.194762"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\packages\\text\\src\\text_communication_protocol.ts",
      "content_type": "code",
      "content": "/**\n * Text communication protocol for UTCP client.\n *\n * This protocol parses UTCP manuals (or OpenAPI specs) from direct text content.\n * It's browser-compatible and requires no file system access.\n */\n// packages/text/src/text_communication_protocol.ts\nimport * as yaml from 'js-yaml';\nimport { CommunicationProtocol, RegisterManualResult, CallTemplate, UtcpManual, UtcpManualSerializer, IUtcpClient } from '@utcp/sdk';\nimport { OpenApiConverter } from '@utcp/http';\nimport { TextCallTemplate, TextCallTemplateSchema } from './text_call_template';\n\n/**\n * REQUIRED\n * Communication protocol for text-based UTCP manuals and tools.\n */\nexport class TextCommunicationProtocol implements CommunicationProtocol {\n  private _log_info(message: string): void {\n    console.log(`[TextCommunicationProtocol] ${message}`);\n  }\n\n  private _log_error(message: string): void {\n    console.error(`[TextCommunicationProtocol Error] ${message}`);\n  }\n\n  /**\n   * REQUIRED\n   * Register a text manual and return its tools as a UtcpManual.\n   */\n  public async registerManual(caller: IUtcpClient, manualCallTemplate: CallTemplate): Promise<RegisterManualResult> {\n    const textCallTemplate = TextCallTemplateSchema.parse(manualCallTemplate);\n\n    try {\n      this._log_info('Parsing direct content for manual');\n      const content = textCallTemplate.content;\n      let data: any;\n\n      // Try JSON first, then YAML\n      try {\n        data = JSON.parse(content);\n      } catch (jsonError) {\n        try {\n          data = yaml.load(content);\n        } catch (yamlError) {\n          throw new Error(`Failed to parse content as JSON or YAML: ${(jsonError as Error).message}`);\n        }\n      }\n\n      let utcpManual: UtcpManual;\n      if (data && typeof data === 'object' && (data.openapi || data.swagger || data.paths)) {\n        this._log_info('Detected OpenAPI specification. Converting to UTCP manual.');\n        const converter = new OpenApiConverter(data, {\n          specUrl: 'text://content',\n          callTemplateName: textCallTemplate.name,\n          authTools: textCallTemplate.auth_tools || undefined,\n          baseUrl: textCallTemplate.base_url,\n        });\n        utcpManual = converter.convert();\n      } else {\n        // Try to validate as UTCP manual directly\n        this._log_info('Validating content as UTCP manual.');\n        utcpManual = new UtcpManualSerializer().validateDict(data);\n      }\n\n      this._log_info(`Successfully registered manual with ${utcpManual.tools.length} tools.`);\n      return {\n        manualCallTemplate: textCallTemplate,\n        manual: utcpManual,\n        success: true,\n        errors: [],\n      };\n    } catch (err: any) {\n      const errMsg = `Failed to register text manual: ${err.message}`;\n      this._log_error(errMsg);\n      return {\n        manualCallTemplate: textCallTemplate,\n        manual: new UtcpManualSerializer().validateDict({ tools: [] }),\n        success: false,\n        errors: [errMsg],\n      };\n    }\n  }\n\n  /**\n   * REQUIRED\n   * Deregister a text manual (no-op).\n   */\n  public async deregisterManual(caller: IUtcpClient, manualCallTemplate: CallTemplate): Promise<void> {\n    this._log_info(`Deregistering text manual '${manualCallTemplate.name}' (no-op)`);\n  }\n\n  /**\n   * REQUIRED\n   * Execute a tool call. Text protocol returns the content directly.\n   */\n  public async callTool(caller: IUtcpClient, toolName: string, toolArgs: Record<string, any>, toolCallTemplate: CallTemplate): Promise<any> {\n    const textCallTemplate = TextCallTemplateSchema.parse(toolCallTemplate);\n    this._log_info(`Returning direct content for tool '${toolName}'`);\n    return textCallTemplate.content;\n  }\n\n  /**\n   * REQUIRED\n   * Streaming variant: yields the full content as a single chunk.\n   */\n  public async *callToolStreaming(caller: IUtcpClient, toolName: string, toolArgs: Record<string, any>, toolCallTemplate: CallTemplate): AsyncGenerator<any, void, unknown> {\n    const result = await this.callTool(caller, toolName, toolArgs, toolCallTemplate);\n    yield result;\n  }\n\n  /**\n   * REQUIRED\n   * Close the protocol connection (no-op for text protocol).\n   */\n  public async close(): Promise<void> {\n    // No cleanup needed for text protocol\n  }\n}\n",
      "line_count": 119,
      "word_count": 428,
      "title": "Text Communication Protocol.Ts",
      "summary": "* Text communication protocol for UTCP client. * This protocol parses UTCP manuals (or OpenAPI specs) from direct text content.",
      "key_terms": [
        "close",
        "const",
        "packages",
        "paths",
        "REQUIRED",
        "async",
        "utcpManual",
        "error",
        "yaml",
        "convert",
        "based",
        "Record",
        "compatible",
        "cleanup",
        "Utcp",
        "unknown",
        "private",
        "It",
        "yield",
        "callTemplateName"
      ],
      "timestamp": "2025-12-24T18:56:20.218725"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\scripts\\update-versions.js",
      "content_type": "code",
      "content": "#!/usr/bin/env node\n\n/**\n * Update versions across all packages in the monorepo\n * Usage: node scripts/update-versions.js [major|minor|patch|set] [version]\n * \n * Examples:\n *   node scripts/update-versions.js patch          # Bump each package patch version independently\n *   node scripts/update-versions.js minor          # Bump each package minor version independently\n *   node scripts/update-versions.js major          # Bump each package major version independently\n *   node scripts/update-versions.js set 1.2.3      # Set all packages to same specific version\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nconst PACKAGES_DIR = path.resolve(__dirname, '../packages');\nconst ROOT_DIR = path.resolve(__dirname, '..');\n\n// Package directories\nconst PACKAGES = ['core', 'http', 'mcp', 'text', 'file', 'cli', 'direct-call', 'dotenv-loader', 'code-mode'];\n\n/**\n * Parse semantic version string\n */\nfunction parseVersion(version) {\n  const match = version.match(/^(\\d+)\\.(\\d+)\\.(\\d+)(?:-(.+))?$/);\n  if (!match) {\n    throw new Error(`Invalid version format: ${version}`);\n  }\n  return {\n    major: parseInt(match[1], 10),\n    minor: parseInt(match[2], 10),\n    patch: parseInt(match[3], 10),\n    prerelease: match[4] || ''\n  };\n}\n\n/**\n * Bump version based on type\n */\nfunction bumpVersion(currentVersion, bumpType) {\n  const version = parseVersion(currentVersion);\n  \n  switch (bumpType) {\n    case 'major':\n      version.major += 1;\n      version.minor = 0;\n      version.patch = 0;\n      break;\n    case 'minor':\n      version.minor += 1;\n      version.patch = 0;\n      break;\n    case 'patch':\n      version.patch += 1;\n      break;\n    default:\n      throw new Error(`Unknown bump type: ${bumpType}`);\n  }\n  \n  version.prerelease = '';\n  return `${version.major}.${version.minor}.${version.patch}`;\n}\n\n/**\n * Update package.json version\n */\nfunction updatePackageVersion(packagePath, newVersion, bumpType = null) {\n  const packageJsonPath = path.join(packagePath, 'package.json');\n  \n  if (!fs.existsSync(packageJsonPath)) {\n    console.warn(`⚠️  Package.json not found: ${packageJsonPath}`);\n    return null;\n  }\n  \n  const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\n  const oldVersion = packageJson.version;\n  \n  // If bumpType is provided, calculate new version from current version\n  const finalVersion = bumpType ? bumpVersion(oldVersion, bumpType) : newVersion;\n  \n  packageJson.version = finalVersion;\n  \n  fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2) + '\\n');\n  \n  return { name: packageJson.name, oldVersion, newVersion: finalVersion };\n}\n\n/**\n * Update peer dependencies versions\n */\nfunction updatePeerDependencies(packagePath, updates) {\n  const packageJsonPath = path.join(packagePath, 'package.json');\n  \n  if (!fs.existsSync(packageJsonPath)) {\n    return;\n  }\n  \n  const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\n  let modified = false;\n  \n  // Update dependencies\n  if (packageJson.dependencies) {\n    for (const [name, oldVersion] of Object.entries(packageJson.dependencies)) {\n      const update = updates.find(u => u.name === name);\n      if (update) {\n        packageJson.dependencies[name] = `^${update.newVersion}`;\n        console.log(`  Updated dependency ${name}: ${oldVersion} -> ^${update.newVersion}`);\n        modified = true;\n      }\n    }\n  }\n  \n  // Update peerDependencies\n  if (packageJson.peerDependencies) {\n    for (const [name, oldVersion] of Object.entries(packageJson.peerDependencies)) {\n      const update = updates.find(u => u.name === name);\n      if (update) {\n        packageJson.peerDependencies[name] = `^${update.newVersion}`;\n        console.log(`  Updated peerDependency ${name}: ${oldVersion} -> ^${update.newVersion}`);\n        modified = true;\n      }\n    }\n  }\n  \n  if (modified) {\n    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2) + '\\n');\n  }\n}\n\n/**\n * Main function\n */\nfunction main() {\n  const args = process.argv.slice(2);\n  \n  if (args.length === 0) {\n    console.error('❌ Usage: node scripts/update-versions.js [major|minor|patch|set] [version?]');\n    console.error('\\nExamples:');\n    console.error('  node scripts/update-versions.js patch    # Bump each package by one patch');\n    console.error('  node scripts/update-versions.js minor    # Bump each package by one minor');\n    console.error('  node scripts/update-versions.js major    # Bump each package by one major');\n    console.error('  node scripts/update-versions.js set 1.2.3 # Set all packages to same version');\n    process.exit(1);\n  }\n  \n  const command = args[0];\n  let newVersion;\n  let bumpType = null;\n  \n  if (command === 'set') {\n    if (args.length < 2) {\n      console.error('❌ Error: Version number required for \"set\" command');\n      console.error('   Usage: node scripts/update-versions.js set 1.2.3');\n      process.exit(1);\n    }\n    newVersion = args[1];\n    \n    // Validate version format\n    try {\n      parseVersion(newVersion);\n    } catch (error) {\n      console.error(`❌ ${error.message}`);\n      process.exit(1);\n    }\n    \n    console.log(`🎯 Setting all packages to version: ${newVersion}\\n`);\n  } else if (['major', 'minor', 'patch'].includes(command)) {\n    bumpType = command;\n    console.log(`🎯 Bumping each package by one ${command} version\\n`);\n  } else {\n    console.error(`❌ Unknown command: ${command}`);\n    console.error('   Valid commands: major, minor, patch, set');\n    process.exit(1);\n  }\n  \n  // Update all package versions\n  const updates = [];\n  \n  console.log('📝 Updating package versions...\\n');\n  \n  for (const pkg of PACKAGES) {\n    const packagePath = path.join(PACKAGES_DIR, pkg);\n    // Pass bumpType for incremental bumps, or newVersion for set command\n    const result = updatePackageVersion(packagePath, newVersion, bumpType);\n    \n    if (result) {\n      updates.push(result);\n      console.log(`✅ ${result.name}: ${result.oldVersion} -> ${result.newVersion}`);\n    }\n  }\n  \n  console.log('\\n📝 Updating cross-package dependencies...\\n');\n  \n  // Update peer dependencies in all packages\n  for (const pkg of PACKAGES) {\n    const packagePath = path.join(PACKAGES_DIR, pkg);\n    console.log(`Checking ${pkg}...`);\n    updatePeerDependencies(packagePath, updates);\n  }\n  \n  console.log('\\n✨ Version update complete!');\n  console.log(`\\n📋 Summary:`);\n  console.log(`   Updated ${updates.length} packages`);\n  updates.forEach(u => console.log(`   - ${u.name}: ${u.oldVersion} -> ${u.newVersion}`));\n  console.log('\\n💡 Next steps:');\n  console.log('   1. Review the changes: git diff');\n  console.log('   2. Commit the changes: git commit -am \"chore: bump package versions\"');\n  console.log('   3. Build the packages: bun run build');\n  console.log('   4. Publish: bun run publish:all');\n}\n\n// Run main function\ntry {\n  main();\n} catch (error) {\n  console.error('❌ Error:', error.message);\n  process.exit(1);\n}\n",
      "line_count": 225,
      "word_count": 729,
      "title": "Update Versions.Js",
      "summary": "* Update versions across all packages in the monorepo * Usage: node scripts/update-versions.js [major|minor|patch|set] [version]",
      "key_terms": [
        "null",
        "build",
        "const",
        "nExamples",
        "packages",
        "number",
        "each",
        "error",
        "If",
        "based",
        "major",
        "mode",
        "format",
        "Commit",
        "same",
        "dependencies",
        "forEach",
        "found",
        "string",
        "existsSync"
      ],
      "timestamp": "2025-12-24T18:56:20.297577"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\tests\\utcp_client.test.ts",
      "content_type": "code",
      "content": "// packages/core/tests/utcp_client.test.ts\nimport { test, expect, afterAll, beforeAll, afterEach, describe } from \"bun:test\";\nimport { Subprocess } from \"bun\";\nimport path from \"path\";\nimport { writeFile, unlink } from \"fs/promises\";\n\nimport { UtcpClient, CommunicationProtocol, RegisterManualResult, CallTemplate, UtcpManual, Tool, IUtcpClient } from \"@utcp/sdk\";\n// Import protocol packages to register their serializers and communication protocols\nimport \"@utcp/http\";\nimport \"@utcp/file\";\nimport \"@utcp/mcp\";\nimport \"@utcp/cli\";\nimport \"@utcp/dotenv-loader\";\n// Import types after registering the packages\nimport type { McpCallTemplate } from \"@utcp/mcp\";\nimport type { HttpCallTemplate } from \"@utcp/http\";\nimport type { FileCallTemplate } from \"@utcp/file\";\nimport type { CliCallTemplate } from \"@utcp/cli\";\n\nlet httpManualServerProcess: Subprocess | null = null;\nlet mcpStdioServerProcess: Subprocess | null = null;\nconst tempFiles: string[] = [];\n\n// Emergency cleanup handler if tests are interrupted\nconst cleanupProcesses = () => {\n  const isWindows = process.platform === \"win32\";\n  \n  if (httpManualServerProcess && httpManualServerProcess.pid) {\n    try {\n      if (isWindows) {\n        Bun.spawnSync([\"taskkill\", \"/F\", \"/T\", \"/PID\", httpManualServerProcess.pid.toString()]);\n      } else {\n        httpManualServerProcess.kill(9);\n      }\n    } catch (e) {\n      // Ignore errors\n    }\n  }\n  \n  if (mcpStdioServerProcess && mcpStdioServerProcess.pid) {\n    try {\n      if (isWindows) {\n        Bun.spawnSync([\"taskkill\", \"/F\", \"/T\", \"/PID\", mcpStdioServerProcess.pid.toString()]);\n      } else {\n        mcpStdioServerProcess.kill(9);\n      }\n    } catch (e) {\n      // Ignore errors\n    }\n  }\n};\n\n// Register cleanup on process exit\nprocess.on('exit', cleanupProcesses);\nprocess.on('SIGINT', () => {\n  cleanupProcesses();\n  process.exit(130);\n});\nprocess.on('SIGTERM', () => {\n  cleanupProcesses();\n  process.exit(143);\n});\n\nconst awaitServerReady = async (stream: ReadableStream<Uint8Array>, readyMsg: string, timeout = 15000) => {\n  const reader = stream.getReader();\n  let output = \"\";\n  const start = Date.now();\n  try {\n    while (Date.now() - start < timeout) {\n      const { done, value } = await reader.read();\n      if (done) break;\n      const chunk = new TextDecoder().decode(value);\n      output += chunk;\n      if (output.includes(readyMsg)) {\n        console.log(`[Test Setup] Server ready: \"${readyMsg}\"`);\n        return;\n      }\n    }\n  } finally {\n    reader.releaseLock();\n  }\n  throw new Error(`[Test Setup] Server did not emit ready message \"${readyMsg}\" in time. Full output:\\n${output}`);\n};\n\n// --- Setup: Start all mock servers before any tests run ---\nbeforeAll(async () => {\n  console.log(\"--- Starting mock servers for UtcpClient E2E test suite ---\");\n\n  const httpManualServerPath = path.resolve(import.meta.dir, \"servers\", \"http_manual_server.ts\");\n  httpManualServerProcess = Bun.spawn([\"bun\", \"run\", httpManualServerPath], {\n    stdout: \"pipe\",\n    stderr: \"inherit\",\n    windowsHide: true,\n  });\n  await awaitServerReady(httpManualServerProcess.stdout, \"HTTP Manual Server running on port 9998\");\n\n  // 2. Start MCP Stdio Server (Bun server)\n  // This server will be spawned by our `McpCommunicationProtocol` in the tests,\n  // but we run it once here to ensure it's built and available.\n  const mcpStdioServerPath = path.resolve(import.meta.dir, \"../packages/mcp/tests/mock_mcp_server.ts\");\n  mcpStdioServerProcess = Bun.spawn([\"bun\", \"run\", mcpStdioServerPath], {\n    stdout: \"pipe\",\n    stderr: \"inherit\",\n    windowsHide: true,\n  });\n  await awaitServerReady(mcpStdioServerProcess.stdout, \"Mock STDIN MCP Server is running.\");\n\n  // 3. Plugins are automatically registered on import\n  // HTTP, Text, and MCP protocols are ready to use.\n\n  console.log(\"--- All mock servers and plugins ready ---\");\n}, 25000);\n\n// --- Teardown: Stop all mock servers after all tests run ---\nafterAll(async () => {\n  console.log(\"--- Stopping mock servers ---\");\n  \n  const isWindows = process.platform === \"win32\";\n  \n  // Force kill processes to ensure cleanup\n  if (httpManualServerProcess && httpManualServerProcess.pid) {\n    if (isWindows) {\n      // On Windows, use taskkill to kill the entire process tree\n      try {\n        Bun.spawnSync([\"taskkill\", \"/F\", \"/T\", \"/PID\", httpManualServerProcess.pid.toString()]);\n      } catch (e) {\n        // Ignore errors if process already terminated\n      }\n    } else {\n      httpManualServerProcess.kill();\n      await new Promise(resolve => setTimeout(resolve, 100));\n      if (!httpManualServerProcess.killed) {\n        httpManualServerProcess.kill(9);\n      }\n    }\n  }\n  \n  if (mcpStdioServerProcess && mcpStdioServerProcess.pid) {\n    if (isWindows) {\n      // On Windows, use taskkill to kill the entire process tree\n      try {\n        Bun.spawnSync([\"taskkill\", \"/F\", \"/T\", \"/PID\", mcpStdioServerProcess.pid.toString()]);\n      } catch (e) {\n        // Ignore errors if process already terminated\n      }\n    } else {\n      mcpStdioServerProcess.kill();\n      await new Promise(resolve => setTimeout(resolve, 100));\n      if (!mcpStdioServerProcess.killed) {\n        mcpStdioServerProcess.kill(9);\n      }\n    }\n  }\n  \n  // Extra safety: wait a bit for ports to be released\n  await new Promise(resolve => setTimeout(resolve, 300));\n\n  for (const file of tempFiles) {\n    try {\n      await unlink(file);\n    } catch (e) {\n      console.warn(`Error deleting temp file ${file}: ${e}`);\n    }\n  }\n  tempFiles.length = 0;\n  console.log(\"--- Mock servers stopped and temp files cleaned ---\");\n});\n\n// --- End-to-End Test Suite for UtcpClient ---\ndescribe(\"UtcpClient End-to-End Tests\", () => {\n\n  test(\"should initialize, register manuals from config, and call a tool from each protocol\", async () => {\n    console.log(\"\\nRunning test: should initialize, register manuals, and call tools\");\n\n    // 1. Arrange: Create mock files and specific CallTemplates for registration\n    // Create a dummy text file for the text_manual to read\n    const dummyTextFilePath = path.join(import.meta.dir, \"dummy_content.txt\");\n    await writeFile(dummyTextFilePath, \"This is dummy content for the text file tool.\");\n    tempFiles.push(dummyTextFilePath);\n\n    // Create a UTCP manual config file for the text protocol to load\n    const textManualContent = {\n      utcp_version: \"1.0.1\",\n      manual_version: \"1.0.0\",\n      tools: [{\n        name: \"read_dummy_file\", // Changed name for clarity\n        description: \"Reads a local dummy text file.\",\n        inputs: { type: 'object', properties: {} },\n        outputs: { type: 'object', properties: { content: { type: 'string' } } },\n        tags: [\"file\", \"io\", \"dummy\"],\n        tool_call_template: {\n          name: \"file_manual\",\n          call_template_type: \"file\",\n          file_path: dummyTextFilePath\n        } as FileCallTemplate\n      }]\n    };\n    const textManualConfigPath = path.join(import.meta.dir, \"test_text_manual.json\");\n    await writeFile(textManualConfigPath, JSON.stringify(textManualContent));\n    tempFiles.push(textManualConfigPath);\n    const mcpStdioServerScriptPath = path.resolve(import.meta.dir, \"../packages/mcp/tests/mock_mcp_server.ts\");\n    // 2. Act: Create the client with manual_call_templates in its config\n    const client = await UtcpClient.create(process.cwd(), {\n      manual_call_templates: [\n        {\n          name: \"http_server_manual\",\n          call_template_type: \"http\",\n          http_method: \"GET\",\n          url: \"http://localhost:9998/utcp\",\n        } as HttpCallTemplate,\n        {\n          name: \"local_file_manual\",\n          call_template_type: \"file\",\n          file_path: textManualConfigPath,\n        } as FileCallTemplate,\n        {\n          name: \"mcp_stdio_client_manual\",\n          call_template_type: \"mcp\",\n          config: {\n            mcpServers: {\n              mock_stdio_server: {\n                transport: 'stdio',\n                command: 'bun',\n                args: ['run', mcpStdioServerScriptPath],\n                cwd: path.dirname(mcpStdioServerScriptPath)\n              }\n            }\n          }\n        } as McpCallTemplate,\n      ]\n    });\n\n    // 3. Assert: Check successful registrations and tool counts\n    const allTools = await client.config.tool_repository.getTools();\n    console.log(`[Test] Total tools registered: ${allTools.length}`);\n\n    // Expected tools: 1 from HTTP, 1 from Text, 2 from MCP = 4 tools\n    expect(allTools.length).toBe(4);\n    const httpTool = await client.config.tool_repository.getTool(\"http_server_manual.get_user\");\n    const fileTool = await client.config.tool_repository.getTool(\"local_file_manual.read_dummy_file\");\n    const mcpEchoTool = await client.config.tool_repository.getTool(\"mcp_stdio_client_manual.mock_stdio_server.echo\");\n    const mcpAddTool = await client.config.tool_repository.getTool(\"mcp_stdio_client_manual.mock_stdio_server.add\");\n\n    expect(httpTool).toBeDefined();\n    expect(fileTool).toBeDefined();\n    expect(mcpEchoTool).toBeDefined();\n    expect(mcpAddTool).toBeDefined();\n\n    // 4. Act & Assert: Call one tool from each protocol\n    console.log(\"\\n[Test] Calling HTTP tool...\");\n    const httpResult = await client.callTool(\"http_server_manual.get_user\", {});\n    expect(httpResult).toEqual({ id: 123, name: \"Alice\" });\n    console.log(`[Test] HTTP tool result: ${JSON.stringify(httpResult)}`);\n\n    console.log(\"\\n[Test] Calling File tool...\");\n    const fileResult = await client.callTool(\"local_file_manual.read_dummy_file\", {});\n    expect(fileResult).toBe(\"This is dummy content for the text file tool.\");\n    console.log(`[Test] File tool result: \"${fileResult.substring(0, 30)}...\"`);\n\n\n    console.log(\"\\n[Test] Calling MCP tool...\");\n    const mcpResult = await client.callTool(\"mcp_stdio_client_manual.mock_stdio_server.add\", { a: 5, b: 3 });\n    expect(mcpResult).toBe(8);\n    console.log(`[Test] MCP tool result: ${mcpResult}`);\n\n    await client.close();\n  });\n\n  test(\"should handle variable substitution from config and .env file\", async () => {\n    console.log(\"\\nRunning test: variable substitution...\");\n\n    // 1. Arrange: Create a temporary .env file with global variables\n    const envTestPath = path.join(import.meta.dir, \".env.test\");\n    await writeFile(envTestPath, \"GLOBAL_SERVICE_HOST=api.example.com\\nGLOBAL_TOKEN=global_secret_key\");\n    tempFiles.push(envTestPath);\n\n    // Create client with namespaced and global variables\n    const client = await UtcpClient.create(process.cwd(), {\n      variables: {\n        // Namespaced variable: \"variable_test_manual\" -> \"variable__test__manual_API_URL\"\n        \"variable__test__manual_API_URL\": \"http://localhost:9998\",\n        // Namespaced variable for API key\n        \"variable__test__manual_LOCAL_API_KEY\": \"local_api_key_from_config\",\n      },\n      load_variables_from: [\n        { variable_loader_type: \"dotenv\", env_file_path: envTestPath }\n      ]\n    });\n\n    // Define a CallTemplate that uses various variable substitution patterns\n    const callTemplateWithVars = {\n      name: \"variable_test_manual\",\n      call_template_type: \"http\",\n      http_method: \"GET\",\n      // API_URL will be namespaced to \"variable__test__manual_API_URL\"\n      // GLOBAL_SERVICE_HOST will look for \"variable__test__manual_GLOBAL_SERVICE_HOST\" first, \n      // but won't find it, so it will fail unless we provide it properly\n      url: \"${API_URL}/endpoint?query=${GLOBAL_SERVICE_HOST}\",\n      headers: {\n        // LOCAL_API_KEY will be namespaced to \"variable__test__manual_LOCAL_API_KEY\"\n        \"X-API-Key\": \"${LOCAL_API_KEY}\",\n        // GLOBAL_TOKEN will be namespaced to \"variable__test__manual_GLOBAL_TOKEN\"\n        // Won't be found - need to provide namespaced version or make it truly global\n        \"Authorization\": \"Bearer ${GLOBAL_TOKEN}\"\n      }\n    } as HttpCallTemplate;\n\n    // Add the namespaced GLOBAL variables to demonstrate proper isolation\n    client.config.variables = client.config.variables || {};\n    client.config.variables[\"variable__test__manual_GLOBAL_SERVICE_HOST\"] = \"api.example.com\";\n    client.config.variables[\"variable__test__manual_GLOBAL_TOKEN\"] = \"global_secret_key\";\n\n    // 2. Act: Substitute variables in the call template\n    const processed = await client.substituteCallTemplateVariables(callTemplateWithVars, callTemplateWithVars.name);\n\n    // 3. Assert: Verify variables are correctly substituted\n    expect(processed.url).toBe(\"http://localhost:9998/endpoint?query=api.example.com\");\n    expect(processed.headers?.[\"X-API-Key\"]).toBe(\"local_api_key_from_config\");\n    expect(processed.headers?.Authorization).toBe(\"Bearer global_secret_key\");\n\n    await client.close();\n  });\n\n  test(\"should search tools across all registered manuals\", async () => {\n    console.log(\"\\nRunning test: tool search across manuals...\");\n\n    // 1. Arrange: Create a clean client and register manuals\n    const client = await UtcpClient.create(process.cwd(), {});\n\n    await client.registerManual({\n      name: \"http_search_manual\",\n      call_template_type: \"http\",\n      http_method: \"GET\",\n      url: \"http://localhost:9998/utcp\"\n    } as HttpCallTemplate);\n\n    const mcpStdioServerScriptPath = path.resolve(import.meta.dir, \"../packages/mcp/tests/mock_mcp_server.ts\");\n    await client.registerManual({\n      name: \"mcp_search_manual\",\n      call_template_type: \"mcp\",\n      config: {\n        mcpServers: {\n          mock_stdio_server: {\n            transport: 'stdio',\n            command: 'bun',\n            args: ['run', mcpStdioServerScriptPath],\n            cwd: path.dirname(mcpStdioServerScriptPath)\n          }\n        }\n      }\n    } as McpCallTemplate);\n\n    // 2. Act: Search for tools\n    const searchResults = await client.searchTools(\"echo\", 5);\n\n    // 3. Assert: Verify the search results\n    // The search should return the \"echo\" tool as the first (highest scored) result\n    console.log(`[Test] Search results for \"echo\": ${searchResults.map(t => t.name).join(', ')}`);\n    expect(searchResults.length).toBeGreaterThan(0);\n    expect(searchResults[0]?.name).toBe(\"mcp_search_manual.mock_stdio_server.echo\");\n\n    await client.close();\n  });\n});\n\n// --- allowed_communication_protocols Tests ---\n// These tests use mock communication protocols to verify protocol filtering behavior\n\n/**\n * Mock communication protocol for testing allowed_communication_protocols.\n * Returns a predefined manual on registration and a predefined result on tool calls.\n */\nclass MockCommunicationProtocol extends CommunicationProtocol {\n  private manual: UtcpManual;\n  private callResult: any;\n\n  constructor(manual?: UtcpManual, callResult: any = \"mock_result\") {\n    super();\n    this.manual = manual || { utcp_version: \"1.0\", manual_version: \"1.0\", tools: [] };\n    this.callResult = callResult;\n  }\n\n  async registerManual(caller: IUtcpClient, manualCallTemplate: CallTemplate): Promise<RegisterManualResult> {\n    return {\n      manualCallTemplate,\n      manual: this.manual,\n      success: true,\n      errors: [],\n    };\n  }\n\n  async deregisterManual(caller: IUtcpClient, manualCallTemplate: CallTemplate): Promise<void> {}\n\n  async callTool(caller: IUtcpClient, toolName: string, toolArgs: Record<string, any>, toolCallTemplate: CallTemplate): Promise<any> {\n    return this.callResult;\n  }\n\n  async *callToolStreaming(caller: IUtcpClient, toolName: string, toolArgs: Record<string, any>, toolCallTemplate: CallTemplate): AsyncGenerator<any, void, unknown> {\n    yield this.callResult;\n  }\n}\n\ndescribe(\"allowed_communication_protocols Tests\", () => {\n  // Store original protocols to restore after tests\n  let originalProtocols: { [type: string]: CommunicationProtocol };\n\n  beforeAll(() => {\n    // Save original protocols\n    originalProtocols = { ...CommunicationProtocol.communicationProtocols };\n  });\n\n  afterEach(() => {\n    // Restore original protocols after each test\n    CommunicationProtocol.communicationProtocols = { ...originalProtocols };\n  });\n\n  test(\"should call tool when its protocol is in the allowed list\", async () => {\n    console.log(\"\\nRunning test: call_tool_allowed_protocol...\");\n\n    // Create HTTP tool\n    const httpTool: Tool = {\n      name: \"http_tool\",\n      description: \"HTTP test tool\",\n      inputs: { type: \"object\", properties: { param1: { type: \"string\" } } },\n      outputs: { type: \"object\", properties: {} },\n      tags: [\"http\"],\n      tool_call_template: {\n        name: \"http_provider\",\n        call_template_type: \"http\",\n        url: \"https://api.example.com/call\",\n        http_method: \"GET\",\n        content_type: \"application/json\",\n      } as HttpCallTemplate,\n    };\n\n    const manual: UtcpManual = { utcp_version: \"1.0\", manual_version: \"1.0\", tools: [httpTool] };\n    const mockProtocol = new MockCommunicationProtocol(manual, \"test_result\");\n    CommunicationProtocol.communicationProtocols[\"http\"] = mockProtocol;\n\n    const client = await UtcpClient.create(process.cwd(), {});\n\n    await client.registerManual({\n      name: \"test_manual\",\n      call_template_type: \"http\",\n      url: \"https://api.example.com/tool\",\n      http_method: \"POST\",\n      content_type: \"application/json\",\n      allowed_communication_protocols: [\"http\", \"cli\"], // Allow both HTTP and CLI\n    } as HttpCallTemplate);\n\n    // Call should succeed since \"http\" is in allowed_communication_protocols\n    const result = await client.callTool(\"test_manual.http_tool\", { param1: \"value1\" });\n    expect(result).toBe(\"test_result\");\n\n    await client.close();\n  });\n\n  test(\"should filter out tools with disallowed protocols during registration\", async () => {\n    console.log(\"\\nRunning test: register_filters_disallowed_protocol_tools...\");\n\n    // Create a CLI tool (which will not be allowed)\n    const cliTool: Tool = {\n      name: \"cli_tool\",\n      description: \"CLI test tool\",\n      inputs: { type: \"object\", properties: { command: { type: \"string\", description: \"Command to execute\" } }, required: [\"command\"] },\n      outputs: { type: \"object\", properties: { output: { type: \"string\", description: \"Command output\" } } },\n      tags: [\"cli\", \"test\"],\n      tool_call_template: {\n        name: \"cli_provider\",\n        call_template_type: \"cli\",\n        commands: [{ command: \"echo UTCP_ARG_command_UTCP_END\" }],\n      } as CliCallTemplate,\n    };\n\n    const manual: UtcpManual = { utcp_version: \"1.0\", manual_version: \"1.0\", tools: [cliTool] };\n    const mockHttpProtocol = new MockCommunicationProtocol(manual);\n    const mockCliProtocol = new MockCommunicationProtocol();\n    CommunicationProtocol.communicationProtocols[\"http\"] = mockHttpProtocol;\n    CommunicationProtocol.communicationProtocols[\"cli\"] = mockCliProtocol;\n\n    const client = await UtcpClient.create(process.cwd(), {});\n\n    const result = await client.registerManual({\n      name: \"http_manual\",\n      call_template_type: \"http\",\n      url: \"https://api.example.com/tool\",\n      http_method: \"POST\",\n      content_type: \"application/json\",\n      allowed_communication_protocols: [\"http\"], // Only allow HTTP\n    } as HttpCallTemplate);\n\n    // CLI tool should be filtered out during registration\n    expect(result.manual.tools.length).toBe(0);\n\n    // Tool should not exist in repository\n    const tool = await client.getTool(\"http_manual.cli_tool\");\n    expect(tool).toBeUndefined();\n\n    await client.close();\n  });\n\n  test(\"should only allow manual's own protocol when no allowed_communication_protocols is set\", async () => {\n    console.log(\"\\nRunning test: call_tool_default_protocol_restriction...\");\n\n    // Create tools: one HTTP (should be registered), one CLI (should be filtered out)\n    const httpTool: Tool = {\n      name: \"http_tool\",\n      description: \"HTTP test tool\",\n      inputs: { type: \"object\", properties: {} },\n      outputs: { type: \"object\", properties: {} },\n      tags: [],\n      tool_call_template: {\n        name: \"http_provider\",\n        call_template_type: \"http\",\n        url: \"https://api.example.com/call\",\n        http_method: \"GET\",\n        content_type: \"application/json\",\n      } as HttpCallTemplate,\n    };\n\n    const cliTool: Tool = {\n      name: \"cli_tool\",\n      description: \"CLI test tool\",\n      inputs: { type: \"object\", properties: {} },\n      outputs: { type: \"object\", properties: {} },\n      tags: [],\n      tool_call_template: {\n        name: \"cli_provider\",\n        call_template_type: \"cli\",\n        commands: [{ command: \"echo test\" }],\n      } as CliCallTemplate,\n    };\n\n    const manual: UtcpManual = { utcp_version: \"1.0\", manual_version: \"1.0\", tools: [httpTool, cliTool] };\n    const mockHttpProtocol = new MockCommunicationProtocol(manual, \"http_result\");\n    const mockCliProtocol = new MockCommunicationProtocol();\n    CommunicationProtocol.communicationProtocols[\"http\"] = mockHttpProtocol;\n    CommunicationProtocol.communicationProtocols[\"cli\"] = mockCliProtocol;\n\n    const client = await UtcpClient.create(process.cwd(), {});\n\n    // Register HTTP manual without explicit protocol restrictions\n    // Default behavior: only HTTP tools should be allowed\n    const result = await client.registerManual({\n      name: \"http_manual\",\n      call_template_type: \"http\",\n      url: \"https://api.example.com/tool\",\n      http_method: \"POST\",\n      content_type: \"application/json\",\n      // No allowed_communication_protocols set - defaults to [\"http\"]\n    } as HttpCallTemplate);\n\n    // Only HTTP tool should be registered, CLI tool should be filtered out\n    expect(result.manual.tools.length).toBe(1);\n    expect(result.manual.tools[0].name).toBe(\"http_manual.http_tool\");\n\n    // HTTP tool call should succeed\n    const callResult = await client.callTool(\"http_manual.http_tool\", {});\n    expect(callResult).toBe(\"http_result\");\n\n    // CLI tool should not exist in repository\n    const cliToolInRepo = await client.getTool(\"http_manual.cli_tool\");\n    expect(cliToolInRepo).toBeUndefined();\n\n    await client.close();\n  });\n\n  test(\"should register tools from multiple protocols when explicitly allowed\", async () => {\n    console.log(\"\\nRunning test: register_with_multiple_allowed_protocols...\");\n\n    const httpTool: Tool = {\n      name: \"http_tool\",\n      description: \"HTTP test tool\",\n      inputs: { type: \"object\", properties: {} },\n      outputs: { type: \"object\", properties: {} },\n      tags: [],\n      tool_call_template: {\n        name: \"http_provider\",\n        call_template_type: \"http\",\n        url: \"https://api.example.com/call\",\n        http_method: \"GET\",\n        content_type: \"application/json\",\n      } as HttpCallTemplate,\n    };\n\n    const cliTool: Tool = {\n      name: \"cli_tool\",\n      description: \"CLI test tool\",\n      inputs: { type: \"object\", properties: {} },\n      outputs: { type: \"object\", properties: {} },\n      tags: [],\n      tool_call_template: {\n        name: \"cli_provider\",\n        call_template_type: \"cli\",\n        commands: [{ command: \"echo test\" }],\n      } as CliCallTemplate,\n    };\n\n    const manual: UtcpManual = { utcp_version: \"1.0\", manual_version: \"1.0\", tools: [httpTool, cliTool] };\n    const mockHttpProtocol = new MockCommunicationProtocol(manual, \"http_result\");\n    const mockCliProtocol = new MockCommunicationProtocol(undefined, \"cli_result\");\n    CommunicationProtocol.communicationProtocols[\"http\"] = mockHttpProtocol;\n    CommunicationProtocol.communicationProtocols[\"cli\"] = mockCliProtocol;\n\n    const client = await UtcpClient.create(process.cwd(), {});\n\n    const result = await client.registerManual({\n      name: \"multi_protocol_manual\",\n      call_template_type: \"http\",\n      url: \"https://api.example.com/tool\",\n      http_method: \"POST\",\n      content_type: \"application/json\",\n      allowed_communication_protocols: [\"http\", \"cli\"], // Allow both\n    } as HttpCallTemplate);\n\n    // Both tools should be registered\n    expect(result.manual.tools.length).toBe(2);\n    const toolNames = result.manual.tools.map(t => t.name);\n    expect(toolNames).toContain(\"multi_protocol_manual.http_tool\");\n    expect(toolNames).toContain(\"multi_protocol_manual.cli_tool\");\n\n    // Both tools should be callable\n    const httpResult = await client.callTool(\"multi_protocol_manual.http_tool\", {});\n    expect(httpResult).toBe(\"http_result\");\n\n    const cliResult = await client.callTool(\"multi_protocol_manual.cli_tool\", {});\n    expect(cliResult).toBe(\"cli_result\");\n\n    await client.close();\n  });\n\n  test(\"should treat empty allowed_communication_protocols array as default (manual's own protocol)\", async () => {\n    console.log(\"\\nRunning test: call_tool_empty_allowed_protocols_defaults_to_manual_type...\");\n\n    // Create a CLI tool (which will be filtered since manual is HTTP)\n    const cliTool: Tool = {\n      name: \"cli_tool\",\n      description: \"CLI test tool\",\n      inputs: { type: \"object\", properties: {} },\n      outputs: { type: \"object\", properties: {} },\n      tags: [],\n      tool_call_template: {\n        name: \"cli_provider\",\n        call_template_type: \"cli\",\n        commands: [{ command: \"echo test\" }],\n      } as CliCallTemplate,\n    };\n\n    const manual: UtcpManual = { utcp_version: \"1.0\", manual_version: \"1.0\", tools: [cliTool] };\n    const mockHttpProtocol = new MockCommunicationProtocol(manual);\n    const mockCliProtocol = new MockCommunicationProtocol(undefined, \"cli_result\");\n    CommunicationProtocol.communicationProtocols[\"http\"] = mockHttpProtocol;\n    CommunicationProtocol.communicationProtocols[\"cli\"] = mockCliProtocol;\n\n    const client = await UtcpClient.create(process.cwd(), {});\n\n    const result = await client.registerManual({\n      name: \"http_manual\",\n      call_template_type: \"http\",\n      url: \"https://api.example.com/tool\",\n      http_method: \"POST\",\n      content_type: \"application/json\",\n      allowed_communication_protocols: [], // Empty list defaults to [\"http\"]\n    } as HttpCallTemplate);\n\n    // CLI tool should be filtered out during registration\n    expect(result.manual.tools.length).toBe(0);\n\n    await client.close();\n  });\n});",
      "line_count": 671,
      "word_count": 2455,
      "title": "Utcp Client.Test.Ts",
      "summary": "// packages/core/tests/utcp_client.test.ts import { test, expect, afterAll, beforeAll, afterEach, describe } from \"bun:test\";",
      "key_terms": [
        "close",
        "const",
        "packages",
        "localhost",
        "getReader",
        "mcpStdioServerPath",
        "mcpAddTool",
        "Setup",
        "Record",
        "list",
        "mcpStdioServerProcess",
        "unlink",
        "afterAll",
        "Reads",
        "during",
        "interrupted",
        "yield",
        "since",
        "global",
        "toolName"
      ],
      "timestamp": "2025-12-24T18:56:20.361391"
    },
    {
      "file_path": "UPSTREAM\\typescript-utcp\\tests\\servers\\http_manual_server.ts",
      "content_type": "code",
      "content": "// packages/core/tests/http_manual_server.ts\nimport { Tool } from \"@utcp/sdk\";\nimport { HttpCallTemplate } from \"@utcp/http\";\n\nconst manual = {\n  utcp_version: \"1.0.1\",\n  manual_version: \"1.0.0\",\n  tools: [\n    {\n      name: \"get_user\",\n      description: \"Gets a user by ID.\",\n      inputs: { type: 'object', properties: {} },\n      outputs: { type: 'object', properties: {} },\n      tags: [],\n      tool_call_template: {\n        name: \"http_test_server\",\n        call_template_type: \"http\",\n        http_method: \"GET\",\n        url: \"http://localhost:9998/users/123\",\n      } as HttpCallTemplate, \n    },\n  ] as Tool[],\n};\n\nconst server = Bun.serve({\n  port: 9998,\n  fetch(req) {\n    const url = new URL(req.url);\n    if (url.pathname === \"/utcp\") {\n      return new Response(JSON.stringify(manual));\n    }\n    if (url.pathname === \"/users/123\") {\n      return new Response(JSON.stringify({ id: 123, name: \"Alice\" }));\n    }\n    return new Response(\"Not Found\", { status: 404 });\n  },\n});\n\n// Graceful shutdown handling\nprocess.on('SIGTERM', () => {\n  console.log('SIGTERM received, closing HTTP server...');\n  server.stop();\n  process.exit(0);\n});\n\nprocess.on('SIGINT', () => {\n  console.log('SIGINT received, closing HTTP server...');\n  server.stop();\n  process.exit(0);\n});\n\nconsole.log(`HTTP Manual Server running on port ${server.port}`);",
      "line_count": 52,
      "word_count": 148,
      "title": "Http Manual Server.Ts",
      "summary": "// packages/core/tests/http_manual_server.ts import { Tool } from \"@utcp/sdk\";",
      "key_terms": [
        "from",
        "process",
        "URL",
        "const",
        "packages",
        "localhost",
        "SIGINT",
        "user",
        "outputs",
        "shutdown",
        "Response",
        "SIGTERM",
        "stop",
        "id",
        "pathname",
        "utcp",
        "as",
        "method",
        "Tool",
        "Bun"
      ],
      "timestamp": "2025-12-24T18:56:20.393204"
    }
  ],
  "timestamp": "2025-12-24T18:56:20.393204"
}